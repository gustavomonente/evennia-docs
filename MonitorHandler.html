<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="./img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>MonitorHandler - Evennia Manual</title>
    <link href="./css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="./css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="./css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="./css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="./js/jquery-3.2.1.min.js"></script>
    <script src="./js/bootstrap-3.3.7.min.js"></script>
    <script src="./js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '.';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Using the MonitorHandler", url: "#_top", children: [
          ]},
        ];

    </script>
    <script src="./js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <p>The <em>MonitorHandler</em> is a system for watching changes in properties or Attributes on objects. A monitor can be thought of as a sort of trigger that responds to change. </p>
<p>The main use for the MonitorHandler is to report changes to the client; for example the client Session may ask Evennia to monitor the value of the Characer's <code>health</code> attribute and report whenever it changes. This way the client could for example update its health bar graphic as needed. </p>
<h2 id="using-the-monitorhandler">Using the MonitorHandler<a class="headerlink" href="#using-the-monitorhandler" title="Permanent link">&para;</a></h2>
<p>The MontorHandler is accessed from the singleton <code>evennia.MONITOR_HANDLER</code>. The code for the handler is in <code>evennia.scripts.monitorhandler</code>.</p>
<p>Here's how to add a new monitor: </p>
<pre><code class="python">from evennia import MONITOR_HANDLER

MONITOR_HANDLER.add(obj, fieldname, callback,
                    idstring=&quot;&quot;, persistent=False, **kwargs)

</code></pre>

<ul>
<li><code>obj</code> (<a href="Typeclasses.html">Typeclassed</a> entity) - the object to monitor. Since this must be typeclassed, it means you can't monitor changes on <a href="Sessions.html">Sessions</a> with the monitorhandler, for example.</li>
<li><code>fieldname</code> (str) - the name of a field or <a href="Attributes.html">Attribute</a> on <code>obj</code>. If you want to monitor a database field you must specify its full name, including the starting <code>db_</code> (like <code>db_key</code>, <code>db_location</code> etc). Any names not starting with <code>db_</code> are instead assumed to be the names of Attributes. This difference matters, since the MonitorHandler will automatically know to watch the <code>db_value</code> field of the Attribute. </li>
<li><code>callback</code>(callable) - This will be called as <code>callback(fieldname=fieldname, obj=obj, **kwargs)</code> when the field updates.</li>
<li><code>idstring</code> (str) - this is used to separate multiple monitors on the same object and fieldname. This is required in order to properly identify and remove the monitor later. It's also used for saving it. </li>
<li><code>persistent</code> (bool) - if True, the monitor will survive a server reboot.</li>
</ul>
<p>Example: </p>
<pre><code class="python">from evennia import MONITOR_HANDLER as monitorhandler

def _monitor_callback(fieldname=&quot;&quot;, obj=None, **kwargs):    
    # reporting callback that works both
    # for db-fields and Attributes
    if fieldname.startswith(&quot;db_&quot;):
        new_value = getattr(obj, fieldname)
    else: # an attribute    
        new_value = obj.attributes.get(fieldname)

    obj.msg(&quot;%s.%s changed to '%s'.&quot; % \
                  (obj.key, fieldname, new_value))

# (we could add _some_other_monitor_callback here too)

# monitor Attribute (assume we have obj from before)
monitorhandler.add(obj, &quot;desc&quot;, _monitor_callback)  

# monitor same db-field with two different callbacks (must separate by id_string)
monitorhandler.add(obj, &quot;db_key&quot;, _monitor_callback, id_string=&quot;foo&quot;)  
monitorhandler.add(obj, &quot;db_key&quot;, _some_other_monitor_callback, id_string=&quot;bar&quot;)

</code></pre>

<p>A monitor is uniquely identified by the combination of the <em>object instance</em> it is monitoring, the <em>name</em> of the field/attribute to monitor on that object and its <code>idstring</code> (<code>obj</code> + <code>fieldname</code> + <code>idstring</code>). The <code>idstring</code> will be the empty string unless given explicitly. </p>
<p>So to "un-monitor" the above you need to supply enough information for the system to uniquely find the monitor to remove:</p>
<pre><code>monitorhandler.remove(obj, &quot;desc&quot;)
monitorhandler.remove(obj, &quot;db_key&quot;, idstring=&quot;foo&quot;)
monitorhandler.remove(obj, &quot;db_key&quot;, idstring=&quot;bar&quot;)
</code></pre>

  <br>
    

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>