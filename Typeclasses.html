<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="img/favicon.ico">
        <title>Typeclasses - Evennia Manual</title>
        <link href="css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="css/font-awesome.min.css" rel="stylesheet">
        <link href="css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="js/jquery-1.10.2.min.js" defer></script>
        <script src="js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html">Evennia Manual</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="index.html">Home</a>
                            </li>
                            <li >
                                <a href="Administrative-Docs.html">Admin</a>
                            </li>
                            <li >
                                <a href="Builder-Docs.html">Building</a>
                            </li>
                            <li >
                                <a href="Developer-Central.html">Game Development</a>
                            </li>
                            <li >
                                <a href="Tutorials.html">Tutorials</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#difference-between-typeclasses-and-classes">Difference between typeclasses and classes</a></li>
        <li class="main "><a href="#creating-a-new-typeclass">Creating a new typeclass</a></li>
            <li><a href="#about-typeclass-properties">About typeclass properties</a></li>
            <li><a href="#overloading-hooks">Overloading hooks</a></li>
            <li><a href="#querying-for-typeclasses">Querying for typeclasses</a></li>
        <li class="main "><a href="#updating-existing-typeclass-instances">Updating existing typeclass instances</a></li>
        <li class="main "><a href="#swap-typeclass">Swap typeclass</a></li>
        <li class="main "><a href="#how-typeclasses-actually-work">How typeclasses actually work</a></li>
            <li><a href="#caveats">Caveats</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><a href="The-main-technical-description-of-a-core-concept.-how-Typeclasses-are-used-and-work."></a></p>
<p><em>Typeclasses</em> form the core of Evennia data storage. It allows Evennia to represent any number of different game entities as Python classes, without having to modify the database schema for every new type.</p>
<p>In Evennia the most important game entities, <a href="Accounts.html">Accounts</a>, <a href="Objects.html">Objects</a>, <a href="Scripts.html">Scripts</a> and <a href="Communications#Channels">Channels</a> are all Python classes inheriting, at varying distance, from <code>evennia.typeclasses.models.TypedObject</code>.  In the documentation we refer to these objects as being "typeclassed" or even "being a typeclass".</p>
<p>This is how the inheritance looks for the typeclasses in Evennia:</p>
<pre><code>                  TypedObject
      _________________|_________________________________
     |                 |                 |               |
1: AccountDB        ObjectDB           ScriptDB         ChannelDB
     |                 |                 |               |
2: DefaultAccount   DefaultObject      DefaultScript    DefaultChannel
     |              DefaultCharacter     |               |
     |              DefaultRoom          |               |
     |              DefaultExit          |               |
     |                 |                 |               |
3: Account          Object              Script           Channel
                   Character
                   Room
                   Exit
</code></pre>

<ul>
<li><strong>Level 1</strong> above is the "database model" level. This describes the database tables and fields (this is technically a <a href="https://docs.djangoproject.com/en/2.2/topics/db/models/">Django model</a>).</li>
<li><strong>Level 2</strong> is where we find Evennia's default implementations of the various game entities, on top of the database. These classes define all the hook methods that Evennia calls in various situations. <code>DefaultObject</code> is a little special since it's the parent for <code>DefaultCharacter</code>, <code>DefaultRoom</code> and <code>DefaultExit</code>. They are all grouped under level 2 because they all represents defaults to build from.</li>
<li><strong>Level 3</strong>, finally, holds empty template classes created in your game directory. This is the level you are meant to modify and tweak as you please, overloading the defaults as befits your game. The templates inherit directly from their defaults, so <code>Object</code> inherits from <code>DefaultObject</code> and <code>Room</code> inherits from <code>DefaultRoom</code>.</li>
</ul>
<p>The <code>typeclass/list</code> command will provide a list of all typeclasses known to
Evennia. This can be useful for getting a feel for what is available. Note
however that if you add a new module with a class in it but do not import that
module from anywhere, the <code>typeclass/list</code> will not find it. To make it known
to Evennia you must import that module from somewhere.</p>
<h3 id="difference-between-typeclasses-and-classes">Difference between typeclasses and classes<a class="headerlink" href="#difference-between-typeclasses-and-classes" title="Permanent link">&para;</a></h3>
<p>All Evennia classes inheriting from class in the table above share one important feature and two important limitations. This is why we don't simply call them "classes" but "typeclasses".</p>
<ol>
<li>A typeclass can save itself to the database. This means that some properties (actually not that many) on the class actually represents database fields and can only hold very specific data types. This is detailed <a href="https://github.com/evennia/evennia/wiki/Typeclasses#about-typeclass-properties">below</a>.</li>
<li>
<p>Due to its connection to the database, the typeclass' name must be <em>unique</em> across the <em>entire</em> server namespace. That is, there must never be two same-named classes defined anywhere. So the below code would give an error (since <code>DefaultObject</code> is now globally found both in this module and in the default library):</p>
<p><code>python
from evennia import DefaultObject as BaseObject
class DefaultObject(BaseObject):
     pass</code></p>
</li>
<li>
<p>A typeclass' <code>__init__</code> method should normally not be overloaded. This has mostly to do with the fact that the <code>__init__</code> method is not called in a predictable way. Instead Evennia suggest you use the <code>at_*_creation</code> hooks (like <code>at_object_creation</code> for Objects) for setting things the very first time the typeclass is saved to the database or the <code>at_init</code> hook which is called every time the object is cached to memory. If you know what you are doing and want to use <code>__init__</code>, it <em>must</em> both accept arbitrary keyword arguments and use <code>super</code> to call its parent::</p>
<p><code>python
def __init__(self, **kwargs):
    # my content
    super().__init__(**kwargs)
    # my content</code></p>
</li>
</ol>
<p>Apart from this, a typeclass works like any normal Python class and you can
treat it as such. </p>
<h2 id="creating-a-new-typeclass">Creating a new typeclass<a class="headerlink" href="#creating-a-new-typeclass" title="Permanent link">&para;</a></h2>
<p>It's easy to work with Typeclasses. Either you use an existing typeclass or you  create a new Python class inheriting from an existing typeclass. Here is an example of creating a new type of Object:</p>
<pre><code class="python">    from evennia import DefaultObject

    class Furniture(DefaultObject):
        # this defines what 'furniture' is, like
        # storing who sits on it or something.
        pass

</code></pre>

<p>You can now create a new <code>Furniture</code> object in two ways.  First (and usually not the most convenient) way is to create an instance of the class and then save it manually to the database:</p>
<pre><code class="python">chair = Furniture(db_key=&quot;Chair&quot;)
chair.save()

</code></pre>

<p>To use this you must give the database field names as keywords to the call. Which are available depends on the entity you are creating, but all start with <code>db_*</code> in Evennia. This is a method you may be familiar with if you know Django from before.</p>
<p>It is recommended that you instead use the <code>create_*</code> functions to create typeclassed entities:</p>
<pre><code class="python">from evennia import create_object

chair = create_object(Furniture, key=&quot;Chair&quot;)
# or (if your typeclass is in a module furniture.py)
chair = create_object(&quot;furniture.Furniture&quot;, key=&quot;Chair&quot;)
</code></pre>

<p>The <code>create_object</code> (<code>create_account</code>, <code>create_script</code> etc) takes the typeclass as its first argument; this can both be the actual class or the python path to the typeclass as found under your game directory. So if your <code>Furniture</code> typeclass sits in <code>mygame/typeclasses/furniture.py</code>, you could point to it as <code>typeclasses.furniture.Furniture</code>. Since Evennia will itself look in <code>mygame/typeclasses</code>, you can shorten this even further to just <code>furniture.Furniture</code>. The create-functions take a lot of extra keywords allowing you to set things like <a href="Attributes.html">Attributes</a> and <a href="Tags.html">Tags</a> all in one go. These keywords don't use the <code>db_*</code> prefix. This will also automatically save the new instance to the database, so you don't need to call <code>save()</code> explicitly.</p>
<h3 id="about-typeclass-properties">About typeclass properties<a class="headerlink" href="#about-typeclass-properties" title="Permanent link">&para;</a></h3>
<p>An example of a database field is <code>db_key</code>. This stores the "name" of the entity you are modifying and can thus only hold a string. This is one way of making sure to update the <code>db_key</code>:</p>
<pre><code class="python">chair.db_key = &quot;Table&quot;
chair.save()

print(chair.db_key)
&lt;&lt;&lt; Table
</code></pre>

<p>That is, we change the chair object to have the <code>db_key</code> "Table", then save this to the database. However, you almost never do things this way; Evennia defines property wrappers for all the database fields. These are named the same as the field, but without the <code>db_</code> part:</p>
<pre><code class="python">chair.key = &quot;Table&quot;

print(chair.key)
&lt;&lt;&lt; Table

</code></pre>

<p>The <code>key</code> wrapper is not only shorter to write, it will make sure to save the field for you, and does so more efficiently by levering sql update mechanics under the hood. So whereas it is good to be aware that the field is named <code>db_key</code> you should use <code>key</code> as much as you can.</p>
<p>Each typeclass entity has some unique fields relevant to that type.  But all also share the following fields (the wrapper name without <code>db_</code> is given):</p>
<ul>
<li><code>key</code> (str): The main identifier for the entity, like "Rose", "myscript" or "Paul". <code>name</code> is an alias.</li>
<li><code>date_created</code> (datetime): Time stamp when this object was created.</li>
<li><code>typeclass_path</code> (str): A python path pointing to the location of this (type)class</li>
</ul>
<p>There is one special field that doesn't use the <code>db_</code> prefix (it's defined by Django):</p>
<ul>
<li><code>id</code> (int): the database id (database ref) of the object. This is an ever-increasing, unique integer. It can also be accessed as <code>dbid</code> (database ID) or <code>pk</code> (primary key). The <code>dbref</code> property returns the string form "#id".</li>
</ul>
<p>The typeclassed entity has several common handlers:</p>
<ul>
<li><code>tags</code> - the <a href="Tags.html">TagHandler</a> that handles tagging. Use <code>tags.add()</code> , <code>tags.get()</code> etc.</li>
<li><code>locks</code> - the <a href="Locks.html">LockHandler</a> that manages access restrictions. Use <code>locks.add()</code>, <code>locks.get()</code> etc.</li>
<li><code>attributes</code> - the <a href="Attributes.html">AttributeHandler</a> that manages Attributes on the object. Use <code>attributes.add()</code>
etc.</li>
<li><code>db</code> (DataBase) - a shortcut property to the AttributeHandler; allowing <code>obj.db.attrname = value</code></li>
<li><code>nattributes</code> - the <a href="Attributes.html">Non-persistent AttributeHandler</a> for attributes not saved in the database.</li>
<li><code>ndb</code> (NotDataBase) - a shortcut property to the Non-peristent AttributeHandler. Allows <code>obj.ndb.attrname = value</code></li>
</ul>
<p>Each of the typeclassed entities then extend this list with their own properties. Go to the respective pages for <a href="Objects.html">Objects</a>, <a href="Scripts.html">Scripts</a>, <a href="Accounts.html">Accounts</a> and <a href="Communications.html">Channels</a> for more info. It's also recommended that you explore the available entities using <a href="Evennia-API">Evennia's flat API</a> to explore which properties and methods they have available.</p>
<h3 id="overloading-hooks">Overloading hooks<a class="headerlink" href="#overloading-hooks" title="Permanent link">&para;</a></h3>
<p>The way to customize typeclasses is usually to overload <em>hook methods</em> on them. Hooks are methods that Evennia call in various situations. An example is the <code>at_object_creation</code> hook on <code>Objects</code>, which is only called once, the very first time this object is saved to the database.  Other examples are the <code>at_login</code> hook of Accounts and the <code>at_repeat</code> hook of Scripts.</p>
<h3 id="querying-for-typeclasses">Querying for typeclasses<a class="headerlink" href="#querying-for-typeclasses" title="Permanent link">&para;</a></h3>
<p>Most of the time you search for objects in the database by using convenience methods like the <code>caller.search()</code> of <a href="Commands.html">Commands</a> or the search functions like <code>evennia.search_objects</code>.</p>
<p>You can however also query for them directly using <a href="https://docs.djangoproject.com/en/1.7/topics/db/queries/">Django's query language</a>. This makes use of a <em>database manager</em> that sits on all typeclasses, named <code>objects</code>. This manager holds methods that allow database searches against that particular type of object (this is the way Django normally works too). When using Django queries, you need to use the full field names (like <code>db_key</code>) to search:</p>
<pre><code class="python">matches = Furniture.objects.get(db_key=&quot;Chair&quot;)

</code></pre>

<p>It is important that this will <em>only</em> find objects inheriting directly from <code>Furniture</code> in your database. If there was a subclass of <code>Furniture</code> named <code>Sitables</code> you would not find any chairs derived from <code>Sitables</code> with this query (this is not a Django feature but special to Evennia). To find objects from subclasses Evennia instead makes the <code>get_family</code> and <code>filter_family</code> query methods available:</p>
<pre><code class="python"># search for all furnitures and subclasses of furnitures
# whose names starts with &quot;Chair&quot;
matches = Furniture.objects.filter_family(db_key__startswith=&quot;Chair&quot;)

</code></pre>

<p>To make sure to search, say, all <code>Scripts</code> <em>regardless</em> of typeclass, you need to query from the database model itself. So for Objects, this would be <code>ObjectDB</code> in the diagram above. Here's an example for Scripts:</p>
<pre><code class="python">from evennia import ScriptDB
matches = ScriptDB.objects.filter(db_key__contains=&quot;Combat&quot;)
</code></pre>

<p>When querying from the database model parent you don't need to use <code>filter_family</code> or <code>get_family</code> - you will always query all children on the database model.</p>
<h2 id="updating-existing-typeclass-instances">Updating existing typeclass instances<a class="headerlink" href="#updating-existing-typeclass-instances" title="Permanent link">&para;</a></h2>
<p>If you already have created instances of Typeclasses, you can modify the <em>Python code</em> at any time - due to how Python inheritance works your changes will automatically be applied to all children once you have reloaded the server.</p>
<p>However, database-saved data, like <code>db_*</code> fields, <a href="Attributes.html">Attributes</a>, <a href="Tags.html">Tags</a> etc, are not themselves embedded into the class and will <em>not</em> be updated automatically. This you need to manage yourself, by searching for all relevant objects and updating or adding the data:</p>
<pre><code class="python"># add a worth Attribute to all existing Furniture
for obj in Furniture.objects.all():
    # this will loop over all Furniture instances
    obj.db.worth = 100
</code></pre>

<p>A common use case is putting all Attributes in the <code>at_*_creation</code> hook of the entity, such as <code>at_object_creation</code> for <code>Objects</code>. This is called every time an object is created - and only then. This is usually what you want but it does mean already existing objects won't get updated if you change the contents of <code>at_object_creation</code> later. You can fix this in a similar way as above (manually setting each Attribute) or with something like this:</p>
<pre><code class="python"># Re-run at_object_creation only on those objects not having the new Attribute
for obj in Furniture.objects.all():
    if not obj.db.worth:
        obj.at_object_creation()
</code></pre>

<p>The above examples can be run in the command prompt created by <code>evennia shell</code>. You could also run it all in-game using <code>@py</code>. That however requires you to put the code (including imports) as one single line using <code>;</code> and <a href="http://www.secnetix.de/olli/Python/list_comprehensions.hawk">list comprehensions</a>, like this (ignore the line break, that's only for readability in the wiki):</p>
<pre><code>@py from typeclasses.furniture import Furniture;
[obj.at_object_creation() for obj in Furniture.objects.all() if not obj.db.worth]
</code></pre>

<p>It is recommended that you plan your game properly before starting to build, to avoid having to retroactively update objects more than necessary.</p>
<h2 id="swap-typeclass">Swap typeclass<a class="headerlink" href="#swap-typeclass" title="Permanent link">&para;</a></h2>
<p>If you want to swap an already existing typeclass, there are two ways to do so: From in-game and via code. From inside the game you can use the default <code>@typeclass</code> command:</p>
<pre><code>@typeclass objname = path.to.new.typeclass
</code></pre>

<p>There are two important switches to this command:
- <code>/reset</code> - This will purge all existing Attributes on the object and re-run the creation hook (like <code>at_object_creation</code> for Objects). This assures you get an object which is purely of this new class.
- <code>/force</code> - This is required if you are changing the class to be <em>the same</em> class the object already has - it's a safety check to avoid user errors. This is usually used together with <code>/reset</code> to re-run the creation hook on an existing class.</p>
<p>In code you instead use the <code>swap_typeclass</code> method which you can find on all typeclassed entities:</p>
<pre><code class="python">obj_to_change.swap_typeclass(new_typeclass_path, clean_attributes=False,
                   run_start_hooks=&quot;all&quot;, no_default=True, clean_cmdsets=False)
</code></pre>

<p>The arguments to this method are described <a href="https://github.com/evennia/evennia/wiki/evennia.typeclasses.models#typedobjectswap_typeclass">in the API docs here</a>.</p>
<h2 id="how-typeclasses-actually-work">How typeclasses actually work<a class="headerlink" href="#how-typeclasses-actually-work" title="Permanent link">&para;</a></h2>
<p><em>This is considered an advanced section.</em></p>
<p>Technically, typeclasses are <a href="https://docs.djangoproject.com/en/1.7/topics/db/models/#proxy-models">Django proxy models</a>.  The only database models that are "real" in the typeclass system (that is, are represented by actual tables in the database) are <code>AccountDB</code>, <code>ObjectDB</code>, <code>ScriptDB</code> and <code>ChannelDB</code> (there are also <a href="Attributes.html">Attributes</a> and <a href="Tags.html">Tags</a> but they are not typeclasses themselves). All the subclasses of them are "proxies", extending them with Python code without actually modifying the database layout.</p>
<p>Evennia modifies Django's proxy model in various ways to allow them to work without any boiler plate (for example you don't need to set the Django "proxy" property in the model <code>Meta</code> subclass, Evennia handles this for you using metaclasses). Evennia also makes sure you can query subclasses as well as patches django to allow multiple inheritance from the same base class.</p>
<h3 id="caveats">Caveats<a class="headerlink" href="#caveats" title="Permanent link">&para;</a></h3>
<p>Evennia uses the <em>idmapper</em> to cache its typeclasses (Django proxy models) in memory. The idmapper allows things like on-object handlers and properties to be stored on typeclass instances and to not get lost as long as the server is running (they will only be cleared on a Server reload). Django does not work like this by default; by default every time you search for an object in the database you'll get a <em>different</em> instance of that object back and anything you stored on it that was not in the database would be lost. The bottom line is that Evennia's Typeclass instances subside in memory a lot longer than vanilla Django model instance do.</p>
<p>There is one  caveat to consider with this, and that relates to <a href="New-Models">making your own models</a>: Foreign relationships to typeclasses are cached by Django and that means that if you were to change an object in a foreign relationship via some other means than via that relationship, the object seeing the relationship may not reliably update but will still see its old cached version. Due to typeclasses staying so long in memory, stale caches of such relationships could be more visible than common in Django. See the <a href="https://github.com/evennia/evennia/issues/1098">closed issue #1098 and its comments</a> for examples and solutions.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = ".",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="js/base.js" defer></script>
        <script src="search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
