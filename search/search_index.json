{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Evennia Documentation \u00b6 This is the manual of Evennia , the open source Python MU* creation system. You can Search the documentation as well as browse all pages alphabetically in the Index . If you have trouble with unclear documentation, please let us know on our mailing list , over IRC or by dropping a note in our quick no-registration online suggestion box ! There is a lengthier introduction to read. You might also want to read about how to get and give help . Getting Started Admin Docs Builder Docs Developer Central Tutorials & Examples API The Getting Started page helps installing and starting Evennia for the first time. The Admin Docs covers running and maintaining an Evennia server. The Builder Docs helps for starting to build a game world using Evennia. The Developer Central describes how Evennia works and is used by coders. The Tutorials & Examples contains help pages on a step-by-step or tutorial format. The API documentation is created from the latest source code.","title":"Home"},{"location":"index.html#evennia-documentation","text":"This is the manual of Evennia , the open source Python MU* creation system. You can Search the documentation as well as browse all pages alphabetically in the Index . If you have trouble with unclear documentation, please let us know on our mailing list , over IRC or by dropping a note in our quick no-registration online suggestion box ! There is a lengthier introduction to read. You might also want to read about how to get and give help . Getting Started Admin Docs Builder Docs Developer Central Tutorials & Examples API The Getting Started page helps installing and starting Evennia for the first time. The Admin Docs covers running and maintaining an Evennia server. The Builder Docs helps for starting to build a game world using Evennia. The Developer Central describes how Evennia works and is used by coders. The Tutorials & Examples contains help pages on a step-by-step or tutorial format. The API documentation is created from the latest source code.","title":"Evennia Documentation"},{"location":"A-voice-operated-elevator-using-events.html","text":"Previous tutorial: Adding dialogues in events This tutorial will walk you through the steps to create a voice-operated elevator, using the in-game Python system . This tutorial assumes the in-game Python system is installed in your game. If it isn't, you can follow the installation steps given in the documentation on in-game Python , and come back on this tutorial once the system is installed. You do not need to read the entire documentation, it's a good reference, but not the easiest way to learn about it. Hence these tutorials. The in-game Python system allows to run code on individual objects in some situations. You don't have to modify the source code to add these features, past the installation. The entire system makes it easy to add specific features to some objects, but not all. What will we try to do? In this tutorial, we are going to create a simple voice-operated elevator. In terms of features, we will: Explore events with parameters. Work on more interesting callbacks. Learn about chained events. Play with variable modification in callbacks. Our study case \u00b6 Let's summarize what we want to achieve first. We would like to create a room that will represent the inside of our elevator. In this room, a character could just say \"1\", \"2\" or \"3\", and the elevator will start moving. The doors will close and open on the new floor (the exits leading in and out of the elevator will be modified). We will work on basic features first, and then will adjust some, showing you how easy and powerfully independent actions can be configured through the in-game Python system. Creating the rooms and exits we need \u00b6 We'll create an elevator right in our room (generally called \"Limbo\", of ID 2). You could easily adapt the following instructions if you already have some rooms and exits, of course, just remember to check the IDs. Note: the in-game Python system uses IDs for a lot of things. While it is not mandatory, it is good practice to know the IDs you have for your callbacks, because it will make manipulation much quicker. There are other ways to identify objects, but as they depend on many factors, IDs are usually the safest path in our callbacks. Let's go into limbo ( #2 ) to add our elevator. We'll add it to the north. To create this room, in-game you could type: tunnel n = Inside of an elevator The game should respond by telling you: Created room Inside of an elevator(#3) of type typeclasses.rooms.Room. Created Exit from Limbo to Inside of an elevator: north(#4) (n). Created Exit back from Inside of an elevator to Limbo: south(#5) (s). Note the given IDs: #2 is limbo, the first room the system created. #3 is our room inside of an elevator. #4 is the north exit from Limbo to our elevator. #5 is the south exit from an elevator to Limbo. Keep these IDs somewhere for the demonstration. You will shortly see why they are important. Why have we created exits to our elevator and back to Limbo? Isn't the elevator supposed to move? It is. But we need to have exits that will represent the way inside the elevator and out. What we will do, at every floor, will be to change these exits so they become connected to the right room. You'll see this process a bit later. We have two more rooms to create: our floor 2 and 3. This time, we'll use dig , because we don't need exits leading there, not yet anyway. dig The second floor dig The third floor Evennia should answer with: Created room The second floor(#6) of type typeclasses.rooms.Room. Created room The third floor(#7) of type typeclasses.rooms.Room. Add these IDs to your list, we will use them too. Our first callback in the elevator \u00b6 Let's go to the elevator (you could use tel #3 if you have the same IDs I have). This is our elevator room. It looks a bit empty, feel free to add a prettier description or other things to decorate it a bit. But what we want now is to be able to say \"1\", \"2\" or \"3\" and have the elevator move in that direction. If you have read the previous tutorial about adding dialogues in events , you may remember what we need to do. If not, here's a summary: we need to run some code when somebody speaks in the room. So we need to create a callback (the callback will contain our lines of code). We just need to know on which event this should be set. You can enter call here to see the possible events in this room. In the table, you should see the \"say\" event, which is called when somebody says something in the room. So we'll need to add a callback to this event. Don't worry if you're a bit lost, just follow the following steps, the way they connect together will become more obvious. call/add here = say 1, 2, 3 We need to add a callback. A callback contains the code that will be executed at a given time. So we use the call/add command and switch. here is our object, the room in which we are. An equal sign. The name of the event to which the callback should be connected. Here, the event is \"say\". Meaning this callback will be executed every time somebody says something in the room. But we add an event parameter to indicate the keywords said in the room that should execute our callback. Otherwise, our callback would be called every time somebody speaks, no matter what. Here we limit, indicating our callback should be executed only if the spoken message contains \"1\", \"2\" or \"3\". An editor should open, inviting you to enter the Python code that should be executed. The first thing to remember is to read the text provided (it can contain important information) and, most of all, the list of variables that are available in this callback: Variables you can use in this event: character: the character having spoken in this room. room: the room connected to this event. message: the text having been spoken by the character. ----------Line Editor [Callback say of Inside of an elevator]--------------------- 01| ----------[l:01 w:000 c:0000]------------(:h for help)---------------------------- This is important, in order to know what variables we can use in our callback out-of-the-box. Let's write a single line to be sure our callback is called when we expect it to: character.msg(\"You just said {}.\".format(message)) You can paste this line in-game, then type the :wq command to exit the editor and save your modifications. Let's check. Try to say \"hello\" in the room. You should see the standard message, but nothing more. Now try to say \"1\". Below the standard message, you should see: You just said 1. You can try it. Our callback is only called when we say \"1\", \"2\" or \"3\". Which is just what we want. Let's go back in our code editor and add something more useful. call/edit here = say Notice that we used the \"edit\" switch this time, since the callback exists, we just want to edit it. The editor opens again. Let's empty it first: :DD And turn off automatic indentation, which will help us: := Auto-indentation is an interesting feature of the code editor, but we'd better not use it at this point, it will make copy/pasting more complicated. Our entire callback in the elevator \u00b6 So here's the time to truly code our callback in-game. Here's a little reminder: We have all the IDs of our three rooms and two exits. When we say \"1\", \"2\" or \"3\", the elevator should move to the right room, that is change the exits. Remember, we already have the exits, we just need to change their location and destination. It's a good idea to try to write this callback yourself, but don't feel bad about checking the solution right now. Here's a possible code that you could paste in the code editor: # First let's have some constants ELEVATOR = get(id=3) FLOORS = { \"1\": get(id=2), \"2\": get(id=6), \"3\": get(id=7), } TO_EXIT = get(id=4) BACK_EXIT = get(id=5) # Now we check that the elevator isn't already at this floor floor = FLOORS.get(message) if floor is None: character.msg(\"Which floor do you want?\") elif TO_EXIT.location is floor: character.msg(\"The elevator already is at this floor.\") else: # 'floor' contains the new room where the elevator should be room.msg_contents(\"The doors of the elevator close with a clank.\") TO_EXIT.location = floor BACK_EXIT.destination = floor room.msg_contents(\"The doors of the elevator open to {floor}.\", mapping=dict(floor=floor)) Let's review this longer callback: We first obtain the objects of both exits and our three floors. We use the get() eventfunc, which is a shortcut to obtaining objects. We usually use it to retrieve specific objects with an ID. We put the floors in a dictionary. The keys of the dictionary are the floor number (as str), the values are room objects. Remember, the message variable contains the message spoken in the room. So either \"1\", \"2\", or \"3\". We still need to check it, however, because if the character says something like \"1 2\" in the room, our callback will be executed. Let's be sure what she says is a floor number. We then check if the elevator is already at this floor. Notice that we use TO_EXIT.location . TO_EXIT contains our \"north\" exit, leading inside of our elevator. Therefore, its location will be the room where the elevator currently is. If the floor is a different one, have the elevator \"move\", changing just the location and destination of both exits. The BACK_EXIT (that is \"north\") should change its location. The elevator shouldn't be accessible through our old floor. The TO_EXIT (that is \"south\", the exit leading out of the elevator) should have a different destination. When we go out of the elevator, we should find ourselves in the new floor, not the old one. Feel free to expand on this example, changing messages, making further checks. Usage and practice are keys. You can quit the editor as usual with :wq and test it out. Adding a pause in our callback \u00b6 Let's improve our callback. One thing that's worth adding would be a pause: for the time being, when we say the floor number in the elevator, the doors close and open right away. It would be better to have a pause of several seconds. More logical. This is a great opportunity to learn about chained events. Chained events are very useful to create pauses. Contrary to the events we have seen so far, chained events aren't called automatically. They must be called by you, and can be called after some time. Chained events always have the name \"chain_X\". Usually, X is a number, but you can give the chained event a more explicit name. In our original callback, we will call our chained events in, say, 15 seconds. We'll also have to make sure the elevator isn't already moving. Other than that, a chained event can be connected to a callback as usual. We'll create a chained event in our elevator, that will only contain the code necessary to open the doors to the new floor. call/add here = chain_1 The callback is added to the \"chain_1\" event, an event that will not be automatically called by the system when something happens. Inside this event, you can paste the code to open the doors at the new floor. You can notice a few differences: TO_EXIT.location = floor TO_EXIT.destination = ELEVATOR BACK_EXIT.location = ELEVATOR BACK_EXIT.destination = floor room.msg_contents(\"The doors of the elevator open to {floor}.\", mapping=dict(floor=floor)) Paste this code into the editor, then use :wq to save and quit the editor. Now let's edit our callback in the \"say\" event. We'll have to change it a bit: The callback will have to check the elevator isn't already moving. It must change the exits when the elevator move. It has to call the \"chain_1\" event we have defined. It should call it 15 seconds later. Let's see the code in our callback. call/edit here = say Remove the current code and disable auto-indentation again: :DD := And you can paste instead the following code. Notice the differences with our first attempt: # First let's have some constants ELEVATOR = get(id=3) FLOORS = { \"1\": get(id=2), \"2\": get(id=6), \"3\": get(id=7), } TO_EXIT = get(id=4) BACK_EXIT = get(id=5) # Now we check that the elevator isn't already at this floor floor = FLOORS.get(message) if floor is None: character.msg(\"Which floor do you want?\") elif BACK_EXIT.location is None: character.msg(\"The elevator is between floors.\") elif TO_EXIT.location is floor: character.msg(\"The elevator already is at this floor.\") else: # 'floor' contains the new room where the elevator should be room.msg_contents(\"The doors of the elevator close with a clank.\") TO_EXIT.location = None BACK_EXIT.location = None call_event(room, \"chain_1\", 15) What changed? We added a little test to make sure the elevator wasn't already moving. If it is, the BACK_EXIT.location (the \"south\" exit leading out of the elevator) should be None . We'll remove the exit while the elevator is moving. When the doors close, we set both exits' location to None . Which \"removes\" them from their room but doesn't destroy them. The exits still exist but they don't connect anything. If you say \"2\" in the elevator and look around while the elevator is moving, you won't see any exits. Instead of opening the doors immediately, we call call_event . We give it the object containing the event to be called (here, our elevator), the name of the event to be called (here, \"chain_1\") and the number of seconds from now when the event should be called (here, 15 ). The chain_1 callback we have created contains the code to \"re-open\" the elevator doors. That is, besides displaying a message, it reset the exits' location and destination . If you try to say \"3\" in the elevator, you should see the doors closing. Look around you and you won't see any exit. Then, 15 seconds later, the doors should open, and you can leave the elevator to go to the third floor. While the elevator is moving, the exit leading to it will be inaccessible. Note: we don't define the variables again in our chained event, we just call them. When we execute call_event , a copy of our current variables is placed in the database. These variables will be restored and accessible again when the chained event is called. You can use the call/tasks command to see the tasks waiting to be executed. For instance, say \"2\" in the room, notice the doors closing, and then type the call/tasks command. You will see a task in the elevator, waiting to call the chain_1 event. Changing exit messages \u00b6 Here's another nice little feature of events: you can modify the message of a single exit without altering the others. In this case, when someone goes north into our elevator, we'd like to see something like: \"someone walks into the elevator.\" Something similar for the back exit would be great too. Inside of the elevator, you can look at the available events on the exit leading outside (south). call south You should see two interesting rows in this table: | msg_arrive | 0 (0) | Customize the message when a character | | | | arrives through this exit. | | msg_leave | 0 (0) | Customize the message when a character leaves | | | | through this exit. | So we can change the message others see when a character leaves, by editing the \"msg_leave\" event. Let's do that: call/add south = msg_leave Take the time to read the help. It gives you all the information you should need. We'll need to change the \"message\" variable, and use custom mapping (between braces) to alter the message. We're given an example, let's use it. In the code editor, you can paste the following line: message = \"{character} walks out of the elevator.\" Again, save and quit the editor by entering :wq . You can create a new character to see it leave. charcreate A beggar tel #8 = here (Obviously, adapt the ID if necessary.) py self.search(\"beggar\").move_to(self.search(\"south\")) This is a crude way to force our beggar out of the elevator, but it allows us to test. You should see: A beggar(#8) walks out of the elevator. Great! Let's do the same thing for the exit leading inside of the elevator. Follow the beggar, then edit \"msg_leave\" of \"north\": call/add north = msg_leave message = \"{character} walks into the elevator.\" Again, you can force our beggar to move and see the message we have just set. This modification applies to these two exits, obviously: the custom message won't be used for other exits. Since we use the same exits for every floor, this will be available no matter at what floor the elevator is, which is pretty neat! Tutorial F.A.Q. \u00b6 Q: what happens if the game reloads or shuts down while a task is waiting to happen? A: if your game reloads while a task is in pause (like our elevator between floors), when the game is accessible again, the task will be called (if necessary, with a new time difference to take into account the reload). If the server shuts down, obviously, the task will not be called, but will be stored and executed when the server is up again. Q: can I use all kinds of variables in my callback? Whether chained or not? A: you can use every variable type you like in your original callback. However, if you execute call_event , since your variables are stored in the database, they will need to respect the constraints on persistent attributes. A callback will not be stored in this way, for instance. This variable will not be available in your chained event. Q: when you say I can call my chained events something else than \"chain_1\", \"chain_2\" and such, what is the naming convention? A: chained events have names beginning by \"chain_\". This is useful for you and for the system. But after the underscore, you can give a more useful name, like \"chain_open_doors\" in our case. Q: do I have to pause several seconds to call a chained event? A: no, you can call it right away. Just leave the third parameter of call_event out (it will default to 0, meaning the chained event will be called right away). This will not create a task. Q: can I have chained events calling themselves? A: you can. There's no limitation. Just be careful, a callback that calls itself, particularly without delay, might be a good recipe for an infinite loop. However, in some cases, it is useful to have chained events calling themselves, to do the same repeated action every X seconds for instance. Q: what if I need several elevators, do I need to copy/paste these callbacks each time? A: not advisable. There are definitely better ways to handle this situation. One of them is to consider adding the code in the source itself. Another possibility is to call chained events with the expected behavior, which makes porting code very easy. This side of chained events will be shown in the next tutorial. Previous tutorial: Adding dialogues in events","title":"A voice operated elevator using events"},{"location":"A-voice-operated-elevator-using-events.html#our-study-case","text":"Let's summarize what we want to achieve first. We would like to create a room that will represent the inside of our elevator. In this room, a character could just say \"1\", \"2\" or \"3\", and the elevator will start moving. The doors will close and open on the new floor (the exits leading in and out of the elevator will be modified). We will work on basic features first, and then will adjust some, showing you how easy and powerfully independent actions can be configured through the in-game Python system.","title":"Our study case"},{"location":"A-voice-operated-elevator-using-events.html#creating-the-rooms-and-exits-we-need","text":"We'll create an elevator right in our room (generally called \"Limbo\", of ID 2). You could easily adapt the following instructions if you already have some rooms and exits, of course, just remember to check the IDs. Note: the in-game Python system uses IDs for a lot of things. While it is not mandatory, it is good practice to know the IDs you have for your callbacks, because it will make manipulation much quicker. There are other ways to identify objects, but as they depend on many factors, IDs are usually the safest path in our callbacks. Let's go into limbo ( #2 ) to add our elevator. We'll add it to the north. To create this room, in-game you could type: tunnel n = Inside of an elevator The game should respond by telling you: Created room Inside of an elevator(#3) of type typeclasses.rooms.Room. Created Exit from Limbo to Inside of an elevator: north(#4) (n). Created Exit back from Inside of an elevator to Limbo: south(#5) (s). Note the given IDs: #2 is limbo, the first room the system created. #3 is our room inside of an elevator. #4 is the north exit from Limbo to our elevator. #5 is the south exit from an elevator to Limbo. Keep these IDs somewhere for the demonstration. You will shortly see why they are important. Why have we created exits to our elevator and back to Limbo? Isn't the elevator supposed to move? It is. But we need to have exits that will represent the way inside the elevator and out. What we will do, at every floor, will be to change these exits so they become connected to the right room. You'll see this process a bit later. We have two more rooms to create: our floor 2 and 3. This time, we'll use dig , because we don't need exits leading there, not yet anyway. dig The second floor dig The third floor Evennia should answer with: Created room The second floor(#6) of type typeclasses.rooms.Room. Created room The third floor(#7) of type typeclasses.rooms.Room. Add these IDs to your list, we will use them too.","title":"Creating the rooms and exits we need"},{"location":"A-voice-operated-elevator-using-events.html#our-first-callback-in-the-elevator","text":"Let's go to the elevator (you could use tel #3 if you have the same IDs I have). This is our elevator room. It looks a bit empty, feel free to add a prettier description or other things to decorate it a bit. But what we want now is to be able to say \"1\", \"2\" or \"3\" and have the elevator move in that direction. If you have read the previous tutorial about adding dialogues in events , you may remember what we need to do. If not, here's a summary: we need to run some code when somebody speaks in the room. So we need to create a callback (the callback will contain our lines of code). We just need to know on which event this should be set. You can enter call here to see the possible events in this room. In the table, you should see the \"say\" event, which is called when somebody says something in the room. So we'll need to add a callback to this event. Don't worry if you're a bit lost, just follow the following steps, the way they connect together will become more obvious. call/add here = say 1, 2, 3 We need to add a callback. A callback contains the code that will be executed at a given time. So we use the call/add command and switch. here is our object, the room in which we are. An equal sign. The name of the event to which the callback should be connected. Here, the event is \"say\". Meaning this callback will be executed every time somebody says something in the room. But we add an event parameter to indicate the keywords said in the room that should execute our callback. Otherwise, our callback would be called every time somebody speaks, no matter what. Here we limit, indicating our callback should be executed only if the spoken message contains \"1\", \"2\" or \"3\". An editor should open, inviting you to enter the Python code that should be executed. The first thing to remember is to read the text provided (it can contain important information) and, most of all, the list of variables that are available in this callback: Variables you can use in this event: character: the character having spoken in this room. room: the room connected to this event. message: the text having been spoken by the character. ----------Line Editor [Callback say of Inside of an elevator]--------------------- 01| ----------[l:01 w:000 c:0000]------------(:h for help)---------------------------- This is important, in order to know what variables we can use in our callback out-of-the-box. Let's write a single line to be sure our callback is called when we expect it to: character.msg(\"You just said {}.\".format(message)) You can paste this line in-game, then type the :wq command to exit the editor and save your modifications. Let's check. Try to say \"hello\" in the room. You should see the standard message, but nothing more. Now try to say \"1\". Below the standard message, you should see: You just said 1. You can try it. Our callback is only called when we say \"1\", \"2\" or \"3\". Which is just what we want. Let's go back in our code editor and add something more useful. call/edit here = say Notice that we used the \"edit\" switch this time, since the callback exists, we just want to edit it. The editor opens again. Let's empty it first: :DD And turn off automatic indentation, which will help us: := Auto-indentation is an interesting feature of the code editor, but we'd better not use it at this point, it will make copy/pasting more complicated.","title":"Our first callback in the elevator"},{"location":"A-voice-operated-elevator-using-events.html#our-entire-callback-in-the-elevator","text":"So here's the time to truly code our callback in-game. Here's a little reminder: We have all the IDs of our three rooms and two exits. When we say \"1\", \"2\" or \"3\", the elevator should move to the right room, that is change the exits. Remember, we already have the exits, we just need to change their location and destination. It's a good idea to try to write this callback yourself, but don't feel bad about checking the solution right now. Here's a possible code that you could paste in the code editor: # First let's have some constants ELEVATOR = get(id=3) FLOORS = { \"1\": get(id=2), \"2\": get(id=6), \"3\": get(id=7), } TO_EXIT = get(id=4) BACK_EXIT = get(id=5) # Now we check that the elevator isn't already at this floor floor = FLOORS.get(message) if floor is None: character.msg(\"Which floor do you want?\") elif TO_EXIT.location is floor: character.msg(\"The elevator already is at this floor.\") else: # 'floor' contains the new room where the elevator should be room.msg_contents(\"The doors of the elevator close with a clank.\") TO_EXIT.location = floor BACK_EXIT.destination = floor room.msg_contents(\"The doors of the elevator open to {floor}.\", mapping=dict(floor=floor)) Let's review this longer callback: We first obtain the objects of both exits and our three floors. We use the get() eventfunc, which is a shortcut to obtaining objects. We usually use it to retrieve specific objects with an ID. We put the floors in a dictionary. The keys of the dictionary are the floor number (as str), the values are room objects. Remember, the message variable contains the message spoken in the room. So either \"1\", \"2\", or \"3\". We still need to check it, however, because if the character says something like \"1 2\" in the room, our callback will be executed. Let's be sure what she says is a floor number. We then check if the elevator is already at this floor. Notice that we use TO_EXIT.location . TO_EXIT contains our \"north\" exit, leading inside of our elevator. Therefore, its location will be the room where the elevator currently is. If the floor is a different one, have the elevator \"move\", changing just the location and destination of both exits. The BACK_EXIT (that is \"north\") should change its location. The elevator shouldn't be accessible through our old floor. The TO_EXIT (that is \"south\", the exit leading out of the elevator) should have a different destination. When we go out of the elevator, we should find ourselves in the new floor, not the old one. Feel free to expand on this example, changing messages, making further checks. Usage and practice are keys. You can quit the editor as usual with :wq and test it out.","title":"Our entire callback in the elevator"},{"location":"A-voice-operated-elevator-using-events.html#adding-a-pause-in-our-callback","text":"Let's improve our callback. One thing that's worth adding would be a pause: for the time being, when we say the floor number in the elevator, the doors close and open right away. It would be better to have a pause of several seconds. More logical. This is a great opportunity to learn about chained events. Chained events are very useful to create pauses. Contrary to the events we have seen so far, chained events aren't called automatically. They must be called by you, and can be called after some time. Chained events always have the name \"chain_X\". Usually, X is a number, but you can give the chained event a more explicit name. In our original callback, we will call our chained events in, say, 15 seconds. We'll also have to make sure the elevator isn't already moving. Other than that, a chained event can be connected to a callback as usual. We'll create a chained event in our elevator, that will only contain the code necessary to open the doors to the new floor. call/add here = chain_1 The callback is added to the \"chain_1\" event, an event that will not be automatically called by the system when something happens. Inside this event, you can paste the code to open the doors at the new floor. You can notice a few differences: TO_EXIT.location = floor TO_EXIT.destination = ELEVATOR BACK_EXIT.location = ELEVATOR BACK_EXIT.destination = floor room.msg_contents(\"The doors of the elevator open to {floor}.\", mapping=dict(floor=floor)) Paste this code into the editor, then use :wq to save and quit the editor. Now let's edit our callback in the \"say\" event. We'll have to change it a bit: The callback will have to check the elevator isn't already moving. It must change the exits when the elevator move. It has to call the \"chain_1\" event we have defined. It should call it 15 seconds later. Let's see the code in our callback. call/edit here = say Remove the current code and disable auto-indentation again: :DD := And you can paste instead the following code. Notice the differences with our first attempt: # First let's have some constants ELEVATOR = get(id=3) FLOORS = { \"1\": get(id=2), \"2\": get(id=6), \"3\": get(id=7), } TO_EXIT = get(id=4) BACK_EXIT = get(id=5) # Now we check that the elevator isn't already at this floor floor = FLOORS.get(message) if floor is None: character.msg(\"Which floor do you want?\") elif BACK_EXIT.location is None: character.msg(\"The elevator is between floors.\") elif TO_EXIT.location is floor: character.msg(\"The elevator already is at this floor.\") else: # 'floor' contains the new room where the elevator should be room.msg_contents(\"The doors of the elevator close with a clank.\") TO_EXIT.location = None BACK_EXIT.location = None call_event(room, \"chain_1\", 15) What changed? We added a little test to make sure the elevator wasn't already moving. If it is, the BACK_EXIT.location (the \"south\" exit leading out of the elevator) should be None . We'll remove the exit while the elevator is moving. When the doors close, we set both exits' location to None . Which \"removes\" them from their room but doesn't destroy them. The exits still exist but they don't connect anything. If you say \"2\" in the elevator and look around while the elevator is moving, you won't see any exits. Instead of opening the doors immediately, we call call_event . We give it the object containing the event to be called (here, our elevator), the name of the event to be called (here, \"chain_1\") and the number of seconds from now when the event should be called (here, 15 ). The chain_1 callback we have created contains the code to \"re-open\" the elevator doors. That is, besides displaying a message, it reset the exits' location and destination . If you try to say \"3\" in the elevator, you should see the doors closing. Look around you and you won't see any exit. Then, 15 seconds later, the doors should open, and you can leave the elevator to go to the third floor. While the elevator is moving, the exit leading to it will be inaccessible. Note: we don't define the variables again in our chained event, we just call them. When we execute call_event , a copy of our current variables is placed in the database. These variables will be restored and accessible again when the chained event is called. You can use the call/tasks command to see the tasks waiting to be executed. For instance, say \"2\" in the room, notice the doors closing, and then type the call/tasks command. You will see a task in the elevator, waiting to call the chain_1 event.","title":"Adding a pause in our callback"},{"location":"A-voice-operated-elevator-using-events.html#changing-exit-messages","text":"Here's another nice little feature of events: you can modify the message of a single exit without altering the others. In this case, when someone goes north into our elevator, we'd like to see something like: \"someone walks into the elevator.\" Something similar for the back exit would be great too. Inside of the elevator, you can look at the available events on the exit leading outside (south). call south You should see two interesting rows in this table: | msg_arrive | 0 (0) | Customize the message when a character | | | | arrives through this exit. | | msg_leave | 0 (0) | Customize the message when a character leaves | | | | through this exit. | So we can change the message others see when a character leaves, by editing the \"msg_leave\" event. Let's do that: call/add south = msg_leave Take the time to read the help. It gives you all the information you should need. We'll need to change the \"message\" variable, and use custom mapping (between braces) to alter the message. We're given an example, let's use it. In the code editor, you can paste the following line: message = \"{character} walks out of the elevator.\" Again, save and quit the editor by entering :wq . You can create a new character to see it leave. charcreate A beggar tel #8 = here (Obviously, adapt the ID if necessary.) py self.search(\"beggar\").move_to(self.search(\"south\")) This is a crude way to force our beggar out of the elevator, but it allows us to test. You should see: A beggar(#8) walks out of the elevator. Great! Let's do the same thing for the exit leading inside of the elevator. Follow the beggar, then edit \"msg_leave\" of \"north\": call/add north = msg_leave message = \"{character} walks into the elevator.\" Again, you can force our beggar to move and see the message we have just set. This modification applies to these two exits, obviously: the custom message won't be used for other exits. Since we use the same exits for every floor, this will be available no matter at what floor the elevator is, which is pretty neat!","title":"Changing exit messages"},{"location":"A-voice-operated-elevator-using-events.html#tutorial-faq","text":"Q: what happens if the game reloads or shuts down while a task is waiting to happen? A: if your game reloads while a task is in pause (like our elevator between floors), when the game is accessible again, the task will be called (if necessary, with a new time difference to take into account the reload). If the server shuts down, obviously, the task will not be called, but will be stored and executed when the server is up again. Q: can I use all kinds of variables in my callback? Whether chained or not? A: you can use every variable type you like in your original callback. However, if you execute call_event , since your variables are stored in the database, they will need to respect the constraints on persistent attributes. A callback will not be stored in this way, for instance. This variable will not be available in your chained event. Q: when you say I can call my chained events something else than \"chain_1\", \"chain_2\" and such, what is the naming convention? A: chained events have names beginning by \"chain_\". This is useful for you and for the system. But after the underscore, you can give a more useful name, like \"chain_open_doors\" in our case. Q: do I have to pause several seconds to call a chained event? A: no, you can call it right away. Just leave the third parameter of call_event out (it will default to 0, meaning the chained event will be called right away). This will not create a task. Q: can I have chained events calling themselves? A: you can. There's no limitation. Just be careful, a callback that calls itself, particularly without delay, might be a good recipe for an infinite loop. However, in some cases, it is useful to have chained events calling themselves, to do the same repeated action every X seconds for instance. Q: what if I need several elevators, do I need to copy/paste these callbacks each time? A: not advisable. There are definitely better ways to handle this situation. One of them is to consider adding the code in the source itself. Another possibility is to call chained events with the expected behavior, which makes porting code very easy. This side of chained events will be shown in the next tutorial. Previous tutorial: Adding dialogues in events","title":"Tutorial F.A.Q."},{"location":"API-refactoring.html","text":"Building up to Evennia 1.0 and beyond, it's time to comb through the Evennia API for old cruft. This whitepage is for anyone interested to contribute with their views on what part of the API needs refactoring, cleanup or clarification (or extension!) Note that this is not a forum. To keep things clean, each opinion text should ideally present a clear argument or lay out a suggestion. Asking for clarification and any side-discussions should be held in chat or forum. Griatch (Aug 13, 2019) \u00b6 This is how to enter an opinion. Use any markdown needed but stay within your section. Also remember to copy your text to the clipboard before saving since if someone else edited the wiki in the meantime you'll have to start over. Griatch (Sept 2, 2019) \u00b6 I don't agree with removing explicit keywords as suggested by Johnny on Aug 29 below . Overriding such a method can still be done by get(self, **kwargs) if so desired, making the kwargs explicit helps IMO readability of the API. If just giving a generic **kwargs , one must read the docstring or even the code to see which keywords are valid. On the other hand, I think it makes sense to as a standard offer an extra **kwargs at the end of arg-lists for common methods that are expected to be over-ridden. This make the API more flexible by hinting to the dev that they could expand their own over-ridden implementation with their own keyword arguments if so desired. Johnny \u00b6 Reduce usage of optional/positional arguments (Aug 29, 2019) \u00b6 # AttributeHandler def get(self, key=None, default=None, category=None, return_obj=False, strattr=False, raise_exception=False, accessing_obj=None, default_access=True, return_list=False): Many classes have methods requiring lengthy positional argument lists, which are tedious and error-prone to extend and override especially in cases where not all arguments are even required. It would be useful if arguments were reserved for required inputs and anything else relegated to kwargs for easier passthrough on extension.","title":"API refactoring"},{"location":"API-refactoring.html#griatch-aug-13-2019","text":"This is how to enter an opinion. Use any markdown needed but stay within your section. Also remember to copy your text to the clipboard before saving since if someone else edited the wiki in the meantime you'll have to start over.","title":"Griatch (Aug 13, 2019)"},{"location":"API-refactoring.html#griatch-sept-2-2019","text":"I don't agree with removing explicit keywords as suggested by Johnny on Aug 29 below . Overriding such a method can still be done by get(self, **kwargs) if so desired, making the kwargs explicit helps IMO readability of the API. If just giving a generic **kwargs , one must read the docstring or even the code to see which keywords are valid. On the other hand, I think it makes sense to as a standard offer an extra **kwargs at the end of arg-lists for common methods that are expected to be over-ridden. This make the API more flexible by hinting to the dev that they could expand their own over-ridden implementation with their own keyword arguments if so desired.","title":"Griatch (Sept 2, 2019)"},{"location":"API-refactoring.html#johnny","text":"","title":"Johnny"},{"location":"API-refactoring.html#reduce-usage-of-optionalpositional-arguments-aug-29-2019","text":"# AttributeHandler def get(self, key=None, default=None, category=None, return_obj=False, strattr=False, raise_exception=False, accessing_obj=None, default_access=True, return_list=False): Many classes have methods requiring lengthy positional argument lists, which are tedious and error-prone to extend and override especially in cases where not all arguments are even required. It would be useful if arguments were reserved for required inputs and anything else relegated to kwargs for easier passthrough on extension.","title":"Reduce usage of optional/positional arguments (Aug 29, 2019)"},{"location":"Accounts.html","text":"All users (real people) that starts a game Session on Evennia are doing so through an object called Account . The Account object has no in-game representation, it represents a unique game account. In order to actually get on the game the Account must puppet an Object (normally a Character ). Exactly how many Sessions can interact with an Account and its Puppets at once is determined by Evennia's MULTISESSION_MODE setting. Apart from storing login information and other account-specific data, the Account object is what is chatting on Channels . It is also a good place to store Permissions to be consistent between different in-game characters as well as configuration options. The Account object also has its own CmdSet , the AccountCmdSet . Logged into default evennia, you can use the ooc command to leave your current character and go into OOC mode. You are quite limited in this mode, basically it works like a simple chat program. It acts as a staging area for switching between Characters (if your game supports that) or as a safety mode if your Character gets deleted. Use ic to attempt to (re)puppet a Character. Note that the Account object can have, and often does have, a different set of Permissions from the Character they control. Normally you should put your permissions on the Account level - this will overrule permissions set on the Character level. For the permissions of the Character to come into play the default quell command can be used. This allows for exploring the game using a different permission set (but you can't escalate your permissions this way - for hierarchical permissions like Builder , Admin etc, the lower of the permissions on the Character/Account will always be used). How to create your own Account types \u00b6 You will usually not want more than one Account typeclass for all new accounts (but you could in principle create a system that changes an account's typeclass dynamically). An Evennia Account is, per definition, a Python class that includes evennia.DefaultAccount among its parents. In mygame/typeclasses/accounts.py there is an empty class ready for you to modify. Evennia defaults to using this (it inherits directly from DefaultAccount ). Here's an example of modifying the default Account class in code: # in mygame/typeclasses/accounts.py from evennia import DefaultAccount class Account(DefaultAccount): # [...] at_account_creation(self): \"this is called only once, when account is first created\" self.db.real_name = None # this is set later self.db.real_address = None # \" self.db.config_1 = True # default config self.db.config_2 = False # \" self.db.config_3 = 1 # \" # ... whatever else our game needs to know ``` Reload the server with `reload`. ... However, if you use examine *self (the asterisk makes you examine your Account object rather than your Character), you won't see your new Attributes yet. This is because at_account_creation is only called the very first time the Account is called and your Account object already exists (any new Accounts that connect will see them though). To update yourself you need to make sure to re-fire the hook on all the Accounts you have already created. Here is an example of how to do this using py : py [account.at_account_creation() for account in evennia.managers.accounts.all()] You should now see the Attributes on yourself. If you wanted Evennia to default to a completely different Account class located elsewhere, you must point Evennia to it. Add BASE_ACCOUNT_TYPECLASS to your settings file, and give the python path to your custom class as its value. By default this points to typeclasses.accounts.Account , the empty template we used above. Properties on Accounts \u00b6 Beyond those properties assigned to all typeclassed objects (see Typeclasses ), the Account also has the following custom properties: user - a unique link to a User Django object, representing the logged-in user. obj - an alias for character . name - an alias for user.username sessions - an instance of ObjectSessionHandler managing all connected Sessions (physical connections) this object listens to (Note: In older versions of Evennia, this was a list). The so-called session-id (used in many places) is found as a property sessid on each Session instance. is_superuser (bool: True/False) - if this account is a superuser. Special handlers: - cmdset - This holds all the current Commands of this Account. By default these are the commands found in the cmdset defined by settings.CMDSET_ACCOUNT . - nicks - This stores and handles Nicks , in the same way as nicks it works on Objects. For Accounts, nicks are primarily used to store custom aliases for Channels . Selection of special methods (see evennia.DefaultAccount for details): - get_puppet - get a currently puppeted object connected to the Account and a given session id, if any. - puppet_object - connect a session to a puppetable Object. - unpuppet_object - disconnect a session from a puppetable Object. - msg - send text to the Account - execute_cmd - runs a command as if this Account did it. - search - search for Accounts.","title":"Accounts"},{"location":"Accounts.html#how-to-create-your-own-account-types","text":"You will usually not want more than one Account typeclass for all new accounts (but you could in principle create a system that changes an account's typeclass dynamically). An Evennia Account is, per definition, a Python class that includes evennia.DefaultAccount among its parents. In mygame/typeclasses/accounts.py there is an empty class ready for you to modify. Evennia defaults to using this (it inherits directly from DefaultAccount ). Here's an example of modifying the default Account class in code: # in mygame/typeclasses/accounts.py from evennia import DefaultAccount class Account(DefaultAccount): # [...] at_account_creation(self): \"this is called only once, when account is first created\" self.db.real_name = None # this is set later self.db.real_address = None # \" self.db.config_1 = True # default config self.db.config_2 = False # \" self.db.config_3 = 1 # \" # ... whatever else our game needs to know ``` Reload the server with `reload`. ... However, if you use examine *self (the asterisk makes you examine your Account object rather than your Character), you won't see your new Attributes yet. This is because at_account_creation is only called the very first time the Account is called and your Account object already exists (any new Accounts that connect will see them though). To update yourself you need to make sure to re-fire the hook on all the Accounts you have already created. Here is an example of how to do this using py : py [account.at_account_creation() for account in evennia.managers.accounts.all()] You should now see the Attributes on yourself. If you wanted Evennia to default to a completely different Account class located elsewhere, you must point Evennia to it. Add BASE_ACCOUNT_TYPECLASS to your settings file, and give the python path to your custom class as its value. By default this points to typeclasses.accounts.Account , the empty template we used above.","title":"How to create your own Account types"},{"location":"Accounts.html#properties-on-accounts","text":"Beyond those properties assigned to all typeclassed objects (see Typeclasses ), the Account also has the following custom properties: user - a unique link to a User Django object, representing the logged-in user. obj - an alias for character . name - an alias for user.username sessions - an instance of ObjectSessionHandler managing all connected Sessions (physical connections) this object listens to (Note: In older versions of Evennia, this was a list). The so-called session-id (used in many places) is found as a property sessid on each Session instance. is_superuser (bool: True/False) - if this account is a superuser. Special handlers: - cmdset - This holds all the current Commands of this Account. By default these are the commands found in the cmdset defined by settings.CMDSET_ACCOUNT . - nicks - This stores and handles Nicks , in the same way as nicks it works on Objects. For Accounts, nicks are primarily used to store custom aliases for Channels . Selection of special methods (see evennia.DefaultAccount for details): - get_puppet - get a currently puppeted object connected to the Account and a given session id, if any. - puppet_object - connect a session to a puppetable Object. - unpuppet_object - disconnect a session from a puppetable Object. - msg - send text to the Account - execute_cmd - runs a command as if this Account did it. - search - search for Accounts.","title":"Properties on Accounts"},{"location":"Add-a-simple-new-web-page.html","text":"Evennia leverages Django which is a web development framework. Huge professional websites are made in Django and there is extensive documentation (and books) on it . You are encouraged to at least look at the Django basic tutorials. Here we will just give a brief introduction for how things hang together, to get you started. We assume you have installed and set up Evennia to run. A webserver and website comes out of the box. You can get to that by entering http://localhost:4001 in your web browser - you should see a welcome page with some game statistics and a link to the web client. Let us add a new page that you can get to by going to http://localhost:4001/story . Create the view \u00b6 A django \"view\" is a normal Python function that django calls to render the HTML page you will see in the web browser. Here we will just have it spit back the raw html, but Django can do all sorts of cool stuff with the page in the view, like adding dynamic content or change it on the fly. Open mygame/web folder and add a new module there named story.py (you could also put it in its own folder if you wanted to be neat. Don't forget to add an empty __init__.py file if you do, to tell Python you can import from the new folder). Here's how it looks: # in mygame/web/story.py from django.shortcuts import render def storypage(request): return render(request, \"story.html\") This view takes advantage of a shortcut provided to use by Django, render . This shortcut gives the template some information from the request, for instance, the game name, and then renders it. The HTML page \u00b6 We need to find a place where Evennia (and Django) looks for html files (called templates in Django parlance). You can specify such places in your settings (see the TEMPLATES variable in default_settings.py for more info), but here we'll use an existing one. Go to mygame/template/overrides/website/ and create a page story.html there. This is not a HTML tutorial, so we'll go simple: {% extends \"base.html\" %} {% block content %} <div class=\"row\"> <div class=\"col\"> <h1>A story about a tree</h1> <p> This is a story about a tree, a classic tale ... </p> </div> </div> {% endblock %} Since we've used the render shortcut, Django will allow us to extend our base styles easily. If you'd rather not take advantage of Evennia's base styles, you can do something like this instead: <html> <body> <h1>A story about a tree</h1> <p> This is a story about a tree, a classic tale ... </body> </html> The URL \u00b6 When you enter the address http://localhost:4001/story in your web browser, Django will parse that field to figure out which page you want to go to. You tell it which patterns are relevant in the file mygame/web/urls.py . Open it now. Django looks for the variable urlpatterns in this file. You want to add your new pattern to the custom_patterns list we have prepared - that is then merged with the default urlpatterns . Here's how it could look: from web import story # ... custom_patterns = [ url(r'story', story.storypage, name='Story'), ] That is, we import our story view module from where we created it earlier and then create an url instance. The first argument to url is the pattern of the url we want to find ( \"story\" ) (this is a regular expression if you are familiar with those) and then our view function we want to direct to. That should be it. Reload Evennia and you should be able to browse to your new story page!","title":"Add a simple new web page"},{"location":"Add-a-simple-new-web-page.html#create-the-view","text":"A django \"view\" is a normal Python function that django calls to render the HTML page you will see in the web browser. Here we will just have it spit back the raw html, but Django can do all sorts of cool stuff with the page in the view, like adding dynamic content or change it on the fly. Open mygame/web folder and add a new module there named story.py (you could also put it in its own folder if you wanted to be neat. Don't forget to add an empty __init__.py file if you do, to tell Python you can import from the new folder). Here's how it looks: # in mygame/web/story.py from django.shortcuts import render def storypage(request): return render(request, \"story.html\") This view takes advantage of a shortcut provided to use by Django, render . This shortcut gives the template some information from the request, for instance, the game name, and then renders it.","title":"Create the view"},{"location":"Add-a-simple-new-web-page.html#the-html-page","text":"We need to find a place where Evennia (and Django) looks for html files (called templates in Django parlance). You can specify such places in your settings (see the TEMPLATES variable in default_settings.py for more info), but here we'll use an existing one. Go to mygame/template/overrides/website/ and create a page story.html there. This is not a HTML tutorial, so we'll go simple: {% extends \"base.html\" %} {% block content %} <div class=\"row\"> <div class=\"col\"> <h1>A story about a tree</h1> <p> This is a story about a tree, a classic tale ... </p> </div> </div> {% endblock %} Since we've used the render shortcut, Django will allow us to extend our base styles easily. If you'd rather not take advantage of Evennia's base styles, you can do something like this instead: <html> <body> <h1>A story about a tree</h1> <p> This is a story about a tree, a classic tale ... </body> </html>","title":"The HTML page"},{"location":"Add-a-simple-new-web-page.html#the-url","text":"When you enter the address http://localhost:4001/story in your web browser, Django will parse that field to figure out which page you want to go to. You tell it which patterns are relevant in the file mygame/web/urls.py . Open it now. Django looks for the variable urlpatterns in this file. You want to add your new pattern to the custom_patterns list we have prepared - that is then merged with the default urlpatterns . Here's how it could look: from web import story # ... custom_patterns = [ url(r'story', story.storypage, name='Story'), ] That is, we import our story view module from where we created it earlier and then create an url instance. The first argument to url is the pattern of the url we want to find ( \"story\" ) (this is a regular expression if you are familiar with those) and then our view function we want to direct to. That should be it. Reload Evennia and you should be able to browse to your new story page!","title":"The URL"},{"location":"Add-a-wiki-on-your-website.html","text":"Before doing this tutorial you will probably want to read the intro in Basic Web tutorial . Reading the three first parts of the Django tutorial might help as well. This tutorial will provide a step-by-step process to installing a wiki on your website. Fortunately, you don't have to create the features manually, since it has been done by others, and we can integrate their work quite easily with Django. I have decided to focus on the Django-wiki . Note: this article has been updated for Evennia 0.9. If you're not yet using this version, be careful, as the django wiki doesn't support Python 2 anymore. (Remove this note when enough time has passed.) The Django-wiki offers a lot of features associated with wikis, is actively maintained (at this time, anyway), and isn't too difficult to install in Evennia. You can see a demonstration of Django-wiki here . Basic installation \u00b6 You should begin by shutting down the Evennia server if it is running. We will run migrations and alter the virtual environment just a bit. Open a terminal and activate your Python environment, the one you use to run the evennia command. On Linux: source evenv/bin/activate Or Windows: evenv\\bin\\activate Installing with pip \u00b6 Install the wiki using pip: pip install wiki Note: this will install the last version of Django wiki. Version >0.4 doesn't support Python 2, so install wiki 0.3 if you haven't updated to Python 3 yet. It might take some time, the Django-wiki having some dependencies. Adding the wiki in the settings \u00b6 You will need to add a few settings to have the wiki app on your website. Open your server/conf/settings.py file and add the following at the bottom (but before importing secret_settings ). Here's what you'll find in my own setting file (add the whole Django-wiki section): r\"\"\" Evennia settings file. ... \"\"\" # Use the defaults from Evennia unless explicitly overridden from evennia.settings_default import * ###################################################################### # Evennia base server config ###################################################################### # This is the name of your game. Make it catchy! SERVERNAME = \"demowiki\" ###################################################################### # Django-wiki settings ###################################################################### INSTALLED_APPS += ( 'django.contrib.humanize.apps.HumanizeConfig', 'django_nyt.apps.DjangoNytConfig', 'mptt', 'sorl.thumbnail', 'wiki.apps.WikiConfig', 'wiki.plugins.attachments.apps.AttachmentsConfig', 'wiki.plugins.notifications.apps.NotificationsConfig', 'wiki.plugins.images.apps.ImagesConfig', 'wiki.plugins.macros.apps.MacrosConfig', ) # Disable wiki handling of login/signup WIKI_ACCOUNT_HANDLING = False WIKI_ACCOUNT_SIGNUP_ALLOWED = False ###################################################################### # Settings given in secret_settings.py override those in this file. ###################################################################### try: from server.conf.secret_settings import * except ImportError: print(\"secret_settings.py file not found or failed to import.\") Adding the new URLs \u00b6 Next we need to add two URLs in our web/urls.py file. Open it and compare the following output: you will need to add two URLs in custom_patterns and add one import line: from django.conf.urls import url, include from django.urls import path # NEW! # default evenni a patterns from evennia.web.urls import urlpatterns # eventual custom patterns custom_patterns = [ # url(r'/desired/url/', view, name='example'), url('notifications/', include('django_nyt.urls')), # NEW! url('wiki/', include('wiki.urls')), # NEW! ] # this is required by Django. urlpatterns = custom_patterns + urlpatterns You will probably need to copy line 2, 10, and 11. Be sure to place them correctly, as shown in the example above. Running migrations \u00b6 It's time to run the new migrations. The wiki app adds a few tables in our database. We'll need to run: evennia migrate And that's it, you can start the server. If you go to http://localhost:4001/wiki , you should see the wiki. Use your account's username and password to connect to it. That's how simple it is. Customizing privileges \u00b6 A wiki can be a great collaborative tool, but who can see it? Who can modify it? Django-wiki comes with a privilege system centered around four values per wiki page. The owner of an article can always read and write in it (which is somewhat logical). The group of the article defines who can read and who can write, if the user seeing the page belongs to this group. The topic of groups in wiki pages will not be discussed here. A last setting determines which other user (that is, these who aren't in the groups, and aren't the article's owner) can read and write. Each article has these four settings (group read, group write, other read, other write). Depending on your purpose, it might not be a good default choice, particularly if you have to remind every builder to keep the pages private. Fortunately, Django-wiki gives us additional settings to customize who can read, and who can write, a specific article. These settings must be placed, as usual, in your server/conf/settings.py file. They take a function as argument, said function (or callback) will be called with the article and the user. Remember, a Django user, for us, is an account. So we could check lockstrings on them if needed. Here is a default setting to restrict the wiki: only builders can write in it, but anyone (including non-logged in users) can read it. The superuser has some additional privileges. # In server/conf/settings.py # ... def is_superuser(article, user): \"\"\"Return True if user is a superuser, False otherwise.\"\"\" return not user.is_anonymous() and user.is_superuser def is_builder(article, user): \"\"\"Return True if user is a builder, False otherwise.\"\"\" return not user.is_anonymous() and user.locks.check_lockstring(user, \"perm(Builders)\") def is_anyone(article, user): \"\"\"Return True even if the user is anonymous.\"\"\" return True # Who can create new groups and users from the wiki? WIKI_CAN_ADMIN = is_superuser # Who can change owner and group membership? WIKI_CAN_ASSIGN = is_superuser # Who can change group membership? WIKI_CAN_ASSIGN_OWNER = is_superuser # Who can change read/write access to groups or others? WIKI_CAN_CHANGE_PERMISSIONS = is_superuser # Who can soft-delete an article? WIKI_CAN_DELETE = is_builder # Who can lock an article and permanently delete it? WIKI_CAN_MODERATE = is_superuser # Who can edit articles? WIKI_CAN_WRITE = is_builder # Who can read articles? WIKI_CAN_READ = is_anyone Here, we have created three functions: one to return True if the user is the superuser, one to return True if the user is a builder, one to return True no matter what (this includes if the user is anonymous, E.G. if it's not logged-in). We then change settings to allow either the superuser or each builder to moderate, read, write, delete, and more. You can, of course, add more functions, adapting them to your need. This is just a demonstration. Providing the WIKI_CAN*... settings will bypass the original permission system. The superuser could change permissions of an article, but still, only builders would be able to write it. If you need something more custom, you will have to expand on the functions you use. Managing wiki pages from Evennia \u00b6 Unfortunately, Django wiki doesn't provide a clear and clean entry point to read and write articles from Evennia and it doesn't seem to be a very high priority. If you really need to keep Django wiki and to create and manage wiki pages from your code, you can do so, but this article won't elaborate, as this is somewhat more technical. However, it is a good opportunity to present a small project that has been created more recently: evennia-wiki has been created to provide a simple wiki, more tailored to Evennia and easier to connect. It doesn't, as yet, provide as many options as does Django wiki, but it's perfectly usable: Pages have an inherent and much-easier to understand hierarchy based on URLs. Article permissions are connected to Evennia groups and are much easier to accommodate specific requirements. Articles can easily be created, read or updated from the Evennia code itself. Markdown is fully-supported with a default integration to Bootstrap to look good on an Evennia website. Tables and table of contents are supported as well as wiki links. The process to override wiki templates makes full use of the template_overrides directory. However evennia-wiki doesn't yet support: Images in markdown and the uploading schema. If images are important to you, please consider contributing to this new project. Modifying permissions on a per page/setting basis. Moving pages to new locations. Viewing page history. Considering the list of features in Django wiki, obviously other things could be added to the list. However, these features may be the most important and useful. Additional ones might not be that necessary. If you're interested in supporting this little project, you are more than welcome to contribute to it . Thanks!","title":"Add a wiki on your website"},{"location":"Add-a-wiki-on-your-website.html#basic-installation","text":"You should begin by shutting down the Evennia server if it is running. We will run migrations and alter the virtual environment just a bit. Open a terminal and activate your Python environment, the one you use to run the evennia command. On Linux: source evenv/bin/activate Or Windows: evenv\\bin\\activate","title":"Basic installation"},{"location":"Add-a-wiki-on-your-website.html#installing-with-pip","text":"Install the wiki using pip: pip install wiki Note: this will install the last version of Django wiki. Version >0.4 doesn't support Python 2, so install wiki 0.3 if you haven't updated to Python 3 yet. It might take some time, the Django-wiki having some dependencies.","title":"Installing with pip"},{"location":"Add-a-wiki-on-your-website.html#adding-the-wiki-in-the-settings","text":"You will need to add a few settings to have the wiki app on your website. Open your server/conf/settings.py file and add the following at the bottom (but before importing secret_settings ). Here's what you'll find in my own setting file (add the whole Django-wiki section): r\"\"\" Evennia settings file. ... \"\"\" # Use the defaults from Evennia unless explicitly overridden from evennia.settings_default import * ###################################################################### # Evennia base server config ###################################################################### # This is the name of your game. Make it catchy! SERVERNAME = \"demowiki\" ###################################################################### # Django-wiki settings ###################################################################### INSTALLED_APPS += ( 'django.contrib.humanize.apps.HumanizeConfig', 'django_nyt.apps.DjangoNytConfig', 'mptt', 'sorl.thumbnail', 'wiki.apps.WikiConfig', 'wiki.plugins.attachments.apps.AttachmentsConfig', 'wiki.plugins.notifications.apps.NotificationsConfig', 'wiki.plugins.images.apps.ImagesConfig', 'wiki.plugins.macros.apps.MacrosConfig', ) # Disable wiki handling of login/signup WIKI_ACCOUNT_HANDLING = False WIKI_ACCOUNT_SIGNUP_ALLOWED = False ###################################################################### # Settings given in secret_settings.py override those in this file. ###################################################################### try: from server.conf.secret_settings import * except ImportError: print(\"secret_settings.py file not found or failed to import.\")","title":"Adding the wiki in the settings"},{"location":"Add-a-wiki-on-your-website.html#adding-the-new-urls","text":"Next we need to add two URLs in our web/urls.py file. Open it and compare the following output: you will need to add two URLs in custom_patterns and add one import line: from django.conf.urls import url, include from django.urls import path # NEW! # default evenni a patterns from evennia.web.urls import urlpatterns # eventual custom patterns custom_patterns = [ # url(r'/desired/url/', view, name='example'), url('notifications/', include('django_nyt.urls')), # NEW! url('wiki/', include('wiki.urls')), # NEW! ] # this is required by Django. urlpatterns = custom_patterns + urlpatterns You will probably need to copy line 2, 10, and 11. Be sure to place them correctly, as shown in the example above.","title":"Adding the new URLs"},{"location":"Add-a-wiki-on-your-website.html#running-migrations","text":"It's time to run the new migrations. The wiki app adds a few tables in our database. We'll need to run: evennia migrate And that's it, you can start the server. If you go to http://localhost:4001/wiki , you should see the wiki. Use your account's username and password to connect to it. That's how simple it is.","title":"Running migrations"},{"location":"Add-a-wiki-on-your-website.html#customizing-privileges","text":"A wiki can be a great collaborative tool, but who can see it? Who can modify it? Django-wiki comes with a privilege system centered around four values per wiki page. The owner of an article can always read and write in it (which is somewhat logical). The group of the article defines who can read and who can write, if the user seeing the page belongs to this group. The topic of groups in wiki pages will not be discussed here. A last setting determines which other user (that is, these who aren't in the groups, and aren't the article's owner) can read and write. Each article has these four settings (group read, group write, other read, other write). Depending on your purpose, it might not be a good default choice, particularly if you have to remind every builder to keep the pages private. Fortunately, Django-wiki gives us additional settings to customize who can read, and who can write, a specific article. These settings must be placed, as usual, in your server/conf/settings.py file. They take a function as argument, said function (or callback) will be called with the article and the user. Remember, a Django user, for us, is an account. So we could check lockstrings on them if needed. Here is a default setting to restrict the wiki: only builders can write in it, but anyone (including non-logged in users) can read it. The superuser has some additional privileges. # In server/conf/settings.py # ... def is_superuser(article, user): \"\"\"Return True if user is a superuser, False otherwise.\"\"\" return not user.is_anonymous() and user.is_superuser def is_builder(article, user): \"\"\"Return True if user is a builder, False otherwise.\"\"\" return not user.is_anonymous() and user.locks.check_lockstring(user, \"perm(Builders)\") def is_anyone(article, user): \"\"\"Return True even if the user is anonymous.\"\"\" return True # Who can create new groups and users from the wiki? WIKI_CAN_ADMIN = is_superuser # Who can change owner and group membership? WIKI_CAN_ASSIGN = is_superuser # Who can change group membership? WIKI_CAN_ASSIGN_OWNER = is_superuser # Who can change read/write access to groups or others? WIKI_CAN_CHANGE_PERMISSIONS = is_superuser # Who can soft-delete an article? WIKI_CAN_DELETE = is_builder # Who can lock an article and permanently delete it? WIKI_CAN_MODERATE = is_superuser # Who can edit articles? WIKI_CAN_WRITE = is_builder # Who can read articles? WIKI_CAN_READ = is_anyone Here, we have created three functions: one to return True if the user is the superuser, one to return True if the user is a builder, one to return True no matter what (this includes if the user is anonymous, E.G. if it's not logged-in). We then change settings to allow either the superuser or each builder to moderate, read, write, delete, and more. You can, of course, add more functions, adapting them to your need. This is just a demonstration. Providing the WIKI_CAN*... settings will bypass the original permission system. The superuser could change permissions of an article, but still, only builders would be able to write it. If you need something more custom, you will have to expand on the functions you use.","title":"Customizing privileges"},{"location":"Add-a-wiki-on-your-website.html#managing-wiki-pages-from-evennia","text":"Unfortunately, Django wiki doesn't provide a clear and clean entry point to read and write articles from Evennia and it doesn't seem to be a very high priority. If you really need to keep Django wiki and to create and manage wiki pages from your code, you can do so, but this article won't elaborate, as this is somewhat more technical. However, it is a good opportunity to present a small project that has been created more recently: evennia-wiki has been created to provide a simple wiki, more tailored to Evennia and easier to connect. It doesn't, as yet, provide as many options as does Django wiki, but it's perfectly usable: Pages have an inherent and much-easier to understand hierarchy based on URLs. Article permissions are connected to Evennia groups and are much easier to accommodate specific requirements. Articles can easily be created, read or updated from the Evennia code itself. Markdown is fully-supported with a default integration to Bootstrap to look good on an Evennia website. Tables and table of contents are supported as well as wiki links. The process to override wiki templates makes full use of the template_overrides directory. However evennia-wiki doesn't yet support: Images in markdown and the uploading schema. If images are important to you, please consider contributing to this new project. Modifying permissions on a per page/setting basis. Moving pages to new locations. Viewing page history. Considering the list of features in Django wiki, obviously other things could be added to the list. However, these features may be the most important and useful. Additional ones might not be that necessary. If you're interested in supporting this little project, you are more than welcome to contribute to it . Thanks!","title":"Managing wiki pages from Evennia"},{"location":"Adding-Command-Tutorial.html","text":"This is a quick first-time tutorial expanding on the Commands documentation. Let's assume you have just downloaded Evennia, installed it and created your game folder (let's call it just mygame here). Now you want to try to add a new command. This is the fastest way to do it. Step 1: Creating a custom command \u00b6 Open mygame/commands/command.py in a text editor. This is just one place commands could be placed but you get it setup from the onset as an easy place to start. It also already contains some example code. Create a new class in command.py inheriting from default_cmds.MuxCommand . Let's call it CmdEcho in this example. Set the class variable key to a good command name, like echo . Give your class a useful docstring . A docstring is the string at the very top of a class or function/method. The docstring at the top of the command class is read by Evennia to become the help entry for the Command (see Command Auto-help ). Define a class method func(self) that echoes your input back to you. Below is an example how this all could look for the echo command: # file mygame/commands/command.py #[...] from evennia import default_cmds class CmdEcho(default_cmds.MuxCommand): \"\"\" Simple command example Usage: echo [text] This command simply echoes text back to the caller. \"\"\" key = \"echo\" def func(self): \"This actually does things\" if not self.args: self.caller.msg(\"You didn't enter anything!\") else: self.caller.msg(\"You gave the string: '%s'\" % self.args) Step 2: Adding the Command to a default Cmdset \u00b6 The command is not available to use until it is part of a Command Set . In this example we will go the easiest route and add it to the default Character commandset that already exists. Edit mygame/commands/default_cmdsets.py Import your new command with from commands.command import CmdEcho . Add a line self.add(CmdEcho()) to CharacterCmdSet , in the at_cmdset_creation method (the template tells you where). This is approximately how it should look at this point: # file mygame/commands/default_cmdsets.py #[...] from commands.command import CmdEcho #[...] class CharacterCmdSet(default_cmds.CharacterCmdSet): key = \"DefaultCharacter\" def at_cmdset_creation(self): # this first adds all default commands super(DefaultSet, self).at_cmdset_creation() # all commands added after this point will extend or # overwrite the default commands. self.add(CmdEcho()) Next, run the @reload command. You should now be able to use your new echo command from inside the game. Use help echo to see the documentation for the command. If you have trouble, make sure to check the log for error messages (probably due to syntax errors in your command definition). Note: Typing echotest will also work. It will be handled as the command echo directly followed by its argument test (which will end up in self.args). To change this behavior, you can add the arg_regex property alongside key , help_category` etc. See the arg_regex documentation for more info. If you want to overload existing default commands (such as look or get ), just add your new command with the same key as the old one - it will then replace it. Just remember that you must use @reload to see any changes. See Commands for many more details and possibilities when defining Commands and using Cmdsets in various ways. Adding the command to specific object types \u00b6 Adding your Command to the CharacterCmdSet is just one easy exapmple. The cmdset system is very generic. You can create your own cmdsets (let's say in a module mycmdsets.py ) and add them to objects as you please (how to control their merging is described in detail in the Command Set documentation ). # file mygame/commands/mycmdsets.py #[...] from commands.command import CmdEcho from evennia import CmdSet #[...] class MyCmdSet(CmdSet): key = \"MyCmdSet\" def at_cmdset_creation(self): self.add(CmdEcho()) Now you just need to add this to an object. To test things (as superuser) you can do @py self.cmdset.add(\"mycmdsets.MyCmdSet\") This will add this cmdset (along with its echo command) to yourself so you can test it. Note that you cannot add a single Command to an object on its own, it must be part of a CommandSet in order to do so. The Command you added is not there permanently at this point. If you do a @reload the merger will be gone. You could add the permanent=True keyword to the cmdset.add call. This will however only make the new merged cmdset permanent on that single object. Often you want all objects of this particular class to have this cmdset. To make sure all new created objects get your new merged set, put the cmdset.add call in your custom Typeclasses ' at_object_creation method: # e.g. in mygame/typeclasses/objects.py from evennia import DefaultObject class MyObject(DefaultObject): def at_object_creation(self): \"called when the object is first created\" self.cmdset.add(\"mycmdset.MyCmdSet\", permanent=True) All new objects of this typeclass will now start with this cmdset and it will survive a @reload . Note: An important caveat with this is that at_object_creation is only called once , when the object is first created. This means that if you already have existing objects in your databases using that typeclass, they will not have been initiated the same way. There are many ways to update them; since it's a one-time update you can usually just simply loop through them. As superuser, try the following: @py from typeclasses.objects import MyObject; [o.cmdset.add(\"mycmdset.MyCmdSet\") for o in MyObject.objects.all()] This goes through all objects in your database having the right typeclass, adding the new cmdset to each. The good news is that you only have to do this if you want to post-add cmdsets . If you just want to add a new command , you can simply add that command to the cmdset's at_cmdset_creation and @reload to make the Command immediately available. Change where Evennia looks for command sets \u00b6 Evennia uses settings variables to know where to look for its default command sets. These are normally not changed unless you want to re-organize your game folder in some way. For example, the default character cmdset defaults to being defined as CMDSET_CHARACTER=\"commands.default_cmdset.CharacterCmdSet\" See evennia/settings_default.py for the other settings.","title":"Adding Command Tutorial"},{"location":"Adding-Command-Tutorial.html#step-1-creating-a-custom-command","text":"Open mygame/commands/command.py in a text editor. This is just one place commands could be placed but you get it setup from the onset as an easy place to start. It also already contains some example code. Create a new class in command.py inheriting from default_cmds.MuxCommand . Let's call it CmdEcho in this example. Set the class variable key to a good command name, like echo . Give your class a useful docstring . A docstring is the string at the very top of a class or function/method. The docstring at the top of the command class is read by Evennia to become the help entry for the Command (see Command Auto-help ). Define a class method func(self) that echoes your input back to you. Below is an example how this all could look for the echo command: # file mygame/commands/command.py #[...] from evennia import default_cmds class CmdEcho(default_cmds.MuxCommand): \"\"\" Simple command example Usage: echo [text] This command simply echoes text back to the caller. \"\"\" key = \"echo\" def func(self): \"This actually does things\" if not self.args: self.caller.msg(\"You didn't enter anything!\") else: self.caller.msg(\"You gave the string: '%s'\" % self.args)","title":"Step 1: Creating a custom command"},{"location":"Adding-Command-Tutorial.html#step-2-adding-the-command-to-a-default-cmdset","text":"The command is not available to use until it is part of a Command Set . In this example we will go the easiest route and add it to the default Character commandset that already exists. Edit mygame/commands/default_cmdsets.py Import your new command with from commands.command import CmdEcho . Add a line self.add(CmdEcho()) to CharacterCmdSet , in the at_cmdset_creation method (the template tells you where). This is approximately how it should look at this point: # file mygame/commands/default_cmdsets.py #[...] from commands.command import CmdEcho #[...] class CharacterCmdSet(default_cmds.CharacterCmdSet): key = \"DefaultCharacter\" def at_cmdset_creation(self): # this first adds all default commands super(DefaultSet, self).at_cmdset_creation() # all commands added after this point will extend or # overwrite the default commands. self.add(CmdEcho()) Next, run the @reload command. You should now be able to use your new echo command from inside the game. Use help echo to see the documentation for the command. If you have trouble, make sure to check the log for error messages (probably due to syntax errors in your command definition). Note: Typing echotest will also work. It will be handled as the command echo directly followed by its argument test (which will end up in self.args). To change this behavior, you can add the arg_regex property alongside key , help_category` etc. See the arg_regex documentation for more info. If you want to overload existing default commands (such as look or get ), just add your new command with the same key as the old one - it will then replace it. Just remember that you must use @reload to see any changes. See Commands for many more details and possibilities when defining Commands and using Cmdsets in various ways.","title":"Step 2: Adding the Command to a default Cmdset"},{"location":"Adding-Command-Tutorial.html#adding-the-command-to-specific-object-types","text":"Adding your Command to the CharacterCmdSet is just one easy exapmple. The cmdset system is very generic. You can create your own cmdsets (let's say in a module mycmdsets.py ) and add them to objects as you please (how to control their merging is described in detail in the Command Set documentation ). # file mygame/commands/mycmdsets.py #[...] from commands.command import CmdEcho from evennia import CmdSet #[...] class MyCmdSet(CmdSet): key = \"MyCmdSet\" def at_cmdset_creation(self): self.add(CmdEcho()) Now you just need to add this to an object. To test things (as superuser) you can do @py self.cmdset.add(\"mycmdsets.MyCmdSet\") This will add this cmdset (along with its echo command) to yourself so you can test it. Note that you cannot add a single Command to an object on its own, it must be part of a CommandSet in order to do so. The Command you added is not there permanently at this point. If you do a @reload the merger will be gone. You could add the permanent=True keyword to the cmdset.add call. This will however only make the new merged cmdset permanent on that single object. Often you want all objects of this particular class to have this cmdset. To make sure all new created objects get your new merged set, put the cmdset.add call in your custom Typeclasses ' at_object_creation method: # e.g. in mygame/typeclasses/objects.py from evennia import DefaultObject class MyObject(DefaultObject): def at_object_creation(self): \"called when the object is first created\" self.cmdset.add(\"mycmdset.MyCmdSet\", permanent=True) All new objects of this typeclass will now start with this cmdset and it will survive a @reload . Note: An important caveat with this is that at_object_creation is only called once , when the object is first created. This means that if you already have existing objects in your databases using that typeclass, they will not have been initiated the same way. There are many ways to update them; since it's a one-time update you can usually just simply loop through them. As superuser, try the following: @py from typeclasses.objects import MyObject; [o.cmdset.add(\"mycmdset.MyCmdSet\") for o in MyObject.objects.all()] This goes through all objects in your database having the right typeclass, adding the new cmdset to each. The good news is that you only have to do this if you want to post-add cmdsets . If you just want to add a new command , you can simply add that command to the cmdset's at_cmdset_creation and @reload to make the Command immediately available.","title":"Adding the command to specific object types"},{"location":"Adding-Command-Tutorial.html#change-where-evennia-looks-for-command-sets","text":"Evennia uses settings variables to know where to look for its default command sets. These are normally not changed unless you want to re-organize your game folder in some way. For example, the default character cmdset defaults to being defined as CMDSET_CHARACTER=\"commands.default_cmdset.CharacterCmdSet\" See evennia/settings_default.py for the other settings.","title":"Change where Evennia looks for command sets"},{"location":"Adding-Object-Typeclass-Tutorial.html","text":"Evennia comes with a few very basic classes of in-game entities: DefaultObject | DefaultCharacter DefaultRoom DefaultExit DefaultChannel When you create a new Evennia game (with for example evennia --init mygame ) Evennia will automatically create empty child classes Object , Character , Room and Exit respectively. They are found mygame/typeclasses/objects.py , mygame/typeclasses/rooms.py etc. Technically these are all Typeclassed , which can be ignored for now. In mygame/typeclasses are also base typeclasses for out-of-character things, notably Channels , Accounts and Scripts . We don't cover those in this tutorial. For your own game you will most likely want to expand on these very simple beginnings. It's normal to want your Characters to have various attributes, for example. Maybe Rooms should hold extra information or even all Objects in your game should have properties not included in basic Evennia. Change Default Rooms, Exits, Character Typeclass \u00b6 This is the simplest case. The default build commands of a new Evennia game is set up to use the Room , Exit and Character classes found in the same-named modules under mygame/typeclasses/ . By default these are empty and just implements the default parents from the Evennia library ( DefaultRoom etc). Just add the changes you want to these classes and run @reload to add your new functionality. Create a new type of object \u00b6 Say you want to create a new \"Heavy\" object-type that characters should not have the ability to pick up. Edit mygame/typeclasses/objects.py (you could also create a new module there, named something like heavy.py , that's up to how you want to organize things). Create a new class inheriting at any distance from DefaultObject . It could look something like this: # end of file mygame/typeclasses/objects.py from evennia import DefaultObject class Heavy(DefaultObject): \"Heavy object\" def at_object_creation(self): \"Called whenever a new object is created\" # lock the object down by default self.locks.add(\"get:false()\") # the default \"get\" command looks for this Attribute in order # to return a customized error message (we just happen to know # this, you'd have to look at the code of the 'get' command to # find out). self.db.get_err_msg = \"This is too heavy to pick up.\" Once you are done, log into the game with a build-capable account and do @create/drop rock:objects.Heavy to drop a new heavy \"rock\" object in your location. Next try to pick it up ( @quell yourself first if you are a superuser). If you get errors, look at your log files where you will find the traceback. The most common error is that you have some sort of syntax error in your class. Note that the Locks and Attribute which are set in the typeclass could just as well have been set using commands in-game, so this is a very simple example. Storing data on initialization \u00b6 The at_object_creation is only called once, when the object is first created. This makes it ideal for database-bound things like Attributes . But sometimes you want to create temporary properties (things that are not to be stored in the database but still always exist every time the object is created). Such properties can be initialized in the at_init method on the object. at_init is called every time the object is loaded into memory. Note: It's usually pointless and wasteful to assign database data in at_init , since this will hit the database with the same value over and over. Put those in at_object_creation instead. You are wise to use ndb (non-database Attributes) to store these non-persistent properties, since ndb-properties are protected against being cached out in various ways and also allows you to list them using various in-game tools: def at_init(self): self.ndb.counter = 0 self.ndb.mylist = [] Note: As mentioned in the Typeclasses documentation, at_init replaces the use of the standard __init__ method of typeclasses due to how the latter may be called in situations other than you'd expect. So use at_init where you would normally use __init__ . Updating existing objects \u00b6 If you already have some Heavy objects created and you add a new Attribute in at_object_creation , you will find that those existing objects will not have this Attribute. This is not so strange, since at_object_creation is only called once, it will not be called again just because you update it. You need to update existing objects manually. If the number of objects is limited, you can use @typeclass/force/reload objectname to force a re-load of the at_object_creation method (only) on the object. This case is common enough that there is an alias @update objectname you can use to get the same effect. If there are multiple objects you can use @py to loop over the objects you need: @py from typeclasses.objects import Heavy; [obj.at_object_creation() for obj in Heavy.objects.all()]","title":"Adding Object Typeclass Tutorial"},{"location":"Adding-Object-Typeclass-Tutorial.html#change-default-rooms-exits-character-typeclass","text":"This is the simplest case. The default build commands of a new Evennia game is set up to use the Room , Exit and Character classes found in the same-named modules under mygame/typeclasses/ . By default these are empty and just implements the default parents from the Evennia library ( DefaultRoom etc). Just add the changes you want to these classes and run @reload to add your new functionality.","title":"Change Default Rooms, Exits, Character Typeclass"},{"location":"Adding-Object-Typeclass-Tutorial.html#create-a-new-type-of-object","text":"Say you want to create a new \"Heavy\" object-type that characters should not have the ability to pick up. Edit mygame/typeclasses/objects.py (you could also create a new module there, named something like heavy.py , that's up to how you want to organize things). Create a new class inheriting at any distance from DefaultObject . It could look something like this: # end of file mygame/typeclasses/objects.py from evennia import DefaultObject class Heavy(DefaultObject): \"Heavy object\" def at_object_creation(self): \"Called whenever a new object is created\" # lock the object down by default self.locks.add(\"get:false()\") # the default \"get\" command looks for this Attribute in order # to return a customized error message (we just happen to know # this, you'd have to look at the code of the 'get' command to # find out). self.db.get_err_msg = \"This is too heavy to pick up.\" Once you are done, log into the game with a build-capable account and do @create/drop rock:objects.Heavy to drop a new heavy \"rock\" object in your location. Next try to pick it up ( @quell yourself first if you are a superuser). If you get errors, look at your log files where you will find the traceback. The most common error is that you have some sort of syntax error in your class. Note that the Locks and Attribute which are set in the typeclass could just as well have been set using commands in-game, so this is a very simple example.","title":"Create a new type of object"},{"location":"Adding-Object-Typeclass-Tutorial.html#storing-data-on-initialization","text":"The at_object_creation is only called once, when the object is first created. This makes it ideal for database-bound things like Attributes . But sometimes you want to create temporary properties (things that are not to be stored in the database but still always exist every time the object is created). Such properties can be initialized in the at_init method on the object. at_init is called every time the object is loaded into memory. Note: It's usually pointless and wasteful to assign database data in at_init , since this will hit the database with the same value over and over. Put those in at_object_creation instead. You are wise to use ndb (non-database Attributes) to store these non-persistent properties, since ndb-properties are protected against being cached out in various ways and also allows you to list them using various in-game tools: def at_init(self): self.ndb.counter = 0 self.ndb.mylist = [] Note: As mentioned in the Typeclasses documentation, at_init replaces the use of the standard __init__ method of typeclasses due to how the latter may be called in situations other than you'd expect. So use at_init where you would normally use __init__ .","title":"Storing data on initialization"},{"location":"Adding-Object-Typeclass-Tutorial.html#updating-existing-objects","text":"If you already have some Heavy objects created and you add a new Attribute in at_object_creation , you will find that those existing objects will not have this Attribute. This is not so strange, since at_object_creation is only called once, it will not be called again just because you update it. You need to update existing objects manually. If the number of objects is limited, you can use @typeclass/force/reload objectname to force a re-load of the at_object_creation method (only) on the object. This case is common enough that there is an alias @update objectname you can use to get the same effect. If there are multiple objects you can use @py to loop over the objects you need: @py from typeclasses.objects import Heavy; [obj.at_object_creation() for obj in Heavy.objects.all()]","title":"Updating existing objects"},{"location":"Administrative-Docs.html","text":"The following pages are aimed at game administrators -- the higher-ups that possess shell access and are responsible for managing the game. Installation and Early Life \u00b6 Choosing (and installing) an SQL Server Getting Started - Installing Evennia Running Evennia in Docker Containers Starting, stopping, reloading and resetting Evennia Keeping your game up to date Resetting your database Making your game available online Hosting options Securing your server with SSL/Let's Encrypt Listing your game at the online Evennia game index Customizing the server \u00b6 Changing the Settings Available Master Settings Change Evennia's language (internationalization) Apache webserver configuration (optional) Changing text encodings used by the server The Connection Screen Guest Logins How to connect Evennia to IRC channels How to connect Evennia to RSS feeds How to connect Evennia to Grapevine How to connect Evennia to Twitter Administrating the running game \u00b6 Supported clients (grid of known client issues) Changing Permissions of users Banning and deleting users Summary of abuse-handling tools in the default cmdset Working with Evennia \u00b6 Setting up your work environment with version control First steps coding with Evennia Setting up a continuous integration build environment","title":"Admin"},{"location":"Administrative-Docs.html#installation-and-early-life","text":"Choosing (and installing) an SQL Server Getting Started - Installing Evennia Running Evennia in Docker Containers Starting, stopping, reloading and resetting Evennia Keeping your game up to date Resetting your database Making your game available online Hosting options Securing your server with SSL/Let's Encrypt Listing your game at the online Evennia game index","title":"Installation and Early Life"},{"location":"Administrative-Docs.html#customizing-the-server","text":"Changing the Settings Available Master Settings Change Evennia's language (internationalization) Apache webserver configuration (optional) Changing text encodings used by the server The Connection Screen Guest Logins How to connect Evennia to IRC channels How to connect Evennia to RSS feeds How to connect Evennia to Grapevine How to connect Evennia to Twitter","title":"Customizing the server"},{"location":"Administrative-Docs.html#administrating-the-running-game","text":"Supported clients (grid of known client issues) Changing Permissions of users Banning and deleting users Summary of abuse-handling tools in the default cmdset","title":"Administrating the running game"},{"location":"Administrative-Docs.html#working-with-evennia","text":"Setting up your work environment with version control First steps coding with Evennia Setting up a continuous integration build environment","title":"Working with Evennia"},{"location":"Apache-Config.html","text":"Warning : This information is presented as a convenience, using another webserver than Evennia's own is not directly supported and you are on your own if you want to do so. Evennia's webserver works out of the box without any extra configuration and also runs in-process making sure to avoid caching race conditions. The browser web client will most likely not work (at least not without tweaking) on a third-party web server. One reason for wanting to use an external webserver like Apache would be to act as a proxy in front of the Evennia webserver. Getting this working with TLS (encryption) requires some extra work covered at the end of this page. Note that the Apache instructions below might be outdated. If something is not working right, or you use Evennia with a different server, please let us know. Also, if there is a particular Linux distro you would like covered, please let us know. mod_wsgi Setup \u00b6 Install mod_wsgi \u00b6 Fedora/RHEL \u00b6 Apache HTTP Server and mod_wsgi are available in the standard package repositories for Fedora and RHEL: # dnf install httpd mod_wsgi or # yum install httpd mod_wsgi Ubuntu/Debian \u00b6 Apache HTTP Server and mod_wsgi are available in the standard package repositories for Ubuntu and Debian: # apt-get update # apt-get install apache2 libapache2-mod-wsgi Copy and modify the VHOST \u00b6 After mod_wsgi is installed, copy the evennia/web/utils/evennia_wsgi_apache.conf file to your apache2 vhosts/sites folder. On Debian/Ubuntu, this is /etc/apache2/sites-enabled/ . Make your modifications after copying the file there. Read the comments and change the paths to point to the appropriate locations within your setup. Restart/Reload Apache \u00b6 You'll then want to reload or restart apache2 after changing the configurations. Fedora/RHEL/Ubuntu \u00b6 # systemctl restart httpd Ubuntu/Debian \u00b6 # systemctl restart apache2 Enjoy \u00b6 With any luck, you'll be able to point your browser at your domain or subdomain that you set up in your vhost and see the nifty default Evennia webpage. If not, read the hopefully informative error message and work from there. Questions may be directed to our Evennia Community site . A note on code reloading \u00b6 If your mod_wsgi is set up to run on daemon mode (as will be the case by default on Debian and Ubuntu), you may tell mod_wsgi to reload by using the touch command on evennia/game/web/utils/apache_wsgi.conf . When mod_wsgi sees that the file modification time has changed, it will force a code reload. Any modifications to the code will not be propagated to the live instance of your site until reloaded. If you are not running in daemon mode or want to force the issue, simply restart or reload apache2 to apply your changes. Further notes and hints: \u00b6 If you get strange (and usually uninformative) Permission denied errors from Apache, make sure that your evennia directory is located in a place the webserver may actually access. For example, some Linux distributions may default to very restrictive access permissions on a user's /home directory. One user commented that they had to add the following to their Apache config to get things to work. Not confirmed, but worth trying if there are trouble. <Directory \"/home/<yourname>/evennia/game/web\"> Options +ExecCGI Allow from all </Directory> mod_proxy and mod_ssl setup \u00b6 Below are steps on running Evennia using a front-end proxy (Apache HTTP), mod_proxy_http , mod_proxy_wstunnel , and mod_ssl . mod_proxy_http and mod_proxy_wstunnel will simply be referred to as mod_proxy below. Install mod_ssl \u00b6 Fedora/RHEL \u00b6 Apache HTTP Server and mod_ssl are available in the standard package repositories for Fedora and RHEL: # dnf install httpd mod_ssl or # yum install httpd mod_ssl Ubuntu/Debian \u00b6 Apache HTTP Server and mod_sslj kl are installed together in the apache2 package and available in the standard package repositories for Ubuntu and Debian. mod_ssl needs to be enabled after installation: # apt-get update # apt-get install apache2 # a2enmod ssl TLS proxy+websocket configuration \u00b6 Below is a sample configuration for Evennia with a TLS-enabled http and websocket proxy. Apache HTTP Server Configuration \u00b6 <VirtualHost *:80> # Always redirect to https/443 ServerName mud.example.com Redirect / https://mud.example.com </VirtualHost> <VirtualHost *:443> ServerName mud.example.com SSLEngine On # Location of certificate and key SSLCertificateFile /etc/pki/tls/certs/mud.example.com.crt SSLCertificateKeyFile /etc/pki/tls/private/mud.example.com.key # Use a tool https://www.ssllabs.com/ssltest/ to scan your set after setting up. SSLProtocol TLSv1.2 SSLCipherSuite HIGH:!eNULL:!NULL:!aNULL # Proxy all websocket traffic to port 4002 in Evennia ProxyPass /ws ws://127.0.0.1:4002/ ProxyPassReverse /ws ws://127.0.0.1:4002/ # Proxy all HTTP traffic to port 4001 in Evennia ProxyPass / http://127.0.0.1:4001/ ProxyPassReverse / http://127.0.0.1:4001/ # Configure separate logging for this Evennia proxy ErrorLog logs/evennia_error.log CustomLog logs/evennia_access.log combined </VirtualHost> Evennia secure websocket configuration \u00b6 There is a slight trick in setting up Evennia so websocket traffic is handled correctly by the proxy. You must set the WEBSOCKET_CLIENT_URL setting in your mymud/server/conf/settings.py file: WEBSOCKET_CLIENT_URL = \"wss://external.example.com/ws\" The setting above is what the client's browser will actually use. Note the use of wss:// is because our client will be communicating over an encrypted connection (\"wss\" indicates websocket over SSL/TLS). Also, especially note the additional path /ws at the end of the URL. This is how Apache HTTP Server identifies that a particular request should be proxied to Evennia's websocket port but this should be applicable also to other types of proxies (like nginx).","title":"Apache Config"},{"location":"Apache-Config.html#mod_wsgi-setup","text":"","title":"mod_wsgi Setup"},{"location":"Apache-Config.html#install-mod_wsgi","text":"","title":"Install mod_wsgi"},{"location":"Apache-Config.html#fedorarhel","text":"Apache HTTP Server and mod_wsgi are available in the standard package repositories for Fedora and RHEL: # dnf install httpd mod_wsgi or # yum install httpd mod_wsgi","title":"Fedora/RHEL"},{"location":"Apache-Config.html#ubuntudebian","text":"Apache HTTP Server and mod_wsgi are available in the standard package repositories for Ubuntu and Debian: # apt-get update # apt-get install apache2 libapache2-mod-wsgi","title":"Ubuntu/Debian"},{"location":"Apache-Config.html#copy-and-modify-the-vhost","text":"After mod_wsgi is installed, copy the evennia/web/utils/evennia_wsgi_apache.conf file to your apache2 vhosts/sites folder. On Debian/Ubuntu, this is /etc/apache2/sites-enabled/ . Make your modifications after copying the file there. Read the comments and change the paths to point to the appropriate locations within your setup.","title":"Copy and modify the VHOST"},{"location":"Apache-Config.html#restartreload-apache","text":"You'll then want to reload or restart apache2 after changing the configurations.","title":"Restart/Reload Apache"},{"location":"Apache-Config.html#fedorarhelubuntu","text":"# systemctl restart httpd","title":"Fedora/RHEL/Ubuntu"},{"location":"Apache-Config.html#ubuntudebian_1","text":"# systemctl restart apache2","title":"Ubuntu/Debian"},{"location":"Apache-Config.html#enjoy","text":"With any luck, you'll be able to point your browser at your domain or subdomain that you set up in your vhost and see the nifty default Evennia webpage. If not, read the hopefully informative error message and work from there. Questions may be directed to our Evennia Community site .","title":"Enjoy"},{"location":"Apache-Config.html#a-note-on-code-reloading","text":"If your mod_wsgi is set up to run on daemon mode (as will be the case by default on Debian and Ubuntu), you may tell mod_wsgi to reload by using the touch command on evennia/game/web/utils/apache_wsgi.conf . When mod_wsgi sees that the file modification time has changed, it will force a code reload. Any modifications to the code will not be propagated to the live instance of your site until reloaded. If you are not running in daemon mode or want to force the issue, simply restart or reload apache2 to apply your changes.","title":"A note on code reloading"},{"location":"Apache-Config.html#further-notes-and-hints","text":"If you get strange (and usually uninformative) Permission denied errors from Apache, make sure that your evennia directory is located in a place the webserver may actually access. For example, some Linux distributions may default to very restrictive access permissions on a user's /home directory. One user commented that they had to add the following to their Apache config to get things to work. Not confirmed, but worth trying if there are trouble. <Directory \"/home/<yourname>/evennia/game/web\"> Options +ExecCGI Allow from all </Directory>","title":"Further notes and hints:"},{"location":"Apache-Config.html#mod_proxy-and-mod_ssl-setup","text":"Below are steps on running Evennia using a front-end proxy (Apache HTTP), mod_proxy_http , mod_proxy_wstunnel , and mod_ssl . mod_proxy_http and mod_proxy_wstunnel will simply be referred to as mod_proxy below.","title":"mod_proxy and mod_ssl setup"},{"location":"Apache-Config.html#install-mod_ssl","text":"","title":"Install mod_ssl"},{"location":"Apache-Config.html#fedorarhel_1","text":"Apache HTTP Server and mod_ssl are available in the standard package repositories for Fedora and RHEL: # dnf install httpd mod_ssl or # yum install httpd mod_ssl","title":"Fedora/RHEL"},{"location":"Apache-Config.html#ubuntudebian_2","text":"Apache HTTP Server and mod_sslj kl are installed together in the apache2 package and available in the standard package repositories for Ubuntu and Debian. mod_ssl needs to be enabled after installation: # apt-get update # apt-get install apache2 # a2enmod ssl","title":"Ubuntu/Debian"},{"location":"Apache-Config.html#tls-proxywebsocket-configuration","text":"Below is a sample configuration for Evennia with a TLS-enabled http and websocket proxy.","title":"TLS proxy+websocket configuration"},{"location":"Apache-Config.html#apache-http-server-configuration","text":"<VirtualHost *:80> # Always redirect to https/443 ServerName mud.example.com Redirect / https://mud.example.com </VirtualHost> <VirtualHost *:443> ServerName mud.example.com SSLEngine On # Location of certificate and key SSLCertificateFile /etc/pki/tls/certs/mud.example.com.crt SSLCertificateKeyFile /etc/pki/tls/private/mud.example.com.key # Use a tool https://www.ssllabs.com/ssltest/ to scan your set after setting up. SSLProtocol TLSv1.2 SSLCipherSuite HIGH:!eNULL:!NULL:!aNULL # Proxy all websocket traffic to port 4002 in Evennia ProxyPass /ws ws://127.0.0.1:4002/ ProxyPassReverse /ws ws://127.0.0.1:4002/ # Proxy all HTTP traffic to port 4001 in Evennia ProxyPass / http://127.0.0.1:4001/ ProxyPassReverse / http://127.0.0.1:4001/ # Configure separate logging for this Evennia proxy ErrorLog logs/evennia_error.log CustomLog logs/evennia_access.log combined </VirtualHost>","title":"Apache HTTP Server Configuration"},{"location":"Apache-Config.html#evennia-secure-websocket-configuration","text":"There is a slight trick in setting up Evennia so websocket traffic is handled correctly by the proxy. You must set the WEBSOCKET_CLIENT_URL setting in your mymud/server/conf/settings.py file: WEBSOCKET_CLIENT_URL = \"wss://external.example.com/ws\" The setting above is what the client's browser will actually use. Note the use of wss:// is because our client will be communicating over an encrypted connection (\"wss\" indicates websocket over SSL/TLS). Also, especially note the additional path /ws at the end of the URL. This is how Apache HTTP Server identifies that a particular request should be proxied to Evennia's websocket port but this should be applicable also to other types of proxies (like nginx).","title":"Evennia secure websocket configuration"},{"location":"Arxcode-installing-help.html","text":"Introduction \u00b6 Arx - After the Reckoning is a big and very popular Evennia -based game. Arx is heavily roleplaying-centric, relying on game masters to drive the story. Technically it's maybe best described as \"a MUSH, but with more coded systems\". In August of 2018, the game's developer, Tehom, generously released the source code of Arx on github . This is a treasure-trove for developers wanting to pick ideas or even get a starting game to build on. These instructions are based on the Arx-code released as of Aug 12, 2018 . If you are not familiar with what Evennia is, you can read an introduction here . It's not too hard to run Arx from the sources (of course you'll start with an empty database) but since part of Arx has grown organically, it doesn't follow standard Evennia paradigms everywhere. This page covers one take on installing and setting things up while making your new Arx-based game better match with the vanilla Evennia install. Installing Evennia \u00b6 Firstly, set aside a folder/directory on your drive for everything to follow. You need to start by installing Evennia by following most of the Getting Started Instructions for your OS. The difference is that you need to git clone https://github.com/TehomCD/evennia.git instead of Evennia's repo because Arx uses TehomCD's older Evennia 0.8 fork , notably still using Python2. This detail is important if referring to newer Evennia documentation. If you are new to Evennia it's highly recommended that you run through the instructions in full - including initializing and starting a new empty game and connecting to it. That way you can be sure Evennia works correctly as a base line. If you have trouble, make sure to read the Troubleshooting instructions for your operating system. You can also drop into our forums , join #evennia on irc.freenode.net or chat from the linked Discord Server . After installing you should have a virtualenv running and you should have the following file structure in your set-aside folder: vienv/ evennia/ mygame/ Here mygame is the empty game you created during the Evennia install, with evennia --init . Go to that and run evennia stop to make sure your empty game is not running. We'll instead let Evenna run Arx, so in principle you could erase mygame - but it could also be good to have a clean game to compare to. Installing Arxcode \u00b6 Clone the arxcode repo \u00b6 Cd to the root of your directory and clone the released source code from github: git clone https://github.com/Arx-Game/arxcode.git myarx A new folder myarx should appear next to the ones you already had. You could rename this to something else if you want. Cd into myarx . If you wonder about the structure of the game dir, you can read more about it here . Clean up settings \u00b6 Arx has split evennia's normal settings into base_settings.py and production_settings.py . It also has its own solution for managing 'secret' parts of the settings file. We'll keep most of Arx way but remove the secret-handling and replace it with the normal Evennia method. Cd into myarx/server/conf/ and open the file settings.py in a text editor. The top part (within \"\"\"...\"\"\" ) is just help text. Wipe everything underneath that and make it look like this instead (don't forget to save): from base_settings import * TELNET_PORTS = [4000] SERVERNAME = \"MyArx\" GAME_SLOGAN = \"The cool game\" try: from server.conf.secret_settings import * except ImportError: print(\"secret_settings.py file not found or failed to import.\") Note: Indents and capitalization matter in Python. Make indents 4 spaces (not tabs) for your own sanity. If you want a starter on Python in Evennia, you can look here . This will import Arx' base settings and override them with the Evennia-default telnet port and give the game a name. The slogan changes the sub-text shown under the name of your game in the website header. You can tweak these to your own liking later. Next, create a new, empty file secret_settings.py in the same location as the settings.py file. This can just contain the following: SECRET_KEY = \"sefsefiwwj3 jnwidufhjw4545_oifej whewiu hwejfpoiwjrpw09&4er43233fwefwfw\" Replace the long random string with random ASCII characters of your own. The secret key should not be shared. Next, open myarx/server/conf/base_settings.py in your text editor. We want to remove/comment out all mentions of the decouple package, which Evennia doesn't use (we use private_settings.py to hide away settings that should not be shared). Comment out from decouple import config by adding a # to the start of the line: # from decouple import config . Then search for config( in the file and comment out all lines where this is used. Many of these are specific to the server environment where the original Arx runs, so is not that relevant to us. Install Arx dependencies \u00b6 Arx has some further dependencies beyond vanilla Evennia. Start by cd :ing to the root of your myarx folder. If you run Linux or Mac : Edit myarx/requirements.txt and comment out the line pypiwin32==219 - it's only needed on Windows and will give an error on other platforms. Make sure your virtualenv is active, then run pip install -r requirements.txt The needed Python packages will be installed for you. Adding logs/ folder \u00b6 The Arx repo does not contain the myarx/server/logs/ folder Evennia expects for storing server logs. This is simple to add: # linux/mac mkdir server/logs # windows mkdir server\\logs Setting up the database and starting \u00b6 From the myarx folder, run evennia migrate This creates the database and will step through all database migrations needed. evennia start If all goes well Evennia will now start up, running Arx! You can connect to it on localhost (or 127.0.0.1 if your platform doesn't alias localhost ), port 4000 using a Telnet client. Alternatively, you can use your web browser to browse to http://localhost:4001 to see the game's website and get to the web client. When you log in you'll get the standard Evennia greeting (since the database is empty), but you can try help to see that it's indeed Arx that is running. Additional Setup Steps \u00b6 The first time you start Evennia after creating the database with the evennia migrate step above, it should create a few starting objects for you - your superuser account, which it will prompt you to enter, a starting room (Limbo), and a character object for you. If for some reason this does not occur, you may have to follow the steps below. For the first time Superuser login you may have to run steps 7-8 and 10 to create and connect to your in-came Character. Login to the game website with your Superuser account. Press the Admin button to get into the (Django-) Admin Interface. Navigate to the Accounts section. Add a new Account named for the new staffer. Use a place holder password and dummy e-mail address. Flag account as Staff and apply the Admin permission group (This assumes you have already set up an Admin Group in Django). Add Tags named player and developer . Log into the game using the web client (or a third-party telnet client) using your superuser account. Move to where you want the new staffer character to appear. In the game client, run @create/drop <staffername>:typeclasses.characters.Character , where <staffername> is usually the same name you used for the Staffer account you created in the Admin earlier (if you are creating a Character for your superuser, use your superuser account name). This creates a new in-game Character and places it in your current location. Have the new Admin player log into the game. Have the new Admin puppet the character with @ic StafferName . Have the new Admin change their password - @password <old password> = <new password> . Now that you have a Character and an Account object, there's a few additional things you may need to do in order for some commands to function properly. You can either execute these as in-game commands while @ic (controlling your character object). @py from web.character.models import RosterEntry;RosterEntry.objects.create(player=self.player, character=self) @py from world.dominion.models import PlayerOrNpc, AssetOwner;dompc = PlayerOrNpc.objects.create(player = self.player);AssetOwner.objects.create(player=dompc) Those steps will give you a 'RosterEntry', 'PlayerOrNpc', and 'AssetOwner' objects. RosterEntry explicitly connects a character and account object together, even while offline, and contains additional information about a character's current presence in game (such as which 'roster' they're in, if you choose to use an active roster of characters). PlayerOrNpc are more character extensions, as well as support for npcs with no in-game presence and just represented by a name which can be offscreen members of a character's family. It also allows for membership in Organizations. AssetOwner holds information about a character or organization's money and resources. Alternate guide by Pax for installing on Windows \u00b6 If for some reason you cannot use the Windows Subsystem for Linux (which would use instructions identical to the ones above), it's possible to get Evennia running under Anaconda for Windows. The process is a little bit trickier. Make sure you have: * Git for Windows https://git-scm.com/download/win * Anaconda for Windows https://www.anaconda.com/distribution/ * VC++ Compiler for Python 2.7 http://aka.ms/vcpython27 conda update conda conda create -n arx python=2.7 source activate arx Set up a convenient repository place for things. cd ~ mkdir Source cd Source mkdir Arx cd Arx Replace the SSH git clone links below with your own github forks. If you don't plan to change Evennia at all, you can use the evennia/evennia.git repo instead of a forked one. git clone git@github.com: /evennia.git git clone git@github.com: /arxcode.git Evennia is a package itself, so we want to install it and all of its prerequisites, after switching to the appropriately-tagged branch for Arxcode. cd evennia git checkout tags/v0.7 -b arx-master pip install -e . Arx has some dependencies of its own, so now we'll go install them As it is not a package, we'll use the normal requirements file. cd ../arxcode pip install -r requirements.txt The git repo doesn't include the empty log directory and Evennia is unhappy if you don't have it, so while still in the arxcode directory... mkdir server/logs Now hit https://github.com/evennia/evennia/wiki/Arxcode-installing-help and change the setup stuff as in the 'Clean up settings' section. Then we will create our default database... ../evennia/bin/windows/evennia.bat migrate ...and do the first run. You need winpty because Windows does not have a TTY/PTY by default, and so the Python console input commands (used for prompts on first run) will fail and you will end up in an unhappy place. Future runs, you should not need winpty. winpty ../evennia/bin/windows/evennia.bat start Once this is done, you should have your Evennia server running Arxcode up on localhost at port 4000, and the webserver at http://localhost:4001/ And you are done! Huzzah!","title":"Arxcode installing help"},{"location":"Arxcode-installing-help.html#introduction","text":"Arx - After the Reckoning is a big and very popular Evennia -based game. Arx is heavily roleplaying-centric, relying on game masters to drive the story. Technically it's maybe best described as \"a MUSH, but with more coded systems\". In August of 2018, the game's developer, Tehom, generously released the source code of Arx on github . This is a treasure-trove for developers wanting to pick ideas or even get a starting game to build on. These instructions are based on the Arx-code released as of Aug 12, 2018 . If you are not familiar with what Evennia is, you can read an introduction here . It's not too hard to run Arx from the sources (of course you'll start with an empty database) but since part of Arx has grown organically, it doesn't follow standard Evennia paradigms everywhere. This page covers one take on installing and setting things up while making your new Arx-based game better match with the vanilla Evennia install.","title":"Introduction"},{"location":"Arxcode-installing-help.html#installing-evennia","text":"Firstly, set aside a folder/directory on your drive for everything to follow. You need to start by installing Evennia by following most of the Getting Started Instructions for your OS. The difference is that you need to git clone https://github.com/TehomCD/evennia.git instead of Evennia's repo because Arx uses TehomCD's older Evennia 0.8 fork , notably still using Python2. This detail is important if referring to newer Evennia documentation. If you are new to Evennia it's highly recommended that you run through the instructions in full - including initializing and starting a new empty game and connecting to it. That way you can be sure Evennia works correctly as a base line. If you have trouble, make sure to read the Troubleshooting instructions for your operating system. You can also drop into our forums , join #evennia on irc.freenode.net or chat from the linked Discord Server . After installing you should have a virtualenv running and you should have the following file structure in your set-aside folder: vienv/ evennia/ mygame/ Here mygame is the empty game you created during the Evennia install, with evennia --init . Go to that and run evennia stop to make sure your empty game is not running. We'll instead let Evenna run Arx, so in principle you could erase mygame - but it could also be good to have a clean game to compare to.","title":"Installing Evennia"},{"location":"Arxcode-installing-help.html#installing-arxcode","text":"","title":"Installing Arxcode"},{"location":"Arxcode-installing-help.html#clone-the-arxcode-repo","text":"Cd to the root of your directory and clone the released source code from github: git clone https://github.com/Arx-Game/arxcode.git myarx A new folder myarx should appear next to the ones you already had. You could rename this to something else if you want. Cd into myarx . If you wonder about the structure of the game dir, you can read more about it here .","title":"Clone the arxcode repo"},{"location":"Arxcode-installing-help.html#clean-up-settings","text":"Arx has split evennia's normal settings into base_settings.py and production_settings.py . It also has its own solution for managing 'secret' parts of the settings file. We'll keep most of Arx way but remove the secret-handling and replace it with the normal Evennia method. Cd into myarx/server/conf/ and open the file settings.py in a text editor. The top part (within \"\"\"...\"\"\" ) is just help text. Wipe everything underneath that and make it look like this instead (don't forget to save): from base_settings import * TELNET_PORTS = [4000] SERVERNAME = \"MyArx\" GAME_SLOGAN = \"The cool game\" try: from server.conf.secret_settings import * except ImportError: print(\"secret_settings.py file not found or failed to import.\") Note: Indents and capitalization matter in Python. Make indents 4 spaces (not tabs) for your own sanity. If you want a starter on Python in Evennia, you can look here . This will import Arx' base settings and override them with the Evennia-default telnet port and give the game a name. The slogan changes the sub-text shown under the name of your game in the website header. You can tweak these to your own liking later. Next, create a new, empty file secret_settings.py in the same location as the settings.py file. This can just contain the following: SECRET_KEY = \"sefsefiwwj3 jnwidufhjw4545_oifej whewiu hwejfpoiwjrpw09&4er43233fwefwfw\" Replace the long random string with random ASCII characters of your own. The secret key should not be shared. Next, open myarx/server/conf/base_settings.py in your text editor. We want to remove/comment out all mentions of the decouple package, which Evennia doesn't use (we use private_settings.py to hide away settings that should not be shared). Comment out from decouple import config by adding a # to the start of the line: # from decouple import config . Then search for config( in the file and comment out all lines where this is used. Many of these are specific to the server environment where the original Arx runs, so is not that relevant to us.","title":"Clean up settings"},{"location":"Arxcode-installing-help.html#install-arx-dependencies","text":"Arx has some further dependencies beyond vanilla Evennia. Start by cd :ing to the root of your myarx folder. If you run Linux or Mac : Edit myarx/requirements.txt and comment out the line pypiwin32==219 - it's only needed on Windows and will give an error on other platforms. Make sure your virtualenv is active, then run pip install -r requirements.txt The needed Python packages will be installed for you.","title":"Install Arx dependencies"},{"location":"Arxcode-installing-help.html#adding-logs-folder","text":"The Arx repo does not contain the myarx/server/logs/ folder Evennia expects for storing server logs. This is simple to add: # linux/mac mkdir server/logs # windows mkdir server\\logs","title":"Adding logs/ folder"},{"location":"Arxcode-installing-help.html#setting-up-the-database-and-starting","text":"From the myarx folder, run evennia migrate This creates the database and will step through all database migrations needed. evennia start If all goes well Evennia will now start up, running Arx! You can connect to it on localhost (or 127.0.0.1 if your platform doesn't alias localhost ), port 4000 using a Telnet client. Alternatively, you can use your web browser to browse to http://localhost:4001 to see the game's website and get to the web client. When you log in you'll get the standard Evennia greeting (since the database is empty), but you can try help to see that it's indeed Arx that is running.","title":"Setting up the database and starting"},{"location":"Arxcode-installing-help.html#additional-setup-steps","text":"The first time you start Evennia after creating the database with the evennia migrate step above, it should create a few starting objects for you - your superuser account, which it will prompt you to enter, a starting room (Limbo), and a character object for you. If for some reason this does not occur, you may have to follow the steps below. For the first time Superuser login you may have to run steps 7-8 and 10 to create and connect to your in-came Character. Login to the game website with your Superuser account. Press the Admin button to get into the (Django-) Admin Interface. Navigate to the Accounts section. Add a new Account named for the new staffer. Use a place holder password and dummy e-mail address. Flag account as Staff and apply the Admin permission group (This assumes you have already set up an Admin Group in Django). Add Tags named player and developer . Log into the game using the web client (or a third-party telnet client) using your superuser account. Move to where you want the new staffer character to appear. In the game client, run @create/drop <staffername>:typeclasses.characters.Character , where <staffername> is usually the same name you used for the Staffer account you created in the Admin earlier (if you are creating a Character for your superuser, use your superuser account name). This creates a new in-game Character and places it in your current location. Have the new Admin player log into the game. Have the new Admin puppet the character with @ic StafferName . Have the new Admin change their password - @password <old password> = <new password> . Now that you have a Character and an Account object, there's a few additional things you may need to do in order for some commands to function properly. You can either execute these as in-game commands while @ic (controlling your character object). @py from web.character.models import RosterEntry;RosterEntry.objects.create(player=self.player, character=self) @py from world.dominion.models import PlayerOrNpc, AssetOwner;dompc = PlayerOrNpc.objects.create(player = self.player);AssetOwner.objects.create(player=dompc) Those steps will give you a 'RosterEntry', 'PlayerOrNpc', and 'AssetOwner' objects. RosterEntry explicitly connects a character and account object together, even while offline, and contains additional information about a character's current presence in game (such as which 'roster' they're in, if you choose to use an active roster of characters). PlayerOrNpc are more character extensions, as well as support for npcs with no in-game presence and just represented by a name which can be offscreen members of a character's family. It also allows for membership in Organizations. AssetOwner holds information about a character or organization's money and resources.","title":"Additional Setup Steps"},{"location":"Arxcode-installing-help.html#alternate-guide-by-pax-for-installing-on-windows","text":"If for some reason you cannot use the Windows Subsystem for Linux (which would use instructions identical to the ones above), it's possible to get Evennia running under Anaconda for Windows. The process is a little bit trickier. Make sure you have: * Git for Windows https://git-scm.com/download/win * Anaconda for Windows https://www.anaconda.com/distribution/ * VC++ Compiler for Python 2.7 http://aka.ms/vcpython27 conda update conda conda create -n arx python=2.7 source activate arx Set up a convenient repository place for things. cd ~ mkdir Source cd Source mkdir Arx cd Arx Replace the SSH git clone links below with your own github forks. If you don't plan to change Evennia at all, you can use the evennia/evennia.git repo instead of a forked one. git clone git@github.com: /evennia.git git clone git@github.com: /arxcode.git Evennia is a package itself, so we want to install it and all of its prerequisites, after switching to the appropriately-tagged branch for Arxcode. cd evennia git checkout tags/v0.7 -b arx-master pip install -e . Arx has some dependencies of its own, so now we'll go install them As it is not a package, we'll use the normal requirements file. cd ../arxcode pip install -r requirements.txt The git repo doesn't include the empty log directory and Evennia is unhappy if you don't have it, so while still in the arxcode directory... mkdir server/logs Now hit https://github.com/evennia/evennia/wiki/Arxcode-installing-help and change the setup stuff as in the 'Clean up settings' section. Then we will create our default database... ../evennia/bin/windows/evennia.bat migrate ...and do the first run. You need winpty because Windows does not have a TTY/PTY by default, and so the Python console input commands (used for prompts on first run) will fail and you will end up in an unhappy place. Future runs, you should not need winpty. winpty ../evennia/bin/windows/evennia.bat start Once this is done, you should have your Evennia server running Arxcode up on localhost at port 4000, and the webserver at http://localhost:4001/ And you are done! Huzzah!","title":"Alternate guide by Pax for installing on Windows"},{"location":"Async-Process.html","text":"This is considered an advanced topic. Synchronous versus Asynchronous \u00b6 Most program code operates synchronously . This means that each statement in your code gets processed and finishes before the next can begin. This makes for easy-to-understand code. It is also a requirement in many cases - a subsequent piece of code often depend on something calculated or defined in a previous statement. Consider this piece of code in a traditional Python program: print(\"before call ...\") long_running_function() print(\"after call ...\") When run, this will print \"before call ...\" , after which the long_running_function gets to work for however long time. Only once that is done, the system prints \"after call ...\" . Easy and logical to follow. Most of Evennia work in this way and often it's important that commands get executed in the same strict order they were coded. Evennia, via Twisted, is a single-process multi-user server. In simple terms this means that it swiftly switches between dealing with player input so quickly that each player feels like they do things at the same time. This is a clever illusion however: If one user, say, runs a command containing that long_running_function , all other players are effectively forced to wait until it finishes. Now, it should be said that on a modern computer system this is rarely an issue. Very few commands run so long that other users notice it. And as mentioned, most of the time you want to enforce all commands to occur in strict sequence. When delays do become noticeable and you don't care in which order the command actually completes, you can run it asynchronously . This makes use of the run_async() function in src/utils/utils.py : run_async(function, *args, **kwargs) Where function will be called asynchronously with *args and **kwargs . Example: from evennia import utils print(\"before call ...\") utils.run_async(long_running_function) print(\"after call ...\") Now, when running this you will find that the program will not wait around for long_running_function to finish. In fact you will see \"before call ...\" and \"after call ...\" printed out right away. The long-running function will run in the background and you (and other users) can go on as normal. Customizing asynchronous operation \u00b6 A complication with using asynchronous calls is what to do with the result from that call. What if long_running_function returns a value that you need? It makes no real sense to put any lines of code after the call to try to deal with the result from long_running_function above - as we saw the \"after call ...\" got printed long before long_running_function was finished, making that line quite pointless for processing any data from the function. Instead one has to use callbacks . utils.run_async takes reserved kwargs that won't be passed into the long-running function: at_return(r) (the callback ) is called when the asynchronous function ( long_running_function above) finishes successfully. The argument r will then be the return value of that function (or None ). python def at_return(r): print(r) at_return_kwargs - an optional dictionary that will be fed as keyword arguments to the at_return callback. at_err(e) (the errback ) is called if the asynchronous function fails and raises an exception. This exception is passed to the errback wrapped in a Failure object e . If you do not supply an errback of your own, Evennia will automatically add one that silently writes errors to the evennia log. An example of an errback is found below: def at_err(e): print(\"There was an error:\", str(e)) at_err_kwargs - an optional dictionary that will be fed as keyword arguments to the at_err errback. An example of making an asynchronous call from inside a Command definition: from evennia import utils, Command class CmdAsync(Command): key = \"asynccommand\" def func(self): def long_running_function(): #[... lots of time-consuming code ...] return final_value def at_return_function(r): self.caller.msg(\"The final value is %s\" % r) def at_err_function(e): self.caller.msg(\"There was an error: %s\" % e) # do the async call, setting all callbacks utils.run_async(long_running_function, at_return=at_return_function, at_err=at_err_function) That's it - from here on we can forget about long_running_function and go on with what else need to be done. Whenever it finishes, the at_return_function function will be called and the final value will pop up for us to see. If not we will see an error message. delay \u00b6 The delay function is a much simpler sibling to run_async . It is in fact just a way to delay the execution of a command until a future time. This is equivalent to something like time.sleep() except delay is asynchronous while sleep would lock the entire server for the duration of the sleep. from evennia.utils import delay # [...] # e.g. inside a Command, where `self.caller` is available def callback(obj): obj.msg(\"Returning!\") delay(10, callback, self.caller) This will delay the execution of the callback for 10 seconds. This function is explored much more in the Command Duration Tutorial . You can also try the following snippet just see how it works: @py from evennia.utils import delay; delay(10, lambda who: who.msg(\"Test!\"), self) Wait 10 seconds and 'Test!' should be echoed back to you. The @interactive decorator \u00b6 As of Evennia 0.9, the @interactive decorator is available. This makes any function or method possible to 'pause' and/or await player input in an interactive way. from evennia.utils import interactive @interactive def myfunc(caller): while True: caller.msg(\"Getting ready to wait ...\") yield(5) caller.msg(\"Now 5 seconds have passed.\") response = yield(\"Do you want to wait another 5 secs?\") if response.lower() not in (\"yes\", \"y\"): break The @interactive decorator gives the function the ability to pause. The use of yield(seconds) will do just that - it will asynchronously pause for the number of seconds given before continuing. This is technically equivalent to using call_async with a callback that continues after 5 secs. But the code with @interactive is a little easier to follow. Within the @interactive function, the response = yield(\"question\") question allows you to ask the user for input. You can then process the input, just like you would if you used the Python input function. There is one caveat to this functionality though - it will only work if the function/method has an argument named exactly caller . This is because internally Evennia will look for the caller argument and treat that as the source of input. All of this makes the @interactive decorator very useful. But it comes with a few caveats. Notably, decorating a function/method with @interactive turns it into a Python generator . The most common issue is that you cannot use return <value> from a generator (just an empty return works). To return a value from a function/method you have decorated with @interactive , you must instead use a special Twisted function twisted.internet.defer.returnValue . Evennia also makes this function conveniently available from evennia.utils : from evennia.utils import interactive, returnValue @interactive def myfunc(): # ... result = 10 # this must be used instead of `return result` returnValue(result) Assorted notes \u00b6 Overall, be careful with choosing when to use asynchronous calls. It is mainly useful for large administration operations that have no direct influence on the game world (imports and backup operations come to mind). Since there is no telling exactly when an asynchronous call actually ends, using them for in-game commands is to potentially invite confusion and inconsistencies (and very hard-to-reproduce bugs). The very first synchronous example above is not really correct in the case of Twisted, which is inherently an asynchronous server. Notably you might find that you will not see the first before call ... text being printed out right away. Instead all texts could end up being delayed until after the long-running process finishes. So all commands will retain their relative order as expected, but they may appear with delays or in groups. Further reading \u00b6 Technically, run_async is just a very thin and simplified wrapper around a Twisted Deferred object; the wrapper sets up a default errback also if none is supplied. If you know what you are doing there is nothing stopping you from bypassing the utility function, building a more sophisticated callback chain after your own liking.","title":"Async Process"},{"location":"Async-Process.html#synchronous-versus-asynchronous","text":"Most program code operates synchronously . This means that each statement in your code gets processed and finishes before the next can begin. This makes for easy-to-understand code. It is also a requirement in many cases - a subsequent piece of code often depend on something calculated or defined in a previous statement. Consider this piece of code in a traditional Python program: print(\"before call ...\") long_running_function() print(\"after call ...\") When run, this will print \"before call ...\" , after which the long_running_function gets to work for however long time. Only once that is done, the system prints \"after call ...\" . Easy and logical to follow. Most of Evennia work in this way and often it's important that commands get executed in the same strict order they were coded. Evennia, via Twisted, is a single-process multi-user server. In simple terms this means that it swiftly switches between dealing with player input so quickly that each player feels like they do things at the same time. This is a clever illusion however: If one user, say, runs a command containing that long_running_function , all other players are effectively forced to wait until it finishes. Now, it should be said that on a modern computer system this is rarely an issue. Very few commands run so long that other users notice it. And as mentioned, most of the time you want to enforce all commands to occur in strict sequence. When delays do become noticeable and you don't care in which order the command actually completes, you can run it asynchronously . This makes use of the run_async() function in src/utils/utils.py : run_async(function, *args, **kwargs) Where function will be called asynchronously with *args and **kwargs . Example: from evennia import utils print(\"before call ...\") utils.run_async(long_running_function) print(\"after call ...\") Now, when running this you will find that the program will not wait around for long_running_function to finish. In fact you will see \"before call ...\" and \"after call ...\" printed out right away. The long-running function will run in the background and you (and other users) can go on as normal.","title":"Synchronous versus Asynchronous"},{"location":"Async-Process.html#customizing-asynchronous-operation","text":"A complication with using asynchronous calls is what to do with the result from that call. What if long_running_function returns a value that you need? It makes no real sense to put any lines of code after the call to try to deal with the result from long_running_function above - as we saw the \"after call ...\" got printed long before long_running_function was finished, making that line quite pointless for processing any data from the function. Instead one has to use callbacks . utils.run_async takes reserved kwargs that won't be passed into the long-running function: at_return(r) (the callback ) is called when the asynchronous function ( long_running_function above) finishes successfully. The argument r will then be the return value of that function (or None ). python def at_return(r): print(r) at_return_kwargs - an optional dictionary that will be fed as keyword arguments to the at_return callback. at_err(e) (the errback ) is called if the asynchronous function fails and raises an exception. This exception is passed to the errback wrapped in a Failure object e . If you do not supply an errback of your own, Evennia will automatically add one that silently writes errors to the evennia log. An example of an errback is found below: def at_err(e): print(\"There was an error:\", str(e)) at_err_kwargs - an optional dictionary that will be fed as keyword arguments to the at_err errback. An example of making an asynchronous call from inside a Command definition: from evennia import utils, Command class CmdAsync(Command): key = \"asynccommand\" def func(self): def long_running_function(): #[... lots of time-consuming code ...] return final_value def at_return_function(r): self.caller.msg(\"The final value is %s\" % r) def at_err_function(e): self.caller.msg(\"There was an error: %s\" % e) # do the async call, setting all callbacks utils.run_async(long_running_function, at_return=at_return_function, at_err=at_err_function) That's it - from here on we can forget about long_running_function and go on with what else need to be done. Whenever it finishes, the at_return_function function will be called and the final value will pop up for us to see. If not we will see an error message.","title":"Customizing asynchronous operation"},{"location":"Async-Process.html#delay","text":"The delay function is a much simpler sibling to run_async . It is in fact just a way to delay the execution of a command until a future time. This is equivalent to something like time.sleep() except delay is asynchronous while sleep would lock the entire server for the duration of the sleep. from evennia.utils import delay # [...] # e.g. inside a Command, where `self.caller` is available def callback(obj): obj.msg(\"Returning!\") delay(10, callback, self.caller) This will delay the execution of the callback for 10 seconds. This function is explored much more in the Command Duration Tutorial . You can also try the following snippet just see how it works: @py from evennia.utils import delay; delay(10, lambda who: who.msg(\"Test!\"), self) Wait 10 seconds and 'Test!' should be echoed back to you.","title":"delay"},{"location":"Async-Process.html#the-interactive-decorator","text":"As of Evennia 0.9, the @interactive decorator is available. This makes any function or method possible to 'pause' and/or await player input in an interactive way. from evennia.utils import interactive @interactive def myfunc(caller): while True: caller.msg(\"Getting ready to wait ...\") yield(5) caller.msg(\"Now 5 seconds have passed.\") response = yield(\"Do you want to wait another 5 secs?\") if response.lower() not in (\"yes\", \"y\"): break The @interactive decorator gives the function the ability to pause. The use of yield(seconds) will do just that - it will asynchronously pause for the number of seconds given before continuing. This is technically equivalent to using call_async with a callback that continues after 5 secs. But the code with @interactive is a little easier to follow. Within the @interactive function, the response = yield(\"question\") question allows you to ask the user for input. You can then process the input, just like you would if you used the Python input function. There is one caveat to this functionality though - it will only work if the function/method has an argument named exactly caller . This is because internally Evennia will look for the caller argument and treat that as the source of input. All of this makes the @interactive decorator very useful. But it comes with a few caveats. Notably, decorating a function/method with @interactive turns it into a Python generator . The most common issue is that you cannot use return <value> from a generator (just an empty return works). To return a value from a function/method you have decorated with @interactive , you must instead use a special Twisted function twisted.internet.defer.returnValue . Evennia also makes this function conveniently available from evennia.utils : from evennia.utils import interactive, returnValue @interactive def myfunc(): # ... result = 10 # this must be used instead of `return result` returnValue(result)","title":"The @interactive decorator"},{"location":"Async-Process.html#assorted-notes","text":"Overall, be careful with choosing when to use asynchronous calls. It is mainly useful for large administration operations that have no direct influence on the game world (imports and backup operations come to mind). Since there is no telling exactly when an asynchronous call actually ends, using them for in-game commands is to potentially invite confusion and inconsistencies (and very hard-to-reproduce bugs). The very first synchronous example above is not really correct in the case of Twisted, which is inherently an asynchronous server. Notably you might find that you will not see the first before call ... text being printed out right away. Instead all texts could end up being delayed until after the long-running process finishes. So all commands will retain their relative order as expected, but they may appear with delays or in groups.","title":"Assorted notes"},{"location":"Async-Process.html#further-reading","text":"Technically, run_async is just a very thin and simplified wrapper around a Twisted Deferred object; the wrapper sets up a default errback also if none is supplied. If you know what you are doing there is nothing stopping you from bypassing the utility function, building a more sophisticated callback chain after your own liking.","title":"Further reading"},{"location":"Attributes.html","text":"When performing actions in Evennia it is often important that you store data for later. If you write a menu system, you have to keep track of the current location in the menu tree so that the player can give correct subsequent commands. If you are writing a combat system, you might have a combattant's next roll get easier dependent on if their opponent failed. Your characters will probably need to store roleplaying-attributes like strength and agility. And so on. Typeclassed game entities ( Accounts , Objects , Scripts and Channels ) always have Attributes associated with them. Attributes are used to store any type of data 'on' such entities. This is different from storing data in properties already defined on entities (such as key or location ) - these have very specific names and require very specific types of data (for example you couldn't assign a python list to the key property no matter how hard you tried). Attributes come into play when you want to assign arbitrary data to arbitrary names. The .db and .ndb shortcuts \u00b6 To save persistent data on a Typeclassed object you normally use the db (DataBase) operator. Let's try to save some data to a Rose (an Object ): # saving rose.db.has_thorns = True # getting it back is_ouch = rose.db.has_thorns This looks like any normal Python assignment, but that db makes sure that an Attribute is created behind the scenes and is stored in the database. Your rose will continue to have thorns throughout the life of the server now, until you deliberately remove them. To be sure to save non-persistently , i.e. to make sure NOT to create a database entry, you use ndb (NonDataBase). It works in the same way: # saving rose.ndb.has_thorns = True # getting it back is_ouch = rose.ndb.has_thorns Technically, ndb has nothing to do with Attributes , despite how similar they look. No Attribute object is created behind the scenes when using ndb . In fact the database is not invoked at all since we are not interested in persistence. There is however an important reason to use ndb to store data rather than to just store variables direct on entities - ndb -stored data is tracked by the server and will not be purged in various cache-cleanup operations Evennia may do while it runs. Data stored on ndb (as well as db ) will also be easily listed by example the @examine command. You can also del properties on db and ndb as normal. This will for example delete an Attribute : del rose.db.has_thorns Both db and ndb defaults to offering an all() method on themselves. This returns all associated attributes or non-persistent properties. list_of_all_rose_attributes = rose.db.all() list_of_all_rose_ndb_attrs = rose.ndb.all() If you use all as the name of an attribute, this will be used instead. Later deleting your custom all will return the default behaviour. The AttributeHandler \u00b6 The .db and .ndb properties are very convenient but if you don't know the name of the Attribute beforehand they cannot be used. Behind the scenes .db actually accesses the AttributeHandler which sits on typeclassed entities as the .attributes property. .ndb does the same for the .nattributes property. The handlers have normal access methods that allow you to manage and retrieve Attributes and NAttributes : has('attrname') - this checks if the object has an Attribute with this key. This is equivalent to doing obj.db.attrname . get(...) - this retrieves the given Attribute. Normally the value property of the Attribute is returned, but the method takes keywords for returning the Attribute object itself. By supplying an accessing_object to the call one can also make sure to check permissions before modifying anything. add(...) - this adds a new Attribute to the object. An optional lockstring can be supplied here to restrict future access and also the call itself may be checked against locks. remove(...) - Remove the given Attribute. This can optionally be made to check for permission before performing the deletion. - clear(...) - removes all Attributes from object. all(...) - returns all Attributes (of the given category) attached to this object. See this section for more about locking down Attribute access and editing. The Nattribute offers no concept of access control. Some examples: import evennia obj = evennia.search_object(\"MyObject\") obj.attributes.add(\"test\", \"testvalue\") print(obj.db.test) # prints \"testvalue\" print(obj.attributes.get(\"test\")) # \" print(obj.attributes.all()) # prints [<AttributeObject>] obj.attributes.remove(\"test\") Properties of Attributes \u00b6 An Attribute object is stored in the database. It has the following properties: key - the name of the Attribute. When doing e.g. obj.db.attrname = value , this property is set to attrname . value - this is the value of the Attribute. This value can be anything which can be pickled - objects, lists, numbers or what have you (see this section for more info). In the example obj.db.attrname = value , the value is stored here. category - this is an optional property that is set to None for most Attributes. Setting this allows to use Attributes for different functionality. This is usually not needed unless you want to use Attributes for very different functionality ( Nicks is an example of using Attributes in this way). To modify this property you need to use the Attribute Handler . strvalue - this is a separate value field that only accepts strings. This severely limits the data possible to store, but allows for easier database lookups. This property is usually not used except when re-using Attributes for some other purpose ( Nicks use it). It is only accessible via the Attribute Handler . There are also two special properties: attrtype - this is used internally by Evennia to separate Nicks , from Attributes (Nicks use Attributes behind the scenes). model - this is a natural-key describing the model this Attribute is attached to. This is on the form appname.modelclass , like objects.objectdb . It is used by the Attribute and NickHandler to quickly sort matches in the database. Neither this nor attrtype should normally need to be modified. Non-database attributes have no equivalence to category nor strvalue , attrtype or model . Persistent vs non-persistent \u00b6 So persistent data means that your data will survive a server reboot, whereas with non-persistent data it will not ... ... So why would you ever want to use non-persistent data? The answer is, you don't have to. Most of the time you really want to save as much as you possibly can. Non-persistent data is potentially useful in a few situations though. You are worried about database performance. Since Evennia caches Attributes very aggressively, this is not an issue unless you are reading and writing to your Attribute very often (like many times per second). Reading from an already cached Attribute is as fast as reading any Python property. But even then this is not likely something to worry about: Apart from Evennia's own caching, modern database systems themselves also cache data very efficiently for speed. Our default database even runs completely in RAM if possible, alleviating much of the need to write to disk during heavy loads. A more valid reason for using non-persistent data is if you want to lose your state when logging off. Maybe you are storing throw-away data that are re-initialized at server startup. Maybe you are implementing some caching of your own. Or maybe you are testing a buggy Script that does potentially harmful stuff to your character object. With non-persistent storage you can be sure that whatever is messed up, it's nothing a server reboot can't clear up. NAttributes have no restrictions at all on what they can store (see next section), since they don't need to worry about being saved to the database - they work very well for temporary storage. You want to implement a fully or partly non-persistent world . Who are we to argue with your grand vision! What types of data can I save in an Attribute? \u00b6 None of the following affects NAttributes, which does not invoke the database at all. There are no restrictions to what can be stored in a NAttribute. The database doesn't know anything about Python objects, so Evennia must serialize Attribute values into a string representation in order to store it to the database. This is done using the pickle module of Python (the only exception is if you use the strattr keyword of the AttributeHandler to save to the strvalue field of the Attribute. In that case you can only save strings which will not be pickled). It's important to note that when you access the data in an Attribute you are always de-serializing it from the database representation every time. This is because we allow for storing database-entities in Attributes too. If we cached it as its Python form, we might end up with situations where the database entity was deleted since we last accessed the Attribute. De-serializing data with a database-entity in it means querying the database for that object and making sure it still exists (otherwise it will be set to None ). Performance-wise this is usually not a big deal. But if you are accessing the Attribute as part of some big loop or doing a large amount of reads/writes you should first extract it to a temporary variable, operate on that and then save the result back to the Attribute. If you are storing a more complex structure like a dict or a list you should make sure to \"disconnect\" it from the database before looping over it, as mentioned in the Retrieving Mutable Objects section below. Storing single objects \u00b6 With a single object, we mean anything that is not iterable , like numbers, strings or custom class instances without the __iter__ method. You can generally store any non-iterable Python entity that can be pickled . Single database objects/typeclasses can be stored as any other in the Attribute. These can normally not be pickled, but Evennia will behind the scenes convert them to an internal representation using their classname, database-id and creation-date with a microsecond precision, guaranteeing you get the same object back when you access the Attribute later. If you hide a database object inside a non-iterable custom class (like stored as a variable inside it), Evennia will not know it's there and won't convert it safely. Storing classes with such hidden database objects is not supported and will lead to errors! # Examples of valid single-value attribute data: obj.db.test1 = 23 obj.db.test1 = False # a database object (will be stored as an internal representation) obj.db.test2 = myobj # example of an invalid, \"hidden\" dbobject class Invalid(object): def __init__(self, dbobj): # no way for Evennia to know this is a dbobj self.dbobj = dbobj invalid = Invalid(myobj) obj.db.invalid = invalid # will cause error! Storing multiple objects \u00b6 This means storing objects in a collection of some kind and are examples of iterables , pickle-able entities you can loop over in a for-loop. Attribute-saving supports the following iterables: Tuples , like (1,2,\"test\", <dbobj>) . Lists , like [1,2,\"test\", <dbobj>] . Dicts , like {1:2, \"test\":<dbobj>] . Sets , like {1,2,\"test\",<dbobj>} . collections.OrderedDict , like OrderedDict((1,2), (\"test\", <dbobj>)) . collections.Deque , like deque((1,2,\"test\",<dbobj>)) . Nestings of any combinations of the above, like lists in dicts or an OrderedDict of tuples, each containing dicts, etc. All other iterables (i.e. entities with the __iter__ method) will be converted to a list . Since you can use any combination of the above iterables, this is generally not much of a limitation. Any entity listed in the Single object section above can be stored in the iterable. As mentioned in the previous section, database entities (aka typeclasses) are not possible to pickle. So when storing an iterable, Evennia must recursively traverse the iterable and all its nested sub-iterables in order to find eventual database objects to convert. This is a very fast process but for efficiency you may want to avoid too deeply nested structures if you can. # examples of valid iterables to store obj.db.test3 = [obj1, 45, obj2, 67] # a dictionary obj.db.test4 = {'str':34, 'dex':56, 'agi':22, 'int':77} # a mixed dictionary/list obj.db.test5 = {'members': [obj1,obj2,obj3], 'enemies':[obj4,obj5]} # a tuple with a list in it obj.db.test6 = (1,3,4,8, [\"test\", \"test2\"], 9) # a set obj.db.test7 = set([1,2,3,4,5]) # in-situ manipulation obj.db.test8 = [1,2,{\"test\":1}] obj.db.test8[0] = 4 obj.db.test8[2][\"test\"] = 5 # test8 is now [4,2,{\"test\":5}] Retrieving Mutable objects \u00b6 A side effect of the way Evennia stores Attributes is that mutable iterables (iterables that can be modified in-place after they were created, which is everything except tuples) are handled by custom objects called _SaverList , _SaverDict etc. These _Saver... classes behave just like the normal variant except that they are aware of the database and saves to it whenever new data gets assigned to them. This is what allows you to do things like self.db.mylist[7] = val and be sure that the new version of list is saved. Without this you would have to load the list into a temporary variable, change it and then re-assign it to the Attribute in order for it to save. There is however an important thing to remember. If you retrieve your mutable iterable into another variable, e.g. mylist2 = obj.db.mylist , your new variable ( mylist2 ) will still be a _SaverList . This means it will continue to save itself to the database whenever it is updated! obj.db.mylist = [1,2,3,4] mylist = obj.db.mylist mylist[3] = 5 # this will also update database print(mylist) # this is now [1,2,3,5] print(obj.db.mylist) # this is also [1,2,3,5] To \"disconnect\" your extracted mutable variable from the database you simply need to convert the _Saver... iterable to a normal Python structure. So to convert a _SaverList , you use the list() function, for a _SaverDict you use dict() and so on. obj.db.mylist = [1,2,3,4] mylist = list(obj.db.mylist) # convert to normal list mylist[3] = 5 print(mylist) # this is now [1,2,3,5] print(obj.db.mylist) # this is still [1,2,3,4] A further problem comes with nested mutables , like a dict containing lists of dicts or something like that. Each of these nested mutables would be _Saver* structures connected to the database and disconnecting the outermost one of them would not disconnect those nested within. To make really sure you disonnect a nested structure entirely from the database, Evennia provides a special function evennia.utils.dbserialize.deserialize : from evennia.utils.dbserialize import deserialize decoupled_mutables = deserialize(nested_mutables) The result of this operation will be a structure only consisting of normal Python mutables ( list instead of _SaverList and so on). Remember, this is only valid for mutable iterables. Immutable objects (strings, numbers, tuples etc) are already disconnected from the database from the onset. obj.db.mytup = (1,2,[3,4]) obj.db.mytup[0] = 5 # this fails since tuples are immutable # this works but will NOT update database since outermost is a tuple obj.db.mytup[2][1] = 5 print(obj.db.mytup[2][1]) # this still returns 4, not 5 mytup1 = obj.db.mytup # mytup1 is already disconnected from database since outermost # iterable is a tuple, so we can edit the internal list as we want # without affecting the database. Attributes will fetch data fresh from the database whenever you read them, so if you are performing big operations on a mutable Attribute property (such as looping over a list or dict) you should make sure to \"disconnect\" the Attribute's value first and operate on this rather than on the Attribute. You can gain dramatic speed improvements to big loops this way. Locking and checking Attributes \u00b6 Attributes are normally not locked down by default, but you can easily change that for individual Attributes (like those that may be game-sensitive in games with user-level building). First you need to set a lock string on your Attribute. Lock strings are specified Locks . The relevant lock types are attrread - limits who may read the value of the Attribute attredit - limits who may set/change this Attribute You cannot use the db handler to modify Attribute object (such as setting a lock on them) - The db handler will return the Attribute's value , not the Attribute object itself. Instead you use the AttributeHandler and set it to return the object instead of the value: lockstring = \"attread:all();attredit:perm(Admins)\" obj.attributes.get(\"myattr\", return_obj=True).locks.add(lockstring) Note the return_obj keyword which makes sure to return the Attribute object so its LockHandler could be accessed. A lock is no good if nothing checks it -- and by default Evennia does not check locks on Attributes. You have to add a check to your commands/code wherever it fits (such as before setting an Attribute). # in some command code where we want to limit # setting of a given attribute name on an object attr = obj.attributes.get(attrname, return_obj=True, accessing_obj=caller, default=None, default_access=False) if not attr: caller.msg(\"You cannot edit that Attribute!\") return # edit the Attribute here The same keywords are available to use with obj.attributes.set() and obj.attributes.remove() , those will check for the attredit lock type.","title":"Attributes"},{"location":"Attributes.html#the-db-and-ndb-shortcuts","text":"To save persistent data on a Typeclassed object you normally use the db (DataBase) operator. Let's try to save some data to a Rose (an Object ): # saving rose.db.has_thorns = True # getting it back is_ouch = rose.db.has_thorns This looks like any normal Python assignment, but that db makes sure that an Attribute is created behind the scenes and is stored in the database. Your rose will continue to have thorns throughout the life of the server now, until you deliberately remove them. To be sure to save non-persistently , i.e. to make sure NOT to create a database entry, you use ndb (NonDataBase). It works in the same way: # saving rose.ndb.has_thorns = True # getting it back is_ouch = rose.ndb.has_thorns Technically, ndb has nothing to do with Attributes , despite how similar they look. No Attribute object is created behind the scenes when using ndb . In fact the database is not invoked at all since we are not interested in persistence. There is however an important reason to use ndb to store data rather than to just store variables direct on entities - ndb -stored data is tracked by the server and will not be purged in various cache-cleanup operations Evennia may do while it runs. Data stored on ndb (as well as db ) will also be easily listed by example the @examine command. You can also del properties on db and ndb as normal. This will for example delete an Attribute : del rose.db.has_thorns Both db and ndb defaults to offering an all() method on themselves. This returns all associated attributes or non-persistent properties. list_of_all_rose_attributes = rose.db.all() list_of_all_rose_ndb_attrs = rose.ndb.all() If you use all as the name of an attribute, this will be used instead. Later deleting your custom all will return the default behaviour.","title":"The .db and .ndb shortcuts"},{"location":"Attributes.html#the-attributehandler","text":"The .db and .ndb properties are very convenient but if you don't know the name of the Attribute beforehand they cannot be used. Behind the scenes .db actually accesses the AttributeHandler which sits on typeclassed entities as the .attributes property. .ndb does the same for the .nattributes property. The handlers have normal access methods that allow you to manage and retrieve Attributes and NAttributes : has('attrname') - this checks if the object has an Attribute with this key. This is equivalent to doing obj.db.attrname . get(...) - this retrieves the given Attribute. Normally the value property of the Attribute is returned, but the method takes keywords for returning the Attribute object itself. By supplying an accessing_object to the call one can also make sure to check permissions before modifying anything. add(...) - this adds a new Attribute to the object. An optional lockstring can be supplied here to restrict future access and also the call itself may be checked against locks. remove(...) - Remove the given Attribute. This can optionally be made to check for permission before performing the deletion. - clear(...) - removes all Attributes from object. all(...) - returns all Attributes (of the given category) attached to this object. See this section for more about locking down Attribute access and editing. The Nattribute offers no concept of access control. Some examples: import evennia obj = evennia.search_object(\"MyObject\") obj.attributes.add(\"test\", \"testvalue\") print(obj.db.test) # prints \"testvalue\" print(obj.attributes.get(\"test\")) # \" print(obj.attributes.all()) # prints [<AttributeObject>] obj.attributes.remove(\"test\")","title":"The AttributeHandler"},{"location":"Attributes.html#properties-of-attributes","text":"An Attribute object is stored in the database. It has the following properties: key - the name of the Attribute. When doing e.g. obj.db.attrname = value , this property is set to attrname . value - this is the value of the Attribute. This value can be anything which can be pickled - objects, lists, numbers or what have you (see this section for more info). In the example obj.db.attrname = value , the value is stored here. category - this is an optional property that is set to None for most Attributes. Setting this allows to use Attributes for different functionality. This is usually not needed unless you want to use Attributes for very different functionality ( Nicks is an example of using Attributes in this way). To modify this property you need to use the Attribute Handler . strvalue - this is a separate value field that only accepts strings. This severely limits the data possible to store, but allows for easier database lookups. This property is usually not used except when re-using Attributes for some other purpose ( Nicks use it). It is only accessible via the Attribute Handler . There are also two special properties: attrtype - this is used internally by Evennia to separate Nicks , from Attributes (Nicks use Attributes behind the scenes). model - this is a natural-key describing the model this Attribute is attached to. This is on the form appname.modelclass , like objects.objectdb . It is used by the Attribute and NickHandler to quickly sort matches in the database. Neither this nor attrtype should normally need to be modified. Non-database attributes have no equivalence to category nor strvalue , attrtype or model .","title":"Properties of Attributes"},{"location":"Attributes.html#persistent-vs-non-persistent","text":"So persistent data means that your data will survive a server reboot, whereas with non-persistent data it will not ... ... So why would you ever want to use non-persistent data? The answer is, you don't have to. Most of the time you really want to save as much as you possibly can. Non-persistent data is potentially useful in a few situations though. You are worried about database performance. Since Evennia caches Attributes very aggressively, this is not an issue unless you are reading and writing to your Attribute very often (like many times per second). Reading from an already cached Attribute is as fast as reading any Python property. But even then this is not likely something to worry about: Apart from Evennia's own caching, modern database systems themselves also cache data very efficiently for speed. Our default database even runs completely in RAM if possible, alleviating much of the need to write to disk during heavy loads. A more valid reason for using non-persistent data is if you want to lose your state when logging off. Maybe you are storing throw-away data that are re-initialized at server startup. Maybe you are implementing some caching of your own. Or maybe you are testing a buggy Script that does potentially harmful stuff to your character object. With non-persistent storage you can be sure that whatever is messed up, it's nothing a server reboot can't clear up. NAttributes have no restrictions at all on what they can store (see next section), since they don't need to worry about being saved to the database - they work very well for temporary storage. You want to implement a fully or partly non-persistent world . Who are we to argue with your grand vision!","title":"Persistent vs non-persistent"},{"location":"Attributes.html#what-types-of-data-can-i-save-in-an-attribute","text":"None of the following affects NAttributes, which does not invoke the database at all. There are no restrictions to what can be stored in a NAttribute. The database doesn't know anything about Python objects, so Evennia must serialize Attribute values into a string representation in order to store it to the database. This is done using the pickle module of Python (the only exception is if you use the strattr keyword of the AttributeHandler to save to the strvalue field of the Attribute. In that case you can only save strings which will not be pickled). It's important to note that when you access the data in an Attribute you are always de-serializing it from the database representation every time. This is because we allow for storing database-entities in Attributes too. If we cached it as its Python form, we might end up with situations where the database entity was deleted since we last accessed the Attribute. De-serializing data with a database-entity in it means querying the database for that object and making sure it still exists (otherwise it will be set to None ). Performance-wise this is usually not a big deal. But if you are accessing the Attribute as part of some big loop or doing a large amount of reads/writes you should first extract it to a temporary variable, operate on that and then save the result back to the Attribute. If you are storing a more complex structure like a dict or a list you should make sure to \"disconnect\" it from the database before looping over it, as mentioned in the Retrieving Mutable Objects section below.","title":"What types of data can I save in an Attribute?"},{"location":"Attributes.html#storing-single-objects","text":"With a single object, we mean anything that is not iterable , like numbers, strings or custom class instances without the __iter__ method. You can generally store any non-iterable Python entity that can be pickled . Single database objects/typeclasses can be stored as any other in the Attribute. These can normally not be pickled, but Evennia will behind the scenes convert them to an internal representation using their classname, database-id and creation-date with a microsecond precision, guaranteeing you get the same object back when you access the Attribute later. If you hide a database object inside a non-iterable custom class (like stored as a variable inside it), Evennia will not know it's there and won't convert it safely. Storing classes with such hidden database objects is not supported and will lead to errors! # Examples of valid single-value attribute data: obj.db.test1 = 23 obj.db.test1 = False # a database object (will be stored as an internal representation) obj.db.test2 = myobj # example of an invalid, \"hidden\" dbobject class Invalid(object): def __init__(self, dbobj): # no way for Evennia to know this is a dbobj self.dbobj = dbobj invalid = Invalid(myobj) obj.db.invalid = invalid # will cause error!","title":"Storing single objects"},{"location":"Attributes.html#storing-multiple-objects","text":"This means storing objects in a collection of some kind and are examples of iterables , pickle-able entities you can loop over in a for-loop. Attribute-saving supports the following iterables: Tuples , like (1,2,\"test\", <dbobj>) . Lists , like [1,2,\"test\", <dbobj>] . Dicts , like {1:2, \"test\":<dbobj>] . Sets , like {1,2,\"test\",<dbobj>} . collections.OrderedDict , like OrderedDict((1,2), (\"test\", <dbobj>)) . collections.Deque , like deque((1,2,\"test\",<dbobj>)) . Nestings of any combinations of the above, like lists in dicts or an OrderedDict of tuples, each containing dicts, etc. All other iterables (i.e. entities with the __iter__ method) will be converted to a list . Since you can use any combination of the above iterables, this is generally not much of a limitation. Any entity listed in the Single object section above can be stored in the iterable. As mentioned in the previous section, database entities (aka typeclasses) are not possible to pickle. So when storing an iterable, Evennia must recursively traverse the iterable and all its nested sub-iterables in order to find eventual database objects to convert. This is a very fast process but for efficiency you may want to avoid too deeply nested structures if you can. # examples of valid iterables to store obj.db.test3 = [obj1, 45, obj2, 67] # a dictionary obj.db.test4 = {'str':34, 'dex':56, 'agi':22, 'int':77} # a mixed dictionary/list obj.db.test5 = {'members': [obj1,obj2,obj3], 'enemies':[obj4,obj5]} # a tuple with a list in it obj.db.test6 = (1,3,4,8, [\"test\", \"test2\"], 9) # a set obj.db.test7 = set([1,2,3,4,5]) # in-situ manipulation obj.db.test8 = [1,2,{\"test\":1}] obj.db.test8[0] = 4 obj.db.test8[2][\"test\"] = 5 # test8 is now [4,2,{\"test\":5}]","title":"Storing multiple objects"},{"location":"Attributes.html#retrieving-mutable-objects","text":"A side effect of the way Evennia stores Attributes is that mutable iterables (iterables that can be modified in-place after they were created, which is everything except tuples) are handled by custom objects called _SaverList , _SaverDict etc. These _Saver... classes behave just like the normal variant except that they are aware of the database and saves to it whenever new data gets assigned to them. This is what allows you to do things like self.db.mylist[7] = val and be sure that the new version of list is saved. Without this you would have to load the list into a temporary variable, change it and then re-assign it to the Attribute in order for it to save. There is however an important thing to remember. If you retrieve your mutable iterable into another variable, e.g. mylist2 = obj.db.mylist , your new variable ( mylist2 ) will still be a _SaverList . This means it will continue to save itself to the database whenever it is updated! obj.db.mylist = [1,2,3,4] mylist = obj.db.mylist mylist[3] = 5 # this will also update database print(mylist) # this is now [1,2,3,5] print(obj.db.mylist) # this is also [1,2,3,5] To \"disconnect\" your extracted mutable variable from the database you simply need to convert the _Saver... iterable to a normal Python structure. So to convert a _SaverList , you use the list() function, for a _SaverDict you use dict() and so on. obj.db.mylist = [1,2,3,4] mylist = list(obj.db.mylist) # convert to normal list mylist[3] = 5 print(mylist) # this is now [1,2,3,5] print(obj.db.mylist) # this is still [1,2,3,4] A further problem comes with nested mutables , like a dict containing lists of dicts or something like that. Each of these nested mutables would be _Saver* structures connected to the database and disconnecting the outermost one of them would not disconnect those nested within. To make really sure you disonnect a nested structure entirely from the database, Evennia provides a special function evennia.utils.dbserialize.deserialize : from evennia.utils.dbserialize import deserialize decoupled_mutables = deserialize(nested_mutables) The result of this operation will be a structure only consisting of normal Python mutables ( list instead of _SaverList and so on). Remember, this is only valid for mutable iterables. Immutable objects (strings, numbers, tuples etc) are already disconnected from the database from the onset. obj.db.mytup = (1,2,[3,4]) obj.db.mytup[0] = 5 # this fails since tuples are immutable # this works but will NOT update database since outermost is a tuple obj.db.mytup[2][1] = 5 print(obj.db.mytup[2][1]) # this still returns 4, not 5 mytup1 = obj.db.mytup # mytup1 is already disconnected from database since outermost # iterable is a tuple, so we can edit the internal list as we want # without affecting the database. Attributes will fetch data fresh from the database whenever you read them, so if you are performing big operations on a mutable Attribute property (such as looping over a list or dict) you should make sure to \"disconnect\" the Attribute's value first and operate on this rather than on the Attribute. You can gain dramatic speed improvements to big loops this way.","title":"Retrieving Mutable objects"},{"location":"Attributes.html#locking-and-checking-attributes","text":"Attributes are normally not locked down by default, but you can easily change that for individual Attributes (like those that may be game-sensitive in games with user-level building). First you need to set a lock string on your Attribute. Lock strings are specified Locks . The relevant lock types are attrread - limits who may read the value of the Attribute attredit - limits who may set/change this Attribute You cannot use the db handler to modify Attribute object (such as setting a lock on them) - The db handler will return the Attribute's value , not the Attribute object itself. Instead you use the AttributeHandler and set it to return the object instead of the value: lockstring = \"attread:all();attredit:perm(Admins)\" obj.attributes.get(\"myattr\", return_obj=True).locks.add(lockstring) Note the return_obj keyword which makes sure to return the Attribute object so its LockHandler could be accessed. A lock is no good if nothing checks it -- and by default Evennia does not check locks on Attributes. You have to add a check to your commands/code wherever it fits (such as before setting an Attribute). # in some command code where we want to limit # setting of a given attribute name on an object attr = obj.attributes.get(attrname, return_obj=True, accessing_obj=caller, default=None, default_access=False) if not attr: caller.msg(\"You cannot edit that Attribute!\") return # edit the Attribute here The same keywords are available to use with obj.attributes.set() and obj.attributes.remove() , those will check for the attredit lock type.","title":"Locking and checking Attributes"},{"location":"Banning.html","text":"Whether due to abuse, blatant breaking of your rules, or some other reason, you will eventually find no other recourse but to kick out a particularly troublesome player. The default command set has admin tools to handle this, primarily @ban , @unban , and @boot . Creating a ban \u00b6 Say we have a troublesome player \"YouSuck\" - this is a person that refuses common courtesy - an abusive and spammy account that is clearly created by some bored internet hooligan only to cause grief. You have tried to be nice. Now you just want this troll gone. Name ban \u00b6 The easiest recourse is to block the account YouSuck from ever connecting again. @ban YouSuck This will lock the name YouSuck (as well as 'yousuck' and any other capitalization combination), and next time they try to log in with this name the server will not let them! You can also give a reason so you remember later why this was a good thing (the banned account will never see this) @ban YouSuck:This is just a troll. If you are sure this is just a spam account, you might even consider deleting the player account outright: @delaccount YouSuck Generally, banning the name is the easier and safer way to stop the use of an account -- if you change your mind you can always remove the block later whereas a deletion is permanent. IP ban \u00b6 Just because you block YouSuck's name might not mean the trolling human behind that account gives up. They can just create a new account YouSuckMore and be back at it. One way to make things harder for them is to tell the server to not allow connections from their particular IP address. First, when the offending account is online, check which IP address they use. This you can do with the who command, which will show you something like this: Account Name On for Idle Room Cmds Host YouSuckMore 01:12 2m 22 212 237.333.0.223 The \"Host\" bit is the IP address from which the account is connecting. Use this to define the ban instead of the name: @ban 237.333.0.223 This will stop YouSuckMore connecting from their computer. Note however that IP address might change easily - either due to how the player's Internet Service Provider operates or by the user simply changing computers. You can make a more general ban by putting asterisks * as wildcards for the groups of three digits in the address. So if you figure out that !YouSuckMore mainly connects from 237.333.0.223, 237.333.0.225, and 237.333.0.256 (only changes in their subnet), it might be an idea to put down a ban like this to include any number in that subnet: @ban 237.333.0.* You should combine the IP ban with a name-ban too of course, so the account YouSuckMore is truly locked regardless of where they connect from. Be careful with too general IP bans however (more asterisks above). If you are unlucky you could be blocking out innocent players who just happen to connect from the same subnet as the offender. Booting \u00b6 YouSuck is not really noticing all this banning yet though - and won't until having logged out and trying to log back in again. Let's help the troll along. @boot YouSuck Good riddance. You can give a reason for booting too (to be echoed to the player before getting kicked out). @boot YouSuck:Go troll somewhere else. Lifting a ban \u00b6 Use the @unban (or @ban ) command without any arguments and you will see a list of all currently active bans: Active bans id name/ip date reason 1 yousuck Fri Jan 3 23:00:22 2020 This is just a Troll. 2 237.333.0.* Fri Jan 3 23:01:03 2020 YouSuck's IP. Use the id from this list to find out which ban to lift. @unban 2 Cleared ban 2: 237.333.0.* Summary of abuse-handling tools \u00b6 Below are other useful commands for dealing with annoying players. who -- (as admin) Find the IP of a account. Note that one account can be connected to from multiple IPs depending on what you allow in your settings. examine/account thomas -- Get all details about an account. You can also use *thomas to get the account. If not given, you will get the Object thomas if it exists in the same location, which is not what you want in this case. boot thomas -- Boot all sessions of the given account name. boot 23 -- Boot one specific client session/IP by its unique id. ban -- List all bans (listed with ids) ban thomas -- Ban the user with the given account name ban/ip 134.233.2.111 -- Ban by IP ban/ip 134.233.2.* -- Widen IP ban ban/ip 134.233.*.* -- Even wider IP ban unban 34 -- Remove ban with id #34 cboot mychannel = thomas -- Boot a subscriber from a channel you control clock mychannel = control:perm(Admin);listen:all();send:all() -- Fine control of access to your channel using lock definitions . Locking a specific command (like page ) is accomplished like so: 1. Examine the source of the command. The default page command class has the lock string \"cmd:not pperm(page_banned)\" . This means that unless the player has the 'permission' \"page_banned\" they can use this command. You can assign any lock string to allow finer customization in your commands. You might look for the value of an Attribute or Tag , your current location etc. 2. perm/account thomas = page_banned -- Give the account the 'permission' which causes (in this case) the lock to fail. perm/del/account thomas = page_banned -- Remove the given permission tel thomas = jail -- Teleport a player to a specified location or #dbref type thomas = FlowerPot -- Turn an annoying player into a flower pot (assuming you have a FlowerPot typeclass ready) userpassword thomas = fooBarFoo -- Change a user's password delaccount thomas -- Delete a player account (not recommended, use ban instead) server -- Show server statistics, such as CPU load, memory usage, and how many objects are cached time -- Gives server uptime, runtime, etc reload -- Reloads the server without disconnecting anyone reset -- Restarts the server, kicking all connections shutdown -- Stops the server cold without it auto-starting again py -- Executes raw Python code, allows for direct inspection of the database and account objects on the fly. For advanced users.","title":"Banning"},{"location":"Banning.html#creating-a-ban","text":"Say we have a troublesome player \"YouSuck\" - this is a person that refuses common courtesy - an abusive and spammy account that is clearly created by some bored internet hooligan only to cause grief. You have tried to be nice. Now you just want this troll gone.","title":"Creating a ban"},{"location":"Banning.html#name-ban","text":"The easiest recourse is to block the account YouSuck from ever connecting again. @ban YouSuck This will lock the name YouSuck (as well as 'yousuck' and any other capitalization combination), and next time they try to log in with this name the server will not let them! You can also give a reason so you remember later why this was a good thing (the banned account will never see this) @ban YouSuck:This is just a troll. If you are sure this is just a spam account, you might even consider deleting the player account outright: @delaccount YouSuck Generally, banning the name is the easier and safer way to stop the use of an account -- if you change your mind you can always remove the block later whereas a deletion is permanent.","title":"Name ban"},{"location":"Banning.html#ip-ban","text":"Just because you block YouSuck's name might not mean the trolling human behind that account gives up. They can just create a new account YouSuckMore and be back at it. One way to make things harder for them is to tell the server to not allow connections from their particular IP address. First, when the offending account is online, check which IP address they use. This you can do with the who command, which will show you something like this: Account Name On for Idle Room Cmds Host YouSuckMore 01:12 2m 22 212 237.333.0.223 The \"Host\" bit is the IP address from which the account is connecting. Use this to define the ban instead of the name: @ban 237.333.0.223 This will stop YouSuckMore connecting from their computer. Note however that IP address might change easily - either due to how the player's Internet Service Provider operates or by the user simply changing computers. You can make a more general ban by putting asterisks * as wildcards for the groups of three digits in the address. So if you figure out that !YouSuckMore mainly connects from 237.333.0.223, 237.333.0.225, and 237.333.0.256 (only changes in their subnet), it might be an idea to put down a ban like this to include any number in that subnet: @ban 237.333.0.* You should combine the IP ban with a name-ban too of course, so the account YouSuckMore is truly locked regardless of where they connect from. Be careful with too general IP bans however (more asterisks above). If you are unlucky you could be blocking out innocent players who just happen to connect from the same subnet as the offender.","title":"IP ban"},{"location":"Banning.html#booting","text":"YouSuck is not really noticing all this banning yet though - and won't until having logged out and trying to log back in again. Let's help the troll along. @boot YouSuck Good riddance. You can give a reason for booting too (to be echoed to the player before getting kicked out). @boot YouSuck:Go troll somewhere else.","title":"Booting"},{"location":"Banning.html#lifting-a-ban","text":"Use the @unban (or @ban ) command without any arguments and you will see a list of all currently active bans: Active bans id name/ip date reason 1 yousuck Fri Jan 3 23:00:22 2020 This is just a Troll. 2 237.333.0.* Fri Jan 3 23:01:03 2020 YouSuck's IP. Use the id from this list to find out which ban to lift. @unban 2 Cleared ban 2: 237.333.0.*","title":"Lifting a ban"},{"location":"Banning.html#summary-of-abuse-handling-tools","text":"Below are other useful commands for dealing with annoying players. who -- (as admin) Find the IP of a account. Note that one account can be connected to from multiple IPs depending on what you allow in your settings. examine/account thomas -- Get all details about an account. You can also use *thomas to get the account. If not given, you will get the Object thomas if it exists in the same location, which is not what you want in this case. boot thomas -- Boot all sessions of the given account name. boot 23 -- Boot one specific client session/IP by its unique id. ban -- List all bans (listed with ids) ban thomas -- Ban the user with the given account name ban/ip 134.233.2.111 -- Ban by IP ban/ip 134.233.2.* -- Widen IP ban ban/ip 134.233.*.* -- Even wider IP ban unban 34 -- Remove ban with id #34 cboot mychannel = thomas -- Boot a subscriber from a channel you control clock mychannel = control:perm(Admin);listen:all();send:all() -- Fine control of access to your channel using lock definitions . Locking a specific command (like page ) is accomplished like so: 1. Examine the source of the command. The default page command class has the lock string \"cmd:not pperm(page_banned)\" . This means that unless the player has the 'permission' \"page_banned\" they can use this command. You can assign any lock string to allow finer customization in your commands. You might look for the value of an Attribute or Tag , your current location etc. 2. perm/account thomas = page_banned -- Give the account the 'permission' which causes (in this case) the lock to fail. perm/del/account thomas = page_banned -- Remove the given permission tel thomas = jail -- Teleport a player to a specified location or #dbref type thomas = FlowerPot -- Turn an annoying player into a flower pot (assuming you have a FlowerPot typeclass ready) userpassword thomas = fooBarFoo -- Change a user's password delaccount thomas -- Delete a player account (not recommended, use ban instead) server -- Show server statistics, such as CPU load, memory usage, and how many objects are cached time -- Gives server uptime, runtime, etc reload -- Reloads the server without disconnecting anyone reset -- Restarts the server, kicking all connections shutdown -- Stops the server cold without it auto-starting again py -- Executes raw Python code, allows for direct inspection of the database and account objects on the fly. For advanced users.","title":"Summary of abuse-handling tools"},{"location":"Batch-Code-Processor.html","text":"For an introduction and motivation to using batch processors, see here . This page describes the Batch- code processor. The Batch- command one is covered here . Basic Usage \u00b6 The batch-code processor is a superuser-only function, invoked by > @batchcode path.to.batchcodefile Where path.to.batchcodefile is the path to a batch-code file . Such a file should have a name ending in \" .py \" (but you shouldn't include that in the path). The path is given like a python path relative to a folder you define to hold your batch files, set by BATCH_IMPORT_PATH in your settings. Default folder is (assuming your game is called \"mygame\") mygame/world/ . So if you want to run the example batch file in mygame/world/batch_code.py , you could simply use > @batchcode batch_code This will try to run through the entire batch file in one go. For more gradual, interactive control you can use the /interactive switch. The switch /debug will put the processor in debug mode. Read below for more info. The batch file \u00b6 A batch-code file is a normal Python file. The difference is that since the batch processor loads and executes the file rather than importing it, you can reliably update the file, then call it again, over and over and see your changes without needing to @reload the server. This makes for easy testing. In the batch-code file you have also access to the following global variables: caller - This is a reference to the object running the batchprocessor. DEBUG - This is a boolean that lets you determine if this file is currently being run in debug-mode or not. See below how this can be useful. Running a plain Python file through the processor will just execute the file from beginning to end. If you want to get more control over the execution you can use the processor's interactive mode. This runs certain code blocks on their own, rerunning only that part until you are happy with it. In order to do this you need to add special markers to your file to divide it up into smaller chunks. These take the form of comments, so the file remains valid Python. Here are the rules of syntax of the batch-code *.py file. #CODE as the first on a line marks the start of a code block. It will last until the beginning of another marker or the end of the file. Code blocks contain functional python code. Each #CODE block will be run in complete isolation from other parts of the file, so make sure it's self-contained. #HEADER as the first on a line marks the start of a header block. It lasts until the next marker or the end of the file. This is intended to hold imports and variables you will need for all other blocks .All python code defined in a header block will always be inserted at the top of every #CODE blocks in the file. You may have more than one #HEADER block, but that is equivalent to having one big one. Note that you can't exchange data between code blocks, so editing a header-variable in one code block won't affect that variable in any other code block! #INSERT path.to.file will insert another batchcode (Python) file at that position. A # that is not starting a #HEADER , #CODE or #INSERT instruction is considered a comment. Inside a block, normal Python syntax rules apply. For the sake of indentation, each block acts as a separate python module. Below is a version of the example file found in evennia/contrib/tutorial_examples/ . # # This is an example batch-code build file for Evennia. # #HEADER # This will be included in all other #CODE blocks from evennia import create_object, search_object from evennia.contrib.tutorial_examples import red_button from typeclasses.objects import Object limbo = search_object('Limbo')[0] #CODE red_button = create_object(red_button.RedButton, key=\"Red button\", location=limbo, aliases=[\"button\"]) # caller points to the one running the script caller.msg(\"A red button was created.\") # importing more code from another batch-code file #INSERT batch_code_insert #CODE table = create_object(Object, key=\"Blue Table\", location=limbo) chair = create_object(Object, key=\"Blue Chair\", location=limbo) string = \"A %s and %s were created.\" if DEBUG: table.delete() chair.delete() string += \" Since debug was active, \" \\ \"they were deleted again.\" caller.msg(string % (table, chair)) This uses Evennia's Python API to create three objects in sequence. Debug mode \u00b6 Try to run the example script with > @batchcode/debug tutorial_examples.example_batch_code The batch script will run to the end and tell you it completed. You will also get messages that the button and the two pieces of furniture were created. Look around and you should see the button there. But you won't see any chair nor a table! This is because we ran this with the /debug switch, which is directly visible as DEBUG==True inside the script. In the above example we handled this state by deleting the chair and table again. The debug mode is intended to be used when you test out a batchscript. Maybe you are looking for bugs in your code or try to see if things behave as they should. Running the script over and over would then create an ever-growing stack of chairs and tables, all with the same name. You would have to go back and painstakingly delete them later. Interactive mode \u00b6 Interactive mode works very similar to the batch-command processor counterpart . It allows you more step-wise control over how the batch file is executed. This is useful for debugging or for picking and choosing only particular blocks to run. Use @batchcode with the /interactive flag to enter interactive mode. > @batchcode/interactive tutorial_examples.batch_code You should see the following: 01/02: red_button = create_object(red_button.RedButton, [...] (hh for help) This shows that you are on the first #CODE block, the first of only two commands in this batch file. Observe that the block has not actually been executed at this point! To take a look at the full code snippet you are about to run, use ll (a batch-processor version of look ). from evennia.utils import create, search from evennia.contrib.tutorial_examples import red_button from typeclasses.objects import Object limbo = search.objects(caller, 'Limbo', global_search=True)[0] red_button = create.create_object(red_button.RedButton, key=\"Red button\", location=limbo, aliases=[\"button\"]) # caller points to the one running the script caller.msg(\"A red button was created.\") Compare with the example code given earlier. Notice how the content of #HEADER has been pasted at the top of the #CODE block. Use pp to actually execute this block (this will create the button and give you a message). Use nn (next) to go to the next command. Use hh for a list of commands. If there are tracebacks, fix them in the batch file, then use rr to reload the file. You will still be at the same code block and can rerun it easily with pp as needed. This makes for a simple debug cycle. It also allows you to rerun individual troublesome blocks - as mentioned, in a large batch file this can be very useful (don't forget the /debug mode either). Use nn and bb (next and back) to step through the file; e.g. nn 12 will jump 12 steps forward (without processing any blocks in between). All normal commands of Evennia should work too while working in interactive mode. Limitations and Caveats \u00b6 The batch-code processor is by far the most flexible way to build a world in Evennia. There are however some caveats you need to keep in mind. Safety \u00b6 Or rather the lack of it. There is a reason only superusers are allowed to run the batch-code processor by default. The code-processor runs without any Evennia security checks and allows full access to Python. If an untrusted party could run the code-processor they could execute arbitrary python code on your machine, which is potentially a very dangerous thing. If you want to allow other users to access the batch-code processor you should make sure to run Evennia as a separate and very limited-access user on your machine (i.e. in a 'jail'). By comparison, the batch-command processor is much safer since the user running it is still 'inside' the game and can't really do anything outside what the game commands allow them to. No communication between code blocks \u00b6 Global variables won't work in code batch files, each block is executed as stand-alone environments. #HEADER blocks are literally pasted on top of each #CODE block so updating some header-variable in your block will not make that change available in another block. Whereas a python execution limitation, allowing this would also lead to very hard-to-debug code when using the interactive mode - this would be a classical example of \"spaghetti code\". The main practical issue with this is when building e.g. a room in one code block and later want to connect that room with a room you built in the current block. There are two ways to do this: Perform a database search for the name of the room you created (since you cannot know in advance which dbref it got assigned). The problem is that a name may not be unique (you may have a lot of \"A dark forest\" rooms). There is an easy way to handle this though - use Tags or Aliases . You can assign any number of tags and/or aliases to any object. Make sure that one of those tags or aliases is unique to the room (like \"room56\") and you will henceforth be able to always uniquely search and find it later. Use the caller global property as an inter-block storage. For example, you could have a dictionary of room references in an ndb : ```python #HEADER if caller.ndb.all_rooms is None: caller.ndb.all_rooms = {} CODE \u00b6 create and store the castle \u00b6 castle = create_object(\"rooms.Room\", key=\"Castle\") caller.ndb.all_rooms[\"castle\"] = castle CODE \u00b6 in another node we want to access the castle \u00b6 castle = caller.ndb.all_rooms.get(\"castle\") `` Note how we check in #HEADER if caller.ndb.all_rooms doesn't already exist before creating the dict. Remember that #HEADER is copied in front of every #CODE block. Without that if` statement we'd be wiping the dict every block! Don't treat a batchcode file like any Python file \u00b6 Despite being a valid Python file, a batchcode file should only be run by the batchcode processor. You should not do things like define Typeclasses or Commands in them, or import them into other code. Importing a module in Python will execute base level of the module, which in the case of your average batchcode file could mean creating a lot of new objects every time. Don't let code rely on the batch-file's real file path \u00b6 When you import things into your batchcode file, don't use relative imports but always import with paths starting from the root of your game directory or evennia library. Code that relies on the batch file's \"actual\" location will fail . Batch code files are read as text and the strings executed. When the code runs it has no knowledge of what file those strings where once a part of.","title":"Batch Code Processor"},{"location":"Batch-Code-Processor.html#basic-usage","text":"The batch-code processor is a superuser-only function, invoked by > @batchcode path.to.batchcodefile Where path.to.batchcodefile is the path to a batch-code file . Such a file should have a name ending in \" .py \" (but you shouldn't include that in the path). The path is given like a python path relative to a folder you define to hold your batch files, set by BATCH_IMPORT_PATH in your settings. Default folder is (assuming your game is called \"mygame\") mygame/world/ . So if you want to run the example batch file in mygame/world/batch_code.py , you could simply use > @batchcode batch_code This will try to run through the entire batch file in one go. For more gradual, interactive control you can use the /interactive switch. The switch /debug will put the processor in debug mode. Read below for more info.","title":"Basic Usage"},{"location":"Batch-Code-Processor.html#the-batch-file","text":"A batch-code file is a normal Python file. The difference is that since the batch processor loads and executes the file rather than importing it, you can reliably update the file, then call it again, over and over and see your changes without needing to @reload the server. This makes for easy testing. In the batch-code file you have also access to the following global variables: caller - This is a reference to the object running the batchprocessor. DEBUG - This is a boolean that lets you determine if this file is currently being run in debug-mode or not. See below how this can be useful. Running a plain Python file through the processor will just execute the file from beginning to end. If you want to get more control over the execution you can use the processor's interactive mode. This runs certain code blocks on their own, rerunning only that part until you are happy with it. In order to do this you need to add special markers to your file to divide it up into smaller chunks. These take the form of comments, so the file remains valid Python. Here are the rules of syntax of the batch-code *.py file. #CODE as the first on a line marks the start of a code block. It will last until the beginning of another marker or the end of the file. Code blocks contain functional python code. Each #CODE block will be run in complete isolation from other parts of the file, so make sure it's self-contained. #HEADER as the first on a line marks the start of a header block. It lasts until the next marker or the end of the file. This is intended to hold imports and variables you will need for all other blocks .All python code defined in a header block will always be inserted at the top of every #CODE blocks in the file. You may have more than one #HEADER block, but that is equivalent to having one big one. Note that you can't exchange data between code blocks, so editing a header-variable in one code block won't affect that variable in any other code block! #INSERT path.to.file will insert another batchcode (Python) file at that position. A # that is not starting a #HEADER , #CODE or #INSERT instruction is considered a comment. Inside a block, normal Python syntax rules apply. For the sake of indentation, each block acts as a separate python module. Below is a version of the example file found in evennia/contrib/tutorial_examples/ . # # This is an example batch-code build file for Evennia. # #HEADER # This will be included in all other #CODE blocks from evennia import create_object, search_object from evennia.contrib.tutorial_examples import red_button from typeclasses.objects import Object limbo = search_object('Limbo')[0] #CODE red_button = create_object(red_button.RedButton, key=\"Red button\", location=limbo, aliases=[\"button\"]) # caller points to the one running the script caller.msg(\"A red button was created.\") # importing more code from another batch-code file #INSERT batch_code_insert #CODE table = create_object(Object, key=\"Blue Table\", location=limbo) chair = create_object(Object, key=\"Blue Chair\", location=limbo) string = \"A %s and %s were created.\" if DEBUG: table.delete() chair.delete() string += \" Since debug was active, \" \\ \"they were deleted again.\" caller.msg(string % (table, chair)) This uses Evennia's Python API to create three objects in sequence.","title":"The batch file"},{"location":"Batch-Code-Processor.html#debug-mode","text":"Try to run the example script with > @batchcode/debug tutorial_examples.example_batch_code The batch script will run to the end and tell you it completed. You will also get messages that the button and the two pieces of furniture were created. Look around and you should see the button there. But you won't see any chair nor a table! This is because we ran this with the /debug switch, which is directly visible as DEBUG==True inside the script. In the above example we handled this state by deleting the chair and table again. The debug mode is intended to be used when you test out a batchscript. Maybe you are looking for bugs in your code or try to see if things behave as they should. Running the script over and over would then create an ever-growing stack of chairs and tables, all with the same name. You would have to go back and painstakingly delete them later.","title":"Debug mode"},{"location":"Batch-Code-Processor.html#interactive-mode","text":"Interactive mode works very similar to the batch-command processor counterpart . It allows you more step-wise control over how the batch file is executed. This is useful for debugging or for picking and choosing only particular blocks to run. Use @batchcode with the /interactive flag to enter interactive mode. > @batchcode/interactive tutorial_examples.batch_code You should see the following: 01/02: red_button = create_object(red_button.RedButton, [...] (hh for help) This shows that you are on the first #CODE block, the first of only two commands in this batch file. Observe that the block has not actually been executed at this point! To take a look at the full code snippet you are about to run, use ll (a batch-processor version of look ). from evennia.utils import create, search from evennia.contrib.tutorial_examples import red_button from typeclasses.objects import Object limbo = search.objects(caller, 'Limbo', global_search=True)[0] red_button = create.create_object(red_button.RedButton, key=\"Red button\", location=limbo, aliases=[\"button\"]) # caller points to the one running the script caller.msg(\"A red button was created.\") Compare with the example code given earlier. Notice how the content of #HEADER has been pasted at the top of the #CODE block. Use pp to actually execute this block (this will create the button and give you a message). Use nn (next) to go to the next command. Use hh for a list of commands. If there are tracebacks, fix them in the batch file, then use rr to reload the file. You will still be at the same code block and can rerun it easily with pp as needed. This makes for a simple debug cycle. It also allows you to rerun individual troublesome blocks - as mentioned, in a large batch file this can be very useful (don't forget the /debug mode either). Use nn and bb (next and back) to step through the file; e.g. nn 12 will jump 12 steps forward (without processing any blocks in between). All normal commands of Evennia should work too while working in interactive mode.","title":"Interactive mode"},{"location":"Batch-Code-Processor.html#limitations-and-caveats","text":"The batch-code processor is by far the most flexible way to build a world in Evennia. There are however some caveats you need to keep in mind.","title":"Limitations and Caveats"},{"location":"Batch-Code-Processor.html#safety","text":"Or rather the lack of it. There is a reason only superusers are allowed to run the batch-code processor by default. The code-processor runs without any Evennia security checks and allows full access to Python. If an untrusted party could run the code-processor they could execute arbitrary python code on your machine, which is potentially a very dangerous thing. If you want to allow other users to access the batch-code processor you should make sure to run Evennia as a separate and very limited-access user on your machine (i.e. in a 'jail'). By comparison, the batch-command processor is much safer since the user running it is still 'inside' the game and can't really do anything outside what the game commands allow them to.","title":"Safety"},{"location":"Batch-Code-Processor.html#no-communication-between-code-blocks","text":"Global variables won't work in code batch files, each block is executed as stand-alone environments. #HEADER blocks are literally pasted on top of each #CODE block so updating some header-variable in your block will not make that change available in another block. Whereas a python execution limitation, allowing this would also lead to very hard-to-debug code when using the interactive mode - this would be a classical example of \"spaghetti code\". The main practical issue with this is when building e.g. a room in one code block and later want to connect that room with a room you built in the current block. There are two ways to do this: Perform a database search for the name of the room you created (since you cannot know in advance which dbref it got assigned). The problem is that a name may not be unique (you may have a lot of \"A dark forest\" rooms). There is an easy way to handle this though - use Tags or Aliases . You can assign any number of tags and/or aliases to any object. Make sure that one of those tags or aliases is unique to the room (like \"room56\") and you will henceforth be able to always uniquely search and find it later. Use the caller global property as an inter-block storage. For example, you could have a dictionary of room references in an ndb : ```python #HEADER if caller.ndb.all_rooms is None: caller.ndb.all_rooms = {}","title":"No communication between code blocks"},{"location":"Batch-Code-Processor.html#code","text":"","title":"CODE"},{"location":"Batch-Code-Processor.html#create-and-store-the-castle","text":"castle = create_object(\"rooms.Room\", key=\"Castle\") caller.ndb.all_rooms[\"castle\"] = castle","title":"create and store the castle"},{"location":"Batch-Code-Processor.html#code_1","text":"","title":"CODE"},{"location":"Batch-Code-Processor.html#in-another-node-we-want-to-access-the-castle","text":"castle = caller.ndb.all_rooms.get(\"castle\") `` Note how we check in #HEADER if caller.ndb.all_rooms doesn't already exist before creating the dict. Remember that #HEADER is copied in front of every #CODE block. Without that if` statement we'd be wiping the dict every block!","title":"in another node we want to access the castle"},{"location":"Batch-Code-Processor.html#dont-treat-a-batchcode-file-like-any-python-file","text":"Despite being a valid Python file, a batchcode file should only be run by the batchcode processor. You should not do things like define Typeclasses or Commands in them, or import them into other code. Importing a module in Python will execute base level of the module, which in the case of your average batchcode file could mean creating a lot of new objects every time.","title":"Don't treat a batchcode file like any Python file"},{"location":"Batch-Code-Processor.html#dont-let-code-rely-on-the-batch-files-real-file-path","text":"When you import things into your batchcode file, don't use relative imports but always import with paths starting from the root of your game directory or evennia library. Code that relies on the batch file's \"actual\" location will fail . Batch code files are read as text and the strings executed. When the code runs it has no knowledge of what file those strings where once a part of.","title":"Don't let code rely on the batch-file's real file path"},{"location":"Batch-Command-Processor.html","text":"For an introduction and motivation to using batch processors, see here . This page describes the Batch- command processor. The Batch- code one is covered here . Basic Usage \u00b6 The batch-command processor is a superuser-only function, invoked by > @batchcommand path.to.batchcmdfile Where path.to.batchcmdfile is the path to a batch-command file with the \" .ev \" file ending. This path is given like a python path relative to a folder you define to hold your batch files, set with BATCH_IMPORT_PATH in your settings. Default folder is (assuming your game is in the mygame folder) mygame/world . So if you want to run the example batch file in mygame/world/batch_cmds.ev , you could use > @batchcommand batch_cmds A batch-command file contains a list of Evennia in-game commands separated by comments. The processor will run the batch file from beginning to end. Note that it will not stop if commands in it fail (there is no universal way for the processor to know what a failure looks like for all different commands). So keep a close watch on the output, or use Interactive mode (see below) to run the file in a more controlled, gradual manner. The batch file \u00b6 The batch file is a simple plain-text file containing Evennia commands. Just like you would write them in-game, except you have more freedom with line breaks. Here are the rules of syntax of an *.ev file. You'll find it's really, really simple: All lines having the # (hash)-symbol as the first one on the line are considered comments . All non-comment lines are treated as a command and/or their arguments. Comment lines have an actual function -- they mark the end of the previous command definition . So never put two commands directly after one another in the file - separate them with a comment, or the second of the two will be considered an argument to the first one. Besides, using plenty of comments is good practice anyway. A line that starts with the word #INSERT is a comment line but also signifies a special instruction. The syntax is #INSERT <path.batchfile> and tries to import a given batch-cmd file into this one. The inserted batch file (file ending .ev ) will run normally from the point of the #INSERT instruction. Extra whitespace in a command definition is ignored . - A completely empty line translates in to a line break in texts. Two empty lines thus means a new paragraph (this is obviously only relevant for commands accepting such formatting, such as the @desc command). The very last command in the file is not required to end with a comment. You cannot nest another @batchcommand statement into your batch file. If you want to link many batch-files together, use the #INSERT batch instruction instead. You also cannot launch the @batchcode command from your batch file, the two batch processors are not compatible. Below is a version of the example file found in evennia/contrib/tutorial_examples/batch_cmds.ev . # # This is an example batch build file for Evennia. # # This creates a red button @create button:tutorial_examples.red_button.RedButton # (This comment ends input for @create) # Next command. Let's create something. @set button/desc = This is a large red button. Now and then it flashes in an evil, yet strangely tantalizing way. A big sign sits next to it. It says: ----------- Press me! ----------- ... It really begs to be pressed! You know you want to! # This inserts the commands from another batch-cmd file named # batch_insert_file.ev. #INSERT examples.batch_insert_file # (This ends the @set command). Note that single line breaks # and extra whitespace in the argument are ignored. Empty lines # translate into line breaks in the output. # Now let's place the button where it belongs (let's say limbo #2 is # the evil lair in our example) @teleport #2 # (This comments ends the @teleport command.) # Now we drop it so others can see it. # The very last command in the file needs not be ended with #. drop button To test this, run @batchcommand on the file: > @batchcommand contrib.tutorial_examples.batch_cmds A button will be created, described and dropped in Limbo. All commands will be executed by the user calling the command. Note that if you interact with the button, you might find that its description changes, loosing your custom-set description above. This is just the way this particular object works. Interactive mode \u00b6 Interactive mode allows you to more step-wise control over how the batch file is executed. This is useful for debugging and also if you have a large batch file and is only updating a small part of it -- running the entire file again would be a waste of time (and in the case of @create -ing objects you would to end up with multiple copies of same-named objects, for example). Use @batchcommand with the /interactive flag to enter interactive mode. > @batchcommand/interactive tutorial_examples.batch_cmds You will see this: 01/04: @create button:tutorial_examples.red_button.RedButton (hh for help) This shows that you are on the @create command, the first out of only four commands in this batch file. Observe that the command @create has not been actually processed at this point! To take a look at the full command you are about to run, use ll (a batch-processor version of look ). Use pp to actually process the current command (this will actually @create the button) -- and make sure it worked as planned. Use nn (next) to go to the next command. Use hh for a list of commands. If there are errors, fix them in the batch file, then use rr to reload the file. You will still be at the same command and can rerun it easily with pp as needed. This makes for a simple debug cycle. It also allows you to rerun individual troublesome commands - as mentioned, in a large batch file this can be very useful. Do note that in many cases, commands depend on the previous ones (e.g. if @create in the example above had failed, the following commands would have had nothing to operate on). Use nn and bb (next and back) to step through the file; e.g. nn 12 will jump 12 steps forward (without processing any command in between). All normal commands of Evennia should work too while working in interactive mode. Limitations and Caveats \u00b6 The batch-command processor is great for automating smaller builds or for testing new commands and objects repeatedly without having to write so much. There are several caveats you have to be aware of when using the batch-command processor for building larger, complex worlds though. The main issue is that when you run a batch-command script you ( you , as in your superuser character) are actually moving around in the game creating and building rooms in sequence, just as if you had been entering those commands manually, one by one. You have to take this into account when creating the file, so that you can 'walk' (or teleport) to the right places in order. This also means there are several pitfalls when designing and adding certain types of objects. Here are some examples: Rooms that change your Command Set : Imagine that you build a 'dark' room, which severely limits the cmdsets of those entering it (maybe you have to find the light switch to proceed). In your batch script you would create this room, then teleport to it - and promptly be shifted into the dark state where none of your normal build commands work ... Auto-teleportation : Rooms that automatically teleport those that enter them to another place (like a trap room, for example). You would be teleported away too. Mobiles : If you add aggressive mobs, they might attack you, drawing you into combat. If they have AI they might even follow you around when building - or they might move away from you before you've had time to finish describing and equipping them! The solution to all these is to plan ahead. Make sure that superusers are never affected by whatever effects are in play. Add an on/off switch to objects and make sure it's always set to off upon creation. It's all doable, one just needs to keep it in mind. Assorted notes \u00b6 The fact that you build as 'yourself' can also be considered an advantage however, should you ever decide to change the default command to allow others than superusers to call the processor. Since normal access-checks are still performed, a malevolent builder with access to the processor should not be able to do all that much damage (this is the main drawback of the Batch Code Processor ) GNU Emacs users might find it interesting to use emacs' evennia mode . This is an Emacs major mode found in evennia/utils/evennia-mode.el . It offers correct syntax highlighting and indentation with <tab> when editing .ev files in Emacs. See the header of that file for installation instructions. VIM users can use amfl's vim-evennia mode instead, see its readme for install instructions.","title":"Batch Command Processor"},{"location":"Batch-Command-Processor.html#basic-usage","text":"The batch-command processor is a superuser-only function, invoked by > @batchcommand path.to.batchcmdfile Where path.to.batchcmdfile is the path to a batch-command file with the \" .ev \" file ending. This path is given like a python path relative to a folder you define to hold your batch files, set with BATCH_IMPORT_PATH in your settings. Default folder is (assuming your game is in the mygame folder) mygame/world . So if you want to run the example batch file in mygame/world/batch_cmds.ev , you could use > @batchcommand batch_cmds A batch-command file contains a list of Evennia in-game commands separated by comments. The processor will run the batch file from beginning to end. Note that it will not stop if commands in it fail (there is no universal way for the processor to know what a failure looks like for all different commands). So keep a close watch on the output, or use Interactive mode (see below) to run the file in a more controlled, gradual manner.","title":"Basic Usage"},{"location":"Batch-Command-Processor.html#the-batch-file","text":"The batch file is a simple plain-text file containing Evennia commands. Just like you would write them in-game, except you have more freedom with line breaks. Here are the rules of syntax of an *.ev file. You'll find it's really, really simple: All lines having the # (hash)-symbol as the first one on the line are considered comments . All non-comment lines are treated as a command and/or their arguments. Comment lines have an actual function -- they mark the end of the previous command definition . So never put two commands directly after one another in the file - separate them with a comment, or the second of the two will be considered an argument to the first one. Besides, using plenty of comments is good practice anyway. A line that starts with the word #INSERT is a comment line but also signifies a special instruction. The syntax is #INSERT <path.batchfile> and tries to import a given batch-cmd file into this one. The inserted batch file (file ending .ev ) will run normally from the point of the #INSERT instruction. Extra whitespace in a command definition is ignored . - A completely empty line translates in to a line break in texts. Two empty lines thus means a new paragraph (this is obviously only relevant for commands accepting such formatting, such as the @desc command). The very last command in the file is not required to end with a comment. You cannot nest another @batchcommand statement into your batch file. If you want to link many batch-files together, use the #INSERT batch instruction instead. You also cannot launch the @batchcode command from your batch file, the two batch processors are not compatible. Below is a version of the example file found in evennia/contrib/tutorial_examples/batch_cmds.ev . # # This is an example batch build file for Evennia. # # This creates a red button @create button:tutorial_examples.red_button.RedButton # (This comment ends input for @create) # Next command. Let's create something. @set button/desc = This is a large red button. Now and then it flashes in an evil, yet strangely tantalizing way. A big sign sits next to it. It says: ----------- Press me! ----------- ... It really begs to be pressed! You know you want to! # This inserts the commands from another batch-cmd file named # batch_insert_file.ev. #INSERT examples.batch_insert_file # (This ends the @set command). Note that single line breaks # and extra whitespace in the argument are ignored. Empty lines # translate into line breaks in the output. # Now let's place the button where it belongs (let's say limbo #2 is # the evil lair in our example) @teleport #2 # (This comments ends the @teleport command.) # Now we drop it so others can see it. # The very last command in the file needs not be ended with #. drop button To test this, run @batchcommand on the file: > @batchcommand contrib.tutorial_examples.batch_cmds A button will be created, described and dropped in Limbo. All commands will be executed by the user calling the command. Note that if you interact with the button, you might find that its description changes, loosing your custom-set description above. This is just the way this particular object works.","title":"The batch file"},{"location":"Batch-Command-Processor.html#interactive-mode","text":"Interactive mode allows you to more step-wise control over how the batch file is executed. This is useful for debugging and also if you have a large batch file and is only updating a small part of it -- running the entire file again would be a waste of time (and in the case of @create -ing objects you would to end up with multiple copies of same-named objects, for example). Use @batchcommand with the /interactive flag to enter interactive mode. > @batchcommand/interactive tutorial_examples.batch_cmds You will see this: 01/04: @create button:tutorial_examples.red_button.RedButton (hh for help) This shows that you are on the @create command, the first out of only four commands in this batch file. Observe that the command @create has not been actually processed at this point! To take a look at the full command you are about to run, use ll (a batch-processor version of look ). Use pp to actually process the current command (this will actually @create the button) -- and make sure it worked as planned. Use nn (next) to go to the next command. Use hh for a list of commands. If there are errors, fix them in the batch file, then use rr to reload the file. You will still be at the same command and can rerun it easily with pp as needed. This makes for a simple debug cycle. It also allows you to rerun individual troublesome commands - as mentioned, in a large batch file this can be very useful. Do note that in many cases, commands depend on the previous ones (e.g. if @create in the example above had failed, the following commands would have had nothing to operate on). Use nn and bb (next and back) to step through the file; e.g. nn 12 will jump 12 steps forward (without processing any command in between). All normal commands of Evennia should work too while working in interactive mode.","title":"Interactive mode"},{"location":"Batch-Command-Processor.html#limitations-and-caveats","text":"The batch-command processor is great for automating smaller builds or for testing new commands and objects repeatedly without having to write so much. There are several caveats you have to be aware of when using the batch-command processor for building larger, complex worlds though. The main issue is that when you run a batch-command script you ( you , as in your superuser character) are actually moving around in the game creating and building rooms in sequence, just as if you had been entering those commands manually, one by one. You have to take this into account when creating the file, so that you can 'walk' (or teleport) to the right places in order. This also means there are several pitfalls when designing and adding certain types of objects. Here are some examples: Rooms that change your Command Set : Imagine that you build a 'dark' room, which severely limits the cmdsets of those entering it (maybe you have to find the light switch to proceed). In your batch script you would create this room, then teleport to it - and promptly be shifted into the dark state where none of your normal build commands work ... Auto-teleportation : Rooms that automatically teleport those that enter them to another place (like a trap room, for example). You would be teleported away too. Mobiles : If you add aggressive mobs, they might attack you, drawing you into combat. If they have AI they might even follow you around when building - or they might move away from you before you've had time to finish describing and equipping them! The solution to all these is to plan ahead. Make sure that superusers are never affected by whatever effects are in play. Add an on/off switch to objects and make sure it's always set to off upon creation. It's all doable, one just needs to keep it in mind.","title":"Limitations and Caveats"},{"location":"Batch-Command-Processor.html#assorted-notes","text":"The fact that you build as 'yourself' can also be considered an advantage however, should you ever decide to change the default command to allow others than superusers to call the processor. Since normal access-checks are still performed, a malevolent builder with access to the processor should not be able to do all that much damage (this is the main drawback of the Batch Code Processor ) GNU Emacs users might find it interesting to use emacs' evennia mode . This is an Emacs major mode found in evennia/utils/evennia-mode.el . It offers correct syntax highlighting and indentation with <tab> when editing .ev files in Emacs. See the header of that file for installation instructions. VIM users can use amfl's vim-evennia mode instead, see its readme for install instructions.","title":"Assorted notes"},{"location":"Batch-Processors.html","text":"Building a game world is a lot of work, especially when starting out. Rooms should be created, descriptions have to be written, objects must be detailed and placed in their proper places. In many traditional MUD setups you had to do all this online, line by line, over a telnet session. Evennia already moves away from much of this by shifting the main coding work to external Python modules. But also building would be helped if one could do some or all of it externally. Enter Evennia's batch processors (there are two of them). The processors allows you, as a game admin, to build your game completely offline in normal text files ( batch files ) that the processors understands. Then, when you are ready, you use the processors to read it all into Evennia (and into the database) in one go. You can of course still build completely online should you want to - this is certainly the easiest way to go when learning and for small build projects. But for major building work, the advantages of using the batch-processors are many: - It's hard to compete with the comfort of a modern desktop text editor; Compared to a traditional MUD line input, you can get much better overview and many more features. Also, accidentally pressing Return won't immediately commit things to the database. - You might run external spell checkers on your batch files. In the case of one of the batch-processors (the one that deals with Python code), you could also run external debuggers and code analyzers on your file to catch problems before feeding it to Evennia. - The batch files (as long as you keep them) are records of your work. They make a natural starting point for quickly re-building your world should you ever decide to start over. - If you are an Evennia developer, using a batch file is a fast way to setup a test-game after having reset the database. - The batch files might come in useful should you ever decide to distribute all or part of your world to others. There are two batch processors, the Batch- command processor and the Batch- code processor. The first one is the simpler of the two. It doesn't require any programming knowledge - you basically just list in-game commands in a text file. The code-processor on the other hand is much more powerful but also more complex - it lets you use Evennia's API to code your world in full-fledged Python code. The Batch Command Processor The Batch Code Processor If you plan to use international characters in your batchfiles you are wise to read about file encodings below. A note on File Encodings \u00b6 As mentioned, both the processors take text files as input and then proceed to process them. As long as you stick to the standard ASCII character set (which means the normal English characters, basically) you should not have to worry much about this section. Many languages however use characters outside the simple ASCII table. Common examples are various apostrophes and umlauts but also completely different symbols like those of the greek or cyrillic alphabets. First, we should make it clear that Evennia itself handles international characters just fine. It (and Django) uses unicode strings internally. The problem is that when reading a text file like the batchfile, we need to know how to decode the byte-data stored therein to universal unicode. That means we need an encoding (a mapping) for how the file stores its data. There are many, many byte-encodings used around the world, with opaque names such as Latin-1 , ISO-8859-3 or ARMSCII-8 to pick just a few examples. Problem is that it's practially impossible to determine which encoding was used to save a file just by looking at it (it's just a bunch of bytes!). You have to know . With this little introduction it should be clear that Evennia can't guess but has to assume an encoding when trying to load a batchfile. The text editor and Evennia must speak the same \"language\" so to speak. Evennia will by default first try the international UTF-8 encoding, but you can have Evennia try any sequence of different encodings by customizing the ENCODINGS list in your settings file. Evennia will use the first encoding in the list that do not raise any errors. Only if none work will the server give up and return an error message. You can often change the text editor encoding (this depends on your editor though), otherwise you need to add the editor's encoding to Evennia's ENCODINGS list. If you are unsure, write a test file with lots of non-ASCII letters in the editor of your choice, then import to make sure it works as it should. More help with encodings can be found in the entry Text Encodings and also in the Wikipedia article here . A footnote for the batch-code processor : Just because Evennia can parse your file and your fancy special characters, doesn't mean that Python allows their use. Python syntax only allows international characters inside strings . In all other source code only ASCII set characters are allowed.","title":"Batch Processors"},{"location":"Batch-Processors.html#a-note-on-file-encodings","text":"As mentioned, both the processors take text files as input and then proceed to process them. As long as you stick to the standard ASCII character set (which means the normal English characters, basically) you should not have to worry much about this section. Many languages however use characters outside the simple ASCII table. Common examples are various apostrophes and umlauts but also completely different symbols like those of the greek or cyrillic alphabets. First, we should make it clear that Evennia itself handles international characters just fine. It (and Django) uses unicode strings internally. The problem is that when reading a text file like the batchfile, we need to know how to decode the byte-data stored therein to universal unicode. That means we need an encoding (a mapping) for how the file stores its data. There are many, many byte-encodings used around the world, with opaque names such as Latin-1 , ISO-8859-3 or ARMSCII-8 to pick just a few examples. Problem is that it's practially impossible to determine which encoding was used to save a file just by looking at it (it's just a bunch of bytes!). You have to know . With this little introduction it should be clear that Evennia can't guess but has to assume an encoding when trying to load a batchfile. The text editor and Evennia must speak the same \"language\" so to speak. Evennia will by default first try the international UTF-8 encoding, but you can have Evennia try any sequence of different encodings by customizing the ENCODINGS list in your settings file. Evennia will use the first encoding in the list that do not raise any errors. Only if none work will the server give up and return an error message. You can often change the text editor encoding (this depends on your editor though), otherwise you need to add the editor's encoding to Evennia's ENCODINGS list. If you are unsure, write a test file with lots of non-ASCII letters in the editor of your choice, then import to make sure it works as it should. More help with encodings can be found in the entry Text Encodings and also in the Wikipedia article here . A footnote for the batch-code processor : Just because Evennia can parse your file and your fancy special characters, doesn't mean that Python allows their use. Python syntax only allows international characters inside strings . In all other source code only ASCII set characters are allowed.","title":"A note on File Encodings"},{"location":"Bootstrap-&-Evennia.html","text":"What is Bootstrap? \u00b6 Evennia's new default web page uses a framework called Bootstrap . This framework is in use across the internet - you'll probably start to recognize its influence once you learn some of the common design patterns. This switch is great for web developers, perhaps like yourself, because instead of wondering about setting up different grid systems or what custom class another designer used, we have a base, a bootstrap, to work from. Bootstrap is responsive by default, and comes with some default styles that Evennia has lightly overrode to keep some of the same colors and styles you're used to from the previous design. For your reading pleasure, a brief overview of Bootstrap follows. For more in-depth info, please read the documentation . The Layout System \u00b6 Other than the basic styling Bootstrap includes, it also includes a built in layout and grid system . The first part of this system is the container . The container is meant to hold all your page content. Bootstrap provides two types: fixed-width and full-width. Fixed-width containers take up a certain max-width of the page - they're useful for limiting the width on Desktop or Tablet platforms, instead of making the content span the width of the page. <div class=\"container\"> <!--- Your content here --> </div> Full width containers take up the maximum width available to them - they'll span across a wide-screen desktop or a smaller screen phone, edge-to-edge. <div class=\"container-fluid\"> <!--- This content will span the whole page --> </div> The second part of the layout system is the grid . This is the bread-and-butter of the layout of Bootstrap - it allows you to change the size of elements depending on the size of the screen, without writing any media queries. We'll briefly go over it - to learn more, please read the docs or look at the source code for Evennia's home page in your browser. Important! Grid elements should be in a .container or .container-fluid. This will center the contents of your site. Bootstrap's grid system allows you to create rows and columns by applying classes based on breakpoints. The default breakpoints are extra small, small, medium, large, and extra-large. If you'd like to know more about these breakpoints, please take a look at the documentation for them. To use the grid system, first create a container for your content, then add your rows and columns like so: <div class=\"container\"> <div class=\"row\"> <div class=\"col\"> 1 of 3 </div> <div class=\"col\"> 2 of 3 </div> <div class=\"col\"> 3 of 3 </div> </div> </div> This layout would create three equal-width columns. To specify your sizes - for instance, Evennia's default site has three columns on desktop and tablet, but reflows to single-column on smaller screens. Try it out! <div class=\"container\"> <div class=\"row\"> <div class=\"col col-md-6 col-lg-3\"> 1 of 4 </div> <div class=\"col col-md-6 col-lg-3\"> 2 of 4 </div> <div class=\"col col-md-6 col-lg-3\"> 3 of 4 </div> <div class=\"col col-md-6 col-lg-3\"> 4 of 4 </div> </div> </div> This layout would be 4 columns on large screens, 2 columns on medium screens, and 1 column on anything smaller. To learn more about Bootstrap's grid, please take a look at the docs More Bootstrap \u00b6 Bootstrap also provides a huge amount of utilities, as well as styling and content elements. To learn more about them, please read the Bootstrap docs or read one of our other web tutorials.","title":"What is Bootstrap?"},{"location":"Bootstrap-&-Evennia.html#what-is-bootstrap","text":"Evennia's new default web page uses a framework called Bootstrap . This framework is in use across the internet - you'll probably start to recognize its influence once you learn some of the common design patterns. This switch is great for web developers, perhaps like yourself, because instead of wondering about setting up different grid systems or what custom class another designer used, we have a base, a bootstrap, to work from. Bootstrap is responsive by default, and comes with some default styles that Evennia has lightly overrode to keep some of the same colors and styles you're used to from the previous design. For your reading pleasure, a brief overview of Bootstrap follows. For more in-depth info, please read the documentation .","title":"What is Bootstrap?"},{"location":"Bootstrap-&-Evennia.html#the-layout-system","text":"Other than the basic styling Bootstrap includes, it also includes a built in layout and grid system . The first part of this system is the container . The container is meant to hold all your page content. Bootstrap provides two types: fixed-width and full-width. Fixed-width containers take up a certain max-width of the page - they're useful for limiting the width on Desktop or Tablet platforms, instead of making the content span the width of the page. <div class=\"container\"> <!--- Your content here --> </div> Full width containers take up the maximum width available to them - they'll span across a wide-screen desktop or a smaller screen phone, edge-to-edge. <div class=\"container-fluid\"> <!--- This content will span the whole page --> </div> The second part of the layout system is the grid . This is the bread-and-butter of the layout of Bootstrap - it allows you to change the size of elements depending on the size of the screen, without writing any media queries. We'll briefly go over it - to learn more, please read the docs or look at the source code for Evennia's home page in your browser. Important! Grid elements should be in a .container or .container-fluid. This will center the contents of your site. Bootstrap's grid system allows you to create rows and columns by applying classes based on breakpoints. The default breakpoints are extra small, small, medium, large, and extra-large. If you'd like to know more about these breakpoints, please take a look at the documentation for them. To use the grid system, first create a container for your content, then add your rows and columns like so: <div class=\"container\"> <div class=\"row\"> <div class=\"col\"> 1 of 3 </div> <div class=\"col\"> 2 of 3 </div> <div class=\"col\"> 3 of 3 </div> </div> </div> This layout would create three equal-width columns. To specify your sizes - for instance, Evennia's default site has three columns on desktop and tablet, but reflows to single-column on smaller screens. Try it out! <div class=\"container\"> <div class=\"row\"> <div class=\"col col-md-6 col-lg-3\"> 1 of 4 </div> <div class=\"col col-md-6 col-lg-3\"> 2 of 4 </div> <div class=\"col col-md-6 col-lg-3\"> 3 of 4 </div> <div class=\"col col-md-6 col-lg-3\"> 4 of 4 </div> </div> </div> This layout would be 4 columns on large screens, 2 columns on medium screens, and 1 column on anything smaller. To learn more about Bootstrap's grid, please take a look at the docs","title":"The Layout System"},{"location":"Bootstrap-&-Evennia.html#more-bootstrap","text":"Bootstrap also provides a huge amount of utilities, as well as styling and content elements. To learn more about them, please read the Bootstrap docs or read one of our other web tutorials.","title":"More Bootstrap"},{"location":"Bootstrap-Components-and-Utilities.html","text":"Bootstrap provides many utilities and components you can use when customizing Evennia's web presence. We'll go over a few examples here that you might find useful. Please take a look at either the basic web tutorial or the web character view tutorial to get a feel for how to add pages to Evennia's website to test these examples. General Styling \u00b6 Bootstrap provides base styles for your site. These can be customized through CSS, but the default styles are intended to provide a consistent, clean look for sites. Color \u00b6 Most elements can be styled with default colors. Take a look at the documentation to learn more about these colors - suffice to say, adding a class of text- or bg- , for instance, text-primary, sets the text color or background color. Borders \u00b6 Simply adding a class of 'border' to an element adds a border to the element. For more in-depth info, please read the documentation on borders. . <span class=\"border border-dark\"></span> You can also easily round corners just by adding a class. <img src=\"...\" class=\"rounded\" /> Spacing \u00b6 Bootstrap provides classes to easily add responsive margin and padding. Most of the time, you might like to add margins or padding through CSS itself - however these classes are used in the default Evennia site. Take a look at the docs to learn more. Components \u00b6 Buttons \u00b6 Buttons in Bootstrap are very easy to use - button styling can be added to <button> , <a> , and <input> elements. <a class=\"btn btn-primary\" href=\"#\" role=\"button\">I'm a Button</a> <button class=\"btn btn-primary\" type=\"submit\">Me too!</button> <input class=\"btn btn-primary\" type=\"button\" value=\"Button\"> <input class=\"btn btn-primary\" type=\"submit\" value=\"Also a Button\"> <input class=\"btn btn-primary\" type=\"reset\" value=\"Button as Well\"> Cards \u00b6 Cards provide a container for other elements that stands out from the rest of the page. The \"Accounts\", \"Recently Connected\", and \"Database Stats\" on the default webpage are all in cards. Cards provide quite a bit of formatting options - the following is a simple example, but read the documentation or look at the site's source for more. <div class=\"card\"> <div class=\"card-body\"> <h4 class=\"card-title\">Card title</h4> <h6 class=\"card-subtitle mb-2 text-muted\">Card subtitle</h6> <p class=\"card-text\">Fancy, isn't it?</p> <a href=\"#\" class=\"card-link\">Card link</a> </div> </div> Jumbotron \u00b6 Jumbotrons are useful for featuring an image or tagline for your game. They can flow with the rest of your content or take up the full width of the page - Evennia's base site uses the former. <div class=\"jumbotron jumbotron-fluid\"> <div class=\"container\"> <h1 class=\"display-3\">Full Width Jumbotron</h1> <p class=\"lead\">Look at the source of the default Evennia page for a regular Jumbotron</p> </div> </div> Forms \u00b6 Forms are highly customizable with Bootstrap. For a more in-depth look at how to use forms and their styles in your own Evennia site, please read over the web character gen tutorial.","title":"Bootstrap Components and Utilities"},{"location":"Bootstrap-Components-and-Utilities.html#general-styling","text":"Bootstrap provides base styles for your site. These can be customized through CSS, but the default styles are intended to provide a consistent, clean look for sites.","title":"General Styling"},{"location":"Bootstrap-Components-and-Utilities.html#color","text":"Most elements can be styled with default colors. Take a look at the documentation to learn more about these colors - suffice to say, adding a class of text- or bg- , for instance, text-primary, sets the text color or background color.","title":"Color"},{"location":"Bootstrap-Components-and-Utilities.html#borders","text":"Simply adding a class of 'border' to an element adds a border to the element. For more in-depth info, please read the documentation on borders. . <span class=\"border border-dark\"></span> You can also easily round corners just by adding a class. <img src=\"...\" class=\"rounded\" />","title":"Borders"},{"location":"Bootstrap-Components-and-Utilities.html#spacing","text":"Bootstrap provides classes to easily add responsive margin and padding. Most of the time, you might like to add margins or padding through CSS itself - however these classes are used in the default Evennia site. Take a look at the docs to learn more.","title":"Spacing"},{"location":"Bootstrap-Components-and-Utilities.html#components","text":"","title":"Components"},{"location":"Bootstrap-Components-and-Utilities.html#buttons","text":"Buttons in Bootstrap are very easy to use - button styling can be added to <button> , <a> , and <input> elements. <a class=\"btn btn-primary\" href=\"#\" role=\"button\">I'm a Button</a> <button class=\"btn btn-primary\" type=\"submit\">Me too!</button> <input class=\"btn btn-primary\" type=\"button\" value=\"Button\"> <input class=\"btn btn-primary\" type=\"submit\" value=\"Also a Button\"> <input class=\"btn btn-primary\" type=\"reset\" value=\"Button as Well\">","title":"Buttons"},{"location":"Bootstrap-Components-and-Utilities.html#cards","text":"Cards provide a container for other elements that stands out from the rest of the page. The \"Accounts\", \"Recently Connected\", and \"Database Stats\" on the default webpage are all in cards. Cards provide quite a bit of formatting options - the following is a simple example, but read the documentation or look at the site's source for more. <div class=\"card\"> <div class=\"card-body\"> <h4 class=\"card-title\">Card title</h4> <h6 class=\"card-subtitle mb-2 text-muted\">Card subtitle</h6> <p class=\"card-text\">Fancy, isn't it?</p> <a href=\"#\" class=\"card-link\">Card link</a> </div> </div>","title":"Cards"},{"location":"Bootstrap-Components-and-Utilities.html#jumbotron","text":"Jumbotrons are useful for featuring an image or tagline for your game. They can flow with the rest of your content or take up the full width of the page - Evennia's base site uses the former. <div class=\"jumbotron jumbotron-fluid\"> <div class=\"container\"> <h1 class=\"display-3\">Full Width Jumbotron</h1> <p class=\"lead\">Look at the source of the default Evennia page for a regular Jumbotron</p> </div> </div>","title":"Jumbotron"},{"location":"Bootstrap-Components-and-Utilities.html#forms","text":"Forms are highly customizable with Bootstrap. For a more in-depth look at how to use forms and their styles in your own Evennia site, please read over the web character gen tutorial.","title":"Forms"},{"location":"Builder-Docs.html","text":"This section contains information useful to world builders. Building basics \u00b6 Default in-game commands Building Quick-start Giving build permissions to others Adding text tags Colored text Clickable links Inline functions Customizing the connection screen Advanced building and World building \u00b6 Overview of batch processors Batch-command processor Batch-code processor Using the Spawner for individualizing objects Adding Zones The Tutorial world \u00b6 Introduction and setup","title":"Building"},{"location":"Builder-Docs.html#building-basics","text":"Default in-game commands Building Quick-start Giving build permissions to others Adding text tags Colored text Clickable links Inline functions Customizing the connection screen","title":"Building basics"},{"location":"Builder-Docs.html#advanced-building-and-world-building","text":"Overview of batch processors Batch-command processor Batch-code processor Using the Spawner for individualizing objects Adding Zones","title":"Advanced building and World building"},{"location":"Builder-Docs.html#the-tutorial-world","text":"Introduction and setup","title":"The Tutorial world"},{"location":"Building-Permissions.html","text":"OBS: This gives only a brief introduction to the access system. Locks and permissions are fully detailed here . The super user \u00b6 There are strictly speaking two types of users in Evennia, the super user and everyone else. The superuser is the first user you create, object #1 . This is the all-powerful server-owner account. Technically the superuser not only has access to everything, it bypasses the permission checks entirely. This makes the superuser impossible to lock out, but makes it unsuitable to actually play-test the game's locks and restrictions with (see @quell below). Usually there is no need to have but one superuser. Assigning permissions \u00b6 Whereas permissions can be used for anything, those put in settings.PERMISSION_HIERARCHY will have a ranking relative each other as well. We refer to these types of permissions as hierarchical permissions . When building locks to check these permissions, the perm() lock function is used. By default Evennia creates the following hierarchy (spelled exactly like this): Developers basically have the same access as superusers except that they do not sidestep the Permission system. Assign only to really trusted server-admin staff since this level gives access both to server reload/shutdown functionality as well as (and this may be more critical) gives access to the all-powerful @py command that allows the execution of arbitrary Python code on the command line. Admins can do everything except affecting the server functions themselves. So an Admin couldn't reload or shutdown the server for example. They also cannot execute arbitrary Python code on the console or import files from the hard drive. Builders - have all the build commands, but cannot affect other accounts or mess with the server. Helpers are almost like a normal Player , but they can also add help files to the database. Players is the default group that new players end up in. A new player have permission to use tells and to use and create new channels. A user having a certain level of permission automatically have access to locks specifying access of a lower level. To assign a new permission from inside the game, you need to be able to use the @perm command. This is an Developer -level command, but it could in principle be made lower-access since it only allows assignments equal or lower to your current level (so you cannot use it to escalate your own permission level). So, assuming you yourself have Developer access (or is superuser), you assign a new account \"Tommy\" to your core staff with the command @perm/account Tommy = Developer or @perm *Tommy = Developer We use a switch or the *name format to make sure to put the permission on the Account and not on any eventual Character that may also be named \"Tommy\". This is usually what you want since the Account will then remain an Developer regardless of which Character they are currently controlling. To limit permission to a per-Character level you should instead use quelling (see below). Normally permissions can be any string, but for these special hierarchical permissions you can also use plural (\"Developer\" and \"Developers\" both grant the same powers). Quelling your permissions \u00b6 When developing it can be useful to check just how things would look had your permission-level been lower. For this you can use quelling . Normally, when you puppet a Character you are using your Account-level permission. So even if your Character only has Accounts level permissions, your Developer -level Account will take precedence. With the @quell command you can change so that the Character's permission takes precedence instead: @quell This will allow you to test out the game using the current Character's permission level. A developer or builder can thus in principle maintain several test characters, all using different permission levels. Note that you cannot escalate your permissions this way; If the Character happens to have a higher permission level than the Account, the Account's (lower) permission will still be used.","title":"Building Permissions"},{"location":"Building-Permissions.html#the-super-user","text":"There are strictly speaking two types of users in Evennia, the super user and everyone else. The superuser is the first user you create, object #1 . This is the all-powerful server-owner account. Technically the superuser not only has access to everything, it bypasses the permission checks entirely. This makes the superuser impossible to lock out, but makes it unsuitable to actually play-test the game's locks and restrictions with (see @quell below). Usually there is no need to have but one superuser.","title":"The super user"},{"location":"Building-Permissions.html#assigning-permissions","text":"Whereas permissions can be used for anything, those put in settings.PERMISSION_HIERARCHY will have a ranking relative each other as well. We refer to these types of permissions as hierarchical permissions . When building locks to check these permissions, the perm() lock function is used. By default Evennia creates the following hierarchy (spelled exactly like this): Developers basically have the same access as superusers except that they do not sidestep the Permission system. Assign only to really trusted server-admin staff since this level gives access both to server reload/shutdown functionality as well as (and this may be more critical) gives access to the all-powerful @py command that allows the execution of arbitrary Python code on the command line. Admins can do everything except affecting the server functions themselves. So an Admin couldn't reload or shutdown the server for example. They also cannot execute arbitrary Python code on the console or import files from the hard drive. Builders - have all the build commands, but cannot affect other accounts or mess with the server. Helpers are almost like a normal Player , but they can also add help files to the database. Players is the default group that new players end up in. A new player have permission to use tells and to use and create new channels. A user having a certain level of permission automatically have access to locks specifying access of a lower level. To assign a new permission from inside the game, you need to be able to use the @perm command. This is an Developer -level command, but it could in principle be made lower-access since it only allows assignments equal or lower to your current level (so you cannot use it to escalate your own permission level). So, assuming you yourself have Developer access (or is superuser), you assign a new account \"Tommy\" to your core staff with the command @perm/account Tommy = Developer or @perm *Tommy = Developer We use a switch or the *name format to make sure to put the permission on the Account and not on any eventual Character that may also be named \"Tommy\". This is usually what you want since the Account will then remain an Developer regardless of which Character they are currently controlling. To limit permission to a per-Character level you should instead use quelling (see below). Normally permissions can be any string, but for these special hierarchical permissions you can also use plural (\"Developer\" and \"Developers\" both grant the same powers).","title":"Assigning permissions"},{"location":"Building-Permissions.html#quelling-your-permissions","text":"When developing it can be useful to check just how things would look had your permission-level been lower. For this you can use quelling . Normally, when you puppet a Character you are using your Account-level permission. So even if your Character only has Accounts level permissions, your Developer -level Account will take precedence. With the @quell command you can change so that the Character's permission takes precedence instead: @quell This will allow you to test out the game using the current Character's permission level. A developer or builder can thus in principle maintain several test characters, all using different permission levels. Note that you cannot escalate your permissions this way; If the Character happens to have a higher permission level than the Account, the Account's (lower) permission will still be used.","title":"Quelling your permissions"},{"location":"Building-Quickstart.html","text":"The default command definitions coming with Evennia follows a style similar to that of MUX, so the commands should be familiar if you used any such code bases before. Throughout the larger documentation you may come across commands prefixed with @ . This is just an optional marker used in some places to make a command stand out. Evennia defaults to ignoring the use of @ in front of your command (so entering dig is the same as entering @dig ). The default commands have the following style (where [...] marks optional parts): command[/switch/switch...] [arguments ...] A switch is a special, optional flag to the command to make it behave differently. It is always put directly after the command name, and begins with a forward slash ( / ). The arguments are one or more inputs to the commands. It's common to use an equal sign ( = ) when assigning something to an object. Below are some examples of commands you can try when logged in to the game. Use help <command> for learning more about each command and their detailed options. Stepping Down From Godhood \u00b6 If you just installed Evennia, your very first player account is called user #1, also known as the superuser or god user . This user is very powerful, so powerful that it will override many game restrictions such as locks. This can be useful, but it also hides some functionality that you might want to test. To temporarily step down from your superuser position you can use the quell command in-game: quell This will make you start using the permission of your current character's level instead of your superuser level. If you didn't change any settings your game Character should have an Developer level permission - high as can be without bypassing locks like the superuser does. This will work fine for the examples on this page. Use unquell to get back to superuser status again afterwards. Creating an Object \u00b6 Basic objects can be anything -- swords, flowers and non-player characters. They are created using the create command: create box This created a new 'box' (of the default object type) in your inventory. Use the command inventory (or i ) to see it. Now, 'box' is a rather short name, let's rename it and tack on a few aliases. name box = very large box;box;very;crate We now renamed the box to very large box (and this is what we will see when looking at it), but we will also recognize it by any of the other names we give - like crate or simply box as before. We could have given these aliases directly after the name in the create command, this is true for all creation commands - you can always tag on a list of ; -separated aliases to the name of your new object. If you had wanted to not change the name itself, but to only add aliases, you could have used the alias command. We are currently carrying the box. Let's drop it (there is also a short cut to create and drop in one go by using the /drop switch, for example create/drop box ). drop box Hey presto - there it is on the ground, in all its normality. examine box This will show some technical details about the box object. For now we will ignore what this information means. Try to look at the box to see the (default) description. look box You see nothing special. The description you get is not very exciting. Let's add some flavor. describe box = This is a large and very heavy box. If you try the get command we will pick up the box. So far so good, but if we really want this to be a large and heavy box, people should not be able to run off with it that easily. To prevent this we need to lock it down. This is done by assigning a Lock to it. Make sure the box was dropped in the room, then try this: lock box = get:false() Locks represent a rather big topic , but for now that will do what we want. This will lock the box so noone can lift it. The exception is superusers, they override all locks and will pick it up anyway. Make sure you are quelling your superuser powers and try to get the box now: > get box You can't get that. Think th\u00eds default error message looks dull? The get command looks for an Attribute named get_err_msg for returning a nicer error message (we just happen to know this, you would need to peek into the code for the get command to find out.). You set attributes using the set command: set box/get_err_msg = It's way too heavy for you to lift. Try to get it now and you should see a nicer error message echoed back to you. You create new Commands (or modify existing ones) in Python outside the game. See the Adding Commands tutorial for help with creating your first own Command. Get a Personality \u00b6 Scripts are powerful out-of-character objects useful for many \"under the hood\" things. One of their optional abilities is to do things on a timer. To try out a first script, let's put one on ourselves. There is an example script in evennia/contrib/tutorial_examples/bodyfunctions.py that is called BodyFunctions . To add this to us we will use the script command: script self = tutorial_examples.bodyfunctions.BodyFunctions (note that you don't have to give the full path as long as you are pointing to a place inside the contrib directory, it's one of the places Evennia looks for Scripts). Wait a while and you will notice yourself starting making random observations. script self This will show details about scripts on yourself (also examine works). You will see how long it is until it \"fires\" next. Don't be alarmed if nothing happens when the countdown reaches zero - this particular script has a randomizer to determine if it will say something or not. So you will not see output every time it fires. When you are tired of your character's \"insights\", kill the script with script/stop self = tutorial_examples.bodyfunctions.BodyFunctions You create your own scripts in Python, outside the game; the path you give to script is literally the Python path to your script file. The Scripts page explains more details. Pushing Your Buttons \u00b6 If we get back to the box we made, there is only so much fun you can do with it at this point. It's just a dumb generic object. If you renamed it to stone and changed its description noone would be the wiser. However, with the combined use of custom Typeclasses , Scripts and object-based Commands , you could expand it and other items to be as unique, complex and interactive as you want. Let's take an example. So far we have only created objects that use the default object typeclass named simply Object . Let's create an object that is a little more interesting. Under evennia/contrib/tutorial_examples there is a module red_button.py . It contains the enigmatic RedButton typeclass. Let's make us one of those ! create/drop button:tutorial_examples.red_button.RedButton We import the RedButton python class the same way you would import it in Python except Evennia makes sure to look in evennia/contrib/ so you don't have to write the full path every time. There you go - one red button. The RedButton is an example object intended to show off a few of Evennia's features. You will find that the Typeclass and Commands controlling it are inside evennia/contrib/tutorial_examples/ . If you wait for a while (make sure you dropped it!) the button will blink invitingly. Why don't you try to push it ...? Surely a big red button is meant to be pushed. You know you want to. Making Yourself a House \u00b6 The main command for shaping the game world is dig . For example, if you are standing in Limbo you can dig a route to your new house location like this: dig house = large red door;door;in,to the outside;out This will create a new room named 'house'. Spaces at the start/end of names and aliases are ignored so you could put more air if you wanted. This call will directly create an exit from your current location named 'large red door' and a corresponding exit named 'to the outside' in the house room leading back to Limbo. We also define a few aliases to those exits, so people don't have to write the full thing all the time. If you wanted to use normal compass directions (north, west, southwest etc), you could do that with dig too. But Evennia also has a limited version of dig that helps for compass directions (and also up/down and in/out). It's called tunnel : tunnel sw = cliff This will create a new room \"cliff\" with an exit \"southwest\" leading there and a path \"northeast\" leading back from the cliff to your current location. You can create new exits from where you are using the open command: open north;n = house This opens an exit north (with an alias n ) to the previously created room house . If you have many rooms named house you will get a list of matches and have to select which one you want to link to. You can also give its database (#dbref) number, which is unique to every object. This can be found with the examine command or by looking at the latest constructions with objects . Follow the north exit to your 'house' or teleport to it: north or: teleport house To manually open an exit back to Limbo (if you didn't do so with the dig command): open door = limbo (or give limbo's dbref which is #2) Reshuffling the World \u00b6 You can find things using the find command. Assuming you are back at Limbo , let's teleport the large box to our house . > teleport box = house very large box is leaving Limbo, heading for house. Teleported very large box -> house. We can still find the box by using find: > find box One Match(#1-#8): very large box(#8) - src.objects.objects.Object Knowing the #dbref of the box (#8 in this example), you can grab the box and get it back here without actually yourself going to house first: teleport #8 = here (You can usually use here to refer to your current location. To refer to yourself you can use self or me ). The box should now be back in Limbo with you. We are getting tired of the box. Let's destroy it. destroy box You can destroy many objects in one go by giving a comma-separated list of objects (or their #dbrefs, if they are not in the same location) to the command. Adding a Help Entry \u00b6 An important part of building is keeping the help files updated. You can add, delete and append to existing help entries using the sethelp command. sethelp/add MyTopic = This help topic is about ... Adding a World \u00b6 After this brief introduction to building you may be ready to see a more fleshed-out example. Evennia comes with a tutorial world for you to explore. First you need to switch back to superuser by using the unquell command. Next, place yourself in Limbo and run the following command: batchcommand tutorial_world.build This will take a while (be patient and don't re-run the command). You will see all the commands used to build the world scroll by as the world is built for you. You will end up with a new exit from Limbo named tutorial . Apart from being a little solo-adventure in its own right, the tutorial world is a good source for learning Evennia building (and coding). Read the batch file to see exactly how it's built, step by step. See also more info about the tutorial world here .","title":"Building Quickstart"},{"location":"Building-Quickstart.html#stepping-down-from-godhood","text":"If you just installed Evennia, your very first player account is called user #1, also known as the superuser or god user . This user is very powerful, so powerful that it will override many game restrictions such as locks. This can be useful, but it also hides some functionality that you might want to test. To temporarily step down from your superuser position you can use the quell command in-game: quell This will make you start using the permission of your current character's level instead of your superuser level. If you didn't change any settings your game Character should have an Developer level permission - high as can be without bypassing locks like the superuser does. This will work fine for the examples on this page. Use unquell to get back to superuser status again afterwards.","title":"Stepping Down From Godhood"},{"location":"Building-Quickstart.html#creating-an-object","text":"Basic objects can be anything -- swords, flowers and non-player characters. They are created using the create command: create box This created a new 'box' (of the default object type) in your inventory. Use the command inventory (or i ) to see it. Now, 'box' is a rather short name, let's rename it and tack on a few aliases. name box = very large box;box;very;crate We now renamed the box to very large box (and this is what we will see when looking at it), but we will also recognize it by any of the other names we give - like crate or simply box as before. We could have given these aliases directly after the name in the create command, this is true for all creation commands - you can always tag on a list of ; -separated aliases to the name of your new object. If you had wanted to not change the name itself, but to only add aliases, you could have used the alias command. We are currently carrying the box. Let's drop it (there is also a short cut to create and drop in one go by using the /drop switch, for example create/drop box ). drop box Hey presto - there it is on the ground, in all its normality. examine box This will show some technical details about the box object. For now we will ignore what this information means. Try to look at the box to see the (default) description. look box You see nothing special. The description you get is not very exciting. Let's add some flavor. describe box = This is a large and very heavy box. If you try the get command we will pick up the box. So far so good, but if we really want this to be a large and heavy box, people should not be able to run off with it that easily. To prevent this we need to lock it down. This is done by assigning a Lock to it. Make sure the box was dropped in the room, then try this: lock box = get:false() Locks represent a rather big topic , but for now that will do what we want. This will lock the box so noone can lift it. The exception is superusers, they override all locks and will pick it up anyway. Make sure you are quelling your superuser powers and try to get the box now: > get box You can't get that. Think th\u00eds default error message looks dull? The get command looks for an Attribute named get_err_msg for returning a nicer error message (we just happen to know this, you would need to peek into the code for the get command to find out.). You set attributes using the set command: set box/get_err_msg = It's way too heavy for you to lift. Try to get it now and you should see a nicer error message echoed back to you. You create new Commands (or modify existing ones) in Python outside the game. See the Adding Commands tutorial for help with creating your first own Command.","title":"Creating an Object"},{"location":"Building-Quickstart.html#get-a-personality","text":"Scripts are powerful out-of-character objects useful for many \"under the hood\" things. One of their optional abilities is to do things on a timer. To try out a first script, let's put one on ourselves. There is an example script in evennia/contrib/tutorial_examples/bodyfunctions.py that is called BodyFunctions . To add this to us we will use the script command: script self = tutorial_examples.bodyfunctions.BodyFunctions (note that you don't have to give the full path as long as you are pointing to a place inside the contrib directory, it's one of the places Evennia looks for Scripts). Wait a while and you will notice yourself starting making random observations. script self This will show details about scripts on yourself (also examine works). You will see how long it is until it \"fires\" next. Don't be alarmed if nothing happens when the countdown reaches zero - this particular script has a randomizer to determine if it will say something or not. So you will not see output every time it fires. When you are tired of your character's \"insights\", kill the script with script/stop self = tutorial_examples.bodyfunctions.BodyFunctions You create your own scripts in Python, outside the game; the path you give to script is literally the Python path to your script file. The Scripts page explains more details.","title":"Get a Personality"},{"location":"Building-Quickstart.html#pushing-your-buttons","text":"If we get back to the box we made, there is only so much fun you can do with it at this point. It's just a dumb generic object. If you renamed it to stone and changed its description noone would be the wiser. However, with the combined use of custom Typeclasses , Scripts and object-based Commands , you could expand it and other items to be as unique, complex and interactive as you want. Let's take an example. So far we have only created objects that use the default object typeclass named simply Object . Let's create an object that is a little more interesting. Under evennia/contrib/tutorial_examples there is a module red_button.py . It contains the enigmatic RedButton typeclass. Let's make us one of those ! create/drop button:tutorial_examples.red_button.RedButton We import the RedButton python class the same way you would import it in Python except Evennia makes sure to look in evennia/contrib/ so you don't have to write the full path every time. There you go - one red button. The RedButton is an example object intended to show off a few of Evennia's features. You will find that the Typeclass and Commands controlling it are inside evennia/contrib/tutorial_examples/ . If you wait for a while (make sure you dropped it!) the button will blink invitingly. Why don't you try to push it ...? Surely a big red button is meant to be pushed. You know you want to.","title":"Pushing Your Buttons"},{"location":"Building-Quickstart.html#making-yourself-a-house","text":"The main command for shaping the game world is dig . For example, if you are standing in Limbo you can dig a route to your new house location like this: dig house = large red door;door;in,to the outside;out This will create a new room named 'house'. Spaces at the start/end of names and aliases are ignored so you could put more air if you wanted. This call will directly create an exit from your current location named 'large red door' and a corresponding exit named 'to the outside' in the house room leading back to Limbo. We also define a few aliases to those exits, so people don't have to write the full thing all the time. If you wanted to use normal compass directions (north, west, southwest etc), you could do that with dig too. But Evennia also has a limited version of dig that helps for compass directions (and also up/down and in/out). It's called tunnel : tunnel sw = cliff This will create a new room \"cliff\" with an exit \"southwest\" leading there and a path \"northeast\" leading back from the cliff to your current location. You can create new exits from where you are using the open command: open north;n = house This opens an exit north (with an alias n ) to the previously created room house . If you have many rooms named house you will get a list of matches and have to select which one you want to link to. You can also give its database (#dbref) number, which is unique to every object. This can be found with the examine command or by looking at the latest constructions with objects . Follow the north exit to your 'house' or teleport to it: north or: teleport house To manually open an exit back to Limbo (if you didn't do so with the dig command): open door = limbo (or give limbo's dbref which is #2)","title":"Making Yourself a House"},{"location":"Building-Quickstart.html#reshuffling-the-world","text":"You can find things using the find command. Assuming you are back at Limbo , let's teleport the large box to our house . > teleport box = house very large box is leaving Limbo, heading for house. Teleported very large box -> house. We can still find the box by using find: > find box One Match(#1-#8): very large box(#8) - src.objects.objects.Object Knowing the #dbref of the box (#8 in this example), you can grab the box and get it back here without actually yourself going to house first: teleport #8 = here (You can usually use here to refer to your current location. To refer to yourself you can use self or me ). The box should now be back in Limbo with you. We are getting tired of the box. Let's destroy it. destroy box You can destroy many objects in one go by giving a comma-separated list of objects (or their #dbrefs, if they are not in the same location) to the command.","title":"Reshuffling the World"},{"location":"Building-Quickstart.html#adding-a-help-entry","text":"An important part of building is keeping the help files updated. You can add, delete and append to existing help entries using the sethelp command. sethelp/add MyTopic = This help topic is about ...","title":"Adding a Help Entry"},{"location":"Building-Quickstart.html#adding-a-world","text":"After this brief introduction to building you may be ready to see a more fleshed-out example. Evennia comes with a tutorial world for you to explore. First you need to switch back to superuser by using the unquell command. Next, place yourself in Limbo and run the following command: batchcommand tutorial_world.build This will take a while (be patient and don't re-run the command). You will see all the commands used to build the world scroll by as the world is built for you. You will end up with a new exit from Limbo named tutorial . Apart from being a little solo-adventure in its own right, the tutorial world is a good source for learning Evennia building (and coding). Read the batch file to see exactly how it's built, step by step. See also more info about the tutorial world here .","title":"Adding a World"},{"location":"Building-a-mech-tutorial.html","text":"This page was adapted from the article \"Building a Giant Mech in Evennia\" by Griatch, published in Imaginary Realities Volume 6, issue 1, 2014. The original article is no longer available online, this is a version adopted to be compatible with the latest Evennia. Creating the Mech \u00b6 Let us create a functioning giant mech using the Python MUD-creation system Evennia. Everyone likes a giant mech, right? Start in-game as a character with build privileges (or the superuser). @create/drop Giant Mech ; mech Boom. We created a Giant Mech Object and dropped it in the room. We also gave it an alias mech . Let\u2019s describe it. @desc mech = This is a huge mech. It has missiles and stuff. Next we define who can \u201cpuppet\u201d the mech object. @lock mech = puppet:all() This makes it so that everyone can control the mech. More mechs to the people! (Note that whereas Evennia\u2019s default commands may look vaguely MUX-like, you can change the syntax to look like whatever interface style you prefer.) Before we continue, let\u2019s make a brief detour. Evennia is very flexible about its objects and even more flexible about using and adding commands to those objects. Here are some ground rules well worth remembering for the remainder of this article: The Account represents the real person logging in and has no game-world existence. Any Object can be puppeted by an Account (with proper permissions). Characters , Rooms , and Exits are just children of normal Objects. Any Object can be inside another (except if it creates a loop). Any Object can store custom sets of commands on it. Those commands can: be made available to the puppeteer (Account), be made available to anyone in the same location as the Object, and be made available to anyone \u201cinside\u201d the Object Also Accounts can store commands on themselves. Account commands are always available unless commands on a puppeted Object explicitly override them. In Evennia, using the @ic command will allow you to puppet a given Object (assuming you have puppet-access to do so). As mentioned above, the bog-standard Character class is in fact like any Object: it is auto-puppeted when logging in and just has a command set on it containing the normal in-game commands, like look, inventory, get and so on. @ic mech You just jumped out of your Character and are now the mech! If people look at you in-game, they will look at a mech. The problem at this point is that the mech Object has no commands of its own. The usual things like look, inventory and get sat on the Character object, remember? So at the moment the mech is not quite as cool as it could be. @ic <Your old Character> You just jumped back to puppeting your normal, mundane Character again. All is well. (But, you ask, where did that @ic command come from, if the mech had no commands on it? The answer is that it came from the Account's command set. This is important. Without the Account being the one with the @ic command, we would not have been able to get back out of our mech again.) Arming the Mech \u00b6 Let us make the mech a little more interesting. In our favorite text editor, we will create some new mech-suitable commands. In Evennia, commands are defined as Python classes. # in a new file mygame/commands/mechcommands.py from evennia import Command class CmdShoot(Command): \"\"\" Firing the mech\u2019s gun Usage: shoot [target] This will fire your mech\u2019s main gun. If no target is given, you will shoot in the air. \"\"\" key = \"shoot\" aliases = [\"fire\", \"fire!\"] def func(self): \"This actually does the shooting\" caller = self.caller location = caller.location if not self.args: # no argument given to command - shoot in the air message = \u201cBOOM! The mech fires its gun in the air!\u201d location.msg_contents(message) return # we have an argument, search for target target = caller.search(self.args) if target: message = \"BOOM! The mech fires its gun at %s\" % target.key location.msg_contents(message) class CmdLaunch(Command): # make your own 'launch'-command here as an exercise! # (it's very similar to the 'shoot' command above). This is saved as a normal Python module (let\u2019s call it mechcommands.py ), in a place Evennia looks for such modules ( mygame/commands/ ). This command will trigger when the player gives the command \u201cshoot\u201d, \u201cfire,\u201d or even \u201cfire!\u201d with an exclamation mark. The mech can shoot in the air or at a target if you give one. In a real game the gun would probably be given a chance to hit and give damage to the target, but this is enough for now. We also make a second command for launching missiles ( CmdLaunch ). To save space we won\u2019t describe it here; it looks the same except it returns a text about the missiles being fired and has different key and aliases . We leave that up to you to create as an exercise. You could have it print \"WOOSH! The mech launches missiles against !\", for example. Now we shove our commands into a command set. A Command Set (CmdSet) is a container holding any number of commands. The command set is what we will store on the mech. # in the same file mygame/commands/mechcommands.py from evennia import CmdSet from evennia import default_cmds class MechCmdSet(CmdSet): \"\"\" This allows mechs to do do mech stuff. \"\"\" key = \"mechcmdset\" def at_cmdset_creation(self): \"Called once, when cmdset is first created\" self.add(CmdShoot()) self.add(CmdLaunch()) This simply groups all the commands we want. We add our new shoot/launch commands. Let\u2019s head back into the game. For testing we will manually attach our new CmdSet to the mech. @py self.search(\"mech\").cmdset.add(\"commands.mechcommands.MechCmdSet\") This is a little Python snippet (run from the command line as an admin) that searches for the mech in our current location and attaches our new MechCmdSet to it. What we add is actually the Python path to our cmdset class. Evennia will import and initialize it behind the scenes. @ic mech We are back as the mech! Let\u2019s do some shooting! fire! BOOM! The mech fires its gun in the air! There we go, one functioning mech. Try your own launch command and see that it works too. We can not only walk around as the mech \u2014 since the CharacterCmdSet is included in our MechCmdSet, the mech can also do everything a Character could do, like look around, pick up stuff, and have an inventory. We could now shoot the gun at a target or try the missile launch command. Once you have your own mech, what else do you need? Note: You'll find that the mech's commands are available to you by just standing in the same location (not just by puppeting it). We'll solve this with a lock in the next section. Making a Mech production line \u00b6 What we\u2019ve done so far is just to make a normal Object, describe it and put some commands on it. This is great for testing. The way we added it, the MechCmdSet will even go away if we reload the server. Now we want to make the mech an actual object \u201ctype\u201d so we can create mechs without those extra steps. For this we need to create a new Typeclass. A Typeclass is a near-normal Python class that stores its existence to the database behind the scenes. A Typeclass is created in a normal Python source file: # in the new file mygame/typeclasses/mech.py from typeclasses.objects import Object from commands.mechcommands import MechCmdSet from evennia import default_cmds class Mech(Object): \"\"\" This typeclass describes an armed Mech. \"\"\" def at_object_creation(self): \"This is called only when object is first created\" self.cmdset.add_default(default_cmds.CharacterCmdSet) self.cmdset.add(MechCmdSet, permanent=True) self.locks.add(\"puppet:all();call:false()\") self.db.desc = \"This is a huge mech. It has missiles and stuff.\" For convenience we include the full contents of the default CharacterCmdSet in there. This will make a Character\u2019s normal commands available to the mech. We also add the mech-commands from before, making sure they are stored persistently in the database. The locks specify that anyone can puppet the meck and no-one can \"call\" the mech's Commands from 'outside' it - you have to puppet it to be able to shoot. That\u2019s it. When Objects of this type are created, they will always start out with the mech\u2019s command set and the correct lock. We set a default description, but you would probably change this with @desc to individualize your mechs as you build them. Back in the game, just exit the old mech ( @ic back to your old character) then do @create/drop The Bigger Mech ; bigmech : mech.Mech We create a new, bigger mech with an alias bigmech. Note how we give the python-path to our Typeclass at the end \u2014 this tells Evennia to create the new object based on that class (we don't have to give the full path in our game dir typeclasses.mech.Mech because Evennia knows to look in the typeclasses folder already). A shining new mech will appear in the room! Just use @ic bigmech to take it on a test drive. Future Mechs \u00b6 To expand on this you could add more commands to the mech and remove others. Maybe the mech shouldn\u2019t work just like a Character after all. Maybe it makes loud noises every time it passes from room to room. Maybe it cannot pick up things without crushing them. Maybe it needs fuel, ammo and repairs. Maybe you\u2019ll lock it down so it can only be puppeted by emo teenagers. Having you puppet the mech-object directly is also just one way to implement a giant mech in Evennia. For example, you could instead picture a mech as a \u201cvehicle\u201d that you \u201center\u201d as your normal Character (since any Object can move inside another). In that case the \u201cinsides\u201d of the mech Object could be the \u201ccockpit\u201d. The cockpit would have the MechCommandSet stored on itself and all the shooting goodness would be made available to you only when you enter it. And of course you could put more guns on it. And make it fly.","title":"Building a mech tutorial"},{"location":"Building-a-mech-tutorial.html#creating-the-mech","text":"Let us create a functioning giant mech using the Python MUD-creation system Evennia. Everyone likes a giant mech, right? Start in-game as a character with build privileges (or the superuser). @create/drop Giant Mech ; mech Boom. We created a Giant Mech Object and dropped it in the room. We also gave it an alias mech . Let\u2019s describe it. @desc mech = This is a huge mech. It has missiles and stuff. Next we define who can \u201cpuppet\u201d the mech object. @lock mech = puppet:all() This makes it so that everyone can control the mech. More mechs to the people! (Note that whereas Evennia\u2019s default commands may look vaguely MUX-like, you can change the syntax to look like whatever interface style you prefer.) Before we continue, let\u2019s make a brief detour. Evennia is very flexible about its objects and even more flexible about using and adding commands to those objects. Here are some ground rules well worth remembering for the remainder of this article: The Account represents the real person logging in and has no game-world existence. Any Object can be puppeted by an Account (with proper permissions). Characters , Rooms , and Exits are just children of normal Objects. Any Object can be inside another (except if it creates a loop). Any Object can store custom sets of commands on it. Those commands can: be made available to the puppeteer (Account), be made available to anyone in the same location as the Object, and be made available to anyone \u201cinside\u201d the Object Also Accounts can store commands on themselves. Account commands are always available unless commands on a puppeted Object explicitly override them. In Evennia, using the @ic command will allow you to puppet a given Object (assuming you have puppet-access to do so). As mentioned above, the bog-standard Character class is in fact like any Object: it is auto-puppeted when logging in and just has a command set on it containing the normal in-game commands, like look, inventory, get and so on. @ic mech You just jumped out of your Character and are now the mech! If people look at you in-game, they will look at a mech. The problem at this point is that the mech Object has no commands of its own. The usual things like look, inventory and get sat on the Character object, remember? So at the moment the mech is not quite as cool as it could be. @ic <Your old Character> You just jumped back to puppeting your normal, mundane Character again. All is well. (But, you ask, where did that @ic command come from, if the mech had no commands on it? The answer is that it came from the Account's command set. This is important. Without the Account being the one with the @ic command, we would not have been able to get back out of our mech again.)","title":"Creating the Mech"},{"location":"Building-a-mech-tutorial.html#arming-the-mech","text":"Let us make the mech a little more interesting. In our favorite text editor, we will create some new mech-suitable commands. In Evennia, commands are defined as Python classes. # in a new file mygame/commands/mechcommands.py from evennia import Command class CmdShoot(Command): \"\"\" Firing the mech\u2019s gun Usage: shoot [target] This will fire your mech\u2019s main gun. If no target is given, you will shoot in the air. \"\"\" key = \"shoot\" aliases = [\"fire\", \"fire!\"] def func(self): \"This actually does the shooting\" caller = self.caller location = caller.location if not self.args: # no argument given to command - shoot in the air message = \u201cBOOM! The mech fires its gun in the air!\u201d location.msg_contents(message) return # we have an argument, search for target target = caller.search(self.args) if target: message = \"BOOM! The mech fires its gun at %s\" % target.key location.msg_contents(message) class CmdLaunch(Command): # make your own 'launch'-command here as an exercise! # (it's very similar to the 'shoot' command above). This is saved as a normal Python module (let\u2019s call it mechcommands.py ), in a place Evennia looks for such modules ( mygame/commands/ ). This command will trigger when the player gives the command \u201cshoot\u201d, \u201cfire,\u201d or even \u201cfire!\u201d with an exclamation mark. The mech can shoot in the air or at a target if you give one. In a real game the gun would probably be given a chance to hit and give damage to the target, but this is enough for now. We also make a second command for launching missiles ( CmdLaunch ). To save space we won\u2019t describe it here; it looks the same except it returns a text about the missiles being fired and has different key and aliases . We leave that up to you to create as an exercise. You could have it print \"WOOSH! The mech launches missiles against !\", for example. Now we shove our commands into a command set. A Command Set (CmdSet) is a container holding any number of commands. The command set is what we will store on the mech. # in the same file mygame/commands/mechcommands.py from evennia import CmdSet from evennia import default_cmds class MechCmdSet(CmdSet): \"\"\" This allows mechs to do do mech stuff. \"\"\" key = \"mechcmdset\" def at_cmdset_creation(self): \"Called once, when cmdset is first created\" self.add(CmdShoot()) self.add(CmdLaunch()) This simply groups all the commands we want. We add our new shoot/launch commands. Let\u2019s head back into the game. For testing we will manually attach our new CmdSet to the mech. @py self.search(\"mech\").cmdset.add(\"commands.mechcommands.MechCmdSet\") This is a little Python snippet (run from the command line as an admin) that searches for the mech in our current location and attaches our new MechCmdSet to it. What we add is actually the Python path to our cmdset class. Evennia will import and initialize it behind the scenes. @ic mech We are back as the mech! Let\u2019s do some shooting! fire! BOOM! The mech fires its gun in the air! There we go, one functioning mech. Try your own launch command and see that it works too. We can not only walk around as the mech \u2014 since the CharacterCmdSet is included in our MechCmdSet, the mech can also do everything a Character could do, like look around, pick up stuff, and have an inventory. We could now shoot the gun at a target or try the missile launch command. Once you have your own mech, what else do you need? Note: You'll find that the mech's commands are available to you by just standing in the same location (not just by puppeting it). We'll solve this with a lock in the next section.","title":"Arming the Mech"},{"location":"Building-a-mech-tutorial.html#making-a-mech-production-line","text":"What we\u2019ve done so far is just to make a normal Object, describe it and put some commands on it. This is great for testing. The way we added it, the MechCmdSet will even go away if we reload the server. Now we want to make the mech an actual object \u201ctype\u201d so we can create mechs without those extra steps. For this we need to create a new Typeclass. A Typeclass is a near-normal Python class that stores its existence to the database behind the scenes. A Typeclass is created in a normal Python source file: # in the new file mygame/typeclasses/mech.py from typeclasses.objects import Object from commands.mechcommands import MechCmdSet from evennia import default_cmds class Mech(Object): \"\"\" This typeclass describes an armed Mech. \"\"\" def at_object_creation(self): \"This is called only when object is first created\" self.cmdset.add_default(default_cmds.CharacterCmdSet) self.cmdset.add(MechCmdSet, permanent=True) self.locks.add(\"puppet:all();call:false()\") self.db.desc = \"This is a huge mech. It has missiles and stuff.\" For convenience we include the full contents of the default CharacterCmdSet in there. This will make a Character\u2019s normal commands available to the mech. We also add the mech-commands from before, making sure they are stored persistently in the database. The locks specify that anyone can puppet the meck and no-one can \"call\" the mech's Commands from 'outside' it - you have to puppet it to be able to shoot. That\u2019s it. When Objects of this type are created, they will always start out with the mech\u2019s command set and the correct lock. We set a default description, but you would probably change this with @desc to individualize your mechs as you build them. Back in the game, just exit the old mech ( @ic back to your old character) then do @create/drop The Bigger Mech ; bigmech : mech.Mech We create a new, bigger mech with an alias bigmech. Note how we give the python-path to our Typeclass at the end \u2014 this tells Evennia to create the new object based on that class (we don't have to give the full path in our game dir typeclasses.mech.Mech because Evennia knows to look in the typeclasses folder already). A shining new mech will appear in the room! Just use @ic bigmech to take it on a test drive.","title":"Making a Mech production line"},{"location":"Building-a-mech-tutorial.html#future-mechs","text":"To expand on this you could add more commands to the mech and remove others. Maybe the mech shouldn\u2019t work just like a Character after all. Maybe it makes loud noises every time it passes from room to room. Maybe it cannot pick up things without crushing them. Maybe it needs fuel, ammo and repairs. Maybe you\u2019ll lock it down so it can only be puppeted by emo teenagers. Having you puppet the mech-object directly is also just one way to implement a giant mech in Evennia. For example, you could instead picture a mech as a \u201cvehicle\u201d that you \u201center\u201d as your normal Character (since any Object can move inside another). In that case the \u201cinsides\u201d of the mech Object could be the \u201ccockpit\u201d. The cockpit would have the MechCommandSet stored on itself and all the shooting goodness would be made available to you only when you enter it. And of course you could put more guns on it. And make it fly.","title":"Future Mechs"},{"location":"Building-menus.html","text":"The building_menu contrib \u00b6 This contrib allows you to write custom and easy to use building menus. As the name implies, these menus are most useful for building things, that is, your builders might appreciate them, although you can use them for your players as well. Building menus are somewhat similar to EvMenu although they don't use the same system at all and are intended to make building easier. They replicate what other engines refer to as \"building editors\", which allow to you to build in a menu instead of having to enter a lot of complex commands. Builders might appreciate this simplicity, and if the code that was used to create them is simple as well, coders could find this contrib useful. A simple menu \u00b6 Before diving in, there are some things to point out: Building menus work on an object. This object will be edited by manipulations in the menu. So you can create a menu to add/edit a room, an exit, a character and so on. Building menus are arranged in layers of choices. A choice gives access to an option or to a sub-menu. Choices are linked to commands (usually very short). For instance, in the example shown below, to edit the room key, after opening the building menu, you can type k . That will lead you to the key choice where you can enter a new key for the room. Then you can enter @ to leave this choice and go back to the entire menu. (All of this can be changed). To open the menu, you will need something like a command. This contrib offers a basic command for demonstration, but we will override it in this example, using the same code with more flexibility. So let's add a very basic example to begin with. A generic editing command \u00b6 Let's begin by adding a new command. You could add or edit the following file (there's no trick here, feel free to organize the code differently): # file: commands/building.py from evennia.contrib.building_menu import BuildingMenu from commands.command import Command class EditCmd(Command): \"\"\" Editing command. Usage: @edit [object] Open a building menu to edit the specified object. This menu allows to specific information about this object. Examples: @edit here @edit self @edit #142 \"\"\" key = \"@edit\" locks = \"cmd:id(1) or perm(Builders)\" help_category = \"Building\" def func(self): if not self.args.strip(): self.msg(\"|rYou should provide an argument to this function: the object to edit.|n\") return obj = self.caller.search(self.args.strip(), global_search=True) if not obj: return if obj.typename == \"Room\": Menu = RoomBuildingMenu else: self.msg(\"|rThe object {} cannot be edited.|n\".format(obj.get_display_name(self.caller))) return menu = Menu(self.caller, obj) menu.open() This command is rather simple in itself: It has a key @edit and a lock to only allow builders to use it. In its func method, it begins by checking the arguments, returning an error if no argument is specified. It then searches for the given argument. We search globally. The search method used in this way will return the found object or None . It will also send the error message to the caller if necessary. Assuming we have found an object, we check the object typename . This will be used later when we want to display several building menus. For the time being, we only handle Room . If the caller specified something else, we'll display an error. Assuming this object is a Room , we have defined a Menu object containing the class of our building menu. We build this class (creating an instance), giving it the caller and the object to edit. We then open the building menu, using the open method. The end might sound a bit surprising at first glance. But the process is still very simple: we create an instance of our building menu and call its open method. Nothing more. Where is our building menu? If you go ahead and add this command and test it, you'll get an error. We haven't defined RoomBuildingMenu yet. To add this command, edit commands/default_cmdsets.py . Import our command, adding an import line at the top of the file: \"\"\" ... \"\"\" from evennia import default_cmds # The following line is to be added from commands.building import EditCmd And in the class below ( CharacterCmdSet ), add the last line of this code: class CharacterCmdSet(default_cmds.CharacterCmdSet): \"\"\" The `CharacterCmdSet` contains general in-game commands like `look`, `get`, etc available on in-game Character objects. It is merged with the `AccountCmdSet` when an Account puppets a Character. \"\"\" key = \"DefaultCharacter\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # # any commands you add below will overload the default ones. # self.add(EditCmd()) Our first menu \u00b6 So far, we can't use our building menu. Our @edit command will throw an error. We have to define the RoomBuildingMenu class. Open the commands/building.py file and add to the end of the file: # ... at the end of commands/building.py # Our building menu class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"key\", \"k\", attr=\"key\") Save these changes, reload your game. You can now use the @edit command. Here's what we get (notice that the commands we enter into the game are prefixed with > , though this prefix will probably not appear in your MUD client): > look Limbo(#2) Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need help, want to contribute, report issues or just join the community. As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build. > @edit here Building menu: Limbo [K]ey: Limbo [Q]uit the menu > q Closing the building menu. > @edit here Building menu: Limbo [K]ey: Limbo [Q]uit the menu > k ------------------------------------------------------------------------------- key for Limbo(#2) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: Limbo > A beautiful meadow ------------------------------------------------------------------------------- key for A beautiful meadow(#2) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: A beautiful meadow > @ Building menu: A beautiful meadow [K]ey: A beautiful meadow [Q]uit the menu > q Closing the building menu. > look A beautiful meadow(#2) Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need help, want to contribute, report issues or just join the community. As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build. Before diving into the code, let's examine what we have: When we use the @edit here command, a building menu for this room appears. This menu has two choices: Enter k to edit the room key. You will go into a choice where you can simply type the key room key (the way we have done here). You can use @ to go back to the menu. You can use q to quit the menu. We then check, with the look command, that the menu has modified this room key. So by adding a class, with a method and a single line of code within, we've added a menu with two choices. Code explanation \u00b6 Let's examine our code again: class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"key\", \"k\", attr=\"key\") We first create a class inheriting from BuildingMenu . This is usually the case when we want to create a building menu with this contrib. In this class, we override the init method, which is called when the menu opens. In this init method, we call add_choice . This takes several arguments, but we've defined only three here: The choice name. This is mandatory and will be used by the building menu to know how to display this choice. The command key to access this choice. We've given a simple \"k\" . Menu commands usually are pretty short (that's part of the reason building menus are appreciated by builders). You can also specify additional aliases, but we'll see that later. We've added a keyword argument, attr . This tells the building menu that when we are in this choice, the text we enter goes into this attribute name. It's called attr , but it could be a room attribute or a typeclass persistent or non-persistent attribute (we'll see other examples as well). We've added the menu choice for key here, why is another menu choice defined for quit ? Our building menu creates a choice at the end of our choice list if it's a top-level menu (sub-menus don't have this feature). You can, however, override it to provide a different \"quit\" message or to perform some actions. I encourage you to play with this code. As simple as it is, it offers some functionalities already. Customizing building menus \u00b6 This somewhat long section explains how to customize building menus. There are different ways depending on what you would like to achieve. We'll go from specific to more advanced here. Generic choices \u00b6 In the previous example, we've used add_choice . This is one of three methods you can use to add choices. The other two are to handle more generic actions: add_choice_edit : this is called to add a choice which points to the EvEditor . It is used to edit a description in most cases, although you could edit other things. We'll see an example shortly. add_choice_edit uses most of the add_choice keyword arguments we'll see, but usually we specify only two (sometimes three): The choice title as usual. The choice key (command key) as usual. Optionally, the attribute of the object to edit, with the attr keyword argument. By default, attr contains db.desc . It means that this persistent data attribute will be edited by the EvEditor . You can change that to whatever you want though. add_choice_quit : this allows to add a choice to quit the editor. Most advisable! If you don't do it, the building menu will do it automatically, except if you really tell it not to. Again, you can specify the title and key of this menu. You can also call a function when this menu closes. So here's a more complete example (you can replace your RoomBuildingMenu class in commands/building.py to see it): class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"key\", \"k\", attr=\"key\") self.add_choice_edit(\"description\", \"d\") self.add_choice_quit(\"quit this editor\", \"q\") So far, our building menu class is still thin... and yet we already have some interesting feature. See for yourself the following MUD client output (again, the commands are prefixed with > to distinguish them): > @reload > @edit here Building menu: A beautiful meadow [K]ey: A beautiful meadow [D]escription: Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need help, want to contribute, report issues or just join the community. As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build. [Q]uit this editor > d ----------Line Editor [editor]---------------------------------------------------- 01| Welcome to your new |wEvennia|n-based game! Visit http://www.evennia.com if you need 02| help, want to contribute, report issues or just join the community. 03| As Account #1 you can create a demo/tutorial area with |w@batchcommand tutorial_world.build|n. > :DD ----------[l:03 w:034 c:0247]------------(:h for help)---------------------------- Cleared 3 lines from buffer. > This is a beautiful meadow. But so beautiful I can't describe it. 01| This is a beautiful meadow. But so beautiful I can't describe it. > :wq Building menu: A beautiful meadow [K]ey: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [Q]uit this editor > q Closing the building menu. > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. So by using the d shortcut in our building menu, an EvEditor opens. You can use the EvEditor commands (like we did here, :DD to remove all, :wq to save and quit). When you quit the editor, the description is saved (here, in room.db.desc ) and you go back to the building menu. Notice that the choice to quit has changed too, which is due to our adding add_choice_quit . In most cases, you will probably not use this method, since the quit menu is added automatically. add_choice options \u00b6 add_choice and the two methods add_choice_edit and add_choice_quit take a lot of optional arguments to make customization easier. Some of these options might not apply to add_choice_edit or add_choice_quit however. Below are the options of add_choice , specify them as arguments: The first positional, mandatory argument is the choice title, as we have seen. This will influence how the choice appears in the menu. The second positional, mandatory argument is the command key to access to this menu. It is best to use keyword arguments for the other arguments. The aliases keyword argument can contain a list of aliases that can be used to access to this menu. For instance: add_choice(..., aliases=['t']) The attr keyword argument contains the attribute to edit when this choice is selected. It's a string, it has to be the name, from the object (specified in the menu constructor) to reach this attribute. For instance, a attr of \"key\" will try to find obj.key to read and write the attribute. You can specify more complex attribute names, for instance, attr=\"db.desc\" to set the desc persistent attribute, or attr=\"ndb.something\" so use a non-persistent data attribute on the object. The text keyword argument is used to change the text that will be displayed when the menu choice is selected. Menu choices provide a default text that you can change. Since this is a long text, it's useful to use multi-line strings (see an example below). The glance keyword argument is used to specify how to display the current information while in the menu, when the choice hasn't been opened. If you examine the previous examples, you will see that the current ( key or db.desc ) was shown in the menu, next to the command key. This is useful for seeing at a glance the current value (hence the name). Again, menu choices will provide a default glance if you don't specify one. The on_enter keyword argument allows to add a callback to use when the menu choice is opened. This is more advanced, but sometimes useful. The on_nomatch keyword argument is called when, once in the menu, the caller enters some text that doesn't match any command (including the @ command). By default, this will edit the specified attr . The on_leave keyword argument allows to specify a callback used when the caller leaves the menu choice. This can be useful for cleanup as well. These are a lot of possibilities, and most of the time you won't need them all. Here is a short example using some of these arguments (again, replace the RoomBuildingMenu class in commands/building.py with the following code to see it working): class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") Reload your game and see it in action: > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [Q]uit the menu > t ------------------------------------------------------------------------------- Editing the title of A beautiful meadow(#2) You can change the title simply by entering it. Use @ to go back to the main menu. Current title: A beautiful meadow > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [Q]uit the menu > q Closing the building menu. The most surprising part is no doubt the text. We use the multi-line syntax (with \"\"\" ). Excessive spaces will be removed from the left for each line automatically. We specify some information between braces... sometimes using double braces. What might be a bit odd: {back} is a direct format argument we'll use (see the .format specifiers). {{obj...}} refers to the object being edited. We use two braces, because .format` will remove them. In glance , we also use {obj.key} to indicate we want to show the room's key. Everything can be a function \u00b6 The keyword arguments of add_choice are often strings (type str ). But each of these arguments can also be a function. This allows for a lot of customization, since we define the callbacks that will be executed to achieve such and such an operation. To demonstrate, we will try to add a new feature. Our building menu for rooms isn't that bad, but it would be great to be able to edit exits too. So we can add a new menu choice below description... but how to actually edit exits? Exits are not just an attribute to set: exits are objects (of type Exit by default) which stands between two rooms (object of type Room ). So how can we show that? First let's add a couple of exits in limbo, so we have something to work with: @tunnel n @tunnel s This should create two new rooms, exits leading to them from limbo and back to limbo. > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. Exits: north(#4) and south(#7) We can access room exits with the exits property: > @py here.exits [<Exit: north>, <Exit: south>] So what we need is to display this list in our building menu... and to allow to edit it would be great. Perhaps even add new exits? First of all, let's write a function to display the glance on existing exits. Here's the code, it's explained below: class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, attr=\"exits\") # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" When the building menu opens, it displays each choice to the caller. A choice is displayed with its title (rendered a bit nicely to show the key as well) and the glance. In the case of the exits choice, the glance is a function, so the building menu calls this function giving it the object being edited (the room here). The function should return the text to see. > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > q Closing the editor. How do I know the parameters of the function to give? The function you give can accept a lot of different parameters. This allows for a flexible approach but might seem complicated at first. Basically, your function can accept any parameter, and the building menu will send only the parameter based on their names. If your function defines an argument named caller for instance (like def func(caller): ), then the building menu knows that the first argument should contain the caller of the building menu. Here are the arguments, you don't have to specify them (if you do, they need to have the same name): menu : if your function defines an argument named menu , it will contain the building menu itself. choice : if your function defines an argument named choice , it will contain the Choice object representing this menu choice. string : if your function defines an argument named string , it will contain the user input to reach this menu choice. This is not very useful, except on nomatch callbacks which we'll see later. obj : if your function defines an argument named obj , it will contain the building menu edited object. caller : if your function defines an argument named caller , it will contain the caller of the building menu. Anything else: any other argument will contain the object being edited by the building menu. So in our case: def glance_exits(room): The only argument we need is room . It's not present in the list of possible arguments, so the editing object of the building menu (the room, here) is given. Why is it useful to get the menu or choice object? Most of the time, you will not need these arguments. In very rare cases, you will use them to get specific data (like the default attribute that was set). This tutorial will not elaborate on these possibilities. Just know that they exist. We should also define a text callback, so that we can enter our menu to see the room exits. We'll see how to edit them in the next section but this is a good opportunity to show a more complete callback. To see it in action, as usual, replace the class and functions in commands/building.py : # Our building menu class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, attr=\"exits\", text=text_exits) # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" def text_exits(caller, room): \"\"\"Show the room exits in the choice itself.\"\"\" text = \"-\" * 79 text += \"\\n\\nRoom exits:\" text += \"\\n Use |y@c|n to create a new exit.\" text += \"\\n\\nExisting exits:\" if room.exits: for exit in room.exits: text += \"\\n |y@e {exit}|n\".format(exit=exit.key) if exit.aliases.all(): text += \" (|y{aliases}|n)\".format(aliases=\"|n, |y\".join( alias for alias in exit.aliases.all())) if exit.destination: text += \" toward {destination}\".format(destination=exit.get_display_name(caller)) else: text += \"\\n\\n |gNo exit has yet been defined.|n\" return text Look at the second callback in particular. It takes an additional argument, the caller (remember, the argument names are important, their order is not relevant). This is useful for displaying destination of exits accurately. Here is a demonstration of this menu: > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > e ------------------------------------------------------------------------------- Room exits: Use @c to create a new exit. Existing exits: @e north (n) toward north(#4) @e south (s) toward south(#7) > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > q Closing the building menu. Using callbacks allows a great flexibility. We'll now see how to handle sub-menus. Sub-menus for complex menus \u00b6 A menu is relatively flat: it has a root (where you see all the menu choices) and individual choices you can go to using the menu choice keys. Once in a choice you can type some input or go back to the root menu by entering the return command (usually @ ). Why shouldn't individual exits have their own menu though? Say, you edit an exit and can change its key, description or aliases... perhaps even destination? Why ever not? It would make building much easier! The building menu system offers two ways to do that. The first is nested keys: nested keys allow to go beyond just one menu/choice, to have menus with more layers. Using them is quick but might feel a bit counter-intuitive at first. Another option is to create a different menu class and redirect from the first to the second. This option might require more lines but is more explicit and can be re-used for multiple menus. Adopt one of them depending of your taste. Nested menu keys \u00b6 So far, we've only used menu keys with one letter. We can add more, of course, but menu keys in their simple shape are just command keys. Press \"e\" to go to the \"exits\" choice. But menu keys can be nested. Nested keys allow to add choices with sub-menus. For instance, type \"e\" to go to the \"exits\" choice, and then you can type \"c\" to open a menu to create a new exit, or \"d\" to open a menu to delete an exit. The first menu would have the \"e.c\" key (first e, then c), the second menu would have key as \"e.d\". That's more advanced and, if the following code doesn't sound very friendly to you, try the next section which provides a different approach of the same problem. So we would like to edit exits. That is, you can type \"e\" to go into the choice of exits, then enter @e followed by the exit name to edit it... which will open another menu. In this sub-menu you could change the exit key or description. So we have a menu hierarchy similar to that: t Change the room title d Change the room description e Access the room exits [exit name] Access the exit name sub-menu [text] Change the exit key Or, if you prefer an example output: > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. Exits: north(#4) and south(#7) > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > e ------------------------------------------------------------------------------- Room exits : Use @c to create a new exit. Existing exits: @e north (n) toward north(#4) @e south (s) toward south(#7) > @e north Editing: north Exit north: Enter the exit key to change it, or @ to go back. New exit key: > door Exit door: Enter the exit key to change it, or @ to go back. New exit key: > @ ------------------------------------------------------------------------------- Room exits : Use @c to create a new exit. Existing exits: @e door (n) toward door(#4) @e south (s) toward south(#7) > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: door south [Q]uit the menu > q Closing the building menu. This needs a bit of code and a bit of explanation. So here we go... the code first, the explanations next! # ... from commands/building.py # Our building menu class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, text=text_exits, on_nomatch=nomatch_exits) # Exit sub-menu self.add_choice(\"exit\", \"e.*\", text=text_single_exit, on_nomatch=nomatch_single_exit) # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" def text_exits(caller, room): \"\"\"Show the room exits in the choice itself.\"\"\" text = \"-\" * 79 text += \"\\n\\nRoom exits:\" text += \"\\n Use |y@c|n to create a new exit.\" text += \"\\n\\nExisting exits:\" if room.exits: for exit in room.exits: text += \"\\n |y@e {exit}|n\".format(exit=exit.key) if exit.aliases.all(): text += \" (|y{aliases}|n)\".format(aliases=\"|n, |y\".join( alias for alias in exit.aliases.all())) if exit.destination: text += \" toward {destination}\".format(destination=exit.get_display_name(caller)) else: text += \"\\n\\n |gNo exit has yet been defined.|n\" return text def nomatch_exits(menu, caller, room, string): \"\"\" The user typed something in the list of exits. Maybe an exit name? \"\"\" string = string[3:] exit = caller.search(string, candidates=room.exits) if exit is None: return # Open a sub-menu, using nested keys caller.msg(\"Editing: {}\".format(exit.key)) menu.move(exit) return False # Exit sub-menu def text_single_exit(menu, caller): \"\"\"Show the text to edit single exits.\"\"\" exit = menu.keys[1] if exit is None: return \"\" return \"\"\" Exit {exit}: Enter the exit key to change it, or |y@|n to go back. New exit key: \"\"\".format(exit=exit.key) def nomatch_single_exit(menu, caller, room, string): \"\"\"The user entered something in the exit sub-menu. Replace the exit key.\"\"\" # exit is the second key element: keys should contain ['e', <Exit object>] exit = menu.keys[1] if exit is None: caller.msg(\"|rCannot find the exit.|n\") menu.move(back=True) return False exit.key = string return True That's a lot of code! And we only handle editing the exit key! That's why at some point you might want to write a real sub-menu, instead of using simple nested keys. But you might need both to build pretty menus too! The first thing new is in our menu class. After creating a on_nomatch callback for the exits menu (that shouldn't be a surprised), we need to add a nested key. We give this menu a key of \"e.*\" . That's a bit odd! \"e\" is our key to the exits menu, . is the separator to indicate a nested menu, and * means anything. So basically, we create a nested menu that is contains within the exits menu and anything. We'll see what this \"anything\" is in practice. The glance_exits and text_exits are basically the same. The nomatch_exits is short but interesting. It's called when we enter some text in the \"exits\" menu (that is, in the list of exits). We have said that the user should enter @e followed by the exit name to edit it. So in the nomatch_exits callbac, we check for that input. If the entered text begins by @e , we try to find the exit in the room. If we do... We call the menu.move method. That's where things get a bit complicated with nested menus: we need to use menu.move to change from layer to layer. Here, we are in the choice of exits (the exits menu, of key \"e\"). We need to go down one layer to edit an exit. So we call menu.move and give it an exit object. The menu system remembers what position the user is based on the keys she has entered: when the user opens the menu, there is no key. If she selects the exits choice, the menu key being \"e\", the position of the user is [\"e\"] (a list with the menu keys). If we call menu.move , whatever we give to this method will be appended to the list of keys, so that the user position becomes [\"e\", <Exit object>] . In the menu class, we have defined the menu \"e.*\", meaning \"the menu contained in the exits choice plus anything\". The \"anything\" here is an exit: we have called menu.move(exit) , so the \"e.*\" menu choice is chosen. In this menu, the text is set to a callback. There is also a on_nomatch callback that is called whenever the user enters some text. If so, we change the exit name. Using menu.move like this is a bit confusing at first. Sometimes it's useful. In this case, if we want a more complex menu for exits, it makes sense to use a real sub-menu, not nested keys like this. But sometimes, you will find yourself in a situation where you don't need a full menu to handle a choice. Full sub-menu as separate classes \u00b6 The best way to handle individual exits is to create two separate classes: One for the room menu. One for the individual exit menu. The first one will have to redirect on the second. This might be more intuitive and flexible, depending on what you want to achieve. So let's build two menus: # Still in commands/building.py, replace the menu class and functions by... # Our building menus class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, text=text_exits, on_nomatch=nomatch_exits) # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" def text_exits(caller, room): \"\"\"Show the room exits in the choice itself.\"\"\" text = \"-\" * 79 text += \"\\n\\nRoom exits:\" text += \"\\n Use |y@c|n to create a new exit.\" text += \"\\n\\nExisting exits:\" if room.exits: for exit in room.exits: text += \"\\n |y@e {exit}|n\".format(exit=exit.key) if exit.aliases.all(): text += \" (|y{aliases}|n)\".format(aliases=\"|n, |y\".join( alias for alias in exit.aliases.all())) if exit.destination: text += \" toward {destination}\".format(destination=exit.get_display_name(caller)) else: text += \"\\n\\n |gNo exit has yet been defined.|n\" return text def nomatch_exits(menu, caller, room, string): \"\"\" The user typed something in the list of exits. Maybe an exit name? \"\"\" string = string[3:] exit = caller.search(string, candidates=room.exits) if exit is None: return # Open a sub-menu, using nested keys caller.msg(\"Editing: {}\".format(exit.key)) menu.open_submenu(\"commands.building.ExitBuildingMenu\", exit, parent_keys=[\"e\"]) return False class ExitBuildingMenu(BuildingMenu): \"\"\" Building menu to edit an exit. \"\"\" def init(self, exit): self.add_choice(\"key\", key=\"k\", attr=\"key\", glance=\"{obj.key}\") self.add_choice_edit(\"description\", \"d\") The code might be much easier to read. But before detailing it, let's see how it behaves in the game: > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: door south [Q]uit the menu > e ------------------------------------------------------------------------------- Room exits: Use @c to create a new exit. Existing exits: @e door (n) toward door(#4) @e south (s) toward south(#7) Editing: door > @e door Building menu: door [K]ey: door [D]escription: None > k ------------------------------------------------------------------------------- key for door(#4) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: door > north ------------------------------------------------------------------------------- key for north(#4) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: north > @ Building menu: north [K]ey: north [D]escription: None > d ----------Line Editor [editor]---------------------------------------------------- 01| None ----------[l:01 w:001 c:0004]------------(:h for help)---------------------------- > :DD Cleared 1 lines from buffer. > This is the northern exit. Cool huh? 01| This is the northern exit. Cool huh? > :wq Building menu: north [K]ey: north [D]escription: This is the northern exit. Cool huh? > @ ------------------------------------------------------------------------------- Room exits: Use @c to create a new exit. Existing exits: @e north (n) toward north(#4) @e south (s) toward south(#7) > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > q Closing the building menu. > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. Exits: north(#4) and south(#7) > @py here.exits[0] >>> here.exits[0] north > @py here.exits[0].db.desc >>> here.exits[0].db.desc This is the northern exit. Cool huh? Very simply, we created two menus and bridged them together. This needs much less callbacks. There is only one line in the nomatch_exits to add: menu.open_submenu(\"commands.building.ExitBuildingMenu\", exit, parent_keys=[\"e\"]) We have to call open_submenu on the menu object (which opens, as its name implies, a sub menu) with three arguments: The path of the menu class to create. It's the Python class leading to the menu (notice the dots). The object that will be edited by the menu. Here, it's our exit, so we give it to the sub-menu. The keys of the parent to open when the sub-menu closes. Basically, when we're in the root of the sub-menu and press @ , we'll open the parent menu, with the parent keys. So we specify [\"e\"] , since the parent menus is the \"exits\" choice. And that's it. The new class will be automatically created. As you can see, we have to create a on_nomatch callback to open the sub-menu, but once opened, it automatically close whenever needed. Generic menu options \u00b6 There are some options that can be set on any menu class. These options allow for greater customization. They are class attributes (see the example below), so just set them in the class body: keys_go_back (default to [\"@\"] ): the keys to use to go back in the menu hierarchy, from choice to root menu, from sub-menu to parent-menu. By default, only a @ is used. You can change this key for one menu or all of them. You can define multiple return commands if you want. sep_keys (default \".\" ): this is the separator for nested keys. There is no real need to redefine it except if you really need the dot as a key, and need nested keys in your menu. joker_key (default to \"*\" ): used for nested keys to indicate \"any key\". Again, you shouldn't need to change it unless you want to be able to use the @*@ in a command key, and also need nested keys in your menu. min_shortcut (default to 1 ): although we didn't see it here, one can create a menu choice without giving it a key. If so, the menu system will try to \"guess\" the key. This option allows to change the minimum length of any key for security reasons. To set one of them just do so in your menu class(es): class RoomBuildingMenu(BuildingMenu): keys_go_back = [\"/\"] min_shortcut = 2 Conclusion \u00b6 Building menus mean to save you time and create a rich yet simple interface. But they can be complicated to learn and require reading the source code to find out how to do such and such a thing. This documentation, however long, is an attempt at describing this system, but chances are you'll still have questions about it after reading it, especially if you try to push this system to a great extent. Do not hesitate to read the documentation of this contrib, it's meant to be exhaustive but user-friendly.","title":"Building menus"},{"location":"Building-menus.html#the-building_menu-contrib","text":"This contrib allows you to write custom and easy to use building menus. As the name implies, these menus are most useful for building things, that is, your builders might appreciate them, although you can use them for your players as well. Building menus are somewhat similar to EvMenu although they don't use the same system at all and are intended to make building easier. They replicate what other engines refer to as \"building editors\", which allow to you to build in a menu instead of having to enter a lot of complex commands. Builders might appreciate this simplicity, and if the code that was used to create them is simple as well, coders could find this contrib useful.","title":"The building_menu contrib"},{"location":"Building-menus.html#a-simple-menu","text":"Before diving in, there are some things to point out: Building menus work on an object. This object will be edited by manipulations in the menu. So you can create a menu to add/edit a room, an exit, a character and so on. Building menus are arranged in layers of choices. A choice gives access to an option or to a sub-menu. Choices are linked to commands (usually very short). For instance, in the example shown below, to edit the room key, after opening the building menu, you can type k . That will lead you to the key choice where you can enter a new key for the room. Then you can enter @ to leave this choice and go back to the entire menu. (All of this can be changed). To open the menu, you will need something like a command. This contrib offers a basic command for demonstration, but we will override it in this example, using the same code with more flexibility. So let's add a very basic example to begin with.","title":"A simple menu"},{"location":"Building-menus.html#a-generic-editing-command","text":"Let's begin by adding a new command. You could add or edit the following file (there's no trick here, feel free to organize the code differently): # file: commands/building.py from evennia.contrib.building_menu import BuildingMenu from commands.command import Command class EditCmd(Command): \"\"\" Editing command. Usage: @edit [object] Open a building menu to edit the specified object. This menu allows to specific information about this object. Examples: @edit here @edit self @edit #142 \"\"\" key = \"@edit\" locks = \"cmd:id(1) or perm(Builders)\" help_category = \"Building\" def func(self): if not self.args.strip(): self.msg(\"|rYou should provide an argument to this function: the object to edit.|n\") return obj = self.caller.search(self.args.strip(), global_search=True) if not obj: return if obj.typename == \"Room\": Menu = RoomBuildingMenu else: self.msg(\"|rThe object {} cannot be edited.|n\".format(obj.get_display_name(self.caller))) return menu = Menu(self.caller, obj) menu.open() This command is rather simple in itself: It has a key @edit and a lock to only allow builders to use it. In its func method, it begins by checking the arguments, returning an error if no argument is specified. It then searches for the given argument. We search globally. The search method used in this way will return the found object or None . It will also send the error message to the caller if necessary. Assuming we have found an object, we check the object typename . This will be used later when we want to display several building menus. For the time being, we only handle Room . If the caller specified something else, we'll display an error. Assuming this object is a Room , we have defined a Menu object containing the class of our building menu. We build this class (creating an instance), giving it the caller and the object to edit. We then open the building menu, using the open method. The end might sound a bit surprising at first glance. But the process is still very simple: we create an instance of our building menu and call its open method. Nothing more. Where is our building menu? If you go ahead and add this command and test it, you'll get an error. We haven't defined RoomBuildingMenu yet. To add this command, edit commands/default_cmdsets.py . Import our command, adding an import line at the top of the file: \"\"\" ... \"\"\" from evennia import default_cmds # The following line is to be added from commands.building import EditCmd And in the class below ( CharacterCmdSet ), add the last line of this code: class CharacterCmdSet(default_cmds.CharacterCmdSet): \"\"\" The `CharacterCmdSet` contains general in-game commands like `look`, `get`, etc available on in-game Character objects. It is merged with the `AccountCmdSet` when an Account puppets a Character. \"\"\" key = \"DefaultCharacter\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # # any commands you add below will overload the default ones. # self.add(EditCmd())","title":"A generic editing command"},{"location":"Building-menus.html#our-first-menu","text":"So far, we can't use our building menu. Our @edit command will throw an error. We have to define the RoomBuildingMenu class. Open the commands/building.py file and add to the end of the file: # ... at the end of commands/building.py # Our building menu class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"key\", \"k\", attr=\"key\") Save these changes, reload your game. You can now use the @edit command. Here's what we get (notice that the commands we enter into the game are prefixed with > , though this prefix will probably not appear in your MUD client): > look Limbo(#2) Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need help, want to contribute, report issues or just join the community. As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build. > @edit here Building menu: Limbo [K]ey: Limbo [Q]uit the menu > q Closing the building menu. > @edit here Building menu: Limbo [K]ey: Limbo [Q]uit the menu > k ------------------------------------------------------------------------------- key for Limbo(#2) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: Limbo > A beautiful meadow ------------------------------------------------------------------------------- key for A beautiful meadow(#2) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: A beautiful meadow > @ Building menu: A beautiful meadow [K]ey: A beautiful meadow [Q]uit the menu > q Closing the building menu. > look A beautiful meadow(#2) Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need help, want to contribute, report issues or just join the community. As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build. Before diving into the code, let's examine what we have: When we use the @edit here command, a building menu for this room appears. This menu has two choices: Enter k to edit the room key. You will go into a choice where you can simply type the key room key (the way we have done here). You can use @ to go back to the menu. You can use q to quit the menu. We then check, with the look command, that the menu has modified this room key. So by adding a class, with a method and a single line of code within, we've added a menu with two choices.","title":"Our first menu"},{"location":"Building-menus.html#code-explanation","text":"Let's examine our code again: class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"key\", \"k\", attr=\"key\") We first create a class inheriting from BuildingMenu . This is usually the case when we want to create a building menu with this contrib. In this class, we override the init method, which is called when the menu opens. In this init method, we call add_choice . This takes several arguments, but we've defined only three here: The choice name. This is mandatory and will be used by the building menu to know how to display this choice. The command key to access this choice. We've given a simple \"k\" . Menu commands usually are pretty short (that's part of the reason building menus are appreciated by builders). You can also specify additional aliases, but we'll see that later. We've added a keyword argument, attr . This tells the building menu that when we are in this choice, the text we enter goes into this attribute name. It's called attr , but it could be a room attribute or a typeclass persistent or non-persistent attribute (we'll see other examples as well). We've added the menu choice for key here, why is another menu choice defined for quit ? Our building menu creates a choice at the end of our choice list if it's a top-level menu (sub-menus don't have this feature). You can, however, override it to provide a different \"quit\" message or to perform some actions. I encourage you to play with this code. As simple as it is, it offers some functionalities already.","title":"Code explanation"},{"location":"Building-menus.html#customizing-building-menus","text":"This somewhat long section explains how to customize building menus. There are different ways depending on what you would like to achieve. We'll go from specific to more advanced here.","title":"Customizing building menus"},{"location":"Building-menus.html#generic-choices","text":"In the previous example, we've used add_choice . This is one of three methods you can use to add choices. The other two are to handle more generic actions: add_choice_edit : this is called to add a choice which points to the EvEditor . It is used to edit a description in most cases, although you could edit other things. We'll see an example shortly. add_choice_edit uses most of the add_choice keyword arguments we'll see, but usually we specify only two (sometimes three): The choice title as usual. The choice key (command key) as usual. Optionally, the attribute of the object to edit, with the attr keyword argument. By default, attr contains db.desc . It means that this persistent data attribute will be edited by the EvEditor . You can change that to whatever you want though. add_choice_quit : this allows to add a choice to quit the editor. Most advisable! If you don't do it, the building menu will do it automatically, except if you really tell it not to. Again, you can specify the title and key of this menu. You can also call a function when this menu closes. So here's a more complete example (you can replace your RoomBuildingMenu class in commands/building.py to see it): class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"key\", \"k\", attr=\"key\") self.add_choice_edit(\"description\", \"d\") self.add_choice_quit(\"quit this editor\", \"q\") So far, our building menu class is still thin... and yet we already have some interesting feature. See for yourself the following MUD client output (again, the commands are prefixed with > to distinguish them): > @reload > @edit here Building menu: A beautiful meadow [K]ey: A beautiful meadow [D]escription: Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need help, want to contribute, report issues or just join the community. As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build. [Q]uit this editor > d ----------Line Editor [editor]---------------------------------------------------- 01| Welcome to your new |wEvennia|n-based game! Visit http://www.evennia.com if you need 02| help, want to contribute, report issues or just join the community. 03| As Account #1 you can create a demo/tutorial area with |w@batchcommand tutorial_world.build|n. > :DD ----------[l:03 w:034 c:0247]------------(:h for help)---------------------------- Cleared 3 lines from buffer. > This is a beautiful meadow. But so beautiful I can't describe it. 01| This is a beautiful meadow. But so beautiful I can't describe it. > :wq Building menu: A beautiful meadow [K]ey: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [Q]uit this editor > q Closing the building menu. > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. So by using the d shortcut in our building menu, an EvEditor opens. You can use the EvEditor commands (like we did here, :DD to remove all, :wq to save and quit). When you quit the editor, the description is saved (here, in room.db.desc ) and you go back to the building menu. Notice that the choice to quit has changed too, which is due to our adding add_choice_quit . In most cases, you will probably not use this method, since the quit menu is added automatically.","title":"Generic choices"},{"location":"Building-menus.html#add_choice-options","text":"add_choice and the two methods add_choice_edit and add_choice_quit take a lot of optional arguments to make customization easier. Some of these options might not apply to add_choice_edit or add_choice_quit however. Below are the options of add_choice , specify them as arguments: The first positional, mandatory argument is the choice title, as we have seen. This will influence how the choice appears in the menu. The second positional, mandatory argument is the command key to access to this menu. It is best to use keyword arguments for the other arguments. The aliases keyword argument can contain a list of aliases that can be used to access to this menu. For instance: add_choice(..., aliases=['t']) The attr keyword argument contains the attribute to edit when this choice is selected. It's a string, it has to be the name, from the object (specified in the menu constructor) to reach this attribute. For instance, a attr of \"key\" will try to find obj.key to read and write the attribute. You can specify more complex attribute names, for instance, attr=\"db.desc\" to set the desc persistent attribute, or attr=\"ndb.something\" so use a non-persistent data attribute on the object. The text keyword argument is used to change the text that will be displayed when the menu choice is selected. Menu choices provide a default text that you can change. Since this is a long text, it's useful to use multi-line strings (see an example below). The glance keyword argument is used to specify how to display the current information while in the menu, when the choice hasn't been opened. If you examine the previous examples, you will see that the current ( key or db.desc ) was shown in the menu, next to the command key. This is useful for seeing at a glance the current value (hence the name). Again, menu choices will provide a default glance if you don't specify one. The on_enter keyword argument allows to add a callback to use when the menu choice is opened. This is more advanced, but sometimes useful. The on_nomatch keyword argument is called when, once in the menu, the caller enters some text that doesn't match any command (including the @ command). By default, this will edit the specified attr . The on_leave keyword argument allows to specify a callback used when the caller leaves the menu choice. This can be useful for cleanup as well. These are a lot of possibilities, and most of the time you won't need them all. Here is a short example using some of these arguments (again, replace the RoomBuildingMenu class in commands/building.py with the following code to see it working): class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") Reload your game and see it in action: > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [Q]uit the menu > t ------------------------------------------------------------------------------- Editing the title of A beautiful meadow(#2) You can change the title simply by entering it. Use @ to go back to the main menu. Current title: A beautiful meadow > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [Q]uit the menu > q Closing the building menu. The most surprising part is no doubt the text. We use the multi-line syntax (with \"\"\" ). Excessive spaces will be removed from the left for each line automatically. We specify some information between braces... sometimes using double braces. What might be a bit odd: {back} is a direct format argument we'll use (see the .format specifiers). {{obj...}} refers to the object being edited. We use two braces, because .format` will remove them. In glance , we also use {obj.key} to indicate we want to show the room's key.","title":"add_choice options"},{"location":"Building-menus.html#everything-can-be-a-function","text":"The keyword arguments of add_choice are often strings (type str ). But each of these arguments can also be a function. This allows for a lot of customization, since we define the callbacks that will be executed to achieve such and such an operation. To demonstrate, we will try to add a new feature. Our building menu for rooms isn't that bad, but it would be great to be able to edit exits too. So we can add a new menu choice below description... but how to actually edit exits? Exits are not just an attribute to set: exits are objects (of type Exit by default) which stands between two rooms (object of type Room ). So how can we show that? First let's add a couple of exits in limbo, so we have something to work with: @tunnel n @tunnel s This should create two new rooms, exits leading to them from limbo and back to limbo. > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. Exits: north(#4) and south(#7) We can access room exits with the exits property: > @py here.exits [<Exit: north>, <Exit: south>] So what we need is to display this list in our building menu... and to allow to edit it would be great. Perhaps even add new exits? First of all, let's write a function to display the glance on existing exits. Here's the code, it's explained below: class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, attr=\"exits\") # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" When the building menu opens, it displays each choice to the caller. A choice is displayed with its title (rendered a bit nicely to show the key as well) and the glance. In the case of the exits choice, the glance is a function, so the building menu calls this function giving it the object being edited (the room here). The function should return the text to see. > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > q Closing the editor. How do I know the parameters of the function to give? The function you give can accept a lot of different parameters. This allows for a flexible approach but might seem complicated at first. Basically, your function can accept any parameter, and the building menu will send only the parameter based on their names. If your function defines an argument named caller for instance (like def func(caller): ), then the building menu knows that the first argument should contain the caller of the building menu. Here are the arguments, you don't have to specify them (if you do, they need to have the same name): menu : if your function defines an argument named menu , it will contain the building menu itself. choice : if your function defines an argument named choice , it will contain the Choice object representing this menu choice. string : if your function defines an argument named string , it will contain the user input to reach this menu choice. This is not very useful, except on nomatch callbacks which we'll see later. obj : if your function defines an argument named obj , it will contain the building menu edited object. caller : if your function defines an argument named caller , it will contain the caller of the building menu. Anything else: any other argument will contain the object being edited by the building menu. So in our case: def glance_exits(room): The only argument we need is room . It's not present in the list of possible arguments, so the editing object of the building menu (the room, here) is given. Why is it useful to get the menu or choice object? Most of the time, you will not need these arguments. In very rare cases, you will use them to get specific data (like the default attribute that was set). This tutorial will not elaborate on these possibilities. Just know that they exist. We should also define a text callback, so that we can enter our menu to see the room exits. We'll see how to edit them in the next section but this is a good opportunity to show a more complete callback. To see it in action, as usual, replace the class and functions in commands/building.py : # Our building menu class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, attr=\"exits\", text=text_exits) # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" def text_exits(caller, room): \"\"\"Show the room exits in the choice itself.\"\"\" text = \"-\" * 79 text += \"\\n\\nRoom exits:\" text += \"\\n Use |y@c|n to create a new exit.\" text += \"\\n\\nExisting exits:\" if room.exits: for exit in room.exits: text += \"\\n |y@e {exit}|n\".format(exit=exit.key) if exit.aliases.all(): text += \" (|y{aliases}|n)\".format(aliases=\"|n, |y\".join( alias for alias in exit.aliases.all())) if exit.destination: text += \" toward {destination}\".format(destination=exit.get_display_name(caller)) else: text += \"\\n\\n |gNo exit has yet been defined.|n\" return text Look at the second callback in particular. It takes an additional argument, the caller (remember, the argument names are important, their order is not relevant). This is useful for displaying destination of exits accurately. Here is a demonstration of this menu: > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > e ------------------------------------------------------------------------------- Room exits: Use @c to create a new exit. Existing exits: @e north (n) toward north(#4) @e south (s) toward south(#7) > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > q Closing the building menu. Using callbacks allows a great flexibility. We'll now see how to handle sub-menus.","title":"Everything can be a function"},{"location":"Building-menus.html#sub-menus-for-complex-menus","text":"A menu is relatively flat: it has a root (where you see all the menu choices) and individual choices you can go to using the menu choice keys. Once in a choice you can type some input or go back to the root menu by entering the return command (usually @ ). Why shouldn't individual exits have their own menu though? Say, you edit an exit and can change its key, description or aliases... perhaps even destination? Why ever not? It would make building much easier! The building menu system offers two ways to do that. The first is nested keys: nested keys allow to go beyond just one menu/choice, to have menus with more layers. Using them is quick but might feel a bit counter-intuitive at first. Another option is to create a different menu class and redirect from the first to the second. This option might require more lines but is more explicit and can be re-used for multiple menus. Adopt one of them depending of your taste.","title":"Sub-menus for complex menus"},{"location":"Building-menus.html#nested-menu-keys","text":"So far, we've only used menu keys with one letter. We can add more, of course, but menu keys in their simple shape are just command keys. Press \"e\" to go to the \"exits\" choice. But menu keys can be nested. Nested keys allow to add choices with sub-menus. For instance, type \"e\" to go to the \"exits\" choice, and then you can type \"c\" to open a menu to create a new exit, or \"d\" to open a menu to delete an exit. The first menu would have the \"e.c\" key (first e, then c), the second menu would have key as \"e.d\". That's more advanced and, if the following code doesn't sound very friendly to you, try the next section which provides a different approach of the same problem. So we would like to edit exits. That is, you can type \"e\" to go into the choice of exits, then enter @e followed by the exit name to edit it... which will open another menu. In this sub-menu you could change the exit key or description. So we have a menu hierarchy similar to that: t Change the room title d Change the room description e Access the room exits [exit name] Access the exit name sub-menu [text] Change the exit key Or, if you prefer an example output: > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. Exits: north(#4) and south(#7) > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > e ------------------------------------------------------------------------------- Room exits : Use @c to create a new exit. Existing exits: @e north (n) toward north(#4) @e south (s) toward south(#7) > @e north Editing: north Exit north: Enter the exit key to change it, or @ to go back. New exit key: > door Exit door: Enter the exit key to change it, or @ to go back. New exit key: > @ ------------------------------------------------------------------------------- Room exits : Use @c to create a new exit. Existing exits: @e door (n) toward door(#4) @e south (s) toward south(#7) > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: door south [Q]uit the menu > q Closing the building menu. This needs a bit of code and a bit of explanation. So here we go... the code first, the explanations next! # ... from commands/building.py # Our building menu class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. For the time being, we have only one choice: key, to edit the room key. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, text=text_exits, on_nomatch=nomatch_exits) # Exit sub-menu self.add_choice(\"exit\", \"e.*\", text=text_single_exit, on_nomatch=nomatch_single_exit) # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" def text_exits(caller, room): \"\"\"Show the room exits in the choice itself.\"\"\" text = \"-\" * 79 text += \"\\n\\nRoom exits:\" text += \"\\n Use |y@c|n to create a new exit.\" text += \"\\n\\nExisting exits:\" if room.exits: for exit in room.exits: text += \"\\n |y@e {exit}|n\".format(exit=exit.key) if exit.aliases.all(): text += \" (|y{aliases}|n)\".format(aliases=\"|n, |y\".join( alias for alias in exit.aliases.all())) if exit.destination: text += \" toward {destination}\".format(destination=exit.get_display_name(caller)) else: text += \"\\n\\n |gNo exit has yet been defined.|n\" return text def nomatch_exits(menu, caller, room, string): \"\"\" The user typed something in the list of exits. Maybe an exit name? \"\"\" string = string[3:] exit = caller.search(string, candidates=room.exits) if exit is None: return # Open a sub-menu, using nested keys caller.msg(\"Editing: {}\".format(exit.key)) menu.move(exit) return False # Exit sub-menu def text_single_exit(menu, caller): \"\"\"Show the text to edit single exits.\"\"\" exit = menu.keys[1] if exit is None: return \"\" return \"\"\" Exit {exit}: Enter the exit key to change it, or |y@|n to go back. New exit key: \"\"\".format(exit=exit.key) def nomatch_single_exit(menu, caller, room, string): \"\"\"The user entered something in the exit sub-menu. Replace the exit key.\"\"\" # exit is the second key element: keys should contain ['e', <Exit object>] exit = menu.keys[1] if exit is None: caller.msg(\"|rCannot find the exit.|n\") menu.move(back=True) return False exit.key = string return True That's a lot of code! And we only handle editing the exit key! That's why at some point you might want to write a real sub-menu, instead of using simple nested keys. But you might need both to build pretty menus too! The first thing new is in our menu class. After creating a on_nomatch callback for the exits menu (that shouldn't be a surprised), we need to add a nested key. We give this menu a key of \"e.*\" . That's a bit odd! \"e\" is our key to the exits menu, . is the separator to indicate a nested menu, and * means anything. So basically, we create a nested menu that is contains within the exits menu and anything. We'll see what this \"anything\" is in practice. The glance_exits and text_exits are basically the same. The nomatch_exits is short but interesting. It's called when we enter some text in the \"exits\" menu (that is, in the list of exits). We have said that the user should enter @e followed by the exit name to edit it. So in the nomatch_exits callbac, we check for that input. If the entered text begins by @e , we try to find the exit in the room. If we do... We call the menu.move method. That's where things get a bit complicated with nested menus: we need to use menu.move to change from layer to layer. Here, we are in the choice of exits (the exits menu, of key \"e\"). We need to go down one layer to edit an exit. So we call menu.move and give it an exit object. The menu system remembers what position the user is based on the keys she has entered: when the user opens the menu, there is no key. If she selects the exits choice, the menu key being \"e\", the position of the user is [\"e\"] (a list with the menu keys). If we call menu.move , whatever we give to this method will be appended to the list of keys, so that the user position becomes [\"e\", <Exit object>] . In the menu class, we have defined the menu \"e.*\", meaning \"the menu contained in the exits choice plus anything\". The \"anything\" here is an exit: we have called menu.move(exit) , so the \"e.*\" menu choice is chosen. In this menu, the text is set to a callback. There is also a on_nomatch callback that is called whenever the user enters some text. If so, we change the exit name. Using menu.move like this is a bit confusing at first. Sometimes it's useful. In this case, if we want a more complex menu for exits, it makes sense to use a real sub-menu, not nested keys like this. But sometimes, you will find yourself in a situation where you don't need a full menu to handle a choice.","title":"Nested menu keys"},{"location":"Building-menus.html#full-sub-menu-as-separate-classes","text":"The best way to handle individual exits is to create two separate classes: One for the room menu. One for the individual exit menu. The first one will have to redirect on the second. This might be more intuitive and flexible, depending on what you want to achieve. So let's build two menus: # Still in commands/building.py, replace the menu class and functions by... # Our building menus class RoomBuildingMenu(BuildingMenu): \"\"\" Building menu to edit a room. \"\"\" def init(self, room): self.add_choice(\"title\", key=\"t\", attr=\"key\", glance=\"{obj.key}\", text=\"\"\" ------------------------------------------------------------------------------- Editing the title of {{obj.key}}(#{{obj.id}}) You can change the title simply by entering it. Use |y{back}|n to go back to the main menu. Current title: |c{{obj.key}}|n \"\"\".format(back=\"|n or |y\".join(self.keys_go_back))) self.add_choice_edit(\"description\", \"d\") self.add_choice(\"exits\", \"e\", glance=glance_exits, text=text_exits, on_nomatch=nomatch_exits) # Menu functions def glance_exits(room): \"\"\"Show the room exits.\"\"\" if room.exits: glance = \"\" for exit in room.exits: glance += \"\\n |y{exit}|n\".format(exit=exit.key) return glance return \"\\n |gNo exit yet|n\" def text_exits(caller, room): \"\"\"Show the room exits in the choice itself.\"\"\" text = \"-\" * 79 text += \"\\n\\nRoom exits:\" text += \"\\n Use |y@c|n to create a new exit.\" text += \"\\n\\nExisting exits:\" if room.exits: for exit in room.exits: text += \"\\n |y@e {exit}|n\".format(exit=exit.key) if exit.aliases.all(): text += \" (|y{aliases}|n)\".format(aliases=\"|n, |y\".join( alias for alias in exit.aliases.all())) if exit.destination: text += \" toward {destination}\".format(destination=exit.get_display_name(caller)) else: text += \"\\n\\n |gNo exit has yet been defined.|n\" return text def nomatch_exits(menu, caller, room, string): \"\"\" The user typed something in the list of exits. Maybe an exit name? \"\"\" string = string[3:] exit = caller.search(string, candidates=room.exits) if exit is None: return # Open a sub-menu, using nested keys caller.msg(\"Editing: {}\".format(exit.key)) menu.open_submenu(\"commands.building.ExitBuildingMenu\", exit, parent_keys=[\"e\"]) return False class ExitBuildingMenu(BuildingMenu): \"\"\" Building menu to edit an exit. \"\"\" def init(self, exit): self.add_choice(\"key\", key=\"k\", attr=\"key\", glance=\"{obj.key}\") self.add_choice_edit(\"description\", \"d\") The code might be much easier to read. But before detailing it, let's see how it behaves in the game: > @edit here Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: door south [Q]uit the menu > e ------------------------------------------------------------------------------- Room exits: Use @c to create a new exit. Existing exits: @e door (n) toward door(#4) @e south (s) toward south(#7) Editing: door > @e door Building menu: door [K]ey: door [D]escription: None > k ------------------------------------------------------------------------------- key for door(#4) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: door > north ------------------------------------------------------------------------------- key for north(#4) You can change this value simply by entering it. Use @ to go back to the main menu. Current value: north > @ Building menu: north [K]ey: north [D]escription: None > d ----------Line Editor [editor]---------------------------------------------------- 01| None ----------[l:01 w:001 c:0004]------------(:h for help)---------------------------- > :DD Cleared 1 lines from buffer. > This is the northern exit. Cool huh? 01| This is the northern exit. Cool huh? > :wq Building menu: north [K]ey: north [D]escription: This is the northern exit. Cool huh? > @ ------------------------------------------------------------------------------- Room exits: Use @c to create a new exit. Existing exits: @e north (n) toward north(#4) @e south (s) toward south(#7) > @ Building menu: A beautiful meadow [T]itle: A beautiful meadow [D]escription: This is a beautiful meadow. But so beautiful I can't describe it. [E]xits: north south [Q]uit the menu > q Closing the building menu. > look A beautiful meadow(#2) This is a beautiful meadow. But so beautiful I can't describe it. Exits: north(#4) and south(#7) > @py here.exits[0] >>> here.exits[0] north > @py here.exits[0].db.desc >>> here.exits[0].db.desc This is the northern exit. Cool huh? Very simply, we created two menus and bridged them together. This needs much less callbacks. There is only one line in the nomatch_exits to add: menu.open_submenu(\"commands.building.ExitBuildingMenu\", exit, parent_keys=[\"e\"]) We have to call open_submenu on the menu object (which opens, as its name implies, a sub menu) with three arguments: The path of the menu class to create. It's the Python class leading to the menu (notice the dots). The object that will be edited by the menu. Here, it's our exit, so we give it to the sub-menu. The keys of the parent to open when the sub-menu closes. Basically, when we're in the root of the sub-menu and press @ , we'll open the parent menu, with the parent keys. So we specify [\"e\"] , since the parent menus is the \"exits\" choice. And that's it. The new class will be automatically created. As you can see, we have to create a on_nomatch callback to open the sub-menu, but once opened, it automatically close whenever needed.","title":"Full sub-menu as separate classes"},{"location":"Building-menus.html#generic-menu-options","text":"There are some options that can be set on any menu class. These options allow for greater customization. They are class attributes (see the example below), so just set them in the class body: keys_go_back (default to [\"@\"] ): the keys to use to go back in the menu hierarchy, from choice to root menu, from sub-menu to parent-menu. By default, only a @ is used. You can change this key for one menu or all of them. You can define multiple return commands if you want. sep_keys (default \".\" ): this is the separator for nested keys. There is no real need to redefine it except if you really need the dot as a key, and need nested keys in your menu. joker_key (default to \"*\" ): used for nested keys to indicate \"any key\". Again, you shouldn't need to change it unless you want to be able to use the @*@ in a command key, and also need nested keys in your menu. min_shortcut (default to 1 ): although we didn't see it here, one can create a menu choice without giving it a key. If so, the menu system will try to \"guess\" the key. This option allows to change the minimum length of any key for security reasons. To set one of them just do so in your menu class(es): class RoomBuildingMenu(BuildingMenu): keys_go_back = [\"/\"] min_shortcut = 2","title":"Generic menu options"},{"location":"Building-menus.html#conclusion","text":"Building menus mean to save you time and create a rich yet simple interface. But they can be complicated to learn and require reading the source code to find out how to do such and such a thing. This documentation, however long, is an attempt at describing this system, but chances are you'll still have questions about it after reading it, especially if you try to push this system to a great extent. Do not hesitate to read the documentation of this contrib, it's meant to be exhaustive but user-friendly.","title":"Conclusion"},{"location":"Choosing-An-SQL-Server.html","text":"This page gives an overview of the supported SQL databases as well as instructions on install: SQLite3 (default) PostgreSQL MySQL / MariaDB Since Evennia uses Django , most of our notes are based off of what we know from the community and their documentation. While the information below may be useful, you can always find the most up-to-date and \"correct\" information at Django's Notes about supported Databases page. SQLite3 \u00b6 SQLite3 is a light weight single-file database. It is our default database and Evennia will set this up for you automatically if you give no other options. SQLite stores the database in a single file ( mygame/server/evennia.db3 ). This means it's very easy to reset this database - just delete (or move) that evennia.db3 file and run evennia migrate again! No server process is needed and the administrative overhead and resource consumption is tiny. It is also very fast since it's run in-memory. For the vast majority of Evennia installs it will probably be all that's ever needed. SQLite will generally be much faster than MySQL/PostgreSQL but its performance comes with two drawbacks: SQLite ignores length constraints by design ; it is possible to store very large strings and numbers in fields that technically should not accept them. This is not something you will notice; your game will read and write them and function normally, but this can create some data migration problems requiring careful thought if you do need to change databases later. SQLite can scale well to storage of millions of objects, but if you end up with a thundering herd of users trying to access your MUD and web site at the same time, or you find yourself writing long-running functions to update large numbers of objects on a live game, either will yield errors and interference. SQLite does not work reliably with multiple concurrent threads or processes accessing its records. This has to do with file-locking clashes of the database file. So for a production server making heavy use of process- or thread pools (or when using a third-party webserver like Apache), a proper database is a more appropriate choice. Install of SQlite3 \u00b6 This is installed and configured as part of Evennia. The database file is created as mygame/server/evennia.db3 when you run evennia migrate without changing any database options. An optional requirement is the sqlite3 client program - this is required if you want to inspect the database data manually. A shortcut for using it with the evennia database is evennia dbshell . Linux users should look for the sqlite3 package for their distro while Mac/Windows should get the sqlite-tools package from this page . To inspect the default Evennia database (once it's been created), go to your game dir and do sqlite3 server/evennia.db3 # or evennia dbshell This will bring you into the sqlite command line. Use .help for instructions and .quit to exit. See here for a cheat-sheet of commands. PostgreSQL \u00b6 PostgreSQL is an open-source database engine, recommended by Django. While not as fast as SQLite for normal usage, it will scale better than SQLite, especially if your game has an very large database and/or extensive web presence through a separate server process. Install and initial setup of PostgreSQL \u00b6 First, install the posgresql server. Version 9.6 is tested with Evennia. Packages are readily available for all distributions. You need to also get the psql client (this is called postgresql-client on debian-derived systems). Windows/Mac users can find what they need on the postgresql download page . You should be setting up a password for your database-superuser (always called postgres ) when you install. For interaction with Evennia you need to also install psycopg2 to your Evennia install ( pip install psycopg2-binary in your virtualenv). This acts as the python bridge to the database server. Next, start the postgres client: psql -U postgres --password :warning: Warning: With the --password argument, Postgres should prompt you for a password. If it won't, replace that with -p yourpassword instead. Do not use the -p argument unless you have to since the resulting command, and your password, will be logged in the shell history. This will open a console to the postgres service using the psql client. On the psql command line: CREATE USER evennia WITH PASSWORD 'somepassword'; CREATE DATABASE evennia; # Postgres-specific optimizations # https://docs.djangoproject.com/en/dev/ref/databases/#optimizing-postgresql-s-configuration ALTER ROLE evennia SET client_encoding TO 'utf8'; ALTER ROLE evennia SET default_transaction_isolation TO 'read committed'; ALTER ROLE evennia SET timezone TO 'UTC'; GRANT ALL PRIVILEGES ON DATABASE evennia TO evennia; \\l # list all databases and permissions \\q # exit Here is a cheat-sheet for psql commands. We create a database user 'evennia' and a new database named evennia (you can call them whatever you want though). We then grant the 'evennia' user full privileges to the new database so it can read/write etc to it. If you in the future wanted to completely wipe the database, an easy way to do is to log in as the postgres superuser again, then do DROP DATABASE evennia; , then CREATE and GRANT steps above again to recreate the database and grant privileges. Evennia PostgreSQL configuration \u00b6 Edit `mygame/server/conf/secret_settings.py and add the following section: # # PostgreSQL Database Configuration # DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'evennia', 'USER': 'evennia', 'PASSWORD': 'somepassword', 'HOST': 'localhost', 'PORT': '' # use default }} If you used some other name for the database and user, enter those instead. Run evennia migrate to populate your database. Should you ever want to inspect the database directly you can from now on also use evennia dbshell as a shortcut to get into the postgres command line for the right database and user. With the database setup you should now be able to start start Evennia normally with your new database. MySQL / MariaDB \u00b6 MySQL is a commonly used proprietary database system, on par with PostgreSQL. There is an open-source alternative called MariaDB that mimics all functionality and command syntax of the former. So this section covers both. Installing and initial setup of MySQL/MariaDB \u00b6 First, install and setup MariaDB or MySQL for your specific server. Linux users should look for the mysql-server or mariadb-server packages for their respective distributions. Windows/Mac users will find what they need from the MySQL downloads or MariaDB downloads pages. You also need the respective database clients ( mysql , mariadb-client ), so you can setup the database itself. When you install the server you should usually be asked to set up the database root user and password. You will finally also need a Python interface to allow Evennia to talk to the database. Django recommends the mysqlclient one. Install this into the evennia virtualenv with pip install mysqlclient . Start the database client (this is named the same for both mysql and mariadb): mysql -u root -p You should get to enter your database root password (set this up when you installed the database server). Inside the database client interface: CREATE USER 'evennia'@'localhost' IDENTIFIED BY 'somepassword'; CREATE DATABASE evennia; ALTER DATABASE `evennia` CHARACTER SET utf8; # note that it's `evennia` not 'evennia'! GRANT ALL PRIVILEGES ON evennia.* TO 'evennia'@'localhost'; FLUSH PRIVILEGES; exit Here is a mysql command cheat sheet. Above we created a new local user and database (we called both 'evennia' here, you can name them what you prefer). We set the character set to utf8 to avoid an issue with prefix character length that can pop up on some installs otherwise. Next we grant the 'evennia' user all privileges on the evennia database and make sure the privileges are applied. Exiting the client brings us back to the normal terminal/console. Note: If you are not using MySQL for anything else you might consider granting the 'evennia' user full privileges with GRANT ALL PRIVILEGES ON *.* TO 'evennia'@'localhost'; . If you do, it means you can use evennia dbshell later to connect to mysql, drop your database and re-create it as a way of easy reset. Without this extra privilege you will be able to drop the database but not re-create it without first switching to the database-root user. Add MySQL configuration to Evennia \u00b6 To tell Evennia to use your new database you need to edit mygame/server/conf/settings.py (or secret_settings.py if you don't want your db info passed around on git repositories). Note: The Django documentation suggests using an external db.cnf or other external conf-formatted file. Evennia users have however found that this leads to problems (see e.g. issue #1184 ). To avoid trouble we recommend you simply put the configuration in your settings as below. # # MySQL Database Configuration # DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'evennia', 'USER': 'evennia', 'PASSWORD': 'somepassword', 'HOST': 'localhost', # or an IP Address that your DB is hosted on 'PORT': '', # use default port } } Change this to fit your database setup. Next, run: evennia migrate to populate your database. Should you ever want to inspect the database directly you can from now on also use evennia dbshell as a shortcut to get into the postgres command line for the right database and user. With the database setup you should now be able to start start Evennia normally with your new database. Others \u00b6 No testing has been performed with Oracle, but it is also supported through Django. There are community maintained drivers for MS SQL and possibly a few others. If you try other databases out, consider expanding this page with instructions.","title":"Choosing An SQL Server"},{"location":"Choosing-An-SQL-Server.html#sqlite3","text":"SQLite3 is a light weight single-file database. It is our default database and Evennia will set this up for you automatically if you give no other options. SQLite stores the database in a single file ( mygame/server/evennia.db3 ). This means it's very easy to reset this database - just delete (or move) that evennia.db3 file and run evennia migrate again! No server process is needed and the administrative overhead and resource consumption is tiny. It is also very fast since it's run in-memory. For the vast majority of Evennia installs it will probably be all that's ever needed. SQLite will generally be much faster than MySQL/PostgreSQL but its performance comes with two drawbacks: SQLite ignores length constraints by design ; it is possible to store very large strings and numbers in fields that technically should not accept them. This is not something you will notice; your game will read and write them and function normally, but this can create some data migration problems requiring careful thought if you do need to change databases later. SQLite can scale well to storage of millions of objects, but if you end up with a thundering herd of users trying to access your MUD and web site at the same time, or you find yourself writing long-running functions to update large numbers of objects on a live game, either will yield errors and interference. SQLite does not work reliably with multiple concurrent threads or processes accessing its records. This has to do with file-locking clashes of the database file. So for a production server making heavy use of process- or thread pools (or when using a third-party webserver like Apache), a proper database is a more appropriate choice.","title":"SQLite3"},{"location":"Choosing-An-SQL-Server.html#install-of-sqlite3","text":"This is installed and configured as part of Evennia. The database file is created as mygame/server/evennia.db3 when you run evennia migrate without changing any database options. An optional requirement is the sqlite3 client program - this is required if you want to inspect the database data manually. A shortcut for using it with the evennia database is evennia dbshell . Linux users should look for the sqlite3 package for their distro while Mac/Windows should get the sqlite-tools package from this page . To inspect the default Evennia database (once it's been created), go to your game dir and do sqlite3 server/evennia.db3 # or evennia dbshell This will bring you into the sqlite command line. Use .help for instructions and .quit to exit. See here for a cheat-sheet of commands.","title":"Install of SQlite3"},{"location":"Choosing-An-SQL-Server.html#postgresql","text":"PostgreSQL is an open-source database engine, recommended by Django. While not as fast as SQLite for normal usage, it will scale better than SQLite, especially if your game has an very large database and/or extensive web presence through a separate server process.","title":"PostgreSQL"},{"location":"Choosing-An-SQL-Server.html#install-and-initial-setup-of-postgresql","text":"First, install the posgresql server. Version 9.6 is tested with Evennia. Packages are readily available for all distributions. You need to also get the psql client (this is called postgresql-client on debian-derived systems). Windows/Mac users can find what they need on the postgresql download page . You should be setting up a password for your database-superuser (always called postgres ) when you install. For interaction with Evennia you need to also install psycopg2 to your Evennia install ( pip install psycopg2-binary in your virtualenv). This acts as the python bridge to the database server. Next, start the postgres client: psql -U postgres --password :warning: Warning: With the --password argument, Postgres should prompt you for a password. If it won't, replace that with -p yourpassword instead. Do not use the -p argument unless you have to since the resulting command, and your password, will be logged in the shell history. This will open a console to the postgres service using the psql client. On the psql command line: CREATE USER evennia WITH PASSWORD 'somepassword'; CREATE DATABASE evennia; # Postgres-specific optimizations # https://docs.djangoproject.com/en/dev/ref/databases/#optimizing-postgresql-s-configuration ALTER ROLE evennia SET client_encoding TO 'utf8'; ALTER ROLE evennia SET default_transaction_isolation TO 'read committed'; ALTER ROLE evennia SET timezone TO 'UTC'; GRANT ALL PRIVILEGES ON DATABASE evennia TO evennia; \\l # list all databases and permissions \\q # exit Here is a cheat-sheet for psql commands. We create a database user 'evennia' and a new database named evennia (you can call them whatever you want though). We then grant the 'evennia' user full privileges to the new database so it can read/write etc to it. If you in the future wanted to completely wipe the database, an easy way to do is to log in as the postgres superuser again, then do DROP DATABASE evennia; , then CREATE and GRANT steps above again to recreate the database and grant privileges.","title":"Install and initial setup of PostgreSQL"},{"location":"Choosing-An-SQL-Server.html#evennia-postgresql-configuration","text":"Edit `mygame/server/conf/secret_settings.py and add the following section: # # PostgreSQL Database Configuration # DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'evennia', 'USER': 'evennia', 'PASSWORD': 'somepassword', 'HOST': 'localhost', 'PORT': '' # use default }} If you used some other name for the database and user, enter those instead. Run evennia migrate to populate your database. Should you ever want to inspect the database directly you can from now on also use evennia dbshell as a shortcut to get into the postgres command line for the right database and user. With the database setup you should now be able to start start Evennia normally with your new database.","title":"Evennia PostgreSQL configuration"},{"location":"Choosing-An-SQL-Server.html#mysql-mariadb","text":"MySQL is a commonly used proprietary database system, on par with PostgreSQL. There is an open-source alternative called MariaDB that mimics all functionality and command syntax of the former. So this section covers both.","title":"MySQL / MariaDB"},{"location":"Choosing-An-SQL-Server.html#installing-and-initial-setup-of-mysqlmariadb","text":"First, install and setup MariaDB or MySQL for your specific server. Linux users should look for the mysql-server or mariadb-server packages for their respective distributions. Windows/Mac users will find what they need from the MySQL downloads or MariaDB downloads pages. You also need the respective database clients ( mysql , mariadb-client ), so you can setup the database itself. When you install the server you should usually be asked to set up the database root user and password. You will finally also need a Python interface to allow Evennia to talk to the database. Django recommends the mysqlclient one. Install this into the evennia virtualenv with pip install mysqlclient . Start the database client (this is named the same for both mysql and mariadb): mysql -u root -p You should get to enter your database root password (set this up when you installed the database server). Inside the database client interface: CREATE USER 'evennia'@'localhost' IDENTIFIED BY 'somepassword'; CREATE DATABASE evennia; ALTER DATABASE `evennia` CHARACTER SET utf8; # note that it's `evennia` not 'evennia'! GRANT ALL PRIVILEGES ON evennia.* TO 'evennia'@'localhost'; FLUSH PRIVILEGES; exit Here is a mysql command cheat sheet. Above we created a new local user and database (we called both 'evennia' here, you can name them what you prefer). We set the character set to utf8 to avoid an issue with prefix character length that can pop up on some installs otherwise. Next we grant the 'evennia' user all privileges on the evennia database and make sure the privileges are applied. Exiting the client brings us back to the normal terminal/console. Note: If you are not using MySQL for anything else you might consider granting the 'evennia' user full privileges with GRANT ALL PRIVILEGES ON *.* TO 'evennia'@'localhost'; . If you do, it means you can use evennia dbshell later to connect to mysql, drop your database and re-create it as a way of easy reset. Without this extra privilege you will be able to drop the database but not re-create it without first switching to the database-root user.","title":"Installing and initial setup of MySQL/MariaDB"},{"location":"Choosing-An-SQL-Server.html#add-mysql-configuration-to-evennia","text":"To tell Evennia to use your new database you need to edit mygame/server/conf/settings.py (or secret_settings.py if you don't want your db info passed around on git repositories). Note: The Django documentation suggests using an external db.cnf or other external conf-formatted file. Evennia users have however found that this leads to problems (see e.g. issue #1184 ). To avoid trouble we recommend you simply put the configuration in your settings as below. # # MySQL Database Configuration # DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'evennia', 'USER': 'evennia', 'PASSWORD': 'somepassword', 'HOST': 'localhost', # or an IP Address that your DB is hosted on 'PORT': '', # use default port } } Change this to fit your database setup. Next, run: evennia migrate to populate your database. Should you ever want to inspect the database directly you can from now on also use evennia dbshell as a shortcut to get into the postgres command line for the right database and user. With the database setup you should now be able to start start Evennia normally with your new database.","title":"Add MySQL configuration to Evennia"},{"location":"Choosing-An-SQL-Server.html#others","text":"No testing has been performed with Oracle, but it is also supported through Django. There are community maintained drivers for MS SQL and possibly a few others. If you try other databases out, consider expanding this page with instructions.","title":"Others"},{"location":"Client-Support-Grid.html","text":"This grid tries to gather Evennia-specific knowledge about the various clients and protocols used. Everyone's welcome to report their findings. Legend: \u00b6 Name : The name of the client. If it's only available for a specific OS, it should be noted here too. Version : Which version or range of client versions were tested. Comments : Any comments or quirks on using this client with Evennia should be added here. Also note if some other protocol than Telnet is used (like Websockets, SSH etc). Client Grid \u00b6 Name Version Comments Evennia webclient 0.6 Uses WS/AJAX. Current client issues tintin++ 2.0+ No MXP support tinyfugue 5.0+ No UTF-8 support MUSHclient (Win) 4.94 NAWS reports full text area Zmud (Win) 7.21 UNTESTED Cmud (Win) v3 UNTESTED Potato 2.0.0b16 No MXP, MCCP support. Win 32bit does not understand \"localhost\", must use 127.0.0.1 . Newline issue . *Won't send a single blank line on Enter press. Mudlet 3.4+ No known issues. Some older versions showed <> as html under MXP. SimpleMU (Win) full UNTESTED . Discontinued. NAWS reports pixel size. Atlantis (Mac) 0.9.9.4 No known issues. GMUD 0.0.1 Can't handle any telnet handshakes. Not recommended. BeipMU (Win) 3.0.255 No MXP support. Best to enable \"MUD prompt handling\", disable \"Handle HTML tags\". MudRammer (IOS) 1.8.7 Bad Telnet Protocol compliance: displays spurious characters. MUDMaster (IOS) 1.3.1 UNTESTED BlowTorch (Andr) 1.1.3 *Telnet NOP displays as spurious character. Mukluk (Andr) 2015.11.20 *Telnet NOP displays as spurious character. Has UTF-8/Emoji support. Gnome-MUD (Unix) 0.11.2 Telnet handshake errors. First (only) attempt at logging in fails. Spyrit 0.4 No MXP, OOB support. JamochaMUD 5.2 Does not support ANSI within MXP text. DuckClient (Chrome) 4.2 No MXP support. Displays Telnet Go-Ahead and WILL SUPPRESS-GO-AHEAD as \u00f9 character. Also seems to run the version command on connection, which will not work in MULTISESSION_MODES above 1. KildClient 2.11.1 No known issues. Workarounds for client issues: \u00b6 Issue: Telnet NOP displays as spurious character. \u00b6 Known Clients \u00b6 BlowTorch (Andr) Mukluk (Andr) Workarounds \u00b6 Set the command in game to @option NOPKEEPALIVE=off for the session, or use the /save parameter to disable it for that Evennian account permanently. Client-side: Set a gag-type trigger on the NOP character to make it invisible to the client. Issue: Won't send blank line on Enter key press. \u00b6 Known Clients \u00b6 Potato Workaround \u00b6 Press Control Enter, then Enter key again to send blank line.","title":"Client Support Grid"},{"location":"Client-Support-Grid.html#legend","text":"Name : The name of the client. If it's only available for a specific OS, it should be noted here too. Version : Which version or range of client versions were tested. Comments : Any comments or quirks on using this client with Evennia should be added here. Also note if some other protocol than Telnet is used (like Websockets, SSH etc).","title":"Legend:"},{"location":"Client-Support-Grid.html#client-grid","text":"Name Version Comments Evennia webclient 0.6 Uses WS/AJAX. Current client issues tintin++ 2.0+ No MXP support tinyfugue 5.0+ No UTF-8 support MUSHclient (Win) 4.94 NAWS reports full text area Zmud (Win) 7.21 UNTESTED Cmud (Win) v3 UNTESTED Potato 2.0.0b16 No MXP, MCCP support. Win 32bit does not understand \"localhost\", must use 127.0.0.1 . Newline issue . *Won't send a single blank line on Enter press. Mudlet 3.4+ No known issues. Some older versions showed <> as html under MXP. SimpleMU (Win) full UNTESTED . Discontinued. NAWS reports pixel size. Atlantis (Mac) 0.9.9.4 No known issues. GMUD 0.0.1 Can't handle any telnet handshakes. Not recommended. BeipMU (Win) 3.0.255 No MXP support. Best to enable \"MUD prompt handling\", disable \"Handle HTML tags\". MudRammer (IOS) 1.8.7 Bad Telnet Protocol compliance: displays spurious characters. MUDMaster (IOS) 1.3.1 UNTESTED BlowTorch (Andr) 1.1.3 *Telnet NOP displays as spurious character. Mukluk (Andr) 2015.11.20 *Telnet NOP displays as spurious character. Has UTF-8/Emoji support. Gnome-MUD (Unix) 0.11.2 Telnet handshake errors. First (only) attempt at logging in fails. Spyrit 0.4 No MXP, OOB support. JamochaMUD 5.2 Does not support ANSI within MXP text. DuckClient (Chrome) 4.2 No MXP support. Displays Telnet Go-Ahead and WILL SUPPRESS-GO-AHEAD as \u00f9 character. Also seems to run the version command on connection, which will not work in MULTISESSION_MODES above 1. KildClient 2.11.1 No known issues.","title":"Client Grid"},{"location":"Client-Support-Grid.html#workarounds-for-client-issues","text":"","title":"Workarounds for client issues:"},{"location":"Client-Support-Grid.html#issue-telnet-nop-displays-as-spurious-character","text":"","title":"Issue: Telnet NOP displays as spurious character."},{"location":"Client-Support-Grid.html#known-clients","text":"BlowTorch (Andr) Mukluk (Andr)","title":"Known Clients"},{"location":"Client-Support-Grid.html#workarounds","text":"Set the command in game to @option NOPKEEPALIVE=off for the session, or use the /save parameter to disable it for that Evennian account permanently. Client-side: Set a gag-type trigger on the NOP character to make it invisible to the client.","title":"Workarounds"},{"location":"Client-Support-Grid.html#issue-wont-send-blank-line-on-enter-key-press","text":"","title":"Issue: Won't send blank line on Enter key press."},{"location":"Client-Support-Grid.html#known-clients_1","text":"Potato","title":"Known Clients"},{"location":"Client-Support-Grid.html#workaround","text":"Press Control Enter, then Enter key again to send blank line.","title":"Workaround"},{"location":"Coding-FAQ.html","text":"This FAQ page is for users to share their solutions to coding problems. Keep it brief and link to the docs if you can rather than too lengthy explanations. Don't forget to check if an answer already exists before answering - maybe you can clarify that answer rather than to make a new Q&A section. Table of Contents \u00b6 Removing default commands Preventing character from moving based on a condition Reference initiating object in an EvMenu command Adding color to default Evennia Channels Selectively turn off commands in a room Select Command based on a condition Automatically updating code when reloading Changing all exit messages Add parsing with the \"to\" delimiter Store last used session IP address Use wide characters with EvTable Removing default commands \u00b6 Q: How does one remove (not replace) e.g. the default get Command from the Character Command Set ? A: Go to mygame/commands/default_cmdsets.py . Find the CharacterCmdSet class. It has one method named at_cmdset_creation . At the end of that method, add the following line: self.remove(default_cmds.CmdGet()) . See the Adding Commands Tutorial for more info. Preventing character from moving based on a condition \u00b6 Q: How does one keep a character from using any exit, if they meet a certain condition? (I.E. in combat, immobilized, etc.) A: The at_before_move hook is called by Evennia just before performing any move. If it returns False , the move is aborted. Let's say we want to check for an Attribute cantmove . Add the following code to the Character class: def at_before_move(self, destination): \"Called just before trying to move\" if self.db.cantmove: # replace with condition you want to test self.msg(\"Something is preventing you from moving!\") return False return True Reference initiating object in an EvMenu command. \u00b6 Q: An object has a Command on it starts up an EvMenu instance. How do I capture a reference to that object for use in the menu? A: When an EvMenu is started, the menu object is stored as caller.ndb._menutree . This is a good place to store menu-specific things since it will clean itself up when the menu closes. When initiating the menu, any additional keywords you give will be available for you as properties on this menu object: class MyObjectCommand(Command): # A Command stored on an object (the object is always accessible from # the Command as self.obj) def func(self): # add the object as the stored_obj menu property EvMenu(caller, ..., stored_obj=self.obj) Inside the menu you can now access the object through caller.ndb._menutree.stored_obj . Adding color to default Evennia Channels \u00b6 Q: How do I add colors to the names of Evennia channels? A: The Channel typeclass' channel_prefix method decides what is shown at the beginning of a channel send. Edit mygame/typeclasses/channels.py (and then @reload ): # define our custom color names CHANNEL_COLORS = {'public': '|015Public|n', 'newbie': '|550N|n|551e|n|552w|n|553b|n|554i|n|555e|n', 'staff': '|010S|n|020t|n|030a|n|040f|n|050f|n'} # Add to the Channel class # ... def channel_prefix(self, msg, emit=False): prefix_string = \"\" if self.key in COLORS: prefix_string = \"[%s] \" % CHANNEL_COLORS.get(self.key.lower()) else: prefix_string = \"[%s] \" % self.key.capitalize() return prefix_string Additional hint: To make colors easier to change from one place you could instead put the CHANNEL_COLORS dict in your settings file and import it as from django.conf.settings import CHANNEL_COLORS . Selectively turn off commands in a room \u00b6 Q: I want certain commands to turn off in a given room. They should still work normally for staff. A: This is done using a custom cmdset on a room locked with the 'call' lock type . Only if this lock is passed will the commands on the room be made available to an object inside it. Here is an example of a room where certain commands are disabled for non-staff: # in mygame/typeclasses/rooms.py from evennia import default_commands, CmdSet class CmdBlocking(default_commands.MuxCommand): # block commands give, get, inventory and drop key = \"give\" aliases = [\"get\", \"inventory\", \"drop\"] def func(self): self.caller.msg(\"You cannot do that in this room.\") class BlockingCmdSet(CmdSet): key = \"blocking_cmdset\" # default commands have prio 0 priority = 1 def at_cmdset_creation(self): self.add(CmdBlocking()) class BlockingRoom(Room): def at_object_creation(self): self.cmdset.add(BlockingCmdSet, permanent=True) # only share commands with players in the room that # are NOT Builders or higher self.locks.add(\"call:not perm(Builders)\") After @reload , make some BlockingRooms (or switch a room to it with @typeclass ). Entering one will now replace the given commands for anyone that does not have the Builders or higher permission. Note that the 'call' lock is special in that even the superuser will be affected by it (otherwise superusers would always see other player's cmdsets and a game would be unplayable for superusers). Select Command based on a condition \u00b6 Q: I want a command to be available only based on a condition. For example I want the \"werewolf\" command to only be available on a full moon, from midnight to three in-game time. A: This is easiest accomplished by putting the \"werewolf\" command on the Character as normal, but to lock it with the \"cmd\" type lock. Only if the \"cmd\" lock type is passed will the command be available. # in mygame/commands/command.py from evennia import Command class CmdWerewolf(Command): key = \"werewolf\" # lock full moon, between 00:00 (midnight) and 03:00. locks = \"cmd:is_full_moon(0, 3)\" def func(self): # ... Add this to the default cmdset as usual . The is_full_moon lock function does not yet exist. We must create that: # in mygame/server/conf/lockfuncs.py def is_full_moon(accessing_obj, accessed_obj, starthour, endhour, *args, **kwargs): # calculate if the moon is full here and # if current game time is between starthour and endhour # return True or False After a @reload , the werewolf command will be available only at the right time, that is when the is_full_moon lock function returns True. Automatically updating code when reloading \u00b6 Q: I have a development server running Evennia. Can I have the server update its code-base when I reload? A: Having a development server that pulls updated code whenever you reload it can be really useful if you have limited shell access to your server, or want to have it done automatically. If you have your project in a configured Git environment, it's a matter of automatically calling git pull when you reload. And that's pretty straightforward: In /server/conf/at_server_startstop.py : import subprocess # ... other hooks ... def at_server_reload_stop(): \"\"\" This is called only time the server stops before a reload. \"\"\" print(\"Pulling from the game repository...\") process = subprocess.call([\"git\", \"pull\"], shell=False) That's all. We call subprocess to execute a shell command (that code works on Windows and Linux, assuming the current directory is your game directory, which is probably the case when you run Evennia). call waits for the process to complete, because otherwise, Evennia would reload on partially-modified code, which would be problematic. Now, when you enter @reload on your development server, the game repository is updated from the configured remote repository (Github, for instance). Your development cycle could resemble something like: Coding on the local machine. Testing modifications. Committing once, twice or more (being sure the code is still working, unittests are pretty useful here). When the time comes, login to the development server and run @reload . The reloading might take one or two additional seconds, since Evennia will pull from your remote Git repository. But it will reload on it and you will have your modifications ready, without needing connecting to your server using SSH or something similar. Changing all exit messages \u00b6 Q: How can I change the default exit messages to something like \"XXX leaves east\" or \"XXX arrives from the west\"? A: the default exit messages are stored in two hooks, namely announce_move_from and announce_move_to , on the Character typeclass (if what you want to change is the message other characters will see when a character exits). These two hooks provide some useful features to easily update the message to be displayed. They take both the default message and mapping as argument. You can easily call the parent hook with these information: The message represents the string of characters sent to characters in the room when a character leaves. The mapping is a dictionary containing additional mappings (you will probably not need it for simple customization). It is advisable to look in the code of both hooks , and read the hooks' documentation. The explanations on how to quickly update the message are shown below: # In typeclasses/characters.py \"\"\" Characters \"\"\" from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" The default character class. ... \"\"\" def announce_move_from(self, destination, msg=None, mapping=None): \"\"\" Called if the move is to be announced. This is called while we are still standing in the old location. Args: destination (Object): The place we are going to. msg (str, optional): a replacement message. mapping (dict, optional): additional mapping objects. You can override this method and call its parent with a message to simply change the default message. In the string, you can use the following as mappings (between braces): object: the object which is moving. exit: the exit from which the object is moving (if found). origin: the location of the object before the move. destination: the location of the object after moving. \"\"\" super().announce_move_from(destination, msg=\"{object} leaves {exit}.\") def announce_move_to(self, source_location, msg=None, mapping=None): \"\"\" Called after the move if the move was not quiet. At this point we are standing in the new location. Args: source_location (Object): The place we came from msg (str, optional): the replacement message if location. mapping (dict, optional): additional mapping objects. You can override this method and call its parent with a message to simply change the default message. In the string, you can use the following as mappings (between braces): object: the object which is moving. exit: the exit from which the object is moving (if found). origin: the location of the object before the move. destination: the location of the object after moving. \"\"\" super().announce_move_to(source_location, msg=\"{object} arrives from the {exit}.\") We override both hooks, but call the parent hook to display a different message. If you read the provided docstrings, you will better understand why and how we use mappings (information between braces). You can provide additional mappings as well, if you want to set a verb to move, for instance, or other, extra information. Add parsing with the \"to\" delimiter \u00b6 Q: How do I change commands to undestand say give obj to target as well as the default give obj = target ? A: You can make change the default MuxCommand parent with your own class making a small change in its parse method: # in mygame/commands/command.py from evennia import default_cmds class MuxCommand(default_cmds.MuxCommand): def parse(self): \"\"\"Implement an additional parsing of 'to'\"\"\" super().parse() if \" to \" in self.args: self.lhs, self.rhs = self.args.split(\" to \", 1) Next you change the parent of the default commands in settings: COMMAND_DEFAULT_CLASS = \"commands.command.MuxCommand\" Do a @reload and all default commands will now use your new tweaked parent class. A copy of the MuxCommand class is also found commented-out in the mygame/commands/command.py file. Store last used session IP address \u00b6 Q: If a user has already logged out of an Evennia account, their IP is no longer visible to staff that wants to ban-by-ip (instead of the user) with @ban/ip ? A: One approach is to write the IP from the last session onto the \"account\" account object. typeclasses/accounts.py def at_post_login(self, session=None, **kwargs): super().at_post_login(session=session, **kwargs) self.db.lastsite = self.sessions.all()[-1].address Adding timestamp for login time and appending to a list to keep the last N login IP addresses and timestamps is possible, also. Additionally, if you don't want the list to grow beyond a do_not_exceed length, conditionally pop a value after you've added it, if the length has grown too long. NOTE: You'll need to add import time to generate the login timestamp. def at_post_login(self, session=None, **kwargs): super().at_post_login(session=session, **kwargs) do_not_exceed = 24 # Keep the last two dozen entries session = self.sessions.all()[-1] # Most recent session if not self.db.lastsite: self.db.lastsite = [] self.db.lastsite.insert(0, (session.address, int(time.time()))) if len(self.db.lastsite) > do_not_exceed: self.db.lastsite.pop() This only stores the data. You may want to interface the @ban command or make a menu-driven viewer for staff to browse the list and display how long ago the login occurred. Non-latin characters in EvTable \u00b6 Q: When using e.g. Chinese characters in EvTable, some lines appear to be too wide, for example +------+------+ | | | | \u6d4b\u8bd5 | \u6d4b\u8bd5 | | | | +~~~~~~+~~~~~~+ A: The reason for this is because certain non-latin characters are visually much wider than their len() suggests. There is little Evennia can (reliably) do about this. If you are using such characters, you need to make sure to use a suitable mono-spaced font where are width are equal. You can set this in your web client and need to recommend it for telnet-client users. See this discussion where some suitable fonts are suggested.","title":"Coding FAQ"},{"location":"Coding-FAQ.html#table-of-contents","text":"Removing default commands Preventing character from moving based on a condition Reference initiating object in an EvMenu command Adding color to default Evennia Channels Selectively turn off commands in a room Select Command based on a condition Automatically updating code when reloading Changing all exit messages Add parsing with the \"to\" delimiter Store last used session IP address Use wide characters with EvTable","title":"Table of Contents"},{"location":"Coding-FAQ.html#removing-default-commands","text":"Q: How does one remove (not replace) e.g. the default get Command from the Character Command Set ? A: Go to mygame/commands/default_cmdsets.py . Find the CharacterCmdSet class. It has one method named at_cmdset_creation . At the end of that method, add the following line: self.remove(default_cmds.CmdGet()) . See the Adding Commands Tutorial for more info.","title":"Removing default commands"},{"location":"Coding-FAQ.html#preventing-character-from-moving-based-on-a-condition","text":"Q: How does one keep a character from using any exit, if they meet a certain condition? (I.E. in combat, immobilized, etc.) A: The at_before_move hook is called by Evennia just before performing any move. If it returns False , the move is aborted. Let's say we want to check for an Attribute cantmove . Add the following code to the Character class: def at_before_move(self, destination): \"Called just before trying to move\" if self.db.cantmove: # replace with condition you want to test self.msg(\"Something is preventing you from moving!\") return False return True","title":"Preventing character from moving based on a condition"},{"location":"Coding-FAQ.html#reference-initiating-object-in-an-evmenu-command","text":"Q: An object has a Command on it starts up an EvMenu instance. How do I capture a reference to that object for use in the menu? A: When an EvMenu is started, the menu object is stored as caller.ndb._menutree . This is a good place to store menu-specific things since it will clean itself up when the menu closes. When initiating the menu, any additional keywords you give will be available for you as properties on this menu object: class MyObjectCommand(Command): # A Command stored on an object (the object is always accessible from # the Command as self.obj) def func(self): # add the object as the stored_obj menu property EvMenu(caller, ..., stored_obj=self.obj) Inside the menu you can now access the object through caller.ndb._menutree.stored_obj .","title":"Reference initiating object in an EvMenu command."},{"location":"Coding-FAQ.html#adding-color-to-default-evennia-channels","text":"Q: How do I add colors to the names of Evennia channels? A: The Channel typeclass' channel_prefix method decides what is shown at the beginning of a channel send. Edit mygame/typeclasses/channels.py (and then @reload ): # define our custom color names CHANNEL_COLORS = {'public': '|015Public|n', 'newbie': '|550N|n|551e|n|552w|n|553b|n|554i|n|555e|n', 'staff': '|010S|n|020t|n|030a|n|040f|n|050f|n'} # Add to the Channel class # ... def channel_prefix(self, msg, emit=False): prefix_string = \"\" if self.key in COLORS: prefix_string = \"[%s] \" % CHANNEL_COLORS.get(self.key.lower()) else: prefix_string = \"[%s] \" % self.key.capitalize() return prefix_string Additional hint: To make colors easier to change from one place you could instead put the CHANNEL_COLORS dict in your settings file and import it as from django.conf.settings import CHANNEL_COLORS .","title":"Adding color to default Evennia Channels"},{"location":"Coding-FAQ.html#selectively-turn-off-commands-in-a-room","text":"Q: I want certain commands to turn off in a given room. They should still work normally for staff. A: This is done using a custom cmdset on a room locked with the 'call' lock type . Only if this lock is passed will the commands on the room be made available to an object inside it. Here is an example of a room where certain commands are disabled for non-staff: # in mygame/typeclasses/rooms.py from evennia import default_commands, CmdSet class CmdBlocking(default_commands.MuxCommand): # block commands give, get, inventory and drop key = \"give\" aliases = [\"get\", \"inventory\", \"drop\"] def func(self): self.caller.msg(\"You cannot do that in this room.\") class BlockingCmdSet(CmdSet): key = \"blocking_cmdset\" # default commands have prio 0 priority = 1 def at_cmdset_creation(self): self.add(CmdBlocking()) class BlockingRoom(Room): def at_object_creation(self): self.cmdset.add(BlockingCmdSet, permanent=True) # only share commands with players in the room that # are NOT Builders or higher self.locks.add(\"call:not perm(Builders)\") After @reload , make some BlockingRooms (or switch a room to it with @typeclass ). Entering one will now replace the given commands for anyone that does not have the Builders or higher permission. Note that the 'call' lock is special in that even the superuser will be affected by it (otherwise superusers would always see other player's cmdsets and a game would be unplayable for superusers).","title":"Selectively turn off commands in a room"},{"location":"Coding-FAQ.html#select-command-based-on-a-condition","text":"Q: I want a command to be available only based on a condition. For example I want the \"werewolf\" command to only be available on a full moon, from midnight to three in-game time. A: This is easiest accomplished by putting the \"werewolf\" command on the Character as normal, but to lock it with the \"cmd\" type lock. Only if the \"cmd\" lock type is passed will the command be available. # in mygame/commands/command.py from evennia import Command class CmdWerewolf(Command): key = \"werewolf\" # lock full moon, between 00:00 (midnight) and 03:00. locks = \"cmd:is_full_moon(0, 3)\" def func(self): # ... Add this to the default cmdset as usual . The is_full_moon lock function does not yet exist. We must create that: # in mygame/server/conf/lockfuncs.py def is_full_moon(accessing_obj, accessed_obj, starthour, endhour, *args, **kwargs): # calculate if the moon is full here and # if current game time is between starthour and endhour # return True or False After a @reload , the werewolf command will be available only at the right time, that is when the is_full_moon lock function returns True.","title":"Select Command based on a condition"},{"location":"Coding-FAQ.html#automatically-updating-code-when-reloading","text":"Q: I have a development server running Evennia. Can I have the server update its code-base when I reload? A: Having a development server that pulls updated code whenever you reload it can be really useful if you have limited shell access to your server, or want to have it done automatically. If you have your project in a configured Git environment, it's a matter of automatically calling git pull when you reload. And that's pretty straightforward: In /server/conf/at_server_startstop.py : import subprocess # ... other hooks ... def at_server_reload_stop(): \"\"\" This is called only time the server stops before a reload. \"\"\" print(\"Pulling from the game repository...\") process = subprocess.call([\"git\", \"pull\"], shell=False) That's all. We call subprocess to execute a shell command (that code works on Windows and Linux, assuming the current directory is your game directory, which is probably the case when you run Evennia). call waits for the process to complete, because otherwise, Evennia would reload on partially-modified code, which would be problematic. Now, when you enter @reload on your development server, the game repository is updated from the configured remote repository (Github, for instance). Your development cycle could resemble something like: Coding on the local machine. Testing modifications. Committing once, twice or more (being sure the code is still working, unittests are pretty useful here). When the time comes, login to the development server and run @reload . The reloading might take one or two additional seconds, since Evennia will pull from your remote Git repository. But it will reload on it and you will have your modifications ready, without needing connecting to your server using SSH or something similar.","title":"Automatically updating code when reloading"},{"location":"Coding-FAQ.html#changing-all-exit-messages","text":"Q: How can I change the default exit messages to something like \"XXX leaves east\" or \"XXX arrives from the west\"? A: the default exit messages are stored in two hooks, namely announce_move_from and announce_move_to , on the Character typeclass (if what you want to change is the message other characters will see when a character exits). These two hooks provide some useful features to easily update the message to be displayed. They take both the default message and mapping as argument. You can easily call the parent hook with these information: The message represents the string of characters sent to characters in the room when a character leaves. The mapping is a dictionary containing additional mappings (you will probably not need it for simple customization). It is advisable to look in the code of both hooks , and read the hooks' documentation. The explanations on how to quickly update the message are shown below: # In typeclasses/characters.py \"\"\" Characters \"\"\" from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" The default character class. ... \"\"\" def announce_move_from(self, destination, msg=None, mapping=None): \"\"\" Called if the move is to be announced. This is called while we are still standing in the old location. Args: destination (Object): The place we are going to. msg (str, optional): a replacement message. mapping (dict, optional): additional mapping objects. You can override this method and call its parent with a message to simply change the default message. In the string, you can use the following as mappings (between braces): object: the object which is moving. exit: the exit from which the object is moving (if found). origin: the location of the object before the move. destination: the location of the object after moving. \"\"\" super().announce_move_from(destination, msg=\"{object} leaves {exit}.\") def announce_move_to(self, source_location, msg=None, mapping=None): \"\"\" Called after the move if the move was not quiet. At this point we are standing in the new location. Args: source_location (Object): The place we came from msg (str, optional): the replacement message if location. mapping (dict, optional): additional mapping objects. You can override this method and call its parent with a message to simply change the default message. In the string, you can use the following as mappings (between braces): object: the object which is moving. exit: the exit from which the object is moving (if found). origin: the location of the object before the move. destination: the location of the object after moving. \"\"\" super().announce_move_to(source_location, msg=\"{object} arrives from the {exit}.\") We override both hooks, but call the parent hook to display a different message. If you read the provided docstrings, you will better understand why and how we use mappings (information between braces). You can provide additional mappings as well, if you want to set a verb to move, for instance, or other, extra information.","title":"Changing all exit messages"},{"location":"Coding-FAQ.html#add-parsing-with-the-to-delimiter","text":"Q: How do I change commands to undestand say give obj to target as well as the default give obj = target ? A: You can make change the default MuxCommand parent with your own class making a small change in its parse method: # in mygame/commands/command.py from evennia import default_cmds class MuxCommand(default_cmds.MuxCommand): def parse(self): \"\"\"Implement an additional parsing of 'to'\"\"\" super().parse() if \" to \" in self.args: self.lhs, self.rhs = self.args.split(\" to \", 1) Next you change the parent of the default commands in settings: COMMAND_DEFAULT_CLASS = \"commands.command.MuxCommand\" Do a @reload and all default commands will now use your new tweaked parent class. A copy of the MuxCommand class is also found commented-out in the mygame/commands/command.py file.","title":"Add parsing with the \"to\" delimiter"},{"location":"Coding-FAQ.html#store-last-used-session-ip-address","text":"Q: If a user has already logged out of an Evennia account, their IP is no longer visible to staff that wants to ban-by-ip (instead of the user) with @ban/ip ? A: One approach is to write the IP from the last session onto the \"account\" account object. typeclasses/accounts.py def at_post_login(self, session=None, **kwargs): super().at_post_login(session=session, **kwargs) self.db.lastsite = self.sessions.all()[-1].address Adding timestamp for login time and appending to a list to keep the last N login IP addresses and timestamps is possible, also. Additionally, if you don't want the list to grow beyond a do_not_exceed length, conditionally pop a value after you've added it, if the length has grown too long. NOTE: You'll need to add import time to generate the login timestamp. def at_post_login(self, session=None, **kwargs): super().at_post_login(session=session, **kwargs) do_not_exceed = 24 # Keep the last two dozen entries session = self.sessions.all()[-1] # Most recent session if not self.db.lastsite: self.db.lastsite = [] self.db.lastsite.insert(0, (session.address, int(time.time()))) if len(self.db.lastsite) > do_not_exceed: self.db.lastsite.pop() This only stores the data. You may want to interface the @ban command or make a menu-driven viewer for staff to browse the list and display how long ago the login occurred.","title":"Store last used session IP address"},{"location":"Coding-FAQ.html#non-latin-characters-in-evtable","text":"Q: When using e.g. Chinese characters in EvTable, some lines appear to be too wide, for example +------+------+ | | | | \u6d4b\u8bd5 | \u6d4b\u8bd5 | | | | +~~~~~~+~~~~~~+ A: The reason for this is because certain non-latin characters are visually much wider than their len() suggests. There is little Evennia can (reliably) do about this. If you are using such characters, you need to make sure to use a suitable mono-spaced font where are width are equal. You can set this in your web client and need to recommend it for telnet-client users. See this discussion where some suitable fonts are suggested.","title":"Non-latin characters in EvTable"},{"location":"Coding-Introduction.html","text":"Evennia allows for a lot of freedom when designing your game - but to code efficiently you still need to adopt some best practices as well as find a good place to start to learn. Here are some pointers to get you going. Python \u00b6 Evennia is developed using Python. Even if you are more of a designer than a coder, it is wise to learn how to read and understand basic Python code. If you are new to Python, or need a refresher, take a look at our two-part Python introduction . Explore Evennia interactively \u00b6 When new to Evennia it can be hard to find things or figure out what is available. Evennia offers a special interactive python shell that allows you to experiment and try out things. It's recommended to use ipython for this since the vanilla python prompt is very limited. Here are some simple commands to get started: # [open a new console/terminal] # [activate your evennia virtualenv in this console/terminal] pip install ipython # [only needed the first time] cd mygame evennia shell This will open an Evennia-aware python shell (using ipython). From within this shell, try import evennia evennia.<TAB> That is, enter evennia. and press the <TAB> key. This will show you all the resources made available at the top level of Evennia's \"flat API\". See the flat API page for more info on how to explore it efficiently. You can complement your exploration by peeking at the sections of the much more detailed Developer Central . The Tutorials section also contains a growing collection of system- or implementation-specific help. Use a python syntax checker \u00b6 Evennia works by importing your own modules and running them as part of the server. Whereas Evennia should just gracefully tell you what errors it finds, it can nevertheless be a good idea for you to check your code for simple syntax errors before you load it into the running server. There are many python syntax checkers out there. A fast and easy one is pyflakes , a more verbose one is pylint . You can also check so that your code looks up to snuff using pep8 . Even with a syntax checker you will not be able to catch every possible problem - some bugs or problems will only appear when you actually run the code. But using such a checker can be a good start to weed out the simple problems. Plan before you code \u00b6 Before you start coding away at your dream game, take a look at our Game Planning page. It might hopefully help you avoid some common pitfalls and time sinks. Code in your game folder, not in the evennia/ repository \u00b6 As part of the Evennia setup you will create a game folder to host your game code. This is your home. You should never need to modify anything in the evennia library (anything you download from us, really). You import useful functionality from here and if you see code you like, copy&paste it out into your game folder and edit it there. If you find that Evennia doesn't support some functionality you need, make a Feature Request about it. Same goes for bugs . If you add features or fix bugs yourself, please consider Contributing your changes upstream! Learn to read tracebacks \u00b6 Python is very good at reporting when and where things go wrong. A traceback shows everything you need to know about crashing code. The text can be pretty long, but you usually are only interested in the last bit, where it says what the error is and at which module and line number it happened - armed with this info you can resolve most problems. Evennia will usually not show the full traceback in-game though. Instead the server outputs errors to the terminal/console from which you started Evennia in the first place. If you want more to show in-game you can add IN_GAME_ERRORS = True to your settings file. This will echo most (but not all) tracebacks both in-game as well as to the terminal/console. This is a potential security problem though, so don't keep this active when your game goes into production. A common confusing error is finding that objects in-game are suddenly of the type DefaultObject rather than your custom typeclass. This happens when you introduce a critical Syntax error to the module holding your custom class. Since such a module is not valid Python, Evennia can't load it at all. Instead of crashing, Evennia will then print the full traceback to the terminal/console and temporarily fall back to the safe DefaultObject until you fix the problem and reload. Docs are here to help you \u00b6 Some people find reading documentation extremely dull and shun it out of principle. That's your call, but reading docs really does help you, promise! Evennia's documentation is pretty thorough and knowing what is possible can often give you a lot of new cool game ideas. That said, if you can't find the answer in the docs, don't be shy to ask questions! The discussion group and the irc chat are also there for you. The most important point \u00b6 And finally, of course, have fun!","title":"Coding Introduction"},{"location":"Coding-Introduction.html#python","text":"Evennia is developed using Python. Even if you are more of a designer than a coder, it is wise to learn how to read and understand basic Python code. If you are new to Python, or need a refresher, take a look at our two-part Python introduction .","title":"Python"},{"location":"Coding-Introduction.html#explore-evennia-interactively","text":"When new to Evennia it can be hard to find things or figure out what is available. Evennia offers a special interactive python shell that allows you to experiment and try out things. It's recommended to use ipython for this since the vanilla python prompt is very limited. Here are some simple commands to get started: # [open a new console/terminal] # [activate your evennia virtualenv in this console/terminal] pip install ipython # [only needed the first time] cd mygame evennia shell This will open an Evennia-aware python shell (using ipython). From within this shell, try import evennia evennia.<TAB> That is, enter evennia. and press the <TAB> key. This will show you all the resources made available at the top level of Evennia's \"flat API\". See the flat API page for more info on how to explore it efficiently. You can complement your exploration by peeking at the sections of the much more detailed Developer Central . The Tutorials section also contains a growing collection of system- or implementation-specific help.","title":"Explore Evennia interactively"},{"location":"Coding-Introduction.html#use-a-python-syntax-checker","text":"Evennia works by importing your own modules and running them as part of the server. Whereas Evennia should just gracefully tell you what errors it finds, it can nevertheless be a good idea for you to check your code for simple syntax errors before you load it into the running server. There are many python syntax checkers out there. A fast and easy one is pyflakes , a more verbose one is pylint . You can also check so that your code looks up to snuff using pep8 . Even with a syntax checker you will not be able to catch every possible problem - some bugs or problems will only appear when you actually run the code. But using such a checker can be a good start to weed out the simple problems.","title":"Use a python syntax checker"},{"location":"Coding-Introduction.html#plan-before-you-code","text":"Before you start coding away at your dream game, take a look at our Game Planning page. It might hopefully help you avoid some common pitfalls and time sinks.","title":"Plan before you code"},{"location":"Coding-Introduction.html#code-in-your-game-folder-not-in-the-evennia-repository","text":"As part of the Evennia setup you will create a game folder to host your game code. This is your home. You should never need to modify anything in the evennia library (anything you download from us, really). You import useful functionality from here and if you see code you like, copy&paste it out into your game folder and edit it there. If you find that Evennia doesn't support some functionality you need, make a Feature Request about it. Same goes for bugs . If you add features or fix bugs yourself, please consider Contributing your changes upstream!","title":"Code in your game folder, not in the evennia/ repository"},{"location":"Coding-Introduction.html#learn-to-read-tracebacks","text":"Python is very good at reporting when and where things go wrong. A traceback shows everything you need to know about crashing code. The text can be pretty long, but you usually are only interested in the last bit, where it says what the error is and at which module and line number it happened - armed with this info you can resolve most problems. Evennia will usually not show the full traceback in-game though. Instead the server outputs errors to the terminal/console from which you started Evennia in the first place. If you want more to show in-game you can add IN_GAME_ERRORS = True to your settings file. This will echo most (but not all) tracebacks both in-game as well as to the terminal/console. This is a potential security problem though, so don't keep this active when your game goes into production. A common confusing error is finding that objects in-game are suddenly of the type DefaultObject rather than your custom typeclass. This happens when you introduce a critical Syntax error to the module holding your custom class. Since such a module is not valid Python, Evennia can't load it at all. Instead of crashing, Evennia will then print the full traceback to the terminal/console and temporarily fall back to the safe DefaultObject until you fix the problem and reload.","title":"Learn to read tracebacks"},{"location":"Coding-Introduction.html#docs-are-here-to-help-you","text":"Some people find reading documentation extremely dull and shun it out of principle. That's your call, but reading docs really does help you, promise! Evennia's documentation is pretty thorough and knowing what is possible can often give you a lot of new cool game ideas. That said, if you can't find the answer in the docs, don't be shy to ask questions! The discussion group and the irc chat are also there for you.","title":"Docs are here to help you"},{"location":"Coding-Introduction.html#the-most-important-point","text":"And finally, of course, have fun!","title":"The most important point"},{"location":"Coding-Utils.html","text":"Evennia comes with many utilities to help with common coding tasks. Most are accessible directly from the flat API, otherwise you can find them in the evennia/utils/ folder. Searching \u00b6 A common thing to do is to search for objects. The most common time one needs to do this is inside a command body. There it's easiest to use the search method defined on all objects. This will search for objects in the same location and inside the caller: obj = self.caller.search(objname) Give the keyword global_search=True to extend search to encompass entire database. Aliases will also be matched by this search. You will find multiple examples of this functionality in the default command set. If you need to search for objects in a code module you can use the functions in evennia.utils.search . You can access these as shortcuts evennia.search_* . from evennia import search_object obj = search_object(objname) Note that these latter methods will always return a list of results, even if the list has one or zero entries. Create \u00b6 Apart from the in-game build commands ( @create etc), you can also build all of Evennia's game entities directly in code (for example when defining new create commands). import evennia # myobj = evennia.create_objects(\"game.gamesrc.objects.myobj.MyObj\", key=\"MyObj\") myscr = evennia.create_script(\"game.gamesrc.scripts.myscripts.MyScript\", obj=myobj) helpentry = evennia.create_help_entry(\"Emoting\", \"Emoting means that ...\") msg = evennia.create_message(senderobj, [receiverobj], \"Hello ...\") channel = evennia.create_channel(\"news\") account = evennia.create_account(\"Henry\", \"henry@test.com\", \"H@passwd\") Each of these create-functions have a host of arguments to further customize the created entity. See evennia/utils/create.py for more information. Logging \u00b6 Normally you can use Python print statements to see output to the terminal/log. The print statement should only be used for debugging though. For producion output, use the logger which will create proper logs either to terminal or to file. from evennia import logger # logger.log_err(\"This is an Error!\") logger.log_warn(\"This is a Warning!\") logger.log_info(\"This is normal information\") logger.log_dep(\"This feature is deprecated\") There is a special log-message type, log_trace() that is intended to be called from inside a traceback - this can be very useful for relaying the traceback message back to log without having it kill the server. try: # [some code that may fail...] except Exception: logger.log_trace(\"This text will show beneath the traceback itself.\") The log_file logger, finally, is a very useful logger for outputting arbitrary log messages. This is a heavily optimized asynchronous log mechanism using threads to avoid overhead. You should be able to use it for very heavy custom logging without fearing disk-write delays. logger.log_file(message, filename=\"mylog.log\") If not an absolute path is given, the log file will appear in the mygame/server/logs/ directory. If the file already exists, it will be appended to. Timestamps on the same format as the normal Evennia logs will be automatically added to each entry. If a filename is not specified, output will be written to a file game/logs/game.log . Game time \u00b6 Evennia tracks the current server time. You can access this time via the evennia.gametime shortcut: from evennia import gametime # all the functions below return times in seconds). # total running time of the server runtime = gametime.runtime() # time since latest hard reboot (not including reloads) uptime = gametime.uptime() # server epoch (its start time) server_epoch = gametime.server_epoch() # in-game epoch (this can be set by `settings.TIME_GAME_EPOCH`. # If not, the server epoch is used. game_epoch = gametime.game_epoch() # in-game time passed since time started running gametime = gametime.gametime() # in-game time plus game epoch (i.e. the current in-game # time stamp) gametime = gametime.gametime(absolute=True) # reset the game time (back to game epoch) gametime.reset_gametime() The setting TIME_FACTOR determines how fast/slow in-game time runs compared to the real world. The setting TIME_GAME_EPOCH sets the starting game epoch (in seconds). The functions from the gametime module all return their times in seconds. You can convert this to whatever units of time you desire for your game. You can use the @time command to view the server time info. You can also schedule things to happen at specific in-game times using the gametime.schedule function: import evennia def church_clock: limbo = evennia.search_object(key=\"Limbo\") limbo.msg_contents(\"The church clock chimes two.\") gametime.schedule(church_clock, hour=2) utils.time_format() \u00b6 This function takes a number of seconds as input (e.g. from the gametime module above) and converts it to a nice text output in days, hours etc. It's useful when you want to show how old something is. It converts to four different styles of output using the style keyword: style 0 - 5d:45m:12s (standard colon output) style 1 - 5d (shows only the longest time unit) style 2 - 5 days, 45 minutes (full format, ignores seconds) style 3 - 5 days, 45 minutes, 12 seconds (full format, with seconds) utils.inherits_from() \u00b6 This useful function takes two arguments - an object to check and a parent. It returns True if object inherits from parent at any distance (as opposed to Python's in-built is_instance() that will only catch immediate dependence). This function also accepts as input any combination of classes, instances or python-paths-to-classes. Note that Python code should usually work with duck typing . But in Evennia's case it can sometimes be useful to check if an object inherits from a given Typeclass as a way of identification. Say for example that we have a typeclass Animal . This has a subclass Felines which in turn has a subclass HouseCat . Maybe there are a bunch of other animal types too, like horses and dogs. Using inherits_from will allow you to check for all animals in one go: from evennia import utils if (utils.inherits_from(obj, \"typeclasses.objects.animals.Animal\"): obj.msg(\"The bouncer stops you in the door. He says: 'No talking animals allowed.'\") utils.delay() \u00b6 from evennia import utils def _callback(obj, text): obj.msg(text) # wait 10 seconds before sending \"Echo!\" to obj (which we assume is defined) deferred = utils.delay(10, _callback, obj, \"Echo!\", persistent=False) # code here will run immediately, not waiting for the delay to fire! This creates an asynchronous delayed call. It will fire the given callback function after the given number of seconds. This is a very light wrapper over a Twisted Deferred . Normally this is run non-persistently, which means that if the server is @reload ed before the delay is over, the callback will never run (the server forgets it). If setting persistent to True, the delay will be stored in the database and survive a @reload - but for this to work it is susceptible to the same limitations incurred when saving to an Attribute . The deferred return object can usually be ignored, but calling its .cancel() method will abort the delay prematurely. utils.delay is the lightest form of delayed call in Evennia. For other way to create time-bound tasks, see the TickerHandler and Scripts . Note that many delayed effects can be achieved without any need for an active timer. For example if you have a trait that should recover a point every 5 seconds you might just need its value when it's needed, but checking the current time and calculating on the fly what value it should have. Some text utilities \u00b6 In a text game, you are naturally doing a lot of work shuffling text back and forth. Here is a non-complete selection of text utilities found in evennia/utils/utils.py (shortcut evennia.utils ). If nothing else it can be good to look here before starting to develop a solution of your own. utils.fill() \u00b6 This flood-fills a text to a given width (shuffles the words to make each line evenly wide). It also indents as needed. outtxt = fill(intxt, width=78, indent=4) utils.crop() \u00b6 This function will crop a very long line, adding a suffix to show the line actually continues. This can be useful in listings when showing multiple lines would mess up things. intxt = \"This is a long text that we want to crop.\" outtxt = crop(intxt, width=19, suffix=\"[...]\") # outtxt is now \"This is a long text[...]\" utils.dedent() \u00b6 This solves what may at first glance appear to be a trivial problem with text - removing indentations. It is used to shift entire paragraphs to the left, without disturbing any further formatting they may have. A common case for this is when using Python triple-quoted strings in code - they will retain whichever indentation they have in the code, and to make easily-readable source code one usually don't want to shift the string to the left edge. #python code is entered at a given indentation intxt = \"\"\" This is an example text that will end up with a lot of whitespace on the left. It also has indentations of its own.\"\"\" outtxt = dedent(intxt) # outtxt will now retain all internal indentation # but be shifted all the way to the left. Normally you do the dedent in the display code (this is for example how the help system homogenizes help entries). text conversion() \u00b6 Evennia supplies two utility functions for converting text to the correct encodings. to_str() and to_bytes() . Unless you are adding a custom protocol and need to send byte-data over the wire, to_str is the only one you'll need. The difference from Python's in-built str() and bytes() operators are that the Evennia ones makes use of the ENCODINGS setting and will try very hard to never raise a traceback but instead echo errors through logging. See here for more info. Making ascii tables \u00b6 The EvTable class ( evennia/utils/evtable.py ) can be used to create correctly formatted text tables. There is also EvForm ( evennia/utils/evform.py ). This reads a fixed-format text template from a file in order to create any level of sophisticated ascii layout. Both evtable and evform have lots of options and inputs so see the header of each module for help. The third-party PrettyTable module is also included in Evennia. PrettyTable is considered deprecated in favor of EvTable since PrettyTable cannot handle ANSI colour. PrettyTable can be found in evennia/utils/prettytable/ . See its homepage above for instructions.","title":"Coding Utils"},{"location":"Coding-Utils.html#searching","text":"A common thing to do is to search for objects. The most common time one needs to do this is inside a command body. There it's easiest to use the search method defined on all objects. This will search for objects in the same location and inside the caller: obj = self.caller.search(objname) Give the keyword global_search=True to extend search to encompass entire database. Aliases will also be matched by this search. You will find multiple examples of this functionality in the default command set. If you need to search for objects in a code module you can use the functions in evennia.utils.search . You can access these as shortcuts evennia.search_* . from evennia import search_object obj = search_object(objname) Note that these latter methods will always return a list of results, even if the list has one or zero entries.","title":"Searching"},{"location":"Coding-Utils.html#create","text":"Apart from the in-game build commands ( @create etc), you can also build all of Evennia's game entities directly in code (for example when defining new create commands). import evennia # myobj = evennia.create_objects(\"game.gamesrc.objects.myobj.MyObj\", key=\"MyObj\") myscr = evennia.create_script(\"game.gamesrc.scripts.myscripts.MyScript\", obj=myobj) helpentry = evennia.create_help_entry(\"Emoting\", \"Emoting means that ...\") msg = evennia.create_message(senderobj, [receiverobj], \"Hello ...\") channel = evennia.create_channel(\"news\") account = evennia.create_account(\"Henry\", \"henry@test.com\", \"H@passwd\") Each of these create-functions have a host of arguments to further customize the created entity. See evennia/utils/create.py for more information.","title":"Create"},{"location":"Coding-Utils.html#logging","text":"Normally you can use Python print statements to see output to the terminal/log. The print statement should only be used for debugging though. For producion output, use the logger which will create proper logs either to terminal or to file. from evennia import logger # logger.log_err(\"This is an Error!\") logger.log_warn(\"This is a Warning!\") logger.log_info(\"This is normal information\") logger.log_dep(\"This feature is deprecated\") There is a special log-message type, log_trace() that is intended to be called from inside a traceback - this can be very useful for relaying the traceback message back to log without having it kill the server. try: # [some code that may fail...] except Exception: logger.log_trace(\"This text will show beneath the traceback itself.\") The log_file logger, finally, is a very useful logger for outputting arbitrary log messages. This is a heavily optimized asynchronous log mechanism using threads to avoid overhead. You should be able to use it for very heavy custom logging without fearing disk-write delays. logger.log_file(message, filename=\"mylog.log\") If not an absolute path is given, the log file will appear in the mygame/server/logs/ directory. If the file already exists, it will be appended to. Timestamps on the same format as the normal Evennia logs will be automatically added to each entry. If a filename is not specified, output will be written to a file game/logs/game.log .","title":"Logging"},{"location":"Coding-Utils.html#game-time","text":"Evennia tracks the current server time. You can access this time via the evennia.gametime shortcut: from evennia import gametime # all the functions below return times in seconds). # total running time of the server runtime = gametime.runtime() # time since latest hard reboot (not including reloads) uptime = gametime.uptime() # server epoch (its start time) server_epoch = gametime.server_epoch() # in-game epoch (this can be set by `settings.TIME_GAME_EPOCH`. # If not, the server epoch is used. game_epoch = gametime.game_epoch() # in-game time passed since time started running gametime = gametime.gametime() # in-game time plus game epoch (i.e. the current in-game # time stamp) gametime = gametime.gametime(absolute=True) # reset the game time (back to game epoch) gametime.reset_gametime() The setting TIME_FACTOR determines how fast/slow in-game time runs compared to the real world. The setting TIME_GAME_EPOCH sets the starting game epoch (in seconds). The functions from the gametime module all return their times in seconds. You can convert this to whatever units of time you desire for your game. You can use the @time command to view the server time info. You can also schedule things to happen at specific in-game times using the gametime.schedule function: import evennia def church_clock: limbo = evennia.search_object(key=\"Limbo\") limbo.msg_contents(\"The church clock chimes two.\") gametime.schedule(church_clock, hour=2)","title":"Game time"},{"location":"Coding-Utils.html#utilstime_format","text":"This function takes a number of seconds as input (e.g. from the gametime module above) and converts it to a nice text output in days, hours etc. It's useful when you want to show how old something is. It converts to four different styles of output using the style keyword: style 0 - 5d:45m:12s (standard colon output) style 1 - 5d (shows only the longest time unit) style 2 - 5 days, 45 minutes (full format, ignores seconds) style 3 - 5 days, 45 minutes, 12 seconds (full format, with seconds)","title":"utils.time_format()"},{"location":"Coding-Utils.html#utilsinherits_from","text":"This useful function takes two arguments - an object to check and a parent. It returns True if object inherits from parent at any distance (as opposed to Python's in-built is_instance() that will only catch immediate dependence). This function also accepts as input any combination of classes, instances or python-paths-to-classes. Note that Python code should usually work with duck typing . But in Evennia's case it can sometimes be useful to check if an object inherits from a given Typeclass as a way of identification. Say for example that we have a typeclass Animal . This has a subclass Felines which in turn has a subclass HouseCat . Maybe there are a bunch of other animal types too, like horses and dogs. Using inherits_from will allow you to check for all animals in one go: from evennia import utils if (utils.inherits_from(obj, \"typeclasses.objects.animals.Animal\"): obj.msg(\"The bouncer stops you in the door. He says: 'No talking animals allowed.'\")","title":"utils.inherits_from()"},{"location":"Coding-Utils.html#utilsdelay","text":"from evennia import utils def _callback(obj, text): obj.msg(text) # wait 10 seconds before sending \"Echo!\" to obj (which we assume is defined) deferred = utils.delay(10, _callback, obj, \"Echo!\", persistent=False) # code here will run immediately, not waiting for the delay to fire! This creates an asynchronous delayed call. It will fire the given callback function after the given number of seconds. This is a very light wrapper over a Twisted Deferred . Normally this is run non-persistently, which means that if the server is @reload ed before the delay is over, the callback will never run (the server forgets it). If setting persistent to True, the delay will be stored in the database and survive a @reload - but for this to work it is susceptible to the same limitations incurred when saving to an Attribute . The deferred return object can usually be ignored, but calling its .cancel() method will abort the delay prematurely. utils.delay is the lightest form of delayed call in Evennia. For other way to create time-bound tasks, see the TickerHandler and Scripts . Note that many delayed effects can be achieved without any need for an active timer. For example if you have a trait that should recover a point every 5 seconds you might just need its value when it's needed, but checking the current time and calculating on the fly what value it should have.","title":"utils.delay()"},{"location":"Coding-Utils.html#some-text-utilities","text":"In a text game, you are naturally doing a lot of work shuffling text back and forth. Here is a non-complete selection of text utilities found in evennia/utils/utils.py (shortcut evennia.utils ). If nothing else it can be good to look here before starting to develop a solution of your own.","title":"Some text utilities"},{"location":"Coding-Utils.html#utilsfill","text":"This flood-fills a text to a given width (shuffles the words to make each line evenly wide). It also indents as needed. outtxt = fill(intxt, width=78, indent=4)","title":"utils.fill()"},{"location":"Coding-Utils.html#utilscrop","text":"This function will crop a very long line, adding a suffix to show the line actually continues. This can be useful in listings when showing multiple lines would mess up things. intxt = \"This is a long text that we want to crop.\" outtxt = crop(intxt, width=19, suffix=\"[...]\") # outtxt is now \"This is a long text[...]\"","title":"utils.crop()"},{"location":"Coding-Utils.html#utilsdedent","text":"This solves what may at first glance appear to be a trivial problem with text - removing indentations. It is used to shift entire paragraphs to the left, without disturbing any further formatting they may have. A common case for this is when using Python triple-quoted strings in code - they will retain whichever indentation they have in the code, and to make easily-readable source code one usually don't want to shift the string to the left edge. #python code is entered at a given indentation intxt = \"\"\" This is an example text that will end up with a lot of whitespace on the left. It also has indentations of its own.\"\"\" outtxt = dedent(intxt) # outtxt will now retain all internal indentation # but be shifted all the way to the left. Normally you do the dedent in the display code (this is for example how the help system homogenizes help entries).","title":"utils.dedent()"},{"location":"Coding-Utils.html#text-conversion","text":"Evennia supplies two utility functions for converting text to the correct encodings. to_str() and to_bytes() . Unless you are adding a custom protocol and need to send byte-data over the wire, to_str is the only one you'll need. The difference from Python's in-built str() and bytes() operators are that the Evennia ones makes use of the ENCODINGS setting and will try very hard to never raise a traceback but instead echo errors through logging. See here for more info.","title":"text conversion()"},{"location":"Coding-Utils.html#making-ascii-tables","text":"The EvTable class ( evennia/utils/evtable.py ) can be used to create correctly formatted text tables. There is also EvForm ( evennia/utils/evform.py ). This reads a fixed-format text template from a file in order to create any level of sophisticated ascii layout. Both evtable and evform have lots of options and inputs so see the header of each module for help. The third-party PrettyTable module is also included in Evennia. PrettyTable is considered deprecated in favor of EvTable since PrettyTable cannot handle ANSI colour. PrettyTable can be found in evennia/utils/prettytable/ . See its homepage above for instructions.","title":"Making ascii tables"},{"location":"Command-Cooldown.html","text":"Some types of games want to limit how often a command can be run. If a character casts the spell Firestorm , you might not want them to spam that command over and over. Or in an advanced combat system, a massive swing may offer a chance of lots of damage at the cost of not being able to re-do it for a while. Such effects are called cooldowns . This page exemplifies a very resource-efficient way to do cooldowns. A more 'active' way is to use asynchronous delays as in the command duration tutorial , the two might be useful to combine if you want to echo some message to the user after the cooldown ends. Non-persistent cooldown \u00b6 This little recipe will limit how often a particular command can be run. Since Commands are class instances, and those are cached in memory, a command instance will remember things you store on it. So just store the current time of execution! Next time the command is run, it just needs to check if it has that time stored, and compare it with the current time to see if a desired delay has passed. import time from evennia import default_cmds class CmdSpellFirestorm(default_cmds.MuxCommand): \"\"\" Spell - Firestorm Usage: cast firestorm <target> This will unleash a storm of flame. You can only release one firestorm every five minutes (assuming you have the mana). \"\"\" key = \"cast firestorm\" locks = \"cmd:isFireMage()\" def func(self): \"Implement the spell\" # check cooldown (5 minute cooldown) now = time.time() if hasattr(self, \"lastcast\") and \\ now - self.lastcast < 5 * 60: message = \"You cannot cast this spell again yet.\" self.caller.msg(message) return #[the spell effect is implemented] # if the spell was successfully cast, store the casting time self.lastcast = now We just check the lastcast flag, and update it if everything works out. Simple and very effective since everything is just stored in memory. The drawback of this simple scheme is that it's non-persistent. If you do @reload , the cache is cleaned and all such ongoing cooldowns will be forgotten. It is also limited only to this one command, other commands cannot (easily) check for this value. Persistent cooldown \u00b6 This is essentially the same mechanism as the simple one above, except we use the database to store the information which means the cooldown will survive a server reload/reboot. Since commands themselves have no representation in the database, you need to use the caster for the storage. # inside the func() of CmdSpellFirestorm as above # check cooldown (5 minute cooldown) now = time.time() lastcast = self.caller.db.firestorm_lastcast if lastcast and now - lastcast < 5 * 60: message = \"You need to wait before casting this spell again.\" self.caller.msg(message) return #[the spell effect is implemented] # if the spell was successfully cast, store the casting time self.caller.db.firestorm_lastcast = now Since we are storing as an Attribute , we need to identify the variable as firestorm_lastcast so we are sure we get the right one (we'll likely have other skills with cooldowns after all). But this method of using cooldowns also has the advantage of working between commands - you can for example let all fire-related spells check the same cooldown to make sure the casting of Firestorm blocks all fire-related spells for a while. Or, in the case of taking that big swing with the sword, this could now block all other types of attacks for a while before the warrior can recover.","title":"Command Cooldown"},{"location":"Command-Cooldown.html#non-persistent-cooldown","text":"This little recipe will limit how often a particular command can be run. Since Commands are class instances, and those are cached in memory, a command instance will remember things you store on it. So just store the current time of execution! Next time the command is run, it just needs to check if it has that time stored, and compare it with the current time to see if a desired delay has passed. import time from evennia import default_cmds class CmdSpellFirestorm(default_cmds.MuxCommand): \"\"\" Spell - Firestorm Usage: cast firestorm <target> This will unleash a storm of flame. You can only release one firestorm every five minutes (assuming you have the mana). \"\"\" key = \"cast firestorm\" locks = \"cmd:isFireMage()\" def func(self): \"Implement the spell\" # check cooldown (5 minute cooldown) now = time.time() if hasattr(self, \"lastcast\") and \\ now - self.lastcast < 5 * 60: message = \"You cannot cast this spell again yet.\" self.caller.msg(message) return #[the spell effect is implemented] # if the spell was successfully cast, store the casting time self.lastcast = now We just check the lastcast flag, and update it if everything works out. Simple and very effective since everything is just stored in memory. The drawback of this simple scheme is that it's non-persistent. If you do @reload , the cache is cleaned and all such ongoing cooldowns will be forgotten. It is also limited only to this one command, other commands cannot (easily) check for this value.","title":"Non-persistent cooldown"},{"location":"Command-Cooldown.html#persistent-cooldown","text":"This is essentially the same mechanism as the simple one above, except we use the database to store the information which means the cooldown will survive a server reload/reboot. Since commands themselves have no representation in the database, you need to use the caster for the storage. # inside the func() of CmdSpellFirestorm as above # check cooldown (5 minute cooldown) now = time.time() lastcast = self.caller.db.firestorm_lastcast if lastcast and now - lastcast < 5 * 60: message = \"You need to wait before casting this spell again.\" self.caller.msg(message) return #[the spell effect is implemented] # if the spell was successfully cast, store the casting time self.caller.db.firestorm_lastcast = now Since we are storing as an Attribute , we need to identify the variable as firestorm_lastcast so we are sure we get the right one (we'll likely have other skills with cooldowns after all). But this method of using cooldowns also has the advantage of working between commands - you can for example let all fire-related spells check the same cooldown to make sure the casting of Firestorm blocks all fire-related spells for a while. Or, in the case of taking that big swing with the sword, this could now block all other types of attacks for a while before the warrior can recover.","title":"Persistent cooldown"},{"location":"Command-Duration.html","text":"Before reading this tutorial, if you haven't done so already, you might want to read the documentation on commands to get a basic understanding of how commands work in Evennia. In some types of games a command should not start and finish immediately. Loading a crossbow might take a bit of time to do - time you don't have when the enemy comes rushing at you. Crafting that armour will not be immediate either. For some types of games the very act of moving or changing pose all comes with a certain time associated with it. The simple way to pause commands with yield \u00b6 Evennia allows a shortcut in syntax to create simple pauses in commands. This syntax uses the yield keyword. The yield keyword is used in Python to create generators, although you don't need to know what generators are to use this syntax. A short example will probably make it clear: class CmdTest(Command): \"\"\" A test command just to test waiting. Usage: test \"\"\" key = \"test\" locks = \"cmd:all()\" def func(self): self.msg(\"Before ten seconds...\") yield 10 self.msg(\"Afterwards.\") Important: The yield functionality will only work in the func method of Commands. It only works because Evennia has especially catered for it in Commands. If you want the same functionality elsewhere you must use the interactive decorator . The important line is the yield 10 . It tells Evennia to \"pause\" the command and to wait for 10 seconds to execute the rest. If you add this command and run it, you'll see the first message, then, after a pause of ten seconds, the next message. You can use yield several times in your command. This syntax will not \"freeze\" all commands. While the command is \"pausing\", you can execute other commands (or even call the same command again). And other players aren't frozen either. Note: this will not save anything in the database. If you reload the game while a command is \"paused\", it will not resume after the server has reloaded. The more advanced way with utils.delay \u00b6 The yield syntax is easy to read, easy to understand, easy to use. But it's not that flexible if you want more advanced options. Learning to use alternatives might be much worth it in the end. Below is a simple command example for adding a duration for a command to finish. from evennia import default_cmds, utils class CmdEcho(default_cmds.MuxCommand): \"\"\" wait for an echo Usage: echo <string> Calls and waits for an echo \"\"\" key = \"echo\" locks = \"cmd:all()\" def func(self): \"\"\" This is called at the initial shout. \"\"\" self.caller.msg(\"You shout '%s' and wait for an echo ...\" % self.args) # this waits non-blocking for 10 seconds, then calls self.echo utils.delay(10, self.echo) # call echo after 10 seconds def echo(self): \"Called after 10 seconds.\" shout = self.args string = \"You hear an echo: %s ... %s ... %s\" string = string % (shout.upper(), shout.capitalize(), shout.lower()) self.caller.msg(string) Import this new echo command into the default command set and reload the server. You will find that it will take 10 seconds before you see your shout coming back. You will also find that this is a non-blocking effect; you can issue other commands in the interim and the game will go on as usual. The echo will come back to you in its own time. About utils.delay() \u00b6 utils.delay(timedelay, callback, persistent=False, *args, **kwargs) is a useful function. It will wait timedelay seconds, then call the callback function, optionally passing to it the arguments provided to utils.delay by way of args and/or *kwargs`. Note: The callback argument should be provided with a python path to the desired function, for instance my_object.my_function instead of my_object.my_function() . Otherwise my_function would get called and run immediately upon attempting to pass it to the delay function. If you want to provide arguments for utils.delay to use, when calling your callback function, you have to do it separatly, for instance using the utils.delay args and/or *kwargs, as mentioned above. If you are not familiar with the syntax *args and **kwargs , see the Python documentation here . Looking at it you might think that utils.delay(10, callback) in the code above is just an alternative to some more familiar thing like time.sleep(10) . This is not the case. If you do time.sleep(10) you will in fact freeze the entire server for ten seconds! The utils.delay() is a thin wrapper around a Twisted Deferred that will delay execution until 10 seconds have passed, but will do so asynchronously, without bothering anyone else (not even you - you can continue to do stuff normally while it waits to continue). The point to remember here is that the delay() call will not \"pause\" at that point when it is called (the way yield does in the previous section). The lines after the delay() call will actually execute right away . What you must do is to tell it which function to call after the time has passed (its \"callback\"). This may sound strange at first, but it is normal practice in asynchronous systems. You can also link such calls together as seen below: from evennia import default_cmds, utils class CmdEcho(default_cmds.MuxCommand): \"\"\" waits for an echo Usage: echo <string> Calls and waits for an echo \"\"\" key = \"echo\" locks = \"cmd:all()\" def func(self): \"This sets off a chain of delayed calls\" self.caller.msg(\"You shout '%s', waiting for an echo ...\" % self.args) # wait 2 seconds before calling self.echo1 utils.delay(2, self.echo1) # callback chain, started above def echo1(self): \"First echo\" self.caller.msg(\"... %s\" % self.args.upper()) # wait 2 seconds for the next one utils.delay(2, self.echo2) def echo2(self): \"Second echo\" self.caller.msg(\"... %s\" % self.args.capitalize()) # wait another 2 seconds utils.delay(2, callback=self.echo3) def echo3(self): \"Last echo\" self.caller.msg(\"... %s ...\" % self.args.lower()) The above version will have the echoes arrive one after another, each separated by a two second delay. > echo Hello! ... HELLO! ... Hello! ... hello! ... Blocking commands \u00b6 As mentioned, a great thing about the delay introduced by yield or utils.delay() is that it does not block. It just goes on in the background and you are free to play normally in the interim. In some cases this is not what you want however. Some commands should simply \"block\" other commands while they are running. If you are in the process of crafting a helmet you shouldn't be able to also start crafting a shield at the same time, or if you just did a huge power-swing with your weapon you should not be able to do it again immediately. The simplest way of implementing blocking is to use the technique covered in the Command Cooldown tutorial. In that tutorial we implemented cooldowns by having the Command store the current time. Next time the Command was called, we compared the current time to the stored time to determine if enough time had passed for a renewed use. This is a very efficient, reliable and passive solution. The drawback is that there is nothing to tell the Player when enough time has passed unless they keep trying. Here is an example where we will use utils.delay to tell the player when the cooldown has passed: from evennia import utils, default_cmds class CmdBigSwing(default_cmds.MuxCommand): \"\"\" swing your weapon in a big way Usage: swing <target> Makes a mighty swing. Doing so will make you vulnerable to counter-attacks before you can recover. \"\"\" key = \"bigswing\" locks = \"cmd:all()\" def func(self): \"Makes the swing\" if self.caller.ndb.off_balance: # we are still off-balance. self.caller.msg(\"You are off balance and need time to recover!\") return # [attack/hit code goes here ...] self.caller.msg(\"You swing big! You are off balance now.\") # set the off-balance flag self.caller.ndb.off_balance = True # wait 8 seconds before we can recover. During this time # we won't be able to swing again due to the check at the top. utils.delay(8, self.recover) def recover(self): \"This will be called after 8 secs\" del self.caller.ndb.off_balance self.caller.msg(\"You regain your balance.\") Note how, after the cooldown, the user will get a message telling them they are now ready for another swing. By storing the off_balance flag on the character (rather than on, say, the Command instance itself) it can be accessed by other Commands too. Other attacks may also not work when you are off balance. You could also have an enemy Command check your off_balance status to gain bonuses, to take another example. Abortable commands \u00b6 One can imagine that you will want to abort a long-running command before it has a time to finish. If you are in the middle of crafting your armor you will probably want to stop doing that when a monster enters your smithy. You can implement this in the same way as you do the \"blocking\" command above, just in reverse. Below is an example of a crafting command that can be aborted by starting a fight: from evennia import utils, default_cmds class CmdCraftArmour(default_cmds.MuxCommand): \"\"\" Craft armour Usage: craft <name of armour> This will craft a suit of armour, assuming you have all the components and tools. Doing some other action (such as attacking someone) will abort the crafting process. \"\"\" key = \"craft\" locks = \"cmd:all()\" def func(self): \"starts crafting\" if self.caller.ndb.is_crafting: self.caller.msg(\"You are already crafting!\") return if self._is_fighting(): self.caller.msg(\"You can't start to craft \" \"in the middle of a fight!\") return # [Crafting code, checking of components, skills etc] # Start crafting self.caller.ndb.is_crafting = True self.caller.msg(\"You start crafting ...\") utils.delay(60, self.step1) def _is_fighting(self): \"checks if we are in a fight.\" if self.caller.ndb.is_fighting: del self.caller.ndb.is_crafting return True def step1(self): \"first step of armour construction\" if self._is_fighting(): return self.msg(\"You create the first part of the armour.\") utils.delay(60, callback=self.step2) def step2(self): \"second step of armour construction\" if self._is_fighting(): return self.msg(\"You create the second part of the armour.\") utils.delay(60, step3) def step3(self): \"last step of armour construction\" if self._is_fighting(): return # [code for creating the armour object etc] del self.caller.ndb.is_crafting self.msg(\"You finalize your armour.\") # example of a command that aborts crafting class CmdAttack(default_cmds.MuxCommand): \"\"\" attack someone Usage: attack <target> Try to cause harm to someone. This will abort eventual crafting you may be currently doing. \"\"\" key = \"attack\" aliases = [\"hit\", \"stab\"] locks = \"cmd:all()\" def func(self): \"Implements the command\" self.caller.ndb.is_fighting = True # [...] The above code creates a delayed crafting command that will gradually create the armour. If the attack command is issued during this process it will set a flag that causes the crafting to be quietly canceled next time it tries to update. Persistent delays \u00b6 In the latter examples above we used .ndb storage. This is fast and easy but it will reset all cooldowns/blocks/crafting etc if you reload the server. If you don't want that you can replace .ndb with .db . But even this won't help because the yield keyword is not persisent and nor is the use of delay shown above. To resolve this you can use delay with the persistent=True keyword. But wait! Making something persistent will add some extra complications, because now you must make sure Evennia can properly store things to the database. Here is the original echo-command reworked to function with persistence: from evennia import default_cmds, utils # this is now in the outermost scope and takes two args! def echo(caller, args): \"Called after 10 seconds.\" shout = args string = \"You hear an echo: %s ... %s ... %s\" string = string % (shout.upper(), shout.capitalize(), shout.lower()) caller.msg(string) class CmdEcho(default_cmds.MuxCommand): \"\"\" wait for an echo Usage: echo <string> Calls and waits for an echo \"\"\" key = \"echo\" locks = \"cmd:all()\" def func(self): \"\"\" This is called at the initial shout. \"\"\" self.caller.msg(\"You shout '%s' and wait for an echo ...\" % self.args) # this waits non-blocking for 10 seconds, then calls echo(self.caller, self.args) utils.delay(10, echo, self.caller, self.args, persistent=True) # changes! Above you notice two changes: - The callback ( echo ) was moved out of the class and became its own stand-alone function in the outermost scope of the module. It also now takes caller and args as arguments (it doesn't have access to them directly since this is now a stand-alone function). - utils.delay specifies the echo function (not self.echo - it's no longer a method!) and sends self.caller and self.args as arguments for it to use. We also set persistent=True . The reason for this change is because Evennia needs to pickle the callback into storage and it cannot do this correctly when the method sits on the command class. Now this behave the same as the first version except if you reload (or even shut down) the server mid-delay it will still fire the callback when the server comes back up (it will resume the countdown and ignore the downtime).","title":"Command Duration"},{"location":"Command-Duration.html#the-simple-way-to-pause-commands-with-yield","text":"Evennia allows a shortcut in syntax to create simple pauses in commands. This syntax uses the yield keyword. The yield keyword is used in Python to create generators, although you don't need to know what generators are to use this syntax. A short example will probably make it clear: class CmdTest(Command): \"\"\" A test command just to test waiting. Usage: test \"\"\" key = \"test\" locks = \"cmd:all()\" def func(self): self.msg(\"Before ten seconds...\") yield 10 self.msg(\"Afterwards.\") Important: The yield functionality will only work in the func method of Commands. It only works because Evennia has especially catered for it in Commands. If you want the same functionality elsewhere you must use the interactive decorator . The important line is the yield 10 . It tells Evennia to \"pause\" the command and to wait for 10 seconds to execute the rest. If you add this command and run it, you'll see the first message, then, after a pause of ten seconds, the next message. You can use yield several times in your command. This syntax will not \"freeze\" all commands. While the command is \"pausing\", you can execute other commands (or even call the same command again). And other players aren't frozen either. Note: this will not save anything in the database. If you reload the game while a command is \"paused\", it will not resume after the server has reloaded.","title":"The simple way to pause commands with yield"},{"location":"Command-Duration.html#the-more-advanced-way-with-utilsdelay","text":"The yield syntax is easy to read, easy to understand, easy to use. But it's not that flexible if you want more advanced options. Learning to use alternatives might be much worth it in the end. Below is a simple command example for adding a duration for a command to finish. from evennia import default_cmds, utils class CmdEcho(default_cmds.MuxCommand): \"\"\" wait for an echo Usage: echo <string> Calls and waits for an echo \"\"\" key = \"echo\" locks = \"cmd:all()\" def func(self): \"\"\" This is called at the initial shout. \"\"\" self.caller.msg(\"You shout '%s' and wait for an echo ...\" % self.args) # this waits non-blocking for 10 seconds, then calls self.echo utils.delay(10, self.echo) # call echo after 10 seconds def echo(self): \"Called after 10 seconds.\" shout = self.args string = \"You hear an echo: %s ... %s ... %s\" string = string % (shout.upper(), shout.capitalize(), shout.lower()) self.caller.msg(string) Import this new echo command into the default command set and reload the server. You will find that it will take 10 seconds before you see your shout coming back. You will also find that this is a non-blocking effect; you can issue other commands in the interim and the game will go on as usual. The echo will come back to you in its own time.","title":"The more advanced way with utils.delay"},{"location":"Command-Duration.html#about-utilsdelay","text":"utils.delay(timedelay, callback, persistent=False, *args, **kwargs) is a useful function. It will wait timedelay seconds, then call the callback function, optionally passing to it the arguments provided to utils.delay by way of args and/or *kwargs`. Note: The callback argument should be provided with a python path to the desired function, for instance my_object.my_function instead of my_object.my_function() . Otherwise my_function would get called and run immediately upon attempting to pass it to the delay function. If you want to provide arguments for utils.delay to use, when calling your callback function, you have to do it separatly, for instance using the utils.delay args and/or *kwargs, as mentioned above. If you are not familiar with the syntax *args and **kwargs , see the Python documentation here . Looking at it you might think that utils.delay(10, callback) in the code above is just an alternative to some more familiar thing like time.sleep(10) . This is not the case. If you do time.sleep(10) you will in fact freeze the entire server for ten seconds! The utils.delay() is a thin wrapper around a Twisted Deferred that will delay execution until 10 seconds have passed, but will do so asynchronously, without bothering anyone else (not even you - you can continue to do stuff normally while it waits to continue). The point to remember here is that the delay() call will not \"pause\" at that point when it is called (the way yield does in the previous section). The lines after the delay() call will actually execute right away . What you must do is to tell it which function to call after the time has passed (its \"callback\"). This may sound strange at first, but it is normal practice in asynchronous systems. You can also link such calls together as seen below: from evennia import default_cmds, utils class CmdEcho(default_cmds.MuxCommand): \"\"\" waits for an echo Usage: echo <string> Calls and waits for an echo \"\"\" key = \"echo\" locks = \"cmd:all()\" def func(self): \"This sets off a chain of delayed calls\" self.caller.msg(\"You shout '%s', waiting for an echo ...\" % self.args) # wait 2 seconds before calling self.echo1 utils.delay(2, self.echo1) # callback chain, started above def echo1(self): \"First echo\" self.caller.msg(\"... %s\" % self.args.upper()) # wait 2 seconds for the next one utils.delay(2, self.echo2) def echo2(self): \"Second echo\" self.caller.msg(\"... %s\" % self.args.capitalize()) # wait another 2 seconds utils.delay(2, callback=self.echo3) def echo3(self): \"Last echo\" self.caller.msg(\"... %s ...\" % self.args.lower()) The above version will have the echoes arrive one after another, each separated by a two second delay. > echo Hello! ... HELLO! ... Hello! ... hello! ...","title":"About utils.delay()"},{"location":"Command-Duration.html#blocking-commands","text":"As mentioned, a great thing about the delay introduced by yield or utils.delay() is that it does not block. It just goes on in the background and you are free to play normally in the interim. In some cases this is not what you want however. Some commands should simply \"block\" other commands while they are running. If you are in the process of crafting a helmet you shouldn't be able to also start crafting a shield at the same time, or if you just did a huge power-swing with your weapon you should not be able to do it again immediately. The simplest way of implementing blocking is to use the technique covered in the Command Cooldown tutorial. In that tutorial we implemented cooldowns by having the Command store the current time. Next time the Command was called, we compared the current time to the stored time to determine if enough time had passed for a renewed use. This is a very efficient, reliable and passive solution. The drawback is that there is nothing to tell the Player when enough time has passed unless they keep trying. Here is an example where we will use utils.delay to tell the player when the cooldown has passed: from evennia import utils, default_cmds class CmdBigSwing(default_cmds.MuxCommand): \"\"\" swing your weapon in a big way Usage: swing <target> Makes a mighty swing. Doing so will make you vulnerable to counter-attacks before you can recover. \"\"\" key = \"bigswing\" locks = \"cmd:all()\" def func(self): \"Makes the swing\" if self.caller.ndb.off_balance: # we are still off-balance. self.caller.msg(\"You are off balance and need time to recover!\") return # [attack/hit code goes here ...] self.caller.msg(\"You swing big! You are off balance now.\") # set the off-balance flag self.caller.ndb.off_balance = True # wait 8 seconds before we can recover. During this time # we won't be able to swing again due to the check at the top. utils.delay(8, self.recover) def recover(self): \"This will be called after 8 secs\" del self.caller.ndb.off_balance self.caller.msg(\"You regain your balance.\") Note how, after the cooldown, the user will get a message telling them they are now ready for another swing. By storing the off_balance flag on the character (rather than on, say, the Command instance itself) it can be accessed by other Commands too. Other attacks may also not work when you are off balance. You could also have an enemy Command check your off_balance status to gain bonuses, to take another example.","title":"Blocking commands"},{"location":"Command-Duration.html#abortable-commands","text":"One can imagine that you will want to abort a long-running command before it has a time to finish. If you are in the middle of crafting your armor you will probably want to stop doing that when a monster enters your smithy. You can implement this in the same way as you do the \"blocking\" command above, just in reverse. Below is an example of a crafting command that can be aborted by starting a fight: from evennia import utils, default_cmds class CmdCraftArmour(default_cmds.MuxCommand): \"\"\" Craft armour Usage: craft <name of armour> This will craft a suit of armour, assuming you have all the components and tools. Doing some other action (such as attacking someone) will abort the crafting process. \"\"\" key = \"craft\" locks = \"cmd:all()\" def func(self): \"starts crafting\" if self.caller.ndb.is_crafting: self.caller.msg(\"You are already crafting!\") return if self._is_fighting(): self.caller.msg(\"You can't start to craft \" \"in the middle of a fight!\") return # [Crafting code, checking of components, skills etc] # Start crafting self.caller.ndb.is_crafting = True self.caller.msg(\"You start crafting ...\") utils.delay(60, self.step1) def _is_fighting(self): \"checks if we are in a fight.\" if self.caller.ndb.is_fighting: del self.caller.ndb.is_crafting return True def step1(self): \"first step of armour construction\" if self._is_fighting(): return self.msg(\"You create the first part of the armour.\") utils.delay(60, callback=self.step2) def step2(self): \"second step of armour construction\" if self._is_fighting(): return self.msg(\"You create the second part of the armour.\") utils.delay(60, step3) def step3(self): \"last step of armour construction\" if self._is_fighting(): return # [code for creating the armour object etc] del self.caller.ndb.is_crafting self.msg(\"You finalize your armour.\") # example of a command that aborts crafting class CmdAttack(default_cmds.MuxCommand): \"\"\" attack someone Usage: attack <target> Try to cause harm to someone. This will abort eventual crafting you may be currently doing. \"\"\" key = \"attack\" aliases = [\"hit\", \"stab\"] locks = \"cmd:all()\" def func(self): \"Implements the command\" self.caller.ndb.is_fighting = True # [...] The above code creates a delayed crafting command that will gradually create the armour. If the attack command is issued during this process it will set a flag that causes the crafting to be quietly canceled next time it tries to update.","title":"Abortable commands"},{"location":"Command-Duration.html#persistent-delays","text":"In the latter examples above we used .ndb storage. This is fast and easy but it will reset all cooldowns/blocks/crafting etc if you reload the server. If you don't want that you can replace .ndb with .db . But even this won't help because the yield keyword is not persisent and nor is the use of delay shown above. To resolve this you can use delay with the persistent=True keyword. But wait! Making something persistent will add some extra complications, because now you must make sure Evennia can properly store things to the database. Here is the original echo-command reworked to function with persistence: from evennia import default_cmds, utils # this is now in the outermost scope and takes two args! def echo(caller, args): \"Called after 10 seconds.\" shout = args string = \"You hear an echo: %s ... %s ... %s\" string = string % (shout.upper(), shout.capitalize(), shout.lower()) caller.msg(string) class CmdEcho(default_cmds.MuxCommand): \"\"\" wait for an echo Usage: echo <string> Calls and waits for an echo \"\"\" key = \"echo\" locks = \"cmd:all()\" def func(self): \"\"\" This is called at the initial shout. \"\"\" self.caller.msg(\"You shout '%s' and wait for an echo ...\" % self.args) # this waits non-blocking for 10 seconds, then calls echo(self.caller, self.args) utils.delay(10, echo, self.caller, self.args, persistent=True) # changes! Above you notice two changes: - The callback ( echo ) was moved out of the class and became its own stand-alone function in the outermost scope of the module. It also now takes caller and args as arguments (it doesn't have access to them directly since this is now a stand-alone function). - utils.delay specifies the echo function (not self.echo - it's no longer a method!) and sends self.caller and self.args as arguments for it to use. We also set persistent=True . The reason for this change is because Evennia needs to pickle the callback into storage and it cannot do this correctly when the method sits on the command class. Now this behave the same as the first version except if you reload (or even shut down) the server mid-delay it will still fire the callback when the server comes back up (it will resume the countdown and ignore the downtime).","title":"Persistent delays"},{"location":"Command-Prompt.html","text":"A prompt is quite common in MUDs. The prompt display useful details about your character that you are likely to want to keep tabs on at all times, such as health, magical power etc. It might also show things like in-game time, weather and so on. Many modern MUD clients (including Evennia's own webclient) allows for identifying the prompt and have it appear in a correct location (usually just above the input line). Usually it will remain like that until it is explicitly updated. Sending a prompt \u00b6 A prompt is sent using the prompt keyword to the msg() method on objects. The prompt will be sent without any line breaks. self.msg(prompt=\"HP: 5, MP: 2, SP: 8\") You can combine the sending of normal text with the sending (updating of the prompt): self.msg(\"This is a text\", prompt=\"This is a prompt\") You can update the prompt on demand, this is normally done using OOB -tracking of the relevant Attributes (like the character's health). You could also make sure that attacking commands update the prompt when they cause a change in health, for example. Here is a simple example of the prompt sent/updated from a command class: from evennia import Command class CmdDiagnose(Command): \"\"\" see how hurt your are Usage: diagnose [target] This will give an estimate of the target's health. Also the target's prompt will be updated. \"\"\" key = \"diagnose\" def func(self): if not self.args: target = self.caller else: target = self.search(self.args) if not target: return # try to get health, mana and stamina hp = target.db.hp mp = target.db.mp sp = target.db.sp if None in (hp, mp, sp): # Attributes not defined self.caller.msg(\"Not a valid target!\") return text = \"You diagnose %s as having \" \\ \"%i health, %i mana and %i stamina.\" \\ % (hp, mp, sp) prompt = \"%i HP, %i MP, %i SP\" % (hp, mp, sp) self.caller.msg(text, prompt=prompt) A prompt sent with every command \u00b6 The prompt sent as described above uses a standard telnet instruction (the Evennia web client gets a special flag). Most MUD telnet clients will understand and allow users to catch this and keep the prompt in place until it updates. So in principle you'd not need to update the prompt every command. However, with a varying user base it can be unclear which clients are used and which skill level the users have. So sending a prompt with every command is a safe catch-all. You don't need to manually go in and edit every command you have though. Instead you edit the base command class for your custom commands (like MuxCommand in your mygame/commands/command.py folder) and overload the at_post_cmd() hook. This hook is always called after the main func() method of the Command. from evennia import default_cmds class MuxCommand(default_cmds.MuxCommand): # ... def at_post_cmd(self): \"called after self.func().\" caller = self.caller prompt = \"%i HP, %i MP, %i SP\" % (caller.db.hp, caller.db.mp, caller.db.sp) caller.msg(prompt=prompt) Modifying default commands \u00b6 If you want to add something small like this to Evennia's default commands without modifying them directly the easiest way is to just wrap those with a multiple inheritance to your own base class: # in (for example) mygame/commands/mycommands.py from evennia import default_cmds # our custom MuxCommand with at_post_cmd hook from commands.command import MuxCommand # overloading the look command class CmdLook(default_cmds.CmdLook, MuxCommand): pass The result of this is that the hooks from your custom MuxCommand will be mixed into the default CmdLook through multiple inheritance. Next you just add this to your default command set: # in mygame/commands/default_cmdsets.py from evennia import default_cmds from commands import mycommands class CharacterCmdSet(default_cmds.CharacterCmdSet): # ... def at_cmdset_creation(self): # ... self.add(mycommands.CmdLook()) This will automatically replace the default look command in your game with your own version.","title":"Command Prompt"},{"location":"Command-Prompt.html#sending-a-prompt","text":"A prompt is sent using the prompt keyword to the msg() method on objects. The prompt will be sent without any line breaks. self.msg(prompt=\"HP: 5, MP: 2, SP: 8\") You can combine the sending of normal text with the sending (updating of the prompt): self.msg(\"This is a text\", prompt=\"This is a prompt\") You can update the prompt on demand, this is normally done using OOB -tracking of the relevant Attributes (like the character's health). You could also make sure that attacking commands update the prompt when they cause a change in health, for example. Here is a simple example of the prompt sent/updated from a command class: from evennia import Command class CmdDiagnose(Command): \"\"\" see how hurt your are Usage: diagnose [target] This will give an estimate of the target's health. Also the target's prompt will be updated. \"\"\" key = \"diagnose\" def func(self): if not self.args: target = self.caller else: target = self.search(self.args) if not target: return # try to get health, mana and stamina hp = target.db.hp mp = target.db.mp sp = target.db.sp if None in (hp, mp, sp): # Attributes not defined self.caller.msg(\"Not a valid target!\") return text = \"You diagnose %s as having \" \\ \"%i health, %i mana and %i stamina.\" \\ % (hp, mp, sp) prompt = \"%i HP, %i MP, %i SP\" % (hp, mp, sp) self.caller.msg(text, prompt=prompt)","title":"Sending a prompt"},{"location":"Command-Prompt.html#a-prompt-sent-with-every-command","text":"The prompt sent as described above uses a standard telnet instruction (the Evennia web client gets a special flag). Most MUD telnet clients will understand and allow users to catch this and keep the prompt in place until it updates. So in principle you'd not need to update the prompt every command. However, with a varying user base it can be unclear which clients are used and which skill level the users have. So sending a prompt with every command is a safe catch-all. You don't need to manually go in and edit every command you have though. Instead you edit the base command class for your custom commands (like MuxCommand in your mygame/commands/command.py folder) and overload the at_post_cmd() hook. This hook is always called after the main func() method of the Command. from evennia import default_cmds class MuxCommand(default_cmds.MuxCommand): # ... def at_post_cmd(self): \"called after self.func().\" caller = self.caller prompt = \"%i HP, %i MP, %i SP\" % (caller.db.hp, caller.db.mp, caller.db.sp) caller.msg(prompt=prompt)","title":"A prompt sent with every command"},{"location":"Command-Prompt.html#modifying-default-commands","text":"If you want to add something small like this to Evennia's default commands without modifying them directly the easiest way is to just wrap those with a multiple inheritance to your own base class: # in (for example) mygame/commands/mycommands.py from evennia import default_cmds # our custom MuxCommand with at_post_cmd hook from commands.command import MuxCommand # overloading the look command class CmdLook(default_cmds.CmdLook, MuxCommand): pass The result of this is that the hooks from your custom MuxCommand will be mixed into the default CmdLook through multiple inheritance. Next you just add this to your default command set: # in mygame/commands/default_cmdsets.py from evennia import default_cmds from commands import mycommands class CharacterCmdSet(default_cmds.CharacterCmdSet): # ... def at_cmdset_creation(self): # ... self.add(mycommands.CmdLook()) This will automatically replace the default look command in your game with your own version.","title":"Modifying default commands"},{"location":"Command-Sets.html","text":"Command Sets are intimately linked with Commands and you should be familiar with Commands before reading this page. The two pages were split for ease of reading. A Command Set (often referred to as a CmdSet or cmdset) is the basic unit for storing one or more Commands . A given Command can go into any number of different command sets. Storing Command classes in a command set is the way to make commands available to use in your game. When storing a CmdSet on an object, you will make the commands in that command set available to the object. An example is the default command set stored on new Characters. This command set contains all the useful commands, from look and inventory to @dig and @reload ( permissions then limit which players may use them, but that's a separate topic). When an account enters a command, cmdsets from the Account, Character, its location, and elsewhere are pulled together into a merge stack . This stack is merged together in a specific order to create a single \"merged\" cmdset, representing the pool of commands available at that very moment. An example would be a Window object that has a cmdset with two commands in it: look through window and open window . The command set would be visible to players in the room with the window, allowing them to use those commands only there. You could imagine all sorts of clever uses of this, like a Television object which had multiple commands for looking at it, switching channels and so on. The tutorial world included with Evennia showcases a dark room that replaces certain critical commands with its own versions because the Character cannot see. If you want a quick start into defining your first commands and using them with command sets, you can head over to the Adding Command Tutorial which steps through things without the explanations. Defining Command Sets \u00b6 A CmdSet is, as most things in Evennia, defined as a Python class inheriting from the correct parent ( evennia.CmdSet , which is a shortcut to evennia.commands.cmdset.CmdSet ). The CmdSet class only needs to define one method, called at_cmdset_creation() . All other class parameters are optional, but are used for more advanced set manipulation and coding (see the merge rules section). # file mygame/commands/mycmdset.py from evennia import CmdSet # this is a theoretical custom module with commands we # created previously: mygame/commands/mycommands.py from commands import mycommands class MyCmdSet(CmdSet): def at_cmdset_creation(self): \"\"\" The only thing this method should need to do is to add commands to the set. \"\"\" self.add(mycommands.MyCommand1()) self.add(mycommands.MyCommand2()) self.add(mycommands.MyCommand3()) The CmdSet's add() method can also take another CmdSet as input. In this case all the commands from that CmdSet will be appended to this one as if you added them line by line: def at_cmdset_creation(): ... self.add(AdditionalCmdSet) # adds all command from this set ... If you added your command to an existing cmdset (like to the default cmdset), that set is already loaded into memory. You need to make the server aware of the code changes: @reload You should now be able to use the command. If you created a new, fresh cmdset, this must be added to an object in order to make the commands within available. A simple way to temporarily test a cmdset on yourself is use the @py command to execute a python snippet: @py self.cmdset.add('commands.mycmdset.MyCmdSet') This will stay with you until you @reset or @shutdown the server, or you run @py self.cmdset.delete('commands.mycmdset.MyCmdSet') In the example above, a specific Cmdset class is removed. Calling delete without arguments will remove the latest added cmdset. Note: Command sets added using cmdset.add are, by default, not persistent in the database. If you want the cmdset to survive a reload, you can do: @py self.cmdset.add(commands.mycmdset.MyCmdSet, permanent=True) Or you could add the cmdset as the default cmdset: @py self.cmdset.add_default(commands.mycmdset.MyCmdSet) An object can only have one \"default\" cmdset (but can also have none). This is meant as a safe fall-back even if all other cmdsets fail or are removed. It is always persistent and will not be affected by cmdset.delete() . To remove a default cmdset you must explicitly call cmdset.remove_default() . Command sets are often added to an object in its at_object_creation method. For more examples of adding commands, read the Step by step tutorial . Generally you can customize which command sets are added to your objects by using self.cmdset.add() or self.cmdset.add_default() . Important: Commands are identified uniquely by key or alias (see Commands ). If any overlap exists, two commands are considered identical. Adding a Command to a command set that already has an identical command will replace the previous command. This is very important. You must take this behavior into account when attempting to overload any default Evennia commands with your own. Otherwise, you may accidentally \"hide\" your own command in your command set when adding a new one that has a matching alias. Properties on Command Sets \u00b6 There are several extra flags that you can set on CmdSets in order to modify how they work. All are optional and will be set to defaults otherwise. Since many of these relate to merging cmdsets, you might want to read the Adding and Merging Command Sets section for some of these to make sense. key (string) - an identifier for the cmdset. This is optional, but should be unique. It is used for display in lists, but also to identify special merging behaviours using the key_mergetype dictionary below. - mergetype (string) - allows for one of the following string values: \" Union \", \" Intersect \", \" Replace \", or \" Remove \". priority (int) - This defines the merge order of the merge stack - cmdsets will merge in rising order of priority with the highest priority set merging last. During a merger, the commands from the set with the higher priority will have precedence (just what happens depends on the merge type ). If priority is identical, the order in the merge stack determines preference. The priority value must be greater or equal to -100 . Most in-game sets should usually have priorities between 0 and 100 . Evennia default sets have priorities as follows (these can be changed if you want a different distribution): EmptySet: -101 (should be lower than all other sets) SessionCmdSet: -20 AccountCmdSet: -10 CharacterCmdSet: 0 ExitCmdSet: 101 (generally should always be available) ChannelCmdSet: 101 (should usually always be available) - since exits never accept arguments, there is no collision between exits named the same as a channel even though the commands \"collide\". key_mergetype (dict) - a dict of key:mergetype pairs. This allows this cmdset to merge differently with certain named cmdsets. If the cmdset to merge with has a key matching an entry in key_mergetype , it will not be merged according to the setting in mergetype but according to the mode in this dict. Please note that this is more complex than it may seem due to the merge order of command sets. Please review that section before using key_mergetype . duplicates (bool/None default None ) - this determines what happens when merging same-priority cmdsets containing same-key commands together. The dupicate option will only apply when merging the cmdset with this option onto one other cmdset with the same priority. The resulting cmdset will not retain this duplicate setting. None (default): No duplicates are allowed and the cmdset being merged \"onto\" the old one will take precedence. The result will be unique commands. However , the system will assume this value to be True for cmdsets on Objects, to avoid dangerous clashes. This is usually the safe bet. False : Like None except the system will not auto-assume any value for cmdsets defined on Objects. True : Same-named, same-prio commands will merge into the same cmdset. This will lead to a multimatch error (the user will get a list of possibilities in order to specify which command they meant). This is is useful e.g. for on-object cmdsets (example: There is a red button and a green button in the room. Both have a press button command, in cmdsets with the same priority. This flag makes sure that just writing press button will force the Player to define just which object's command was intended). no_objs this is a flag for the cmdhandler that builds the set of commands available at every moment. It tells the handler not to include cmdsets from objects around the account (nor from rooms or inventory) when building the merged set. Exit commands will still be included. This option can have three values: None (default): Passthrough of any value set explicitly earlier in the merge stack. If never set explicitly, this acts as False . True / False : Explicitly turn on/off. If two sets with explicit no_objs are merged, priority determines what is used. no_exits - this is a flag for the cmdhandler that builds the set of commands available at every moment. It tells the handler not to include cmdsets from exits. This flag can have three values: None (default): Passthrough of any value set explicitly earlier in the merge stack. If never set explicitly, this acts as False . True / False : Explicitly turn on/off. If two sets with explicit no_exits are merged, priority determines what is used. no_channels (bool) - this is a flag for the cmdhandler that builds the set of commands available at every moment. It tells the handler not to include cmdsets from available in-game channels. This flag can have three values: None (default): Passthrough of any value set explicitly earlier in the merge stack. If never set explicitly, this acts as False . True / False : Explicitly turn on/off. If two sets with explicit no_channels are merged, priority determines what is used. Command Sets Searched \u00b6 When a user issues a command, it is matched against the merged command sets available to the player at the moment. Which those are may change at any time (such as when the player walks into the room with the Window object described earlier). The currently valid command sets are collected from the following sources: The cmdsets stored on the currently active Session . Default is the empty SessionCmdSet with merge priority -20 . The cmdsets defined on the Account . Default is the AccountCmdSet with merge priority -10 . All cmdsets on the Character/Object (assuming the Account is currently puppeting such a Character/Object). Merge priority 0 . The cmdsets of all objects carried by the puppeted Character (checks the call lock). Will not be included if no_objs option is active in the merge stack. The cmdsets of the Character's current location (checks the call lock). Will not be included if no_objs option is active in the merge stack. The cmdsets of objects in the current location (checks the call lock). Will not be included if no_objs option is active in the merge stack. The cmdsets of Exits in the location. Merge priority +101 . Will not be included if no_exits or no_objs option is active in the merge stack. The channel cmdset containing commands for posting to all channels the account or character is currently connected to. Merge priority +101 . Will not be included if no_channels option is active in the merge stack. Note that an object does not have to share its commands with its surroundings. A Character's cmdsets should not be shared for example, or all other Characters would get multi-match errors just by being in the same room. The ability of an object to share its cmdsets is managed by its call lock . For example, Character objects defaults to call:false() so that any cmdsets on them can only be accessed by themselves, not by other objects around them. Another example might be to lock an object with call:inside() to only make their commands available to objects inside them, or cmd:holds() to make their commands available only if they are held. Adding and Merging Command Sets \u00b6 Note: This is an advanced topic. It's very useful to know about, but you might want to skip it if this is your first time learning about commands. CmdSets have the special ability that they can be merged together into new sets. Which of the ingoing commands end up in the merged set is defined by the merge rule and the relative priorities of the two sets. Removing the latest added set will restore things back to the way it was before the addition. CmdSets are non-destructively stored in a stack inside the cmdset handler on the object. This stack is parsed to create the \"combined\" cmdset active at the moment. CmdSets from other sources are also included in the merger such as those on objects in the same room (like buttons to press) or those introduced by state changes (such as when entering a menu). The cmdsets are all ordered after priority and then merged together in reverse order . That is, the higher priority will be merged \"onto\" lower-prio ones. By defining a cmdset with a merge-priority between that of two other sets, you will make sure it will be merged in between them. The very first cmdset in this stack is called the Default cmdset and is protected from accidental deletion. Running obj.cmdset.delete() will never delete the default set. Instead one should add new cmdsets on top of the default to \"hide\" it, as described below. Use the special obj.cmdset.delete_default() only if you really know what you are doing. CmdSet merging is an advanced feature useful for implementing powerful game effects. Imagine for example a player entering a dark room. You don't want the player to be able to find everything in the room at a glance - maybe you even want them to have a hard time to find stuff in their backpack! You can then define a different CmdSet with commands that override the normal ones. While they are in the dark room, maybe the look and inv commands now just tell the player they cannot see anything! Another example would be to offer special combat commands only when the player is in combat. Or when being on a boat. Or when having taken the super power-up. All this can be done on the fly by merging command sets. Merge Rules \u00b6 Basic rule is that command sets are merged in reverse priority order . That is, lower-prio sets are merged first and higher prio sets are merged \"on top\" of them. Think of it like a layered cake with the highest priority on top. To further understand how sets merge, we need to define some examples. Let's call the first command set A and the second B . We assume B is the command set already active on our object and we will merge A onto B . In code terms this would be done by object.cdmset.add(A) . Remember, B is already active on object from before. We let the A set have higher priority than B . A priority is simply an integer number. As seen in the list above, Evennia's default cmdsets have priorities in the range -101 to 120 . You are usually safe to use a priority of 0 or 1 for most game effects. In our examples, both sets contain a number of commands which we'll identify by numbers, like A1, A2 for set A and B1, B2, B3, B4 for B . So for that example both sets contain commands with the same keys (or aliases) \"1\" and \"2\" (this could for example be \"look\" and \"get\" in the real game), whereas commands 3 and 4 are unique to B . To describe a merge between these sets, we would write A1,A2 + B1,B2,B3,B4 = ? where ? is a list of commands that depend on which merge type A has, and which relative priorities the two sets have. By convention, we read this statement as \"New command set A is merged onto the old command set B to form ? \". Below are the available merge types and how they work. Names are partly borrowed from Set theory . Union (default) - The two cmdsets are merged so that as many commands as possible from each cmdset ends up in the merged cmdset. Same-key commands are merged by priority. # Union A1,A2 + B1,B2,B3,B4 = A1,A2,B3,B4 Intersect - Only commands found in both cmdsets (i.e. which have the same keys) end up in the merged cmdset, with the higher-priority cmdset replacing the lower one's commands. # Intersect A1,A3,A5 + B1,B2,B4,B5 = A1,A5 Replace - The commands of the higher-prio cmdset completely replaces the lower-priority cmdset's commands, regardless of if same-key commands exist or not. # Replace A1,A3 + B1,B2,B4,B5 = A1,A3 Remove - The high-priority command sets removes same-key commands from the lower-priority cmdset. They are not replaced with anything, so this is a sort of filter that prunes the low-prio set using the high-prio one as a template. # Remove A1,A3 + B1,B2,B3,B4,B5 = B2,B4,B5 Besides priority and mergetype , a command-set also takes a few other variables to control how they merge: duplicates (bool) - determines what happens when two sets of equal priority merge. Default is that the new set in the merger (i.e. A above) automatically takes precedence. But if duplicates is true, the result will be a merger with more than one of each name match. This will usually lead to the player receiving a multiple-match error higher up the road, but can be good for things like cmdsets on non-player objects in a room, to allow the system to warn that more than one 'ball' in the room has the same 'kick' command defined on it and offer a chance to select which ball to kick ... Allowing duplicates only makes sense for Union and Intersect , the setting is ignored for the other mergetypes. key_mergetypes (dict) - allows the cmdset to define a unique mergetype for particular cmdsets, identified by their cmdset key . Format is {CmdSetkey:mergetype} . Example: {'Myevilcmdset','Replace'} which would make sure for this set to always use 'Replace' on the cmdset with the key Myevilcmdset only, no matter what the main mergetype is set to. Warning: The key_mergetypes dictionary can only work on the cmdset we merge onto . When using key_mergetypes it is thus important to consider the merge priorities - you must make sure that you pick a priority between the cmdset you want to detect and the next higher one, if any. That is, if we define a cmdset with a high priority and set it to affect a cmdset that is far down in the merge stack, we would not \"see\" that set when it's time for us to merge. Example: Merge stack is A(prio=-10), B(prio=-5), C(prio=0), D(prio=5) . We now merge a cmdset E(prio=10) onto this stack, with a key_mergetype={\"B\":\"Replace\"} . But priorities dictate that we won't be merged onto B, we will be merged onto E (which is a merger of the lower-prio sets at this point). Since we are merging onto E and not B, our key_mergetype directive won't trigger. To make sure it works we must make sure we merge onto B. Setting E's priority to, say, -4 will make sure to merge it onto B and affect it appropriately. More advanced cmdset example: from commands import mycommands class MyCmdSet(CmdSet): key = \"MyCmdSet\" priority = 4 mergetype = \"Replace\" key_mergetypes = {'MyOtherCmdSet':'Union'} def at_cmdset_creation(self): \"\"\" The only thing this method should need to do is to add commands to the set. \"\"\" self.add(mycommands.MyCommand1()) self.add(mycommands.MyCommand2()) self.add(mycommands.MyCommand3()) Assorted Notes \u00b6 It is very important to remember that two commands are compared both by their key properties and by their aliases properties. If either keys or one of their aliases match, the two commands are considered the same . So consider these two Commands: A Command with key \"kick\" and alias \"fight\" A Command with key \"punch\" also with an alias \"fight\" During the cmdset merging (which happens all the time since also things like channel commands and exits are merged in), these two commands will be considered identical since they share alias. It means only one of them will remain after the merger. Each will also be compared with all other commands having any combination of the keys and/or aliases \"kick\", \"punch\" or \"fight\". ... So avoid duplicate aliases, it will only cause confusion.","title":"Command Sets"},{"location":"Command-Sets.html#defining-command-sets","text":"A CmdSet is, as most things in Evennia, defined as a Python class inheriting from the correct parent ( evennia.CmdSet , which is a shortcut to evennia.commands.cmdset.CmdSet ). The CmdSet class only needs to define one method, called at_cmdset_creation() . All other class parameters are optional, but are used for more advanced set manipulation and coding (see the merge rules section). # file mygame/commands/mycmdset.py from evennia import CmdSet # this is a theoretical custom module with commands we # created previously: mygame/commands/mycommands.py from commands import mycommands class MyCmdSet(CmdSet): def at_cmdset_creation(self): \"\"\" The only thing this method should need to do is to add commands to the set. \"\"\" self.add(mycommands.MyCommand1()) self.add(mycommands.MyCommand2()) self.add(mycommands.MyCommand3()) The CmdSet's add() method can also take another CmdSet as input. In this case all the commands from that CmdSet will be appended to this one as if you added them line by line: def at_cmdset_creation(): ... self.add(AdditionalCmdSet) # adds all command from this set ... If you added your command to an existing cmdset (like to the default cmdset), that set is already loaded into memory. You need to make the server aware of the code changes: @reload You should now be able to use the command. If you created a new, fresh cmdset, this must be added to an object in order to make the commands within available. A simple way to temporarily test a cmdset on yourself is use the @py command to execute a python snippet: @py self.cmdset.add('commands.mycmdset.MyCmdSet') This will stay with you until you @reset or @shutdown the server, or you run @py self.cmdset.delete('commands.mycmdset.MyCmdSet') In the example above, a specific Cmdset class is removed. Calling delete without arguments will remove the latest added cmdset. Note: Command sets added using cmdset.add are, by default, not persistent in the database. If you want the cmdset to survive a reload, you can do: @py self.cmdset.add(commands.mycmdset.MyCmdSet, permanent=True) Or you could add the cmdset as the default cmdset: @py self.cmdset.add_default(commands.mycmdset.MyCmdSet) An object can only have one \"default\" cmdset (but can also have none). This is meant as a safe fall-back even if all other cmdsets fail or are removed. It is always persistent and will not be affected by cmdset.delete() . To remove a default cmdset you must explicitly call cmdset.remove_default() . Command sets are often added to an object in its at_object_creation method. For more examples of adding commands, read the Step by step tutorial . Generally you can customize which command sets are added to your objects by using self.cmdset.add() or self.cmdset.add_default() . Important: Commands are identified uniquely by key or alias (see Commands ). If any overlap exists, two commands are considered identical. Adding a Command to a command set that already has an identical command will replace the previous command. This is very important. You must take this behavior into account when attempting to overload any default Evennia commands with your own. Otherwise, you may accidentally \"hide\" your own command in your command set when adding a new one that has a matching alias.","title":"Defining Command Sets"},{"location":"Command-Sets.html#properties-on-command-sets","text":"There are several extra flags that you can set on CmdSets in order to modify how they work. All are optional and will be set to defaults otherwise. Since many of these relate to merging cmdsets, you might want to read the Adding and Merging Command Sets section for some of these to make sense. key (string) - an identifier for the cmdset. This is optional, but should be unique. It is used for display in lists, but also to identify special merging behaviours using the key_mergetype dictionary below. - mergetype (string) - allows for one of the following string values: \" Union \", \" Intersect \", \" Replace \", or \" Remove \". priority (int) - This defines the merge order of the merge stack - cmdsets will merge in rising order of priority with the highest priority set merging last. During a merger, the commands from the set with the higher priority will have precedence (just what happens depends on the merge type ). If priority is identical, the order in the merge stack determines preference. The priority value must be greater or equal to -100 . Most in-game sets should usually have priorities between 0 and 100 . Evennia default sets have priorities as follows (these can be changed if you want a different distribution): EmptySet: -101 (should be lower than all other sets) SessionCmdSet: -20 AccountCmdSet: -10 CharacterCmdSet: 0 ExitCmdSet: 101 (generally should always be available) ChannelCmdSet: 101 (should usually always be available) - since exits never accept arguments, there is no collision between exits named the same as a channel even though the commands \"collide\". key_mergetype (dict) - a dict of key:mergetype pairs. This allows this cmdset to merge differently with certain named cmdsets. If the cmdset to merge with has a key matching an entry in key_mergetype , it will not be merged according to the setting in mergetype but according to the mode in this dict. Please note that this is more complex than it may seem due to the merge order of command sets. Please review that section before using key_mergetype . duplicates (bool/None default None ) - this determines what happens when merging same-priority cmdsets containing same-key commands together. The dupicate option will only apply when merging the cmdset with this option onto one other cmdset with the same priority. The resulting cmdset will not retain this duplicate setting. None (default): No duplicates are allowed and the cmdset being merged \"onto\" the old one will take precedence. The result will be unique commands. However , the system will assume this value to be True for cmdsets on Objects, to avoid dangerous clashes. This is usually the safe bet. False : Like None except the system will not auto-assume any value for cmdsets defined on Objects. True : Same-named, same-prio commands will merge into the same cmdset. This will lead to a multimatch error (the user will get a list of possibilities in order to specify which command they meant). This is is useful e.g. for on-object cmdsets (example: There is a red button and a green button in the room. Both have a press button command, in cmdsets with the same priority. This flag makes sure that just writing press button will force the Player to define just which object's command was intended). no_objs this is a flag for the cmdhandler that builds the set of commands available at every moment. It tells the handler not to include cmdsets from objects around the account (nor from rooms or inventory) when building the merged set. Exit commands will still be included. This option can have three values: None (default): Passthrough of any value set explicitly earlier in the merge stack. If never set explicitly, this acts as False . True / False : Explicitly turn on/off. If two sets with explicit no_objs are merged, priority determines what is used. no_exits - this is a flag for the cmdhandler that builds the set of commands available at every moment. It tells the handler not to include cmdsets from exits. This flag can have three values: None (default): Passthrough of any value set explicitly earlier in the merge stack. If never set explicitly, this acts as False . True / False : Explicitly turn on/off. If two sets with explicit no_exits are merged, priority determines what is used. no_channels (bool) - this is a flag for the cmdhandler that builds the set of commands available at every moment. It tells the handler not to include cmdsets from available in-game channels. This flag can have three values: None (default): Passthrough of any value set explicitly earlier in the merge stack. If never set explicitly, this acts as False . True / False : Explicitly turn on/off. If two sets with explicit no_channels are merged, priority determines what is used.","title":"Properties on Command Sets"},{"location":"Command-Sets.html#command-sets-searched","text":"When a user issues a command, it is matched against the merged command sets available to the player at the moment. Which those are may change at any time (such as when the player walks into the room with the Window object described earlier). The currently valid command sets are collected from the following sources: The cmdsets stored on the currently active Session . Default is the empty SessionCmdSet with merge priority -20 . The cmdsets defined on the Account . Default is the AccountCmdSet with merge priority -10 . All cmdsets on the Character/Object (assuming the Account is currently puppeting such a Character/Object). Merge priority 0 . The cmdsets of all objects carried by the puppeted Character (checks the call lock). Will not be included if no_objs option is active in the merge stack. The cmdsets of the Character's current location (checks the call lock). Will not be included if no_objs option is active in the merge stack. The cmdsets of objects in the current location (checks the call lock). Will not be included if no_objs option is active in the merge stack. The cmdsets of Exits in the location. Merge priority +101 . Will not be included if no_exits or no_objs option is active in the merge stack. The channel cmdset containing commands for posting to all channels the account or character is currently connected to. Merge priority +101 . Will not be included if no_channels option is active in the merge stack. Note that an object does not have to share its commands with its surroundings. A Character's cmdsets should not be shared for example, or all other Characters would get multi-match errors just by being in the same room. The ability of an object to share its cmdsets is managed by its call lock . For example, Character objects defaults to call:false() so that any cmdsets on them can only be accessed by themselves, not by other objects around them. Another example might be to lock an object with call:inside() to only make their commands available to objects inside them, or cmd:holds() to make their commands available only if they are held.","title":"Command Sets Searched"},{"location":"Command-Sets.html#adding-and-merging-command-sets","text":"Note: This is an advanced topic. It's very useful to know about, but you might want to skip it if this is your first time learning about commands. CmdSets have the special ability that they can be merged together into new sets. Which of the ingoing commands end up in the merged set is defined by the merge rule and the relative priorities of the two sets. Removing the latest added set will restore things back to the way it was before the addition. CmdSets are non-destructively stored in a stack inside the cmdset handler on the object. This stack is parsed to create the \"combined\" cmdset active at the moment. CmdSets from other sources are also included in the merger such as those on objects in the same room (like buttons to press) or those introduced by state changes (such as when entering a menu). The cmdsets are all ordered after priority and then merged together in reverse order . That is, the higher priority will be merged \"onto\" lower-prio ones. By defining a cmdset with a merge-priority between that of two other sets, you will make sure it will be merged in between them. The very first cmdset in this stack is called the Default cmdset and is protected from accidental deletion. Running obj.cmdset.delete() will never delete the default set. Instead one should add new cmdsets on top of the default to \"hide\" it, as described below. Use the special obj.cmdset.delete_default() only if you really know what you are doing. CmdSet merging is an advanced feature useful for implementing powerful game effects. Imagine for example a player entering a dark room. You don't want the player to be able to find everything in the room at a glance - maybe you even want them to have a hard time to find stuff in their backpack! You can then define a different CmdSet with commands that override the normal ones. While they are in the dark room, maybe the look and inv commands now just tell the player they cannot see anything! Another example would be to offer special combat commands only when the player is in combat. Or when being on a boat. Or when having taken the super power-up. All this can be done on the fly by merging command sets.","title":"Adding and Merging Command Sets"},{"location":"Command-Sets.html#merge-rules","text":"Basic rule is that command sets are merged in reverse priority order . That is, lower-prio sets are merged first and higher prio sets are merged \"on top\" of them. Think of it like a layered cake with the highest priority on top. To further understand how sets merge, we need to define some examples. Let's call the first command set A and the second B . We assume B is the command set already active on our object and we will merge A onto B . In code terms this would be done by object.cdmset.add(A) . Remember, B is already active on object from before. We let the A set have higher priority than B . A priority is simply an integer number. As seen in the list above, Evennia's default cmdsets have priorities in the range -101 to 120 . You are usually safe to use a priority of 0 or 1 for most game effects. In our examples, both sets contain a number of commands which we'll identify by numbers, like A1, A2 for set A and B1, B2, B3, B4 for B . So for that example both sets contain commands with the same keys (or aliases) \"1\" and \"2\" (this could for example be \"look\" and \"get\" in the real game), whereas commands 3 and 4 are unique to B . To describe a merge between these sets, we would write A1,A2 + B1,B2,B3,B4 = ? where ? is a list of commands that depend on which merge type A has, and which relative priorities the two sets have. By convention, we read this statement as \"New command set A is merged onto the old command set B to form ? \". Below are the available merge types and how they work. Names are partly borrowed from Set theory . Union (default) - The two cmdsets are merged so that as many commands as possible from each cmdset ends up in the merged cmdset. Same-key commands are merged by priority. # Union A1,A2 + B1,B2,B3,B4 = A1,A2,B3,B4 Intersect - Only commands found in both cmdsets (i.e. which have the same keys) end up in the merged cmdset, with the higher-priority cmdset replacing the lower one's commands. # Intersect A1,A3,A5 + B1,B2,B4,B5 = A1,A5 Replace - The commands of the higher-prio cmdset completely replaces the lower-priority cmdset's commands, regardless of if same-key commands exist or not. # Replace A1,A3 + B1,B2,B4,B5 = A1,A3 Remove - The high-priority command sets removes same-key commands from the lower-priority cmdset. They are not replaced with anything, so this is a sort of filter that prunes the low-prio set using the high-prio one as a template. # Remove A1,A3 + B1,B2,B3,B4,B5 = B2,B4,B5 Besides priority and mergetype , a command-set also takes a few other variables to control how they merge: duplicates (bool) - determines what happens when two sets of equal priority merge. Default is that the new set in the merger (i.e. A above) automatically takes precedence. But if duplicates is true, the result will be a merger with more than one of each name match. This will usually lead to the player receiving a multiple-match error higher up the road, but can be good for things like cmdsets on non-player objects in a room, to allow the system to warn that more than one 'ball' in the room has the same 'kick' command defined on it and offer a chance to select which ball to kick ... Allowing duplicates only makes sense for Union and Intersect , the setting is ignored for the other mergetypes. key_mergetypes (dict) - allows the cmdset to define a unique mergetype for particular cmdsets, identified by their cmdset key . Format is {CmdSetkey:mergetype} . Example: {'Myevilcmdset','Replace'} which would make sure for this set to always use 'Replace' on the cmdset with the key Myevilcmdset only, no matter what the main mergetype is set to. Warning: The key_mergetypes dictionary can only work on the cmdset we merge onto . When using key_mergetypes it is thus important to consider the merge priorities - you must make sure that you pick a priority between the cmdset you want to detect and the next higher one, if any. That is, if we define a cmdset with a high priority and set it to affect a cmdset that is far down in the merge stack, we would not \"see\" that set when it's time for us to merge. Example: Merge stack is A(prio=-10), B(prio=-5), C(prio=0), D(prio=5) . We now merge a cmdset E(prio=10) onto this stack, with a key_mergetype={\"B\":\"Replace\"} . But priorities dictate that we won't be merged onto B, we will be merged onto E (which is a merger of the lower-prio sets at this point). Since we are merging onto E and not B, our key_mergetype directive won't trigger. To make sure it works we must make sure we merge onto B. Setting E's priority to, say, -4 will make sure to merge it onto B and affect it appropriately. More advanced cmdset example: from commands import mycommands class MyCmdSet(CmdSet): key = \"MyCmdSet\" priority = 4 mergetype = \"Replace\" key_mergetypes = {'MyOtherCmdSet':'Union'} def at_cmdset_creation(self): \"\"\" The only thing this method should need to do is to add commands to the set. \"\"\" self.add(mycommands.MyCommand1()) self.add(mycommands.MyCommand2()) self.add(mycommands.MyCommand3())","title":"Merge Rules"},{"location":"Command-Sets.html#assorted-notes","text":"It is very important to remember that two commands are compared both by their key properties and by their aliases properties. If either keys or one of their aliases match, the two commands are considered the same . So consider these two Commands: A Command with key \"kick\" and alias \"fight\" A Command with key \"punch\" also with an alias \"fight\" During the cmdset merging (which happens all the time since also things like channel commands and exits are merged in), these two commands will be considered identical since they share alias. It means only one of them will remain after the merger. Each will also be compared with all other commands having any combination of the keys and/or aliases \"kick\", \"punch\" or \"fight\". ... So avoid duplicate aliases, it will only cause confusion.","title":"Assorted Notes"},{"location":"Command-System.html","text":"Commands Command Sets Command Auto-help See also: - Default Command Help - Adding Command Tutorial","title":"Command System"},{"location":"Commands.html","text":"Commands are intimately linked to Command Sets and you need to read that page too to be familiar with how the command system works. The two pages were split for easy reading. The basic way for users to communicate with the game is through Commands . These can be commands directly related to the game world such as look , get , drop and so on, or administrative commands such as examine or @dig . The default commands coming with Evennia are 'MUX-like' in that they use @ for admin commands, support things like switches, syntax with the '=' symbol etc, but there is nothing that prevents you from implementing a completely different command scheme for your game. You can find the default commands in evennia/commands/default . You should not edit these directly - they will be updated by the Evennia team as new features are added. Rather you should look to them for inspiration and inherit your own designs from them. There are two components to having a command running - the Command class and the Command Set (command sets were split into a separate wiki page for ease of reading). A Command is a python class containing all the functioning code for what a command does - for example, a get command would contain code for picking up objects. A Command Set (often referred to as a CmdSet or cmdset) is like a container for one or more Commands. A given Command can go into any number of different command sets. Only by putting the command set on a character object you will make all the commands therein available to use by that character. You can also store command sets on normal objects if you want users to be able to use the object in various ways. Consider a \"Tree\" object with a cmdset defining the commands climb and chop down . Or a \"Clock\" with a cmdset containing the single command check time . This page goes into full detail about how to use Commands. To fully use them you must also read the page detailing Command Sets . There is also a step-by-step Adding Command Tutorial that will get you started quickly without the extra explanations. Defining Commands \u00b6 All commands are implemented as normal Python classes inheriting from the base class Command ( evennia.Command ). You will find that this base class is very \"bare\". The default commands of Evennia actually inherit from a child of Command called MuxCommand - this is the class that knows all the mux-like syntax like /switches , splitting by \"=\" etc. Below we'll avoid mux-specifics and use the base Command class directly. # basic Command definition from evennia import Command class MyCmd(Command): \"\"\" This is the help-text for the command \"\"\" key = \"mycommand\" def parse(self): # parsing the command line here def func(self): # executing the command here Here is a minimalistic command with no custom parsing: from evennia import Command class CmdEcho(self): key = \"echo\" def func(self): # echo the caller's input back to the caller self.caller.msg(\"Echo: {}\".format(self.args) You define a new command by assigning a few class-global properties on your inherited class and overloading one or two hook functions. The full gritty mechanic behind how commands work are found towards the end of this page; for now you only need to know that the command handler creates an instance of this class and uses that instance whenever you use this command - it also dynamically assigns the new command instance a few useful properties that you can assume to always be available. Who is calling the command? \u00b6 In Evennia there are three types of objects that may call the command. It is important to be aware of this since this will also assign appropriate caller , session , sessid and account properties on the command body at runtime. Most often the calling type is Session . A Session . This is by far the most common case when a user is entering a command in their client. caller - this is set to the puppeted Object if such an object exists. If no puppet is found, caller is set equal to account . Only if an Account is not found either (such as before being logged in) will this be set to the Session object itself. session - a reference to the Session object itself. sessid - sessid.id , a unique integer identifier of the session. account - the Account object connected to this Session. None if not logged in. An Account . This only happens if account.execute_cmd() was used. No Session information can be obtained in this case. caller - this is set to the puppeted Object if such an object can be determined (without Session info this can only be determined in MULTISESSION_MODE=0 or 1 ). If no puppet is found, this is equal to account . session - None* sessid - None* account - Set to the Account object. An Object . This only happens if object.execute_cmd() was used (for example by an NPC). caller - This is set to the calling Object in question. session - None* sessid - None* account - None *) : There is a way to make the Session available also inside tests run directly on Accounts and Objects, and that is to pass it to execute_cmd like so: account.execute_cmd(\"...\", session=<Session>) . Doing so will make the .session and .sessid properties available in the command. Properties assigned to the command instance at run-time \u00b6 Let's say account Bob with a character BigGuy enters the command look at sword . After the system having successfully identified this as the \"look\" command and determined that BigGuy really has access to a command named look , it chugs the look command class out of storage and either loads an existing Command instance from cache or creates one. After some more checks it then assigns it the following properties: caller - The character BigGuy, in this example. This is a reference to the object executing the command. The value of this depends on what type of object is calling the command; see the previous section. session - the Session Bob uses to connect to the game and control BigGuy (see also previous section). sessid - the unique id of self.session , for quick lookup. account - the Account Bob (see previous section). cmdstring - the matched key for the command. This would be look in our example. args - this is the rest of the string, except the command name. So if the string entered was look at sword , args would be \" at sword \". Note the space kept - Evennia would correctly interpret lookat sword too. This is useful for things like /switches that should not use space. In the MuxCommand class used for default commands, this space is stripped. Also see the arg_regex property if you want to enforce a space to make lookat sword give a command-not-found error. obj - the game Object on which this command is defined. This need not be the caller, but since look is a common (default) command, this is probably defined directly on BigGuy - so obj will point to BigGuy. Otherwise obj could be an Account or any interactive object with commands defined on it, like in the example of the \"check time\" command defined on a \"Clock\" object. cmdset - this is a reference to the merged CmdSet (see below) from which this command was matched. This variable is rarely used, it's main use is for the auto-help system ( Advanced note: the merged cmdset need NOT be the same as BigGuy.cmdset . The merged set can be a combination of the cmdsets from other objects in the room, for example ). raw_string - this is the raw input coming from the user, without stripping any surrounding whitespace. The only thing that is stripped is the ending newline marker. Other useful utility methods: \u00b6 .get_help(caller, cmdset) - Get the help entry for this command. By default the arguments are not used, but they could be used to implement alternate help-display systems. .client_width() - Shortcut for getting the client's screen-width. Note that not all clients will truthfully report this value - that case the settings.DEFAULT_SCREEN_WIDTH will be returned. .styled_table(*args, **kwargs) - This returns an EvTable styled based on the session calling this command. The args/kwargs are the same as for EvTable, except styling defaults are set. .styled_header , _footer , separator - These will produce styled decorations for display to the user. They are useful for creating listings and forms with colors adjustable per-user. Defining your own command classes \u00b6 Beyond the properties Evennia always assigns to the command at run-time (listed above), your job is to define the following class properties: key (string) - the identifier for the command, like look . This should (ideally) be unique. A key can consist of more than one word, like \"press button\" or \"pull left lever\". Note that both key and aliases below determine the identity of a command. So two commands are considered if either matches. This is important for merging cmdsets described below. aliases (optional list) - a list of alternate names for the command ( [\"glance\", \"see\", \"l\"] ). Same name rules as for key applies. locks (string) - a lock definition , usually on the form cmd:<lockfuncs> . Locks is a rather big topic, so until you learn more about locks, stick to giving the lockstring \"cmd:all()\" to make the command available to everyone (if you don't provide a lock string, this will be assigned for you). help_category (optional string) - setting this helps to structure the auto-help into categories. If none is set, this will be set to General . save_for_next (optional boolean). This defaults to False . If True , a copy of this command object (along with any changes you have done to it) will be stored by the system and can be accessed by the next command by retrieving self.caller.ndb.last_cmd . The next run command will either clear or replace the storage. arg_regex (optional raw string): Used to force the parser to limit itself and tell it when the command-name ends and arguments begin (such as requiring this to be a space or a /switch). This is done with a regular expression. See the arg_regex section for the details. auto_help (optional boolean). Defaults to True . This allows for turning off the auto-help system on a per-command basis. This could be useful if you either want to write your help entries manually or hide the existence of a command from help 's generated list. is_exit (bool) - this marks the command as being used for an in-game exit. This is, by default, set by all Exit objects and you should not need to set it manually unless you make your own Exit system. It is used for optimization and allows the cmdhandler to easily disregard this command when the cmdset has its no_exits flag set. is_channel (bool)- this marks the command as being used for an in-game channel. This is, by default, set by all Channel objects and you should not need to set it manually unless you make your own Channel system. is used for optimization and allows the cmdhandler to easily disregard this command when its cmdset has its no_channels flag set. msg_all_sessions (bool): This affects the behavior of the Command.msg method. If unset (default), calling self.msg(text) from the Command will always only send text to the Session that actually triggered this Command. If set however, self.msg(text) will send to all Sessions relevant to the object this Command sits on. Just which Sessions receives the text depends on the object and the server's MULTISESSION_MODE . You should also implement at least two methods, parse() and func() (You could also implement perm() , but that's not needed unless you want to fundamentally change how access checks work). at_pre_cmd() is called very first on the command. If this function returns anything that evaluates to True the command execution is aborted at this point. parse() is intended to parse the arguments ( self.args ) of the function. You can do this in any way you like, then store the result(s) in variable(s) on the command object itself (i.e. on self ). To take an example, the default mux-like system uses this method to detect \"command switches\" and store them as a list in self.switches . Since the parsing is usually quite similar inside a command scheme you should make parse() as generic as possible and then inherit from it rather than re-implementing it over and over. In this way, the default MuxCommand class implements a parse() for all child commands to use. func() is called right after parse() and should make use of the pre-parsed input to actually do whatever the command is supposed to do. This is the main body of the command. The return value from this method will be returned from the execution as a Twisted Deferred. at_post_cmd() is called after func() to handle eventual cleanup. Finally, you should always make an informative doc string ( __doc__ ) at the top of your class. This string is dynamically read by the Help System to create the help entry for this command. You should decide on a way to format your help and stick to that. Below is how you define a simple alternative \" smile \" command: from evennia import Command class CmdSmile(Command): \"\"\" A smile command Usage: smile [at] [<someone>] grin [at] [<someone>] Smiles to someone in your vicinity or to the room in general. (This initial string (the __doc__ string) is also used to auto-generate the help for this command) \"\"\" key = \"smile\" aliases = [\"smile at\", \"grin\", \"grin at\"] locks = \"cmd:all()\" help_category = \"General\" def parse(self): \"Very trivial parser\" target = self.args.strip() def func(self): \"This actually does things\" caller = self.caller if not self.target or self.target == \"here\": string = f\"{caller.key} smiles\" else: target = caller.search(self.target) if not target: return string = f\"{caller.key} smiles at {target.key}\" caller.location.msg_contents(string) The power of having commands as classes and to separate parse() and func() lies in the ability to inherit functionality without having to parse every command individually. For example, as mentioned the default commands all inherit from MuxCommand . MuxCommand implements its own version of parse() that understands all the specifics of MUX-like commands. Almost none of the default commands thus need to implement parse() at all, but can assume the incoming string is already split up and parsed in suitable ways by its parent. Before you can actually use the command in your game, you must now store it within a command set . See the Command Sets page. On arg_regex \u00b6 The command parser is very general and does not require a space to end your command name. This means that the alias : to emote can be used like :smiles without modification. It also means getstone will get you the stone (unless there is a command specifically named getstone , then that will be used). If you want to tell the parser to require a certain separator between the command name and its arguments (so that get stone works but getstone gives you a 'command not found' error) you can do so with the arg_regex property. The arg_regex is a raw regular expression string . The regex will be compiled by the system at runtime. This allows you to customize how the part immediately following the command name (or alias) must look in order for the parser to match for this command. Some examples: commandname argument ( arg_regex = r\"\\s.+\" ): This forces the parser to require the command name to be followed by one or more spaces. Whatever is entered after the space will be treated as an argument. However, if you'd forget the space (like a command having no arguments), this would not match commandname . commandname or commandname argument ( arg_regex = r\"\\s.+|$\" ): This makes both look and look me work but lookme will not. commandname/switches arguments ( arg_regex = r\"(?:^(?:\\s+|\\/).*$)|^$\" . If you are using Evennia's MuxCommand Command parent, you may wish to use this since it will allow /switche s to work as well as having or not having a space. The arg_regex allows you to customize the behavior of your commands. You can put it in the parent class of your command to customize all children of your Commands. However, you can also change the base default behavior for all Commands by modifying settings.COMMAND_DEFAULT_ARG_REGEX . Exiting a command \u00b6 Normally you just use return in one of your Command class' hook methods to exit that method. That will however still fire the other hook methods of the Command in sequence. That's usually what you want but sometimes it may be useful to just abort the command, for example if you find some unacceptable input in your parse method. To exit the command this way you can raise evennia.InterruptCommand : from evennia import InterruptCommand class MyCommand(Command): # ... def parse(self): # ... # if this fires, `func()` and `at_post_cmd` will not # be called at all raise InterruptCommand() Pauses in commands \u00b6 Sometimes you want to pause the execution of your command for a little while before continuing - maybe you want to simulate a heavy swing taking some time to finish, maybe you want the echo of your voice to return to you with an ever-longer delay. Since Evennia is running asynchronously, you cannot use time.sleep() in your commands (or anywhere, really). If you do, the entire game will be frozen for everyone! So don't do that. Fortunately, Evennia offers a really quick syntax for making pauses in commands. In your func() method, you can use the yield keyword. This is a Python keyword that will freeze the current execution of your command and wait for more before processing. Note that you cannot just drop yield into any code and expect it to pause. Evennia will only pause for you if you yield inside the Command's func() method. Don't expect it to work anywhere else. Here's an example of a command using a small pause of five seconds between messages: from evennia import Command class CmdWait(Command): \"\"\" A dummy command to show how to wait Usage: wait \"\"\" key = \"wait\" locks = \"cmd:all()\" help_category = \"General\" def func(self): \"\"\"Command execution.\"\"\" self.msg(\"Starting to wait ...\") yield 5 self.msg(\"... This shows after 5 seconds. Waiting ...\") yield 2 self.msg(\"... And now another 2 seconds have passed.\") The important line is the yield 5 and yield 2 lines. It will tell Evennia to pause execution here and not continue until the number of seconds given has passed. There are two things to remember when using yield in your Command's func method: The paused state produced by the yield is not saved anywhere. So if the server reloads in the middle of your command pausing, it will not resume when the server comes back up - the remainder of the command will never fire. So be careful that you are not freezing the character or account in a way that will not be cleared on reload. If you use yield you may not also use return <values> in your func method. You'll get an error explaining this. This is due to how Python generators work. You can however use a \"naked\" return just fine. Usually there is no need for func to return a value, but if you ever do need to mix yield with a final return value in the same func , look at twisted.internet.defer.returnValue . Asking for user input \u00b6 The yield keyword can also be used to ask for user input. Again you can't use Python's input in your command, for it would freeze Evennia for everyone while waiting for that user to input their text. Inside a Command's func method, the following syntax can also be used: answer = yield(\"Your question\") Here's a very simple example: class CmdConfirm(Command): \"\"\" A dummy command to show confirmation. Usage: confirm \"\"\" key = \"confirm\" def func(self): answer = yield(\"Are you sure you want to go on?\") if answer.strip().lower() in (\"yes\", \"y\"): self.msg(\"Yes!\") else: self.msg(\"No!\") This time, when the user enters the 'confirm' command, she will be asked if she wants to go on. Entering 'yes' or \"y\" (regardless of case) will give the first reply, otherwise the second reply will show. Note again that the yield keyword does not store state. If the game reloads while waiting for the user to answer, the user will have to start over. It is not a good idea to use yield for important or complex choices, a persistent EvMenu might be more appropriate in this case. System commands \u00b6 Note: This is an advanced topic. Skip it if this is your first time learning about commands. There are several command-situations that are exceptional in the eyes of the server. What happens if the account enters an empty string? What if the 'command' given is infact the name of a channel the user wants to send a message to? Or if there are multiple command possibilities? Such 'special cases' are handled by what's called system commands . A system command is defined in the same way as other commands, except that their name (key) must be set to one reserved by the engine (the names are defined at the top of evennia/commands/cmdhandler.py ). You can find (unused) implementations of the system commands in evennia/commands/default/system_commands.py . Since these are not (by default) included in any CmdSet they are not actually used, they are just there for show. When the special situation occurs, Evennia will look through all valid CmdSet s for your custom system command. Only after that will it resort to its own, hard-coded implementation. Here are the exceptional situations that triggers system commands. You can find the command keys they use as properties on evennia.syscmdkeys : No input ( syscmdkeys.CMD_NOINPUT ) - the account just pressed return without any input. Default is to do nothing, but it can be useful to do something here for certain implementations such as line editors that interpret non-commands as text input (an empty line in the editing buffer). Command not found ( syscmdkeys.CMD_NOMATCH ) - No matching command was found. Default is to display the \"Huh?\" error message. Several matching commands where found ( syscmdkeys.CMD_MULTIMATCH ) - Default is to show a list of matches. User is not allowed to execute the command ( syscmdkeys.CMD_NOPERM ) - Default is to display the \"Huh?\" error message. Channel ( syscmdkeys.CMD_CHANNEL ) - This is a Channel name of a channel you are subscribing to - Default is to relay the command's argument to that channel. Such commands are created by the Comm system on the fly depending on your subscriptions. New session connection ( syscmdkeys.CMD_LOGINSTART ). This command name should be put in the settings.CMDSET_UNLOGGEDIN . Whenever a new connection is established, this command is always called on the server (default is to show the login screen). Below is an example of redefining what happens when the account doesn't provide any input (e.g. just presses return). Of course the new system command must be added to a cmdset as well before it will work. from evennia import syscmdkeys, Command class MyNoInputCommand(Command): \"Usage: Just press return, I dare you\" key = syscmdkeys.CMD_NOINPUT def func(self): self.caller.msg(\"Don't just press return like that, talk to me!\") Dynamic Commands \u00b6 Note: This is an advanced topic. Normally Commands are created as fixed classes and used without modification. There are however situations when the exact key, alias or other properties is not possible (or impractical) to pre-code ( Exits is an example of this). To create a command with a dynamic call signature, first define the command body normally in a class (set your key , aliases to default values), then use the following call (assuming the command class you created is named MyCommand ): cmd = MyCommand(key=\"newname\", aliases=[\"test\", \"test2\"], locks=\"cmd:all()\", ...) All keyword arguments you give to the Command constructor will be stored as a property on the command object. This will overload existing properties defined on the parent class. Normally you would define your class and only overload things like key and aliases at run-time. But you could in principle also send method objects (like func ) as keyword arguments in order to make your command completely customized at run-time. Exits \u00b6 Note: This is an advanced topic. Exits are examples of the use of a Dynamic Command . The functionality of Exit objects in Evennia is not hard-coded in the engine. Instead Exits are normal typeclassed objects that auto-create a CmdSet on themselves when they load. This cmdset has a single dynamically created Command with the same properties (key, aliases and locks) as the Exit object itself. When entering the name of the exit, this dynamic exit-command is triggered and (after access checks) moves the Character to the exit's destination. Whereas you could customize the Exit object and its command to achieve completely different behaviour, you will usually be fine just using the appropriate traverse_* hooks on the Exit object. But if you are interested in really changing how things work under the hood, check out evennia/objects/objects.py for how the Exit typeclass is set up. Command instances are re-used \u00b6 Note: This is an advanced topic that can be skipped when first learning about Commands. A Command class sitting on an object is instantiated once and then re-used. So if you run a command from object1 over and over you are in fact running the same command instance over and over (if you run the same command but sitting on object2 however, it will be a different instance). This is usually not something you'll notice, since every time the Command-instance is used, all the relevant properties on it will be overwritten. But armed with this knowledge you can implement some of the more exotic command mechanism out there, like the command having a 'memory' of what you last entered so that you can back-reference the previous arguments etc. Note: On a server reload, all Commands are rebuilt and memory is flushed. To show this in practice, consider this command: class CmdTestID(Command): key = \"testid\" def func(self): if not hasattr(self, \"xval\"): self.xval = 0 self.xval += 1 self.caller.msg(\"Command memory ID: {} (xval={})\".format(id(self), self.xval)) Adding this to the default character cmdset gives a result like this in-game: > testid Command memory ID: 140313967648552 (xval=1) > testid Command memory ID: 140313967648552 (xval=2) > testid Command memory ID: 140313967648552 (xval=3) Note how the in-memory address of the testid command never changes, but xval keeps ticking up. Dynamically created commands \u00b6 This is also an advanced topic. Commands can also be created and added to a cmdset on the fly. Creating a class instance with a keyword argument, will assign that keyword argument as a property on this paricular command: class MyCmdSet(CmdSet): def at_cmdset_creation(self): self.add(MyCommand(myvar=1, foo=\"test\") This will start the MyCommand with myvar and foo set as properties (accessable as self.myvar and self.foo ). How they are used is up to the Command. Remember however the discussion from the previous section - since the Command instance is re-used, those properties will remain on the command as long as this cmdset and the object it sits is in memory (i.e. until the next reload). Unless myvar and foo are somehow reset when the command runs, they can be modified and that change will be remembered for subsequent uses of the command. How commands actually work \u00b6 Note: This is an advanced topic mainly of interest to server developers. Any time the user sends text to Evennia, the server tries to figure out if the text entered corresponds to a known command. This is how the command handler sequence looks for a logged-in user: A user enters a string of text and presses enter. The user's Session determines the text is not some protocol-specific control sequence or OOB command, but sends it on to the command handler. Evennia's command handler analyzes the Session and grabs eventual references to Account and eventual puppeted Characters (these will be stored on the command object later). The caller property is set appropriately. If input is an empty string, resend command as CMD_NOINPUT . If no such command is found in cmdset, ignore. If command.key matches settings.IDLE_COMMAND , update timers but don't do anything more. The command handler gathers the CmdSets available to caller at this time: The caller's own currently active CmdSet. CmdSets defined on the current account, if caller is a puppeted object. CmdSets defined on the Session itself. The active CmdSets of eventual objects in the same location (if any). This includes commands on Exits . Sets of dynamically created System commands representing available Communications . All CmdSets of the same priority are merged together in groups. Grouping avoids order-dependent issues of merging multiple same-prio sets onto lower ones. All the grouped CmdSets are merged in reverse priority into one combined CmdSet according to each set's merge rules. Evennia's command parser takes the merged cmdset and matches each of its commands (using its key and aliases) against the beginning of the string entered by caller . This produces a set of candidates. The cmd parser next rates the matches by how many characters they have and how many percent matches the respective known command. Only if candidates cannot be separated will it return multiple matches. If multiple matches were returned, resend as CMD_MULTIMATCH . If no such command is found in cmdset, return hard-coded list of matches. If no match was found, resend as CMD_NOMATCH . If no such command is found in cmdset, give hard-coded error message. If a single command was found by the parser, the correct command object is plucked out of storage. This usually doesn't mean a re-initialization. It is checked that the caller actually has access to the command by validating the lockstring of the command. If not, it is not considered as a suitable match and CMD_NOMATCH is triggered. If the new command is tagged as a channel-command, resend as CMD_CHANNEL . If no such command is found in cmdset, use hard-coded implementation. Assign several useful variables to the command instance (see previous sections). Call at_pre_command() on the command instance. Call parse() on the command instance. This is fed the remainder of the string, after the name of the command. It's intended to pre-parse the string into a form useful for the func() method. Call func() on the command instance. This is the functional body of the command, actually doing useful things. Call at_post_command() on the command instance. Assorted notes \u00b6 The return value of Command.func() is a Twisted deferred . Evennia does not use this return value at all by default. If you do, you must thus do so asynchronously, using callbacks. # in command class func() def callback(ret, caller): caller.msg(\"Returned is %s\" % ret) deferred = self.execute_command(\"longrunning\") deferred.addCallback(callback, self.caller) This is probably not relevant to any but the most advanced/exotic designs (one might use it to create a \"nested\" command structure for example). The save_for_next class variable can be used to implement state-persistent commands. For example it can make a command operate on \"it\", where it is determined by what the previous command operated on.","title":"Commands"},{"location":"Commands.html#defining-commands","text":"All commands are implemented as normal Python classes inheriting from the base class Command ( evennia.Command ). You will find that this base class is very \"bare\". The default commands of Evennia actually inherit from a child of Command called MuxCommand - this is the class that knows all the mux-like syntax like /switches , splitting by \"=\" etc. Below we'll avoid mux-specifics and use the base Command class directly. # basic Command definition from evennia import Command class MyCmd(Command): \"\"\" This is the help-text for the command \"\"\" key = \"mycommand\" def parse(self): # parsing the command line here def func(self): # executing the command here Here is a minimalistic command with no custom parsing: from evennia import Command class CmdEcho(self): key = \"echo\" def func(self): # echo the caller's input back to the caller self.caller.msg(\"Echo: {}\".format(self.args) You define a new command by assigning a few class-global properties on your inherited class and overloading one or two hook functions. The full gritty mechanic behind how commands work are found towards the end of this page; for now you only need to know that the command handler creates an instance of this class and uses that instance whenever you use this command - it also dynamically assigns the new command instance a few useful properties that you can assume to always be available.","title":"Defining Commands"},{"location":"Commands.html#who-is-calling-the-command","text":"In Evennia there are three types of objects that may call the command. It is important to be aware of this since this will also assign appropriate caller , session , sessid and account properties on the command body at runtime. Most often the calling type is Session . A Session . This is by far the most common case when a user is entering a command in their client. caller - this is set to the puppeted Object if such an object exists. If no puppet is found, caller is set equal to account . Only if an Account is not found either (such as before being logged in) will this be set to the Session object itself. session - a reference to the Session object itself. sessid - sessid.id , a unique integer identifier of the session. account - the Account object connected to this Session. None if not logged in. An Account . This only happens if account.execute_cmd() was used. No Session information can be obtained in this case. caller - this is set to the puppeted Object if such an object can be determined (without Session info this can only be determined in MULTISESSION_MODE=0 or 1 ). If no puppet is found, this is equal to account . session - None* sessid - None* account - Set to the Account object. An Object . This only happens if object.execute_cmd() was used (for example by an NPC). caller - This is set to the calling Object in question. session - None* sessid - None* account - None *) : There is a way to make the Session available also inside tests run directly on Accounts and Objects, and that is to pass it to execute_cmd like so: account.execute_cmd(\"...\", session=<Session>) . Doing so will make the .session and .sessid properties available in the command.","title":"Who is calling the command?"},{"location":"Commands.html#properties-assigned-to-the-command-instance-at-run-time","text":"Let's say account Bob with a character BigGuy enters the command look at sword . After the system having successfully identified this as the \"look\" command and determined that BigGuy really has access to a command named look , it chugs the look command class out of storage and either loads an existing Command instance from cache or creates one. After some more checks it then assigns it the following properties: caller - The character BigGuy, in this example. This is a reference to the object executing the command. The value of this depends on what type of object is calling the command; see the previous section. session - the Session Bob uses to connect to the game and control BigGuy (see also previous section). sessid - the unique id of self.session , for quick lookup. account - the Account Bob (see previous section). cmdstring - the matched key for the command. This would be look in our example. args - this is the rest of the string, except the command name. So if the string entered was look at sword , args would be \" at sword \". Note the space kept - Evennia would correctly interpret lookat sword too. This is useful for things like /switches that should not use space. In the MuxCommand class used for default commands, this space is stripped. Also see the arg_regex property if you want to enforce a space to make lookat sword give a command-not-found error. obj - the game Object on which this command is defined. This need not be the caller, but since look is a common (default) command, this is probably defined directly on BigGuy - so obj will point to BigGuy. Otherwise obj could be an Account or any interactive object with commands defined on it, like in the example of the \"check time\" command defined on a \"Clock\" object. cmdset - this is a reference to the merged CmdSet (see below) from which this command was matched. This variable is rarely used, it's main use is for the auto-help system ( Advanced note: the merged cmdset need NOT be the same as BigGuy.cmdset . The merged set can be a combination of the cmdsets from other objects in the room, for example ). raw_string - this is the raw input coming from the user, without stripping any surrounding whitespace. The only thing that is stripped is the ending newline marker.","title":"Properties assigned to the command instance at run-time"},{"location":"Commands.html#other-useful-utility-methods","text":".get_help(caller, cmdset) - Get the help entry for this command. By default the arguments are not used, but they could be used to implement alternate help-display systems. .client_width() - Shortcut for getting the client's screen-width. Note that not all clients will truthfully report this value - that case the settings.DEFAULT_SCREEN_WIDTH will be returned. .styled_table(*args, **kwargs) - This returns an EvTable styled based on the session calling this command. The args/kwargs are the same as for EvTable, except styling defaults are set. .styled_header , _footer , separator - These will produce styled decorations for display to the user. They are useful for creating listings and forms with colors adjustable per-user.","title":"Other useful utility methods:"},{"location":"Commands.html#defining-your-own-command-classes","text":"Beyond the properties Evennia always assigns to the command at run-time (listed above), your job is to define the following class properties: key (string) - the identifier for the command, like look . This should (ideally) be unique. A key can consist of more than one word, like \"press button\" or \"pull left lever\". Note that both key and aliases below determine the identity of a command. So two commands are considered if either matches. This is important for merging cmdsets described below. aliases (optional list) - a list of alternate names for the command ( [\"glance\", \"see\", \"l\"] ). Same name rules as for key applies. locks (string) - a lock definition , usually on the form cmd:<lockfuncs> . Locks is a rather big topic, so until you learn more about locks, stick to giving the lockstring \"cmd:all()\" to make the command available to everyone (if you don't provide a lock string, this will be assigned for you). help_category (optional string) - setting this helps to structure the auto-help into categories. If none is set, this will be set to General . save_for_next (optional boolean). This defaults to False . If True , a copy of this command object (along with any changes you have done to it) will be stored by the system and can be accessed by the next command by retrieving self.caller.ndb.last_cmd . The next run command will either clear or replace the storage. arg_regex (optional raw string): Used to force the parser to limit itself and tell it when the command-name ends and arguments begin (such as requiring this to be a space or a /switch). This is done with a regular expression. See the arg_regex section for the details. auto_help (optional boolean). Defaults to True . This allows for turning off the auto-help system on a per-command basis. This could be useful if you either want to write your help entries manually or hide the existence of a command from help 's generated list. is_exit (bool) - this marks the command as being used for an in-game exit. This is, by default, set by all Exit objects and you should not need to set it manually unless you make your own Exit system. It is used for optimization and allows the cmdhandler to easily disregard this command when the cmdset has its no_exits flag set. is_channel (bool)- this marks the command as being used for an in-game channel. This is, by default, set by all Channel objects and you should not need to set it manually unless you make your own Channel system. is used for optimization and allows the cmdhandler to easily disregard this command when its cmdset has its no_channels flag set. msg_all_sessions (bool): This affects the behavior of the Command.msg method. If unset (default), calling self.msg(text) from the Command will always only send text to the Session that actually triggered this Command. If set however, self.msg(text) will send to all Sessions relevant to the object this Command sits on. Just which Sessions receives the text depends on the object and the server's MULTISESSION_MODE . You should also implement at least two methods, parse() and func() (You could also implement perm() , but that's not needed unless you want to fundamentally change how access checks work). at_pre_cmd() is called very first on the command. If this function returns anything that evaluates to True the command execution is aborted at this point. parse() is intended to parse the arguments ( self.args ) of the function. You can do this in any way you like, then store the result(s) in variable(s) on the command object itself (i.e. on self ). To take an example, the default mux-like system uses this method to detect \"command switches\" and store them as a list in self.switches . Since the parsing is usually quite similar inside a command scheme you should make parse() as generic as possible and then inherit from it rather than re-implementing it over and over. In this way, the default MuxCommand class implements a parse() for all child commands to use. func() is called right after parse() and should make use of the pre-parsed input to actually do whatever the command is supposed to do. This is the main body of the command. The return value from this method will be returned from the execution as a Twisted Deferred. at_post_cmd() is called after func() to handle eventual cleanup. Finally, you should always make an informative doc string ( __doc__ ) at the top of your class. This string is dynamically read by the Help System to create the help entry for this command. You should decide on a way to format your help and stick to that. Below is how you define a simple alternative \" smile \" command: from evennia import Command class CmdSmile(Command): \"\"\" A smile command Usage: smile [at] [<someone>] grin [at] [<someone>] Smiles to someone in your vicinity or to the room in general. (This initial string (the __doc__ string) is also used to auto-generate the help for this command) \"\"\" key = \"smile\" aliases = [\"smile at\", \"grin\", \"grin at\"] locks = \"cmd:all()\" help_category = \"General\" def parse(self): \"Very trivial parser\" target = self.args.strip() def func(self): \"This actually does things\" caller = self.caller if not self.target or self.target == \"here\": string = f\"{caller.key} smiles\" else: target = caller.search(self.target) if not target: return string = f\"{caller.key} smiles at {target.key}\" caller.location.msg_contents(string) The power of having commands as classes and to separate parse() and func() lies in the ability to inherit functionality without having to parse every command individually. For example, as mentioned the default commands all inherit from MuxCommand . MuxCommand implements its own version of parse() that understands all the specifics of MUX-like commands. Almost none of the default commands thus need to implement parse() at all, but can assume the incoming string is already split up and parsed in suitable ways by its parent. Before you can actually use the command in your game, you must now store it within a command set . See the Command Sets page.","title":"Defining your own command classes"},{"location":"Commands.html#on-arg_regex","text":"The command parser is very general and does not require a space to end your command name. This means that the alias : to emote can be used like :smiles without modification. It also means getstone will get you the stone (unless there is a command specifically named getstone , then that will be used). If you want to tell the parser to require a certain separator between the command name and its arguments (so that get stone works but getstone gives you a 'command not found' error) you can do so with the arg_regex property. The arg_regex is a raw regular expression string . The regex will be compiled by the system at runtime. This allows you to customize how the part immediately following the command name (or alias) must look in order for the parser to match for this command. Some examples: commandname argument ( arg_regex = r\"\\s.+\" ): This forces the parser to require the command name to be followed by one or more spaces. Whatever is entered after the space will be treated as an argument. However, if you'd forget the space (like a command having no arguments), this would not match commandname . commandname or commandname argument ( arg_regex = r\"\\s.+|$\" ): This makes both look and look me work but lookme will not. commandname/switches arguments ( arg_regex = r\"(?:^(?:\\s+|\\/).*$)|^$\" . If you are using Evennia's MuxCommand Command parent, you may wish to use this since it will allow /switche s to work as well as having or not having a space. The arg_regex allows you to customize the behavior of your commands. You can put it in the parent class of your command to customize all children of your Commands. However, you can also change the base default behavior for all Commands by modifying settings.COMMAND_DEFAULT_ARG_REGEX .","title":"On arg_regex"},{"location":"Commands.html#exiting-a-command","text":"Normally you just use return in one of your Command class' hook methods to exit that method. That will however still fire the other hook methods of the Command in sequence. That's usually what you want but sometimes it may be useful to just abort the command, for example if you find some unacceptable input in your parse method. To exit the command this way you can raise evennia.InterruptCommand : from evennia import InterruptCommand class MyCommand(Command): # ... def parse(self): # ... # if this fires, `func()` and `at_post_cmd` will not # be called at all raise InterruptCommand()","title":"Exiting a command"},{"location":"Commands.html#pauses-in-commands","text":"Sometimes you want to pause the execution of your command for a little while before continuing - maybe you want to simulate a heavy swing taking some time to finish, maybe you want the echo of your voice to return to you with an ever-longer delay. Since Evennia is running asynchronously, you cannot use time.sleep() in your commands (or anywhere, really). If you do, the entire game will be frozen for everyone! So don't do that. Fortunately, Evennia offers a really quick syntax for making pauses in commands. In your func() method, you can use the yield keyword. This is a Python keyword that will freeze the current execution of your command and wait for more before processing. Note that you cannot just drop yield into any code and expect it to pause. Evennia will only pause for you if you yield inside the Command's func() method. Don't expect it to work anywhere else. Here's an example of a command using a small pause of five seconds between messages: from evennia import Command class CmdWait(Command): \"\"\" A dummy command to show how to wait Usage: wait \"\"\" key = \"wait\" locks = \"cmd:all()\" help_category = \"General\" def func(self): \"\"\"Command execution.\"\"\" self.msg(\"Starting to wait ...\") yield 5 self.msg(\"... This shows after 5 seconds. Waiting ...\") yield 2 self.msg(\"... And now another 2 seconds have passed.\") The important line is the yield 5 and yield 2 lines. It will tell Evennia to pause execution here and not continue until the number of seconds given has passed. There are two things to remember when using yield in your Command's func method: The paused state produced by the yield is not saved anywhere. So if the server reloads in the middle of your command pausing, it will not resume when the server comes back up - the remainder of the command will never fire. So be careful that you are not freezing the character or account in a way that will not be cleared on reload. If you use yield you may not also use return <values> in your func method. You'll get an error explaining this. This is due to how Python generators work. You can however use a \"naked\" return just fine. Usually there is no need for func to return a value, but if you ever do need to mix yield with a final return value in the same func , look at twisted.internet.defer.returnValue .","title":"Pauses in commands"},{"location":"Commands.html#asking-for-user-input","text":"The yield keyword can also be used to ask for user input. Again you can't use Python's input in your command, for it would freeze Evennia for everyone while waiting for that user to input their text. Inside a Command's func method, the following syntax can also be used: answer = yield(\"Your question\") Here's a very simple example: class CmdConfirm(Command): \"\"\" A dummy command to show confirmation. Usage: confirm \"\"\" key = \"confirm\" def func(self): answer = yield(\"Are you sure you want to go on?\") if answer.strip().lower() in (\"yes\", \"y\"): self.msg(\"Yes!\") else: self.msg(\"No!\") This time, when the user enters the 'confirm' command, she will be asked if she wants to go on. Entering 'yes' or \"y\" (regardless of case) will give the first reply, otherwise the second reply will show. Note again that the yield keyword does not store state. If the game reloads while waiting for the user to answer, the user will have to start over. It is not a good idea to use yield for important or complex choices, a persistent EvMenu might be more appropriate in this case.","title":"Asking for user input"},{"location":"Commands.html#system-commands","text":"Note: This is an advanced topic. Skip it if this is your first time learning about commands. There are several command-situations that are exceptional in the eyes of the server. What happens if the account enters an empty string? What if the 'command' given is infact the name of a channel the user wants to send a message to? Or if there are multiple command possibilities? Such 'special cases' are handled by what's called system commands . A system command is defined in the same way as other commands, except that their name (key) must be set to one reserved by the engine (the names are defined at the top of evennia/commands/cmdhandler.py ). You can find (unused) implementations of the system commands in evennia/commands/default/system_commands.py . Since these are not (by default) included in any CmdSet they are not actually used, they are just there for show. When the special situation occurs, Evennia will look through all valid CmdSet s for your custom system command. Only after that will it resort to its own, hard-coded implementation. Here are the exceptional situations that triggers system commands. You can find the command keys they use as properties on evennia.syscmdkeys : No input ( syscmdkeys.CMD_NOINPUT ) - the account just pressed return without any input. Default is to do nothing, but it can be useful to do something here for certain implementations such as line editors that interpret non-commands as text input (an empty line in the editing buffer). Command not found ( syscmdkeys.CMD_NOMATCH ) - No matching command was found. Default is to display the \"Huh?\" error message. Several matching commands where found ( syscmdkeys.CMD_MULTIMATCH ) - Default is to show a list of matches. User is not allowed to execute the command ( syscmdkeys.CMD_NOPERM ) - Default is to display the \"Huh?\" error message. Channel ( syscmdkeys.CMD_CHANNEL ) - This is a Channel name of a channel you are subscribing to - Default is to relay the command's argument to that channel. Such commands are created by the Comm system on the fly depending on your subscriptions. New session connection ( syscmdkeys.CMD_LOGINSTART ). This command name should be put in the settings.CMDSET_UNLOGGEDIN . Whenever a new connection is established, this command is always called on the server (default is to show the login screen). Below is an example of redefining what happens when the account doesn't provide any input (e.g. just presses return). Of course the new system command must be added to a cmdset as well before it will work. from evennia import syscmdkeys, Command class MyNoInputCommand(Command): \"Usage: Just press return, I dare you\" key = syscmdkeys.CMD_NOINPUT def func(self): self.caller.msg(\"Don't just press return like that, talk to me!\")","title":"System commands"},{"location":"Commands.html#dynamic-commands","text":"Note: This is an advanced topic. Normally Commands are created as fixed classes and used without modification. There are however situations when the exact key, alias or other properties is not possible (or impractical) to pre-code ( Exits is an example of this). To create a command with a dynamic call signature, first define the command body normally in a class (set your key , aliases to default values), then use the following call (assuming the command class you created is named MyCommand ): cmd = MyCommand(key=\"newname\", aliases=[\"test\", \"test2\"], locks=\"cmd:all()\", ...) All keyword arguments you give to the Command constructor will be stored as a property on the command object. This will overload existing properties defined on the parent class. Normally you would define your class and only overload things like key and aliases at run-time. But you could in principle also send method objects (like func ) as keyword arguments in order to make your command completely customized at run-time.","title":"Dynamic Commands"},{"location":"Commands.html#exits","text":"Note: This is an advanced topic. Exits are examples of the use of a Dynamic Command . The functionality of Exit objects in Evennia is not hard-coded in the engine. Instead Exits are normal typeclassed objects that auto-create a CmdSet on themselves when they load. This cmdset has a single dynamically created Command with the same properties (key, aliases and locks) as the Exit object itself. When entering the name of the exit, this dynamic exit-command is triggered and (after access checks) moves the Character to the exit's destination. Whereas you could customize the Exit object and its command to achieve completely different behaviour, you will usually be fine just using the appropriate traverse_* hooks on the Exit object. But if you are interested in really changing how things work under the hood, check out evennia/objects/objects.py for how the Exit typeclass is set up.","title":"Exits"},{"location":"Commands.html#command-instances-are-re-used","text":"Note: This is an advanced topic that can be skipped when first learning about Commands. A Command class sitting on an object is instantiated once and then re-used. So if you run a command from object1 over and over you are in fact running the same command instance over and over (if you run the same command but sitting on object2 however, it will be a different instance). This is usually not something you'll notice, since every time the Command-instance is used, all the relevant properties on it will be overwritten. But armed with this knowledge you can implement some of the more exotic command mechanism out there, like the command having a 'memory' of what you last entered so that you can back-reference the previous arguments etc. Note: On a server reload, all Commands are rebuilt and memory is flushed. To show this in practice, consider this command: class CmdTestID(Command): key = \"testid\" def func(self): if not hasattr(self, \"xval\"): self.xval = 0 self.xval += 1 self.caller.msg(\"Command memory ID: {} (xval={})\".format(id(self), self.xval)) Adding this to the default character cmdset gives a result like this in-game: > testid Command memory ID: 140313967648552 (xval=1) > testid Command memory ID: 140313967648552 (xval=2) > testid Command memory ID: 140313967648552 (xval=3) Note how the in-memory address of the testid command never changes, but xval keeps ticking up.","title":"Command instances are re-used"},{"location":"Commands.html#dynamically-created-commands","text":"This is also an advanced topic. Commands can also be created and added to a cmdset on the fly. Creating a class instance with a keyword argument, will assign that keyword argument as a property on this paricular command: class MyCmdSet(CmdSet): def at_cmdset_creation(self): self.add(MyCommand(myvar=1, foo=\"test\") This will start the MyCommand with myvar and foo set as properties (accessable as self.myvar and self.foo ). How they are used is up to the Command. Remember however the discussion from the previous section - since the Command instance is re-used, those properties will remain on the command as long as this cmdset and the object it sits is in memory (i.e. until the next reload). Unless myvar and foo are somehow reset when the command runs, they can be modified and that change will be remembered for subsequent uses of the command.","title":"Dynamically created commands"},{"location":"Commands.html#how-commands-actually-work","text":"Note: This is an advanced topic mainly of interest to server developers. Any time the user sends text to Evennia, the server tries to figure out if the text entered corresponds to a known command. This is how the command handler sequence looks for a logged-in user: A user enters a string of text and presses enter. The user's Session determines the text is not some protocol-specific control sequence or OOB command, but sends it on to the command handler. Evennia's command handler analyzes the Session and grabs eventual references to Account and eventual puppeted Characters (these will be stored on the command object later). The caller property is set appropriately. If input is an empty string, resend command as CMD_NOINPUT . If no such command is found in cmdset, ignore. If command.key matches settings.IDLE_COMMAND , update timers but don't do anything more. The command handler gathers the CmdSets available to caller at this time: The caller's own currently active CmdSet. CmdSets defined on the current account, if caller is a puppeted object. CmdSets defined on the Session itself. The active CmdSets of eventual objects in the same location (if any). This includes commands on Exits . Sets of dynamically created System commands representing available Communications . All CmdSets of the same priority are merged together in groups. Grouping avoids order-dependent issues of merging multiple same-prio sets onto lower ones. All the grouped CmdSets are merged in reverse priority into one combined CmdSet according to each set's merge rules. Evennia's command parser takes the merged cmdset and matches each of its commands (using its key and aliases) against the beginning of the string entered by caller . This produces a set of candidates. The cmd parser next rates the matches by how many characters they have and how many percent matches the respective known command. Only if candidates cannot be separated will it return multiple matches. If multiple matches were returned, resend as CMD_MULTIMATCH . If no such command is found in cmdset, return hard-coded list of matches. If no match was found, resend as CMD_NOMATCH . If no such command is found in cmdset, give hard-coded error message. If a single command was found by the parser, the correct command object is plucked out of storage. This usually doesn't mean a re-initialization. It is checked that the caller actually has access to the command by validating the lockstring of the command. If not, it is not considered as a suitable match and CMD_NOMATCH is triggered. If the new command is tagged as a channel-command, resend as CMD_CHANNEL . If no such command is found in cmdset, use hard-coded implementation. Assign several useful variables to the command instance (see previous sections). Call at_pre_command() on the command instance. Call parse() on the command instance. This is fed the remainder of the string, after the name of the command. It's intended to pre-parse the string into a form useful for the func() method. Call func() on the command instance. This is the functional body of the command, actually doing useful things. Call at_post_command() on the command instance.","title":"How commands actually work"},{"location":"Commands.html#assorted-notes","text":"The return value of Command.func() is a Twisted deferred . Evennia does not use this return value at all by default. If you do, you must thus do so asynchronously, using callbacks. # in command class func() def callback(ret, caller): caller.msg(\"Returned is %s\" % ret) deferred = self.execute_command(\"longrunning\") deferred.addCallback(callback, self.caller) This is probably not relevant to any but the most advanced/exotic designs (one might use it to create a \"nested\" command structure for example). The save_for_next class variable can be used to implement state-persistent commands. For example it can make a command operate on \"it\", where it is determined by what the previous command operated on.","title":"Assorted notes"},{"location":"Communications.html","text":"Apart from moving around in the game world and talking, players might need other forms of communication. This is offered by Evennia's Comm system. Stock evennia implements a 'MUX-like' system of channels, but there is nothing stopping you from changing things to better suit your taste. Comms rely on two main database objects - Msg and Channel . There is also the TempMsg which mimics the API of a Msg but has no connection to the database. Msg \u00b6 The Msg object is the basic unit of communication in Evennia. A message works a little like an e-mail; it always has a sender (a Account ) and one or more recipients. The recipients may be either other Accounts, or a Channel (see below). You can mix recipients to send the message to both Channels and Accounts if you like. Once created, a Msg is normally not changed. It is peristently saved in the database. This allows for comprehensive logging of communications. This could be useful for allowing senders/receivers to have 'mailboxes' with the messages they want to keep. Properties defined on Msg \u00b6 senders - this is a reference to one or many Account or Objects (normally Characters ) sending the message. This could also be an External Connection such as a message coming in over IRC/IMC2 (see below). There is usually only one sender, but the types can also be mixed in any combination. receivers - a list of target Accounts , Objects (usually Characters ) or Channels to send the message to. The types of receivers can be mixed in any combination. header - this is a text field for storing a title or header for the message. message - the actual text being sent. date_sent - when message was sent (auto-created). locks - a lock definition . hide_from - this can optionally hold a list of objects, accounts or channels to hide this Msg from. This relationship is stored in the database primarily for optimization reasons, allowing for quickly post-filter out messages not intended for a given target. There is no in-game methods for setting this, it's intended to be done in code. You create new messages in code using evennia.create_message (or evennia.utils.create.create_message. ) TempMsg \u00b6 evennia.comms.models also has TempMsg which mimics the API of Msg but is not connected to the database. TempMsgs are used by Evennia for channel messages by default. They can be used for any system expecting a Msg but when you don't actually want to save anything. Channels \u00b6 Channels are Typeclassed entities, which mean they can be easily extended and their functionality modified. To change which channel typeclass Evennia uses, change settings.BASE_CHANNEL_TYPECLASS. Channels act as generic distributors of messages. Think of them as \"switch boards\" redistributing Msg or TempMsg objects. Internally they hold a list of \"listening\" objects and any Msg (or TempMsg ) sent to the channel will be distributed out to all channel listeners. Channels have Locks to limit who may listen and/or send messages through them. The sending of text to a channel is handled by a dynamically created Command that always have the same name as the channel. This is created for each channel by the global ChannelHandler . The Channel command is added to the Account's cmdset and normal command locks are used to determine which channels are possible to write to. When subscribing to a channel, you can then just write the channel name and the text to send. The default ChannelCommand (which can be customized by pointing settings.CHANNEL_COMMAND_CLASS to your own command), implements a few convenient features: It only sends TempMsg objects. Instead of storing individual entries in the database it instead dumps channel output a file log in server/logs/channel_<channelname>.log . This is mainly for practical reasons - we find one rarely need to query individual Msg objects at a later date. Just stupidly dumping the log to a file also means a lot less database overhead. It adds a /history switch to view the 20 last messages in the channel. These are read from the end of the log file. One can also supply a line number to start further back in the file (but always 20 entries at a time). It's used like this: > public/history > public/history 35 There are two default channels created in stock Evennia - MudInfo and Public . MudInfo receives server-related messages meant for Admins whereas Public is open to everyone to chat on (all new accounts are automatically joined to it when logging in, it is useful for asking questions). The default channels are defined by the DEFAULT_CHANNELS list (see evennia/settings_default.py for more details). You create new channels with evennia.create_channel (or evennia.utils.create.create_channel ). In code, messages are sent to a channel using the msg or tempmsg methods of channels: channel.msg(msgobj, header=None, senders=None, persistent=True) The argument msgobj can be either a string, a previously constructed Msg or a TempMsg - in the latter cases all the following keywords are ignored since the message objects already contains all this information. If msgobj is a string, the other keywords are used for creating a new Msg or TempMsg on the fly, depending on if persistent is set or not. By default, a TempMsg is emitted for channel communication (since the default ChannelCommand instead logs to a file). # assume we have a 'sender' object and a channel named 'mychan' # manually sending a message to a channel mychan.msg(\"Hello!\", senders=[sender]) Properties defined on Channel \u00b6 key - main name for channel aliases - alternative native names for channels desc - optional description of channel (seen in listings) keep_log (bool) - if the channel should store messages (default) locks - A lock definition . Channels normally use the access_types send, control and listen .","title":"Communications"},{"location":"Communications.html#msg","text":"The Msg object is the basic unit of communication in Evennia. A message works a little like an e-mail; it always has a sender (a Account ) and one or more recipients. The recipients may be either other Accounts, or a Channel (see below). You can mix recipients to send the message to both Channels and Accounts if you like. Once created, a Msg is normally not changed. It is peristently saved in the database. This allows for comprehensive logging of communications. This could be useful for allowing senders/receivers to have 'mailboxes' with the messages they want to keep.","title":"Msg"},{"location":"Communications.html#properties-defined-on-msg","text":"senders - this is a reference to one or many Account or Objects (normally Characters ) sending the message. This could also be an External Connection such as a message coming in over IRC/IMC2 (see below). There is usually only one sender, but the types can also be mixed in any combination. receivers - a list of target Accounts , Objects (usually Characters ) or Channels to send the message to. The types of receivers can be mixed in any combination. header - this is a text field for storing a title or header for the message. message - the actual text being sent. date_sent - when message was sent (auto-created). locks - a lock definition . hide_from - this can optionally hold a list of objects, accounts or channels to hide this Msg from. This relationship is stored in the database primarily for optimization reasons, allowing for quickly post-filter out messages not intended for a given target. There is no in-game methods for setting this, it's intended to be done in code. You create new messages in code using evennia.create_message (or evennia.utils.create.create_message. )","title":"Properties defined on Msg"},{"location":"Communications.html#tempmsg","text":"evennia.comms.models also has TempMsg which mimics the API of Msg but is not connected to the database. TempMsgs are used by Evennia for channel messages by default. They can be used for any system expecting a Msg but when you don't actually want to save anything.","title":"TempMsg"},{"location":"Communications.html#channels","text":"Channels are Typeclassed entities, which mean they can be easily extended and their functionality modified. To change which channel typeclass Evennia uses, change settings.BASE_CHANNEL_TYPECLASS. Channels act as generic distributors of messages. Think of them as \"switch boards\" redistributing Msg or TempMsg objects. Internally they hold a list of \"listening\" objects and any Msg (or TempMsg ) sent to the channel will be distributed out to all channel listeners. Channels have Locks to limit who may listen and/or send messages through them. The sending of text to a channel is handled by a dynamically created Command that always have the same name as the channel. This is created for each channel by the global ChannelHandler . The Channel command is added to the Account's cmdset and normal command locks are used to determine which channels are possible to write to. When subscribing to a channel, you can then just write the channel name and the text to send. The default ChannelCommand (which can be customized by pointing settings.CHANNEL_COMMAND_CLASS to your own command), implements a few convenient features: It only sends TempMsg objects. Instead of storing individual entries in the database it instead dumps channel output a file log in server/logs/channel_<channelname>.log . This is mainly for practical reasons - we find one rarely need to query individual Msg objects at a later date. Just stupidly dumping the log to a file also means a lot less database overhead. It adds a /history switch to view the 20 last messages in the channel. These are read from the end of the log file. One can also supply a line number to start further back in the file (but always 20 entries at a time). It's used like this: > public/history > public/history 35 There are two default channels created in stock Evennia - MudInfo and Public . MudInfo receives server-related messages meant for Admins whereas Public is open to everyone to chat on (all new accounts are automatically joined to it when logging in, it is useful for asking questions). The default channels are defined by the DEFAULT_CHANNELS list (see evennia/settings_default.py for more details). You create new channels with evennia.create_channel (or evennia.utils.create.create_channel ). In code, messages are sent to a channel using the msg or tempmsg methods of channels: channel.msg(msgobj, header=None, senders=None, persistent=True) The argument msgobj can be either a string, a previously constructed Msg or a TempMsg - in the latter cases all the following keywords are ignored since the message objects already contains all this information. If msgobj is a string, the other keywords are used for creating a new Msg or TempMsg on the fly, depending on if persistent is set or not. By default, a TempMsg is emitted for channel communication (since the default ChannelCommand instead logs to a file). # assume we have a 'sender' object and a channel named 'mychan' # manually sending a message to a channel mychan.msg(\"Hello!\", senders=[sender])","title":"Channels"},{"location":"Communications.html#properties-defined-on-channel","text":"key - main name for channel aliases - alternative native names for channels desc - optional description of channel (seen in listings) keep_log (bool) - if the channel should store messages (default) locks - A lock definition . Channels normally use the access_types send, control and listen .","title":"Properties defined on Channel"},{"location":"Connection-Screen.html","text":"When you first connect to your game you are greeted by Evennia's default connection screen. ============================================================== Welcome to Evennia, version Beta-ra4d24e8a3cab+! If you have an existing account, connect to it by typing: connect <username> <password> If you need to create an account, type (without the <>'s): create <username> <password> If you have spaces in your username, enclose it in quotes. Enter help for more info. look will re-show this screen. ============================================================== Effective, but not very exciting. You will most likely want to change this to be more unique for your game. This is simple: Edit mygame/server/conf/connection_screens.py . Reload Evennia. Evennia will look into this module and locate all globally defined strings in it. These strings are used as the text in your connection screen and are shown to the user at startup. If more than one such string/screen is defined in the module, a random screen will be picked from among those available. Commands available at the Connection Screen \u00b6 You can also customize the Commands available to use while the connection screen is shown ( connect , create etc). These commands are a bit special since when the screen is running the account is not yet logged in. A command is made available at the login screen by adding them to UnloggedinCmdSet in mygame/commands/default_cmdset.py . See Commands and the tutorial section on how to add new commands to a default command set.","title":"Connection Screen"},{"location":"Connection-Screen.html#commands-available-at-the-connection-screen","text":"You can also customize the Commands available to use while the connection screen is shown ( connect , create etc). These commands are a bit special since when the screen is running the account is not yet logged in. A command is made available at the login screen by adding them to UnloggedinCmdSet in mygame/commands/default_cmdset.py . See Commands and the tutorial section on how to add new commands to a default command set.","title":"Commands available at the Connection Screen"},{"location":"Continuous-Integration.html","text":"One of the advantages of Evennia over traditional MUSH development systems is that Evennia is capable of integrating into enterprise level integration environments and source control. Because of this, it can also be the subject of automation for additional convenience, allowing a more streamlined development environment. What is Continuous Integration? \u00b6 Continuous Integration (CI) is a development practice that requires developers to integrate code into a shared repository several times a day. Each check-in is then verified by an automated build, allowing teams to detect problems early. For Evennia, continuous integration allows an automated build process to: * Pull down a latest build from Source Control. * Run migrations on the backing SQL database. * Automate additional unique tasks for that project. * Run unit tests. * Publish those files to the server directory * Reload the game. Preparation \u00b6 To prepare a CI environment for your MU* , it will be necessary to set up some prerequisite software for your server. Among those you will need: * A Continuous Integration Environment. * I recommend TeamCity which has an in-depth Setup Guide * Source Control * This could be Git or SVN or any other available SC. Linux TeamCity Setup \u00b6 For this part of the guide, an example setup will be provided for administrators running a TeamCity build integration environment on Linux. After meeting the preparation steps for your specific environment, log on to your teamcity interface at http://<your server>:8111/ . Create a new project named \"Evennia\" and in it construct a new template called continuous-integration. A Quick Overview \u00b6 Templates are fancy objects in TeamCity that allow an administrator to define build steps that are shared between one or more build projects. Assigning a VCS Root (Source Control) is unnecessary at this stage, primarily you'll be worrying about the build steps and your default parameters (both visible on the tabs to the left.) Template Setup \u00b6 In this template, you'll be outlining the steps necessary to build your specific game. (A number of sample scripts are provided under this section below!) Click Build Steps and prepare your general flow. For this example, we will be doing a few basic example steps: Transforming the Settings.py file We do this to update ports or other information that make your production environment unique from your development environment. Making migrations and migrating the game database. Publishing the game files. Reloading the server. For each step we'll being use the \"Command Line Runner\" (a fancy name for a shell script executor). Create a build step with the name: Transform Configuration For the script add: ```bash !/bin/bash \u00b6 Replaces the game configuration with one \u00b6 appropriate for this deployment. \u00b6 CONFIG=\"%system.teamcity.build.checkoutDir%/server/conf/settings.py\" MYCONF=\"%system.teamcity.build.checkoutDir%/server/conf/my.cnf\" sed -e 's/TELNET_PORTS = [4000]/TELNET_PORTS = [%game.ports%]/g' \"$CONFIG\" > \"$CONFIG\".tmp && mv \"$CONFIG\".tmp \"$CONFIG\" sed -e 's/WEBSERVER_PORTS = [(4001, 4002)]/WEBSERVER_PORTS = [%game.webports%]/g' \"$CONFIG\" > \"$CONFIG\".tmp && mv \"$CONFIG\".tmp \"$CONFIG\" settings.py MySQL DB configuration \u00b6 echo Configuring Game Database... echo \"\" >> \"$CONFIG\" echo \"######################################################################\" >> \"$CONFIG\" echo \"# MySQL Database Configuration\" >> \"$CONFIG\" echo \"######################################################################\" >> \"$CONFIG\" echo \"DATABASES = {\" >> \"$CONFIG\" echo \" 'default': {\" >> \"$CONFIG\" echo \" 'ENGINE': 'django.db.backends.mysql',\" >> \"$CONFIG\" echo \" 'OPTIONS': {\" >> \"$CONFIG\" echo \" 'read_default_file': 'server/conf/my.cnf',\" >> \"$CONFIG\" echo \" },\" >> \"$CONFIG\" echo \" }\" >> \"$CONFIG\" echo \"}\" >> \"$CONFIG\" Create the My.CNF file. \u00b6 echo \"[client]\" >> \"$MYCONF\" echo \"database = %mysql.db%\" >> \"$MYCONF\" echo \"user = %mysql.user%\" >> \"$MYCONF\" echo \"password = %mysql.pass%\" >> \"$MYCONF\" echo \"default-character-set = utf8\" >> \"$MYCONF\" ``` If you look at the parameters side of the page after saving this script, you'll notice that some new parameters have been populated for you. This is because we've included new teamcity configuration parameters that are populated when the build itself is ran. When creating projects that inherit this template, we'll be able to fill in or override those parameters for project-specific configuration. Go ahead and create another build step called \"Make Database Migration\" If you're using SQLLite on your game, it will be prudent to change working directory on this step to: %game.dir% In this script include: ```bash !/bin/bash \u00b6 Update the DB migration \u00b6 LOGDIR=\"server/logs\" . %evenv.dir%/bin/activate Check that the logs directory exists. \u00b6 if [ ! -d \"$LOGDIR\" ]; then # Control will enter here if $LOGDIR doesn't exist. mkdir \"$LOGDIR\" fi evennia makemigrations ``` Create yet another build step, this time named: \"Execute Database Migration\": If you're using SQLLite on your game, it will be prudent to change working directory on this step to: %game.dir% ```bash #!/bin/bash # Apply the database migration. LOGDIR=\"server/logs\" . %evenv.dir%/bin/activate Check that the logs directory exists. \u00b6 if [ ! -d \"$LOGDIR\" ]; then # Control will enter here if $LOGDIR doesn't exist. mkdir \"$LOGDIR\" fi evennia migrate ``` Our next build step is where we actually publish our build. Up until now, all work on game has been done in a 'work' directory on TeamCity's build agent. From that directory we will now copy our files to where our game actually exists on the local server. Create a new build step called \"Publish Build\": If you're using SQLLite on your game, be sure to order this step ABOVE the Database Migration steps. The build order will matter! ```bash #!/bin/bash # Publishes the build to the proper build directory. DIRECTORY=\"%game.dir%\" if [ ! -d \"$DIRECTORY\" ]; then # Control will enter here if $DIRECTORY doesn't exist. mkdir \"$DIRECTORY\" fi Copy all the files. \u00b6 cp -ruv %teamcity.build.checkoutDir%/* \"$DIRECTORY\" chmod -R 775 \"$DIRECTORY\" ``` Finally the last script will reload our game for us. Create a new script called \"Reload Game\": The working directory on this build step will be: %game.dir% ```bash #!/bin/bash # Apply the database migration. LOGDIR=\"server/logs\" PIDDIR=\"server/server.pid\" . %evenv.dir%/bin/activate Check that the logs directory exists. \u00b6 if [ ! -d \"$LOGDIR\" ]; then # Control will enter here if $LOGDIR doesn't exist. mkdir \"$LOGDIR\" fi Check that the server is running. \u00b6 if [ -d \"$PIDDIR\" ]; then # Control will enter here if the game is running. evennia reload fi ``` Now the template is ready for use! It would be useful this time to revisit the parameters page and set the evenv parameter to the directory where your virtualenv exists: IE \"/srv/mush/evenv\". Creating the Project \u00b6 Now it's time for the last few steps to set up a CI environment. Return to the Evennia Project overview/administration page. Create a new Sub-Project called \"Production\" This will be the category that holds our actual game. Create a new Build Configuration in Production with the name of your MUSH. Base this configuration off of the continuous-integration template we made earlier. In the build configuration, enter VCS roots and create a new VCS root that points to the branch/version control that you are using. Go to the parameters page and fill in the undefined parameters for your specific configuration. If you wish for the CI to run every time a commit is made, go to the VCS triggers and add one for \"On Every Commit\". And you're done! At this point, you can return to the project overview page and queue a new build for your game. If everything was set up correctly, the build will complete successfully. Additional build steps could be added or removed at this point, adding some features like Unit Testing or more!","title":"Continuous Integration"},{"location":"Continuous-Integration.html#what-is-continuous-integration","text":"Continuous Integration (CI) is a development practice that requires developers to integrate code into a shared repository several times a day. Each check-in is then verified by an automated build, allowing teams to detect problems early. For Evennia, continuous integration allows an automated build process to: * Pull down a latest build from Source Control. * Run migrations on the backing SQL database. * Automate additional unique tasks for that project. * Run unit tests. * Publish those files to the server directory * Reload the game.","title":"What is Continuous Integration?"},{"location":"Continuous-Integration.html#preparation","text":"To prepare a CI environment for your MU* , it will be necessary to set up some prerequisite software for your server. Among those you will need: * A Continuous Integration Environment. * I recommend TeamCity which has an in-depth Setup Guide * Source Control * This could be Git or SVN or any other available SC.","title":"Preparation"},{"location":"Continuous-Integration.html#linux-teamcity-setup","text":"For this part of the guide, an example setup will be provided for administrators running a TeamCity build integration environment on Linux. After meeting the preparation steps for your specific environment, log on to your teamcity interface at http://<your server>:8111/ . Create a new project named \"Evennia\" and in it construct a new template called continuous-integration.","title":"Linux TeamCity Setup"},{"location":"Continuous-Integration.html#a-quick-overview","text":"Templates are fancy objects in TeamCity that allow an administrator to define build steps that are shared between one or more build projects. Assigning a VCS Root (Source Control) is unnecessary at this stage, primarily you'll be worrying about the build steps and your default parameters (both visible on the tabs to the left.)","title":"A Quick Overview"},{"location":"Continuous-Integration.html#template-setup","text":"In this template, you'll be outlining the steps necessary to build your specific game. (A number of sample scripts are provided under this section below!) Click Build Steps and prepare your general flow. For this example, we will be doing a few basic example steps: Transforming the Settings.py file We do this to update ports or other information that make your production environment unique from your development environment. Making migrations and migrating the game database. Publishing the game files. Reloading the server. For each step we'll being use the \"Command Line Runner\" (a fancy name for a shell script executor). Create a build step with the name: Transform Configuration For the script add: ```bash","title":"Template Setup"},{"location":"Continuous-Integration.html#binbash","text":"","title":"!/bin/bash"},{"location":"Continuous-Integration.html#replaces-the-game-configuration-with-one","text":"","title":"Replaces the game configuration with one"},{"location":"Continuous-Integration.html#appropriate-for-this-deployment","text":"CONFIG=\"%system.teamcity.build.checkoutDir%/server/conf/settings.py\" MYCONF=\"%system.teamcity.build.checkoutDir%/server/conf/my.cnf\" sed -e 's/TELNET_PORTS = [4000]/TELNET_PORTS = [%game.ports%]/g' \"$CONFIG\" > \"$CONFIG\".tmp && mv \"$CONFIG\".tmp \"$CONFIG\" sed -e 's/WEBSERVER_PORTS = [(4001, 4002)]/WEBSERVER_PORTS = [%game.webports%]/g' \"$CONFIG\" > \"$CONFIG\".tmp && mv \"$CONFIG\".tmp \"$CONFIG\"","title":"appropriate for this deployment."},{"location":"Continuous-Integration.html#settingspy-mysql-db-configuration","text":"echo Configuring Game Database... echo \"\" >> \"$CONFIG\" echo \"######################################################################\" >> \"$CONFIG\" echo \"# MySQL Database Configuration\" >> \"$CONFIG\" echo \"######################################################################\" >> \"$CONFIG\" echo \"DATABASES = {\" >> \"$CONFIG\" echo \" 'default': {\" >> \"$CONFIG\" echo \" 'ENGINE': 'django.db.backends.mysql',\" >> \"$CONFIG\" echo \" 'OPTIONS': {\" >> \"$CONFIG\" echo \" 'read_default_file': 'server/conf/my.cnf',\" >> \"$CONFIG\" echo \" },\" >> \"$CONFIG\" echo \" }\" >> \"$CONFIG\" echo \"}\" >> \"$CONFIG\"","title":"settings.py MySQL DB configuration"},{"location":"Continuous-Integration.html#create-the-mycnf-file","text":"echo \"[client]\" >> \"$MYCONF\" echo \"database = %mysql.db%\" >> \"$MYCONF\" echo \"user = %mysql.user%\" >> \"$MYCONF\" echo \"password = %mysql.pass%\" >> \"$MYCONF\" echo \"default-character-set = utf8\" >> \"$MYCONF\" ``` If you look at the parameters side of the page after saving this script, you'll notice that some new parameters have been populated for you. This is because we've included new teamcity configuration parameters that are populated when the build itself is ran. When creating projects that inherit this template, we'll be able to fill in or override those parameters for project-specific configuration. Go ahead and create another build step called \"Make Database Migration\" If you're using SQLLite on your game, it will be prudent to change working directory on this step to: %game.dir% In this script include: ```bash","title":"Create the My.CNF file."},{"location":"Continuous-Integration.html#binbash_1","text":"","title":"!/bin/bash"},{"location":"Continuous-Integration.html#update-the-db-migration","text":"LOGDIR=\"server/logs\" . %evenv.dir%/bin/activate","title":"Update the DB migration"},{"location":"Continuous-Integration.html#check-that-the-logs-directory-exists","text":"if [ ! -d \"$LOGDIR\" ]; then # Control will enter here if $LOGDIR doesn't exist. mkdir \"$LOGDIR\" fi evennia makemigrations ``` Create yet another build step, this time named: \"Execute Database Migration\": If you're using SQLLite on your game, it will be prudent to change working directory on this step to: %game.dir% ```bash #!/bin/bash # Apply the database migration. LOGDIR=\"server/logs\" . %evenv.dir%/bin/activate","title":"Check that the logs directory exists."},{"location":"Continuous-Integration.html#check-that-the-logs-directory-exists_1","text":"if [ ! -d \"$LOGDIR\" ]; then # Control will enter here if $LOGDIR doesn't exist. mkdir \"$LOGDIR\" fi evennia migrate ``` Our next build step is where we actually publish our build. Up until now, all work on game has been done in a 'work' directory on TeamCity's build agent. From that directory we will now copy our files to where our game actually exists on the local server. Create a new build step called \"Publish Build\": If you're using SQLLite on your game, be sure to order this step ABOVE the Database Migration steps. The build order will matter! ```bash #!/bin/bash # Publishes the build to the proper build directory. DIRECTORY=\"%game.dir%\" if [ ! -d \"$DIRECTORY\" ]; then # Control will enter here if $DIRECTORY doesn't exist. mkdir \"$DIRECTORY\" fi","title":"Check that the logs directory exists."},{"location":"Continuous-Integration.html#copy-all-the-files","text":"cp -ruv %teamcity.build.checkoutDir%/* \"$DIRECTORY\" chmod -R 775 \"$DIRECTORY\" ``` Finally the last script will reload our game for us. Create a new script called \"Reload Game\": The working directory on this build step will be: %game.dir% ```bash #!/bin/bash # Apply the database migration. LOGDIR=\"server/logs\" PIDDIR=\"server/server.pid\" . %evenv.dir%/bin/activate","title":"Copy all the files."},{"location":"Continuous-Integration.html#check-that-the-logs-directory-exists_2","text":"if [ ! -d \"$LOGDIR\" ]; then # Control will enter here if $LOGDIR doesn't exist. mkdir \"$LOGDIR\" fi","title":"Check that the logs directory exists."},{"location":"Continuous-Integration.html#check-that-the-server-is-running","text":"if [ -d \"$PIDDIR\" ]; then # Control will enter here if the game is running. evennia reload fi ``` Now the template is ready for use! It would be useful this time to revisit the parameters page and set the evenv parameter to the directory where your virtualenv exists: IE \"/srv/mush/evenv\".","title":"Check that the server is running."},{"location":"Continuous-Integration.html#creating-the-project","text":"Now it's time for the last few steps to set up a CI environment. Return to the Evennia Project overview/administration page. Create a new Sub-Project called \"Production\" This will be the category that holds our actual game. Create a new Build Configuration in Production with the name of your MUSH. Base this configuration off of the continuous-integration template we made earlier. In the build configuration, enter VCS roots and create a new VCS root that points to the branch/version control that you are using. Go to the parameters page and fill in the undefined parameters for your specific configuration. If you wish for the CI to run every time a commit is made, go to the VCS triggers and add one for \"On Every Commit\". And you're done! At this point, you can return to the project overview page and queue a new build for your game. If everything was set up correctly, the build will complete successfully. Additional build steps could be added or removed at this point, adding some features like Unit Testing or more!","title":"Creating the Project"},{"location":"Contributing.html","text":"Wanna help out? Great! Here's how. Spreading the word \u00b6 Even if you are not keen on working on the server code yourself, just spreading the word is a big help - it will help attract more people which leads to more feedback, motivation and interest. Consider writing about Evennia on your blog or in your favorite (relevant) forum. Write a review somewhere (good or bad, we like feedback either way). Rate it on places like ohloh . Talk about it to your friends ... that kind of thing. Donations \u00b6 The best way to support Evennia is to become an Evennia patron . Evennia is a free, open-source project and any monetary donations you want to offer are completely voluntary. See it as a way of announcing that you appreciate the work done - a tip of the hat! A patron donates a (usually small) sum every month to show continued support. If this is not your thing you can also show your appreciation via a one-time donation (this is a PayPal link but you don't need PayPal yourself). Help with Documentation \u00b6 Evennia depends heavily on good documentation and we are always looking for extra eyes and hands to improve it. Even small things such as fixing typos are a great help! The documentation is a wiki and as long as you have a GitHub account you can edit it. It can be a good idea to discuss in the chat or forums if you want to add new pages/tutorials. Otherwise, it goes a long way just pointing out wiki errors so we can fix them (in an Issue or just over chat/forum). Contributing through a forked repository \u00b6 We always need more eyes and hands on the code. Even if you don't feel confident with tackling a bug or feature , just correcting typos, adjusting formatting or simply using the thing and reporting when stuff doesn't make sense helps us a lot. The most elegant way to contribute code to Evennia is to use GitHub to create a fork of the Evennia repository and make your changes to that. Refer to the Forking Evennia version control instructions for detailed instructions. Once you have a fork set up, you can not only work on your own game in a separate branch, you can also commit your fixes to Evennia itself. Make separate branches for all Evennia additions you do - don't edit your local master or develop branches directly. It will make your life a lot easier. If you have a change that you think is suitable for the main Evennia repository, you issue a Pull Request . This will let Evennia devs know you have stuff to share. Bug fixes should generally be done against the master branch of Evennia, while new features/contribs should go into the develop branch. If you are unsure, just pick one and we'll figure it out. Contributing with Patches \u00b6 To help with Evennia development it's recommended to do so using a fork repository as described above. But for small, well isolated fixes you are also welcome to submit your suggested Evennia fixes/addendums as a patch . You can include your patch in an Issue or a Mailing list post. Please avoid pasting the full patch text directly in your post though, best is to use a site like Pastebin and just supply the link. Contributing with Contribs \u00b6 While Evennia's core is pretty much game-agnostic, it also has a contrib/ directory. The contrib directory contains game systems that are specialized or useful only to certain types of games. Users are welcome to contribute to the contrib/ directory. Such contributions should always happen via a Forked repository as described above. If you are unsure if your idea/code is suitable as a contrib, ask the devs before putting any work into it . This can also be a good idea in order to not duplicate efforts. This can also act as a check that your implementation idea is sound. We are, for example, unlikely to accept contribs that require large modifications of the game directory structure. If your code is intended primarily as an example or shows a concept/principle rather than a working system, it is probably not suitable for contrib/ . You are instead welcome to use it as part of a new tutorial ! The code should ideally be contained within a single Python module. But if the contribution is large this may not be practical and it should instead be grouped in its own subdirectory (not as loose modules). The contribution should preferably be isolated (only make use of core Evennia) so it can easily be dropped into use. If it does depend on other contribs or third-party modules, these must be clearly documented and part of the installation instructions. The code itself should follow Evennia's Code style guidelines . The code must be well documented as described in our documentation style guide . Expect that your code will be read and should be possible to understand by others. Include comments as well as a header in all modules. If a single file, the header should include info about how to include the contrib in a game (installation instructions). If stored in a subdirectory, this info should go into a new README.md file within that directory. Within reason, your contribution should be designed as genre-agnostic as possible. Limit the amount of game-style-specific code. Assume your code will be applied to a very different game than you had in mind when creating it. To make the licensing situation clear we assume all contributions are released with the same license as Evennia . If this is not possible for some reason, talk to us and we'll handle it on a case-by-case basis. Your contribution must be covered by unit tests . Having unit tests will both help make your code more stable and make sure small changes does not break it without it being noticed, it will also help us test its functionality and merge it quicker. If your contribution is a single module, you can add your unit tests to evennia/contribs/tests.py . If your contribution is bigger and in its own sub-directory you could just put the tests in your own tests.py file (Evennia will find it automatically). Merging of your code into Evennia is not guaranteed. Be ready to receive feedback and to be asked to make corrections or fix bugs. Furthermore, merging a contrib means the Evennia project takes on the responsibility of maintaining and supporting it. For various reasons this may be deemed to be beyond our manpower. However, if your code were to not be accepted for merger for some reason, we will instead add a link to your online repository so people can still find and use your work if they want.","title":"Contributing"},{"location":"Contributing.html#spreading-the-word","text":"Even if you are not keen on working on the server code yourself, just spreading the word is a big help - it will help attract more people which leads to more feedback, motivation and interest. Consider writing about Evennia on your blog or in your favorite (relevant) forum. Write a review somewhere (good or bad, we like feedback either way). Rate it on places like ohloh . Talk about it to your friends ... that kind of thing.","title":"Spreading the word"},{"location":"Contributing.html#donations","text":"The best way to support Evennia is to become an Evennia patron . Evennia is a free, open-source project and any monetary donations you want to offer are completely voluntary. See it as a way of announcing that you appreciate the work done - a tip of the hat! A patron donates a (usually small) sum every month to show continued support. If this is not your thing you can also show your appreciation via a one-time donation (this is a PayPal link but you don't need PayPal yourself).","title":"Donations"},{"location":"Contributing.html#help-with-documentation","text":"Evennia depends heavily on good documentation and we are always looking for extra eyes and hands to improve it. Even small things such as fixing typos are a great help! The documentation is a wiki and as long as you have a GitHub account you can edit it. It can be a good idea to discuss in the chat or forums if you want to add new pages/tutorials. Otherwise, it goes a long way just pointing out wiki errors so we can fix them (in an Issue or just over chat/forum).","title":"Help with Documentation"},{"location":"Contributing.html#contributing-through-a-forked-repository","text":"We always need more eyes and hands on the code. Even if you don't feel confident with tackling a bug or feature , just correcting typos, adjusting formatting or simply using the thing and reporting when stuff doesn't make sense helps us a lot. The most elegant way to contribute code to Evennia is to use GitHub to create a fork of the Evennia repository and make your changes to that. Refer to the Forking Evennia version control instructions for detailed instructions. Once you have a fork set up, you can not only work on your own game in a separate branch, you can also commit your fixes to Evennia itself. Make separate branches for all Evennia additions you do - don't edit your local master or develop branches directly. It will make your life a lot easier. If you have a change that you think is suitable for the main Evennia repository, you issue a Pull Request . This will let Evennia devs know you have stuff to share. Bug fixes should generally be done against the master branch of Evennia, while new features/contribs should go into the develop branch. If you are unsure, just pick one and we'll figure it out.","title":"Contributing through a forked repository"},{"location":"Contributing.html#contributing-with-patches","text":"To help with Evennia development it's recommended to do so using a fork repository as described above. But for small, well isolated fixes you are also welcome to submit your suggested Evennia fixes/addendums as a patch . You can include your patch in an Issue or a Mailing list post. Please avoid pasting the full patch text directly in your post though, best is to use a site like Pastebin and just supply the link.","title":"Contributing with Patches"},{"location":"Contributing.html#contributing-with-contribs","text":"While Evennia's core is pretty much game-agnostic, it also has a contrib/ directory. The contrib directory contains game systems that are specialized or useful only to certain types of games. Users are welcome to contribute to the contrib/ directory. Such contributions should always happen via a Forked repository as described above. If you are unsure if your idea/code is suitable as a contrib, ask the devs before putting any work into it . This can also be a good idea in order to not duplicate efforts. This can also act as a check that your implementation idea is sound. We are, for example, unlikely to accept contribs that require large modifications of the game directory structure. If your code is intended primarily as an example or shows a concept/principle rather than a working system, it is probably not suitable for contrib/ . You are instead welcome to use it as part of a new tutorial ! The code should ideally be contained within a single Python module. But if the contribution is large this may not be practical and it should instead be grouped in its own subdirectory (not as loose modules). The contribution should preferably be isolated (only make use of core Evennia) so it can easily be dropped into use. If it does depend on other contribs or third-party modules, these must be clearly documented and part of the installation instructions. The code itself should follow Evennia's Code style guidelines . The code must be well documented as described in our documentation style guide . Expect that your code will be read and should be possible to understand by others. Include comments as well as a header in all modules. If a single file, the header should include info about how to include the contrib in a game (installation instructions). If stored in a subdirectory, this info should go into a new README.md file within that directory. Within reason, your contribution should be designed as genre-agnostic as possible. Limit the amount of game-style-specific code. Assume your code will be applied to a very different game than you had in mind when creating it. To make the licensing situation clear we assume all contributions are released with the same license as Evennia . If this is not possible for some reason, talk to us and we'll handle it on a case-by-case basis. Your contribution must be covered by unit tests . Having unit tests will both help make your code more stable and make sure small changes does not break it without it being noticed, it will also help us test its functionality and merge it quicker. If your contribution is a single module, you can add your unit tests to evennia/contribs/tests.py . If your contribution is bigger and in its own sub-directory you could just put the tests in your own tests.py file (Evennia will find it automatically). Merging of your code into Evennia is not guaranteed. Be ready to receive feedback and to be asked to make corrections or fix bugs. Furthermore, merging a contrib means the Evennia project takes on the responsibility of maintaining and supporting it. For various reasons this may be deemed to be beyond our manpower. However, if your code were to not be accepted for merger for some reason, we will instead add a link to your online repository so people can still find and use your work if they want.","title":"Contributing with Contribs"},{"location":"Coordinates.html","text":"Adding room coordinates in your game \u00b6 This tutorial is moderately difficult in content. You might want to be familiar and at ease with some Python concepts (like properties) and possibly Django concepts (like queries), although this tutorial will try to walk you through the process and give enough explanations each time. If you don't feel very confident with math, don't hesitate to pause, go to the example section, which shows a tiny map, and try to walk around the code or read the explanation. Evennia doesn't have a coordinate system by default. Rooms and other objects are linked by location and content: An object can be in a location, that is, another object. Like an exit in a room. An object can access its content. A room can see what objects uses it as location (that would include exits, rooms, characters and so on). This system allows for a lot of flexibility and, fortunately, can be extended by other systems. Here, I offer you a way to add coordinates to every room in a way most compliant with Evennia design. This will also show you how to use coordinates, find rooms around a given point for instance. Coordinates as tags \u00b6 The first concept might be the most surprising at first glance: we will create coordinates as tags . Why not attributes, wouldn't that be easier? It would. We could just do something like room.db.x = 3 . The advantage of using tags is that it will be easy and effective to search. Although this might not seem like a huge advantage right now, with a database of thousands of rooms, it might make a difference, particularly if you have a lot of things based on coordinates. Rather than giving you a step-by-step process, I'll show you the code. Notice that we use properties to easily access and update coordinates. This is a Pythonic approach. Here's our first Room class, that you can modify in typeclasses/rooms.py : # in typeclasses/rooms.py from evennia import DefaultRoom class Room(DefaultRoom): \"\"\" Rooms are like any Object, except their location is None (which is default). They also use basetype_setup() to add locks so they cannot be puppeted or picked up. (to change that, use at_object_creation instead) See examples/object.py for a list of properties and methods available on all Objects. \"\"\" @property def x(self): \"\"\"Return the X coordinate or None.\"\"\" x = self.tags.get(category=\"coordx\") return int(x) if isinstance(x, str) else None @x.setter def x(self, x): \"\"\"Change the X coordinate.\"\"\" old = self.tags.get(category=\"coordx\") if old is not None: self.tags.remove(old, category=\"coordx\") if x is not None: self.tags.add(str(x), category=\"coordx\") @property def y(self): \"\"\"Return the Y coordinate or None.\"\"\" y = self.tags.get(category=\"coordy\") return int(y) if isinstance(y, str) else None @y.setter def y(self, y): \"\"\"Change the Y coordinate.\"\"\" old = self.tags.get(category=\"coordy\") if old is not None: self.tags.remove(old, category=\"coordy\") if y is not None: self.tags.add(str(y), category=\"coordy\") @property def z(self): \"\"\"Return the Z coordinate or None.\"\"\" z = self.tags.get(category=\"coordz\") return int(z) if isinstance(z, str) else None @z.setter def z(self, z): \"\"\"Change the Z coordinate.\"\"\" old = self.tags.get(category=\"coordz\") if old is not None: self.tags.remove(old, category=\"coordz\") if z is not None: self.tags.add(str(z), category=\"coordz\") If you aren't familiar with the concept of properties in Python, I encourage you to read a good tutorial on the subject. This article on Python properties is well-explained and should help you understand the idea. Let's look at our properties for x . First of all is the read property. @property def x(self): \"\"\"Return the X coordinate or None.\"\"\" x = self.tags.get(category=\"coordx\") return int(x) if isinstance(x, str) else None What it does is pretty simple: It gets the tag of category \"coordx\" . It's the tag category where we store our X coordinate. The tags.get method will return None if the tag can't be found. We convert the value to an integer, if it's a str . Remember that tags can only contain str , so we'll need to convert it. I thought tags couldn't contain values? Well, technically, they can't: they're either here or not. But using tag categories, as we have done, we get a tag, knowing only its category. That's the basic approach to coordinates in this tutorial. Now, let's look at the method that will be called when we wish to set x in our room: @x.setter def x(self, x): \"\"\"Change the X coordinate.\"\"\" old = self.tags.get(category=\"coordx\") if old is not None: self.tags.remove(old, category=\"coordx\") if x is not None: self.tags.add(str(x), category=\"coordx\") First, we remove the old X coordinate, if it exists. Otherwise, we'd end up with two tags in our room with \"coordx\" as their category, which wouldn't do at all. Then we add the new tag, giving it the proper category. Now what? If you add this code and reload your game, once you're logged in with a character in a room as its location, you can play around: @py here.x @py here.x = 0 @py here.y = 3 @py here.z = -2 @py here.z = None The code might not be that easy to read, but you have to admit it's fairly easy to use. Some additional searches \u00b6 Having coordinates is useful for several reasons: It can help in shaping a truly logical world, in its geography, at least. It can allow to look for specific rooms at given coordinates. It can be good in order to quickly find the rooms around a location. It can even be great in path-finding (finding the shortest path between two rooms). So far, our coordinate system can help with 1., but not much else. Here are some methods that we could add to the Room typeclass. These methods will just be search methods. Notice that they are class methods, since we want to get rooms. Finding one room \u00b6 First, a simple one: how to find a room at a given coordinate? Say, what is the room at X=0, Y=0, Z=0? class Room(DefaultRoom): # ... @classmethod def get_room_at(cls, x, y, z): \"\"\" Return the room at the given location or None if not found. Args: x (int): the X coord. y (int): the Y coord. z (int): the Z coord. Return: The room at this location (Room) or None if not found. \"\"\" rooms = cls.objects.filter( db_tags__db_key=str(x), db_tags__db_category=\"coordx\").filter( db_tags__db_key=str(y), db_tags__db_category=\"coordy\").filter( db_tags__db_key=str(z), db_tags__db_category=\"coordz\") if rooms: return rooms[0] return None This solution includes a bit of Django queries . Basically, what we do is reach for the object manager and search for objects with the matching tags. Again, don't spend too much time worrying about the mechanism, the method is quite easy to use: Room.get_room_at(5, 2, -3) Notice that this is a class method: you will call it from Room (the class), not an instance. Though you still can: @py here.get_room_at(3, 8, 0) Finding several rooms \u00b6 Here's another useful method that allows us to look for rooms around a given coordinate. This is more advanced search and doing some calculation, beware! Look at the following section if you're lost. from math import sqrt class Room(DefaultRoom): # ... @classmethod def get_rooms_around(cls, x, y, z, distance): \"\"\" Return the list of rooms around the given coordinates. This method returns a list of tuples (distance, room) that can easily be browsed. This list is sorted by distance (the closest room to the specified position is always at the top of the list). Args: x (int): the X coord. y (int): the Y coord. z (int): the Z coord. distance (int): the maximum distance to the specified position. Returns: A list of tuples containing the distance to the specified position and the room at this distance. Several rooms can be at equal distance from the position. \"\"\" # Performs a quick search to only get rooms in a square x_r = list(reversed([str(x - i) for i in range(0, distance + 1)])) x_r += [str(x + i) for i in range(1, distance + 1)] y_r = list(reversed([str(y - i) for i in range(0, distance + 1)])) y_r += [str(y + i) for i in range(1, distance + 1)] z_r = list(reversed([str(z - i) for i in range(0, distance + 1)])) z_r += [str(z + i) for i in range(1, distance + 1)] wide = cls.objects.filter( db_tags__db_key__in=x_r, db_tags__db_category=\"coordx\").filter( db_tags__db_key__in=y_r, db_tags__db_category=\"coordy\").filter( db_tags__db_key__in=z_r, db_tags__db_category=\"coordz\") # We now need to filter down this list to find out whether # these rooms are really close enough, and at what distance # In short: we change the square to a circle. rooms = [] for room in wide: x2 = int(room.tags.get(category=\"coordx\")) y2 = int(room.tags.get(category=\"coordy\")) z2 = int(room.tags.get(category=\"coordz\")) distance_to_room = sqrt( (x2 - x) ** 2 + (y2 - y) ** 2 + (z2 - z) ** 2) if distance_to_room <= distance: rooms.append((distance_to_room, room)) # Finally sort the rooms by distance rooms.sort(key=lambda tup: tup[0]) return rooms This gets more serious. We have specified coordinates as parameters. We determine a broad range using the distance. That is, for each coordinate, we create a list of possible matches. See the example below. We then search for the rooms within this broader range. It gives us a square around our location. Some rooms are definitely outside the range. Again, see the example below to follow the logic. We filter down the list and sort it by distance from the specified coordinates. Notice that we only search starting at step 2. Thus, the Django search doesn't look and cache all objects, just a wider range than what would be really necessary. This method returns a circle of coordinates around a specified point. Django looks for a square. What wouldn't fit in the circle is removed at step 3, which is the only part that includes systematic calculation. This method is optimized to be quick and efficient. An example \u00b6 An example might help. Consider this very simple map (a textual description follows): 4 A B C D 3 E F G H 2 I J K L 1 M N O P 1 2 3 4 The X coordinates are given below. The Y coordinates are given on the left. This is a simple square with 16 rooms: 4 on each line, 4 lines of them. All the rooms are identified by letters in this example: the first line at the top has rooms A to D, the second E to H, the third I to L and the fourth M to P. The bottom-left room, X=1 and Y=1, is M. The upper-right room X=4 and Y=4 is D. So let's say we want to find all the neighbors, distance 1, from the room J. J is at X=2, Y=2. So we use: Room.get_rooms_around(x=2, y=2, z=0, distance=1) # we'll assume a z coordinate of 0 for simplicity First, this method gets all the rooms in a square around J. So it gets E F G, I J K, M N O. If you want, draw the square around these coordinates to see what's happening. Next, we browse over this list and check the real distance between J (X=2, Y=2) and the room. The four corners of the square are not in this circle. For instance, the distance between J and M is not 1. If you draw a circle of center J and radius 1, you'll notice that the four corners of our square (E, G, M and O) are not in this circle. So we remove them. We sort by distance from J. So in the end we might obtain something like this: [ (0, J), # yes, J is part of this circle after all, with a distance of 0 (1, F), (1, I), (1, K), (1, N), ] You can try with more examples if you want to see this in action. To conclude \u00b6 You can definitely use this system to map other objects, not just rooms. You can easily remove the `Z coordinate too, if you simply need X and Y.","title":"Adding room coordinates in your game"},{"location":"Coordinates.html#adding-room-coordinates-in-your-game","text":"This tutorial is moderately difficult in content. You might want to be familiar and at ease with some Python concepts (like properties) and possibly Django concepts (like queries), although this tutorial will try to walk you through the process and give enough explanations each time. If you don't feel very confident with math, don't hesitate to pause, go to the example section, which shows a tiny map, and try to walk around the code or read the explanation. Evennia doesn't have a coordinate system by default. Rooms and other objects are linked by location and content: An object can be in a location, that is, another object. Like an exit in a room. An object can access its content. A room can see what objects uses it as location (that would include exits, rooms, characters and so on). This system allows for a lot of flexibility and, fortunately, can be extended by other systems. Here, I offer you a way to add coordinates to every room in a way most compliant with Evennia design. This will also show you how to use coordinates, find rooms around a given point for instance.","title":"Adding room coordinates in your game"},{"location":"Coordinates.html#coordinates-as-tags","text":"The first concept might be the most surprising at first glance: we will create coordinates as tags . Why not attributes, wouldn't that be easier? It would. We could just do something like room.db.x = 3 . The advantage of using tags is that it will be easy and effective to search. Although this might not seem like a huge advantage right now, with a database of thousands of rooms, it might make a difference, particularly if you have a lot of things based on coordinates. Rather than giving you a step-by-step process, I'll show you the code. Notice that we use properties to easily access and update coordinates. This is a Pythonic approach. Here's our first Room class, that you can modify in typeclasses/rooms.py : # in typeclasses/rooms.py from evennia import DefaultRoom class Room(DefaultRoom): \"\"\" Rooms are like any Object, except their location is None (which is default). They also use basetype_setup() to add locks so they cannot be puppeted or picked up. (to change that, use at_object_creation instead) See examples/object.py for a list of properties and methods available on all Objects. \"\"\" @property def x(self): \"\"\"Return the X coordinate or None.\"\"\" x = self.tags.get(category=\"coordx\") return int(x) if isinstance(x, str) else None @x.setter def x(self, x): \"\"\"Change the X coordinate.\"\"\" old = self.tags.get(category=\"coordx\") if old is not None: self.tags.remove(old, category=\"coordx\") if x is not None: self.tags.add(str(x), category=\"coordx\") @property def y(self): \"\"\"Return the Y coordinate or None.\"\"\" y = self.tags.get(category=\"coordy\") return int(y) if isinstance(y, str) else None @y.setter def y(self, y): \"\"\"Change the Y coordinate.\"\"\" old = self.tags.get(category=\"coordy\") if old is not None: self.tags.remove(old, category=\"coordy\") if y is not None: self.tags.add(str(y), category=\"coordy\") @property def z(self): \"\"\"Return the Z coordinate or None.\"\"\" z = self.tags.get(category=\"coordz\") return int(z) if isinstance(z, str) else None @z.setter def z(self, z): \"\"\"Change the Z coordinate.\"\"\" old = self.tags.get(category=\"coordz\") if old is not None: self.tags.remove(old, category=\"coordz\") if z is not None: self.tags.add(str(z), category=\"coordz\") If you aren't familiar with the concept of properties in Python, I encourage you to read a good tutorial on the subject. This article on Python properties is well-explained and should help you understand the idea. Let's look at our properties for x . First of all is the read property. @property def x(self): \"\"\"Return the X coordinate or None.\"\"\" x = self.tags.get(category=\"coordx\") return int(x) if isinstance(x, str) else None What it does is pretty simple: It gets the tag of category \"coordx\" . It's the tag category where we store our X coordinate. The tags.get method will return None if the tag can't be found. We convert the value to an integer, if it's a str . Remember that tags can only contain str , so we'll need to convert it. I thought tags couldn't contain values? Well, technically, they can't: they're either here or not. But using tag categories, as we have done, we get a tag, knowing only its category. That's the basic approach to coordinates in this tutorial. Now, let's look at the method that will be called when we wish to set x in our room: @x.setter def x(self, x): \"\"\"Change the X coordinate.\"\"\" old = self.tags.get(category=\"coordx\") if old is not None: self.tags.remove(old, category=\"coordx\") if x is not None: self.tags.add(str(x), category=\"coordx\") First, we remove the old X coordinate, if it exists. Otherwise, we'd end up with two tags in our room with \"coordx\" as their category, which wouldn't do at all. Then we add the new tag, giving it the proper category. Now what? If you add this code and reload your game, once you're logged in with a character in a room as its location, you can play around: @py here.x @py here.x = 0 @py here.y = 3 @py here.z = -2 @py here.z = None The code might not be that easy to read, but you have to admit it's fairly easy to use.","title":"Coordinates as tags"},{"location":"Coordinates.html#some-additional-searches","text":"Having coordinates is useful for several reasons: It can help in shaping a truly logical world, in its geography, at least. It can allow to look for specific rooms at given coordinates. It can be good in order to quickly find the rooms around a location. It can even be great in path-finding (finding the shortest path between two rooms). So far, our coordinate system can help with 1., but not much else. Here are some methods that we could add to the Room typeclass. These methods will just be search methods. Notice that they are class methods, since we want to get rooms.","title":"Some additional searches"},{"location":"Coordinates.html#finding-one-room","text":"First, a simple one: how to find a room at a given coordinate? Say, what is the room at X=0, Y=0, Z=0? class Room(DefaultRoom): # ... @classmethod def get_room_at(cls, x, y, z): \"\"\" Return the room at the given location or None if not found. Args: x (int): the X coord. y (int): the Y coord. z (int): the Z coord. Return: The room at this location (Room) or None if not found. \"\"\" rooms = cls.objects.filter( db_tags__db_key=str(x), db_tags__db_category=\"coordx\").filter( db_tags__db_key=str(y), db_tags__db_category=\"coordy\").filter( db_tags__db_key=str(z), db_tags__db_category=\"coordz\") if rooms: return rooms[0] return None This solution includes a bit of Django queries . Basically, what we do is reach for the object manager and search for objects with the matching tags. Again, don't spend too much time worrying about the mechanism, the method is quite easy to use: Room.get_room_at(5, 2, -3) Notice that this is a class method: you will call it from Room (the class), not an instance. Though you still can: @py here.get_room_at(3, 8, 0)","title":"Finding one room"},{"location":"Coordinates.html#finding-several-rooms","text":"Here's another useful method that allows us to look for rooms around a given coordinate. This is more advanced search and doing some calculation, beware! Look at the following section if you're lost. from math import sqrt class Room(DefaultRoom): # ... @classmethod def get_rooms_around(cls, x, y, z, distance): \"\"\" Return the list of rooms around the given coordinates. This method returns a list of tuples (distance, room) that can easily be browsed. This list is sorted by distance (the closest room to the specified position is always at the top of the list). Args: x (int): the X coord. y (int): the Y coord. z (int): the Z coord. distance (int): the maximum distance to the specified position. Returns: A list of tuples containing the distance to the specified position and the room at this distance. Several rooms can be at equal distance from the position. \"\"\" # Performs a quick search to only get rooms in a square x_r = list(reversed([str(x - i) for i in range(0, distance + 1)])) x_r += [str(x + i) for i in range(1, distance + 1)] y_r = list(reversed([str(y - i) for i in range(0, distance + 1)])) y_r += [str(y + i) for i in range(1, distance + 1)] z_r = list(reversed([str(z - i) for i in range(0, distance + 1)])) z_r += [str(z + i) for i in range(1, distance + 1)] wide = cls.objects.filter( db_tags__db_key__in=x_r, db_tags__db_category=\"coordx\").filter( db_tags__db_key__in=y_r, db_tags__db_category=\"coordy\").filter( db_tags__db_key__in=z_r, db_tags__db_category=\"coordz\") # We now need to filter down this list to find out whether # these rooms are really close enough, and at what distance # In short: we change the square to a circle. rooms = [] for room in wide: x2 = int(room.tags.get(category=\"coordx\")) y2 = int(room.tags.get(category=\"coordy\")) z2 = int(room.tags.get(category=\"coordz\")) distance_to_room = sqrt( (x2 - x) ** 2 + (y2 - y) ** 2 + (z2 - z) ** 2) if distance_to_room <= distance: rooms.append((distance_to_room, room)) # Finally sort the rooms by distance rooms.sort(key=lambda tup: tup[0]) return rooms This gets more serious. We have specified coordinates as parameters. We determine a broad range using the distance. That is, for each coordinate, we create a list of possible matches. See the example below. We then search for the rooms within this broader range. It gives us a square around our location. Some rooms are definitely outside the range. Again, see the example below to follow the logic. We filter down the list and sort it by distance from the specified coordinates. Notice that we only search starting at step 2. Thus, the Django search doesn't look and cache all objects, just a wider range than what would be really necessary. This method returns a circle of coordinates around a specified point. Django looks for a square. What wouldn't fit in the circle is removed at step 3, which is the only part that includes systematic calculation. This method is optimized to be quick and efficient.","title":"Finding several rooms"},{"location":"Coordinates.html#an-example","text":"An example might help. Consider this very simple map (a textual description follows): 4 A B C D 3 E F G H 2 I J K L 1 M N O P 1 2 3 4 The X coordinates are given below. The Y coordinates are given on the left. This is a simple square with 16 rooms: 4 on each line, 4 lines of them. All the rooms are identified by letters in this example: the first line at the top has rooms A to D, the second E to H, the third I to L and the fourth M to P. The bottom-left room, X=1 and Y=1, is M. The upper-right room X=4 and Y=4 is D. So let's say we want to find all the neighbors, distance 1, from the room J. J is at X=2, Y=2. So we use: Room.get_rooms_around(x=2, y=2, z=0, distance=1) # we'll assume a z coordinate of 0 for simplicity First, this method gets all the rooms in a square around J. So it gets E F G, I J K, M N O. If you want, draw the square around these coordinates to see what's happening. Next, we browse over this list and check the real distance between J (X=2, Y=2) and the room. The four corners of the square are not in this circle. For instance, the distance between J and M is not 1. If you draw a circle of center J and radius 1, you'll notice that the four corners of our square (E, G, M and O) are not in this circle. So we remove them. We sort by distance from J. So in the end we might obtain something like this: [ (0, J), # yes, J is part of this circle after all, with a distance of 0 (1, F), (1, I), (1, K), (1, N), ] You can try with more examples if you want to see this in action.","title":"An example"},{"location":"Coordinates.html#to-conclude","text":"You can definitely use this system to map other objects, not just rooms. You can easily remove the `Z coordinate too, if you simply need X and Y.","title":"To conclude"},{"location":"Custom-Protocols.html","text":"Note: This is considered an advanced topic and is mostly of interest to users planning to implement their own custom client protocol. A PortalSession is the basic data object representing an external connection to the Evennia Portal -- usually a human player running a mud client of some kind. The way they connect (the language the player's client and Evennia use to talk to each other) is called the connection Protocol . The most common such protocol for MUD:s is the Telnet protocol. All Portal Sessions are stored and managed by the Portal's sessionhandler . It's technically sometimes hard to separate the concept of PortalSession from the concept of Protocol since both depend heavily on the other (they are often created as the same class). When data flows through this part of the system, this is how it goes # In the Portal You <-> Protocol + PortalSession <-> PortalSessionHandler <-> (AMP) <-> ServerSessionHandler <-> ServerSession <-> InputFunc (See the Message Path for the bigger picture of how data flows through Evennia). The parts that needs to be customized to make your own custom protocol is the Protocol + PortalSession (which translates between data coming in/out over the wire to/from Evennia internal representation) as well as the InputFunc (which handles incoming data). Adding custom Protocols \u00b6 Evennia has a plugin-system that add the protocol as a new \"service\" to the application. Take a look at evennia/server/portal/portal.py , notably the sections towards the end of that file. These are where the various in-built services like telnet, ssh, webclient etc are added to the Portal (there is an equivalent but shorter list in evennia/server/server.py ). To add a new service of your own (for example your own custom client protocol) to the Portal or Server, look at mygame/server/conf/server_services_plugins and portal_services_plugins . By default Evennia will look into these modules to find plugins. If you wanted to have it look for more modules, you could do the following: # add to the Server SERVER_SERVICES_PLUGIN_MODULES.append('server.conf.my_server_plugins') # or, if you want to add to the Portal PORTAL_SERVICES_PLUGIN_MODULES.append('server.conf.my_portal_plugins') When adding a new connection you'll most likely only need to add new things to the PORTAL_SERVICES_PLUGIN_MODULES . This module can contain whatever you need to define your protocol, but it must contain a function start_plugin_services(app) . This is called by the Portal as part of its upstart. The function start_plugin_services must contain all startup code the server need. The app argument is a reference to the Portal/Server application itself so the custom service can be added to it. The function should not return anything. This is how it looks: # mygame/server/conf/portal_services_plugins.py # here the new Portal Twisted protocol is defined class MyOwnFactory( ... ): [...] # some configs MYPROC_ENABLED = True # convenient off-flag to avoid having to edit settings all the time MY_PORT = 6666 def start_plugin_services(portal): \"This is called by the Portal during startup\" if not MYPROC_ENABLED: return # output to list this with the other services at startup print(\" myproc: %s\" % MY_PORT) # some setup (simple example) factory = MyOwnFactory() my_service = internet.TCPServer(MY_PORT, factory) # all Evennia services must be uniquely named my_service.setName(\"MyService\") # add to the main portal application portal.services.addService(my_service) Once the module is defined and targeted in settings, just reload the server and your new protocol/services should start with the others. Writing your own Protocol \u00b6 Writing a stable communication protocol from scratch is not something we'll cover here, it's no trivial task. The good news is that Twisted offers implementations of many common protocols, ready for adapting. Writing a protocol implementation in Twisted usually involves creating a class inheriting from an already existing Twisted protocol class and from evennia.server.session.Session (multiple inheritance), then overloading the methods that particular protocol uses to link them to the Evennia-specific inputs. Here's a example to show the concept: # In module that we'll later add to the system through PORTAL_SERVICE_PLUGIN_MODULES # pseudo code from twisted.something import TwistedClient # this class is used both for Portal- and Server Sessions from evennia.server.session import Session from evennia.server.portal.portalsessionhandler import PORTAL_SESSIONS class MyCustomClient(TwistedClient, Session): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.sessionhandler = PORTAL_SESSIONS # these are methods we must know that TwistedClient uses for # communication. Name and arguments could vary for different Twisted protocols def onOpen(self, *args, **kwargs): # let's say this is called when the client first connects # we need to init the session and connect to the sessionhandler. The .factory # is available through the Twisted parents client_address = self.getClientAddress() # get client address somehow self.init_session(\"mycustom_protocol\", client_address, self.factory.sessionhandler) self.sessionhandler.connect(self) def onClose(self, reason, *args, **kwargs): # called when the client connection is dropped # link to the Evennia equivalent self.disconnect(reason) def onMessage(self, indata, *args, **kwargs): # called with incoming data # convert as needed here self.data_in(data=indata) def sendMessage(self, outdata, *args, **kwargs): # called to send data out # modify if needed super().sendMessage(self, outdata, *args, **kwargs) # these are Evennia methods. They must all exist and look exactly like this # The above twisted-methods call them and vice-versa. This connects the protocol # the Evennia internals. def disconnect(self, reason=None): \"\"\" Called when connection closes. This can also be called directly by Evennia when manually closing the connection. Do any cleanups here. \"\"\" self.sessionhandler.disconnect(self) def at_login(self): \"\"\" Called when this session authenticates by the server (if applicable) \"\"\" def data_in(self, **kwargs): \"\"\" Data going into the server should go through this method. It should pass data into `sessionhandler.data_in`. THis will be called by the sessionhandler with the data it gets from the approrpriate send_* method found later in this protocol. \"\"\" self.sessionhandler.data_in(self, text=kwargs['data']) def data_out(self, **kwargs): \"\"\" Data going out from the server should go through this method. It should hand off to the protocol's send method, whatever it's called. \"\"\" # we assume we have a 'text' outputfunc self.onMessage(kwargs['text']) # 'outputfuncs' are defined as `send_<outputfunc_name>`. From in-code, they are called # with `msg(outfunc_name=<data>)`. def send_text(self, txt, *args, **kwargs): \"\"\" Send text, used with e.g. `session.msg(text=\"foo\")` \"\"\" # we make use of the self.data_out(text=txt) def send_default(self, cmdname, *args, **kwargs): \"\"\" Handles all outputfuncs without an explicit `send_*` method to handle them. \"\"\" self.data_out(**{cmdname: str(args)}) The principle here is that the Twisted-specific methods are overridden to redirect inputs/outputs to the Evennia-specific methods. Sending data out \u00b6 To send data out through this protocol, you'd need to get its Session and then you could e.g. session.msg(text=\"foo\") The message will pass through the system such that the sessionhandler will dig out the session and check if it has a send_text method (it has). It will then pass the \"foo\" into that method, which in our case means sending \"foo\" across the network. Receiving data \u00b6 Just because the protocol is there, does not mean Evennia knows what to do with it. An Inputfunc must exist to receive it. In the case of the text input exemplified above, Evennia alredy handles this input - it will parse it as a Command name followed by its inputs. So handle that you need to simply add a cmdset with commands on your receiving Session (and/or the Object/Character it is puppeting). If not you may need to add your own Inputfunc (see the Inputfunc page for how to do this. These might not be as clear-cut in all protocols, but the principle is there. These four basic components - however they are accessed - links to the Portal Session , which is the actual common interface between the different low-level protocols and Evennia. Assorted notes \u00b6 To take two examples, Evennia supports the telnet protocol as well as webclient , via ajax or websockets. You'll find that whereas telnet is a textbook example of a Twisted protocol as seen above, the ajax protocol looks quite different due to how it interacts with the webserver through long-polling (comet) style requests. All the necessary parts mentioned above are still there, but by necessity implemented in very different ways.","title":"Custom Protocols"},{"location":"Custom-Protocols.html#adding-custom-protocols","text":"Evennia has a plugin-system that add the protocol as a new \"service\" to the application. Take a look at evennia/server/portal/portal.py , notably the sections towards the end of that file. These are where the various in-built services like telnet, ssh, webclient etc are added to the Portal (there is an equivalent but shorter list in evennia/server/server.py ). To add a new service of your own (for example your own custom client protocol) to the Portal or Server, look at mygame/server/conf/server_services_plugins and portal_services_plugins . By default Evennia will look into these modules to find plugins. If you wanted to have it look for more modules, you could do the following: # add to the Server SERVER_SERVICES_PLUGIN_MODULES.append('server.conf.my_server_plugins') # or, if you want to add to the Portal PORTAL_SERVICES_PLUGIN_MODULES.append('server.conf.my_portal_plugins') When adding a new connection you'll most likely only need to add new things to the PORTAL_SERVICES_PLUGIN_MODULES . This module can contain whatever you need to define your protocol, but it must contain a function start_plugin_services(app) . This is called by the Portal as part of its upstart. The function start_plugin_services must contain all startup code the server need. The app argument is a reference to the Portal/Server application itself so the custom service can be added to it. The function should not return anything. This is how it looks: # mygame/server/conf/portal_services_plugins.py # here the new Portal Twisted protocol is defined class MyOwnFactory( ... ): [...] # some configs MYPROC_ENABLED = True # convenient off-flag to avoid having to edit settings all the time MY_PORT = 6666 def start_plugin_services(portal): \"This is called by the Portal during startup\" if not MYPROC_ENABLED: return # output to list this with the other services at startup print(\" myproc: %s\" % MY_PORT) # some setup (simple example) factory = MyOwnFactory() my_service = internet.TCPServer(MY_PORT, factory) # all Evennia services must be uniquely named my_service.setName(\"MyService\") # add to the main portal application portal.services.addService(my_service) Once the module is defined and targeted in settings, just reload the server and your new protocol/services should start with the others.","title":"Adding custom Protocols"},{"location":"Custom-Protocols.html#writing-your-own-protocol","text":"Writing a stable communication protocol from scratch is not something we'll cover here, it's no trivial task. The good news is that Twisted offers implementations of many common protocols, ready for adapting. Writing a protocol implementation in Twisted usually involves creating a class inheriting from an already existing Twisted protocol class and from evennia.server.session.Session (multiple inheritance), then overloading the methods that particular protocol uses to link them to the Evennia-specific inputs. Here's a example to show the concept: # In module that we'll later add to the system through PORTAL_SERVICE_PLUGIN_MODULES # pseudo code from twisted.something import TwistedClient # this class is used both for Portal- and Server Sessions from evennia.server.session import Session from evennia.server.portal.portalsessionhandler import PORTAL_SESSIONS class MyCustomClient(TwistedClient, Session): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.sessionhandler = PORTAL_SESSIONS # these are methods we must know that TwistedClient uses for # communication. Name and arguments could vary for different Twisted protocols def onOpen(self, *args, **kwargs): # let's say this is called when the client first connects # we need to init the session and connect to the sessionhandler. The .factory # is available through the Twisted parents client_address = self.getClientAddress() # get client address somehow self.init_session(\"mycustom_protocol\", client_address, self.factory.sessionhandler) self.sessionhandler.connect(self) def onClose(self, reason, *args, **kwargs): # called when the client connection is dropped # link to the Evennia equivalent self.disconnect(reason) def onMessage(self, indata, *args, **kwargs): # called with incoming data # convert as needed here self.data_in(data=indata) def sendMessage(self, outdata, *args, **kwargs): # called to send data out # modify if needed super().sendMessage(self, outdata, *args, **kwargs) # these are Evennia methods. They must all exist and look exactly like this # The above twisted-methods call them and vice-versa. This connects the protocol # the Evennia internals. def disconnect(self, reason=None): \"\"\" Called when connection closes. This can also be called directly by Evennia when manually closing the connection. Do any cleanups here. \"\"\" self.sessionhandler.disconnect(self) def at_login(self): \"\"\" Called when this session authenticates by the server (if applicable) \"\"\" def data_in(self, **kwargs): \"\"\" Data going into the server should go through this method. It should pass data into `sessionhandler.data_in`. THis will be called by the sessionhandler with the data it gets from the approrpriate send_* method found later in this protocol. \"\"\" self.sessionhandler.data_in(self, text=kwargs['data']) def data_out(self, **kwargs): \"\"\" Data going out from the server should go through this method. It should hand off to the protocol's send method, whatever it's called. \"\"\" # we assume we have a 'text' outputfunc self.onMessage(kwargs['text']) # 'outputfuncs' are defined as `send_<outputfunc_name>`. From in-code, they are called # with `msg(outfunc_name=<data>)`. def send_text(self, txt, *args, **kwargs): \"\"\" Send text, used with e.g. `session.msg(text=\"foo\")` \"\"\" # we make use of the self.data_out(text=txt) def send_default(self, cmdname, *args, **kwargs): \"\"\" Handles all outputfuncs without an explicit `send_*` method to handle them. \"\"\" self.data_out(**{cmdname: str(args)}) The principle here is that the Twisted-specific methods are overridden to redirect inputs/outputs to the Evennia-specific methods.","title":"Writing your own Protocol"},{"location":"Custom-Protocols.html#sending-data-out","text":"To send data out through this protocol, you'd need to get its Session and then you could e.g. session.msg(text=\"foo\") The message will pass through the system such that the sessionhandler will dig out the session and check if it has a send_text method (it has). It will then pass the \"foo\" into that method, which in our case means sending \"foo\" across the network.","title":"Sending data out"},{"location":"Custom-Protocols.html#receiving-data","text":"Just because the protocol is there, does not mean Evennia knows what to do with it. An Inputfunc must exist to receive it. In the case of the text input exemplified above, Evennia alredy handles this input - it will parse it as a Command name followed by its inputs. So handle that you need to simply add a cmdset with commands on your receiving Session (and/or the Object/Character it is puppeting). If not you may need to add your own Inputfunc (see the Inputfunc page for how to do this. These might not be as clear-cut in all protocols, but the principle is there. These four basic components - however they are accessed - links to the Portal Session , which is the actual common interface between the different low-level protocols and Evennia.","title":"Receiving data"},{"location":"Custom-Protocols.html#assorted-notes","text":"To take two examples, Evennia supports the telnet protocol as well as webclient , via ajax or websockets. You'll find that whereas telnet is a textbook example of a Twisted protocol as seen above, the ajax protocol looks quite different due to how it interacts with the webserver through long-polling (comet) style requests. All the necessary parts mentioned above are still there, but by necessity implemented in very different ways.","title":"Assorted notes"},{"location":"Customize-channels.html","text":"Channel commands in Evennia \u00b6 By default, Evennia's default channel commands are inspired by MUX. They all begin with \"c\" followed by the action to perform (like \"ccreate\" or \"cdesc\"). If this default seems strange to you compared to other Evennia commands that rely on switches, you might want to check this tutorial out. This tutorial will also give you insight into the workings of the channel system. So it may be useful even if you don't plan to make the exact changes shown here. What we will try to do \u00b6 Our mission: change the default channel commands to have a different syntax. This tutorial will do the following changes: Remove all the default commands to handle channels. Add a + and - command to join and leave a channel. So, assuming there is a public channel on your game (most often the case), you could type +public to join it and -public to leave it. Group the commands to manipulate channels under the channel name, after a switch. For instance, instead of writing cdesc public = My public channel , you would write public/desc My public channel . I listed removing the default Evennia commands as a first step in the process. Actually, we'll move it at the very bottom of the list, since we still want to use them, we might get it wrong and rely on Evennia commands for a while longer. A command to join, another to leave \u00b6 We'll do the most simple task at first: create two commands, one to join a channel, one to leave. Why not have them as switches? public/join and public/leave for instance? For security reasons, I will hide channels to which the caller is not connected. It means that if the caller is not connected to the \"public\" channel, he won't be able to use the \"public\" command. This is somewhat standard: if we create an administrator-only channel, we don't want players to try (or even know) the channel command. Again, you could design it a different way should you want to. First create a file named comms.py in your commands package. It's a rather logical place, since we'll write different commands to handle communication. Okay, let's add the first command to join a channel: # in commands/comms.py from evennia.utils.search import search_channel from commands.command import Command class CmdConnect(Command): \"\"\" Connect to a channel. \"\"\" key = \"+\" help_category = \"Comms\" locks = \"cmd:not pperm(channel_banned)\" auto_help = False def func(self): \"\"\"Implement the command\"\"\" caller = self.caller args = self.args if not args: self.msg(\"Which channel do you want to connect to?\") return channelname = self.args channel = search_channel(channelname) if not channel: return # Check permissions if not channel.access(caller, 'listen'): self.msg(\"%s: You are not allowed to listen to this channel.\" % channel.key) return # If not connected to the channel, try to connect if not channel.has_connection(caller): if not channel.connect(caller): self.msg(\"%s: You are not allowed to join this channel.\" % channel.key) return else: self.msg(\"You now are connected to the %s channel. \" % channel.key.lower()) else: self.msg(\"You already are connected to the %s channel. \" % channel.key.lower()) Okay, let's review this code, but if you're used to Evennia commands, it shouldn't be too strange: We import search_channel . This is a little helper function that we will use to search for channels by name and aliases, found in evennia.utils.search . It's just more convenient. Our class CmdConnect contains the body of our command to join a channel. Notice the key of this command is simply \"+\" . When you enter +something in the game, it will try to find a command key +something . Failing that, it will look at other potential matches. Evennia is smart enough to understand that when we type +something , + is the command key and something is the command argument. This will, of course, fail if you have a command beginning by + conflicting with the CmdConnect key. We have altered some class attributes, like auto_help . If you want to know what they do and why they have changed here, you can check the documentation on commands . In the command body, we begin by extracting the channel name. Remember that this name should be in the command arguments (that is, in self.args ). Following the same example, if a player enters +something , self.args should contain \"something\" . We use search_channel to see if this channel exists. We then check the access level of the channel, to see if the caller can listen to it (not necessarily use it to speak, mind you, just listen to others speak, as these are two different locks on Evennia). Finally, we connect the caller if he's not already connected to the channel. We use the channel's connect method to do this. Pretty straightforward eh? Now we'll add a command to leave a channel. It's almost the same, turned upside down: class CmdDisconnect(Command): \"\"\" Disconnect from a channel. \"\"\" key = \"-\" help_category = \"Comms\" locks = \"cmd:not pperm(channel_banned)\" auto_help = False def func(self): \"\"\"Implement the command\"\"\" caller = self.caller args = self.args if not args: self.msg(\"Which channel do you want to disconnect from?\") return channelname = self.args channel = search_channel(channelname) if not channel: return # If connected to the channel, try to disconnect if channel.has_connection(caller): if not channel.disconnect(caller): self.msg(\"%s: You are not allowed to disconnect from this channel.\" % channel.key) return else: self.msg(\"You stop listening to the %s channel. \" % channel.key.lower()) else: self.msg(\"You are not connected to the %s channel. \" % channel.key.lower()) So far, you shouldn't have trouble following what this command does: it's pretty much the same as the CmdConnect class in logic, though it accomplishes the opposite. If you are connected to the channel public you could disconnect from it using -public . Remember, you can use channel aliases too ( +pub and -pub will also work, assuming you have the alias pub on the public channel). It's time to test this code, and to do so, you will need to add these two commands. Here is a good time to say it: by default, Evennia connects accounts to channels. Some other games (usually with a higher multisession mode) will want to connect characters instead of accounts, so that several characters in the same account can be connected to various channels. You can definitely add these commands either in the AccountCmdSet or CharacterCmdSet , the caller will be different and the command will add or remove accounts of characters. If you decide to install these commands on the CharacterCmdSet , you might have to disconnect your superuser account (account #1) from the channel before joining it with your characters, as Evennia tends to subscribe all accounts automatically if you don't tell it otherwise. So here's an example of how to add these commands into your AccountCmdSet . Edit the file commands/default_cmdsets.py to change a few things: # In commands/default_cmdsets.py from evennia import default_cmds from commands.comms import CmdConnect, CmdDisconnect # ... Skip to the AccountCmdSet class ... class AccountCmdSet(default_cmds.AccountCmdSet): \"\"\" This is the cmdset available to the Account at all times. It is combined with the `CharacterCmdSet` when the Account puppets a Character. It holds game-account-specific commands, channel commands, etc. \"\"\" key = \"DefaultAccount\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # Channel commands self.add(CmdConnect()) self.add(CmdDisconnect()) Save, reload your game, and you should be able to use +public and -public now! A generic channel command with switches \u00b6 It's time to dive a little deeper into channel processing. What happens in Evennia when a player enters public Hello everybody! ? Like exits, channels are a particular command that Evennia automatically creates and attaches to individual channels. So when you enter public message in your game, Evennia calls the public command. But I didn't add any public command... Evennia will just create these commands automatically based on the existing channels. The base command is the command we'll need to edit. Why edit it? It works just fine to talk. Unfortunately, if we want to add switches to our channel names, we'll have to edit this command. It's not too hard, however, we'll just start writing a standard command with minor twitches. Some additional imports \u00b6 You'll need to add a line of import in your commands/comms.py file. We'll see why this import is important when diving in the command itself: from evennia.comms.models import ChannelDB The class layout \u00b6 # In commands/comms.py class ChannelCommand(Command): \"\"\" {channelkey} channel {channeldesc} Usage: {lower_channelkey} <message> {lower_channelkey}/history [start] {lower_channelkey}/me <message> {lower_channelkey}/who Switch: history: View 20 previous messages, either from the end or from <start> number of messages from the end. me: Perform an emote on this channel. who: View who is connected to this channel. Example: {lower_channelkey} Hello World! {lower_channelkey}/history {lower_channelkey}/history 30 {lower_channelkey}/me grins. {lower_channelkey}/who \"\"\" # note that channeldesc and lower_channelkey will be filled # automatically by ChannelHandler # this flag is what identifies this cmd as a channel cmd # and branches off to the system send-to-channel command # (which is customizable by admin) is_channel = True key = \"general\" help_category = \"Channel Names\" obj = None arg_regex = \"\" There are some differences here compared to most common commands. There is something disconcerting in the class docstring. Some information is between curly braces. This is a format-style which is only used for channel commands. {channelkey} will be replaced by the actual channel key (like public). {channeldesc} will be replaced by the channel description (like \"public channel\"). And {lower_channelkey} . We have set is_channel to True in the command class variables. You shouldn't worry too much about that: it just tells Evennia this is a special command just for channels. key is a bit misleading because it will be replaced eventually. So we could set it to virtually anything. The obj class variable is another one we won't detail right now. arg_regex is important: the default arg_regex in the channel command will forbid to use switches (a slash just after the channel name is not allowed). That's why we enforce it here, we allow any syntax. What will become of this command? Well, when we'll be through with it, and once we'll add it as the default command to handle channels, Evennia will create one per existing channel. For instance, the public channel will receive one command of this class, with key set to public and aliases set to the channel aliases (like ['pub'] ). Can I see it work? Not just yet, there's still a lot of code needed. Okay we have the command structure but it's rather empty. The parse method \u00b6 The parse method is called before func in every command. Its job is to parse arguments and in our case, we will analyze switches here. # ... def parse(self): \"\"\" Simple parser \"\"\" # channel-handler sends channame:msg here. channelname, msg = self.args.split(\":\", 1) self.switch = None if msg.startswith(\"/\"): try: switch, msg = msg[1:].split(\" \", 1) except ValueError: switch = msg[1:] msg = \"\" self.switch = switch.lower().strip() self.args = (channelname.strip(), msg.strip()) Reading the comments we see that the channel handler will send the command in a strange way: a string with the channel name, a colon and the actual message entered by the player. So if the player enters \"public hello\", the command args will contain \"public:hello\" . You can look at the way the channel name and message are parsed, this can be used in a lot of different commands. Next we check if there's any switch, that is, if the message starts with a slash. This would be the case if a player entered public/me jumps up and down , for instance. If there is a switch, we save it in self.switch . We alter self.args at the end to contain a tuple with two values: the channel name, and the message (if a switch was used, notice that the switch will be stored in self.switch , not in the second element of self.args ). The command func \u00b6 Finally, let's see the func method in the command class. It will have to handle switches and also the raw message to send if no switch was used. # ... def func(self): \"\"\" Create a new message and send it to channel, using the already formatted input. \"\"\" channelkey, msg = self.args caller = self.caller channel = ChannelDB.objects.get_channel(channelkey) # Check that the channel exists if not channel: self.msg(_(\"Channel '%s' not found.\") % channelkey) return # Check that the caller is connected if not channel.has_connection(caller): string = \"You are not connected to channel '%s'.\" self.msg(string % channelkey) return # Check that the caller has send access if not channel.access(caller, 'send'): string = \"You are not permitted to send to channel '%s'.\" self.msg(string % channelkey) return # Handle the various switches if self.switch == \"me\": if not msg: self.msg(\"What do you want to do on this channel?\") else: msg = \"{} {}\".format(caller.key, msg) channel.msg(msg, online=True) elif self.switch: self.msg(\"{}: Invalid switch {}.\".format(channel.key, self.switch)) elif not msg: self.msg(\"Say what?\") else: if caller in channel.mutelist: self.msg(\"You currently have %s muted.\" % channel) return channel.msg(msg, senders=self.caller, online=True) First of all, we try to get the channel object from the channel name we have in the self.args tuple. We use ChannelDB.objects.get_channel this time because we know the channel name isn't an alias (that was part of the deal, channelname in the parse method contains a command key). We check that the channel does exist. We then check that the caller is connected to the channel. Remember, if the caller isn't connected, we shouldn't allow him to use this command (that includes the switches on channels). We then check that the caller has access to the channel's send lock. This time, we make sure the caller can send messages to the channel, no matter what operation he's trying to perform. Finally we handle switches. We try only one switch: me . This switch would be used if a player entered public/me jumps up and down (to do a channel emote). We handle the case where the switch is unknown and where there's no switch (the player simply wants to talk on this channel). The good news: The code is not too complicated by itself. The bad news is that this is just an abridged version of the code. If you want to handle all the switches mentioned in the command help, you will have more code to write. This is left as an exercise. End of class \u00b6 It's almost done, but we need to add a method in this command class that isn't often used. I won't detail it's usage too much, just know that Evennia will use it and will get angry if you don't add it. So at the end of your class, just add: # ... def get_extra_info(self, caller, **kwargs): \"\"\" Let users know that this command is for communicating on a channel. Args: caller (TypedObject): A Character or Account who has entered an ambiguous command. Returns: A string with identifying information to disambiguate the object, conventionally with a preceding space. \"\"\" return \" (channel)\" Adding this channel command \u00b6 Contrary to most Evennia commands, we won't add our ChannelCommand to a CmdSet . Instead we need to tell Evennia that it should use the command we just created instead of its default channel-command. In your server/conf/settings.py file, add a new setting: # Channel options CHANNEL_COMMAND_CLASS = \"commands.comms.ChannelCommand\" Then you can reload your game. Try to type public hello and public/me jumps up and down . Don't forget to enter help public to see if your command has truly been added. Conclusion and full code \u00b6 That was some adventure! And there's still things to do! But hopefully, this tutorial will have helped you in designing your own channel system. Here are a few things to do: Add more switches to handle various actions, like changing the description of a channel for instance, or listing the connected participants. Remove the default Evennia commands to handle channels. Alter the behavior of the channel system so it better aligns with what you want to do. As a special bonus, you can find a full, working example of a communication system similar to the one I've shown you: this is a working example, it integrates all switches and does ever some extra checking, but it's also very close from the code I've provided here. Notice, however, that this resource is external to Evennia and not maintained by anyone but the original author of this article. Read the full example on Github","title":"Customize channels"},{"location":"Customize-channels.html#channel-commands-in-evennia","text":"By default, Evennia's default channel commands are inspired by MUX. They all begin with \"c\" followed by the action to perform (like \"ccreate\" or \"cdesc\"). If this default seems strange to you compared to other Evennia commands that rely on switches, you might want to check this tutorial out. This tutorial will also give you insight into the workings of the channel system. So it may be useful even if you don't plan to make the exact changes shown here.","title":"Channel commands in Evennia"},{"location":"Customize-channels.html#what-we-will-try-to-do","text":"Our mission: change the default channel commands to have a different syntax. This tutorial will do the following changes: Remove all the default commands to handle channels. Add a + and - command to join and leave a channel. So, assuming there is a public channel on your game (most often the case), you could type +public to join it and -public to leave it. Group the commands to manipulate channels under the channel name, after a switch. For instance, instead of writing cdesc public = My public channel , you would write public/desc My public channel . I listed removing the default Evennia commands as a first step in the process. Actually, we'll move it at the very bottom of the list, since we still want to use them, we might get it wrong and rely on Evennia commands for a while longer.","title":"What we will try to do"},{"location":"Customize-channels.html#a-command-to-join-another-to-leave","text":"We'll do the most simple task at first: create two commands, one to join a channel, one to leave. Why not have them as switches? public/join and public/leave for instance? For security reasons, I will hide channels to which the caller is not connected. It means that if the caller is not connected to the \"public\" channel, he won't be able to use the \"public\" command. This is somewhat standard: if we create an administrator-only channel, we don't want players to try (or even know) the channel command. Again, you could design it a different way should you want to. First create a file named comms.py in your commands package. It's a rather logical place, since we'll write different commands to handle communication. Okay, let's add the first command to join a channel: # in commands/comms.py from evennia.utils.search import search_channel from commands.command import Command class CmdConnect(Command): \"\"\" Connect to a channel. \"\"\" key = \"+\" help_category = \"Comms\" locks = \"cmd:not pperm(channel_banned)\" auto_help = False def func(self): \"\"\"Implement the command\"\"\" caller = self.caller args = self.args if not args: self.msg(\"Which channel do you want to connect to?\") return channelname = self.args channel = search_channel(channelname) if not channel: return # Check permissions if not channel.access(caller, 'listen'): self.msg(\"%s: You are not allowed to listen to this channel.\" % channel.key) return # If not connected to the channel, try to connect if not channel.has_connection(caller): if not channel.connect(caller): self.msg(\"%s: You are not allowed to join this channel.\" % channel.key) return else: self.msg(\"You now are connected to the %s channel. \" % channel.key.lower()) else: self.msg(\"You already are connected to the %s channel. \" % channel.key.lower()) Okay, let's review this code, but if you're used to Evennia commands, it shouldn't be too strange: We import search_channel . This is a little helper function that we will use to search for channels by name and aliases, found in evennia.utils.search . It's just more convenient. Our class CmdConnect contains the body of our command to join a channel. Notice the key of this command is simply \"+\" . When you enter +something in the game, it will try to find a command key +something . Failing that, it will look at other potential matches. Evennia is smart enough to understand that when we type +something , + is the command key and something is the command argument. This will, of course, fail if you have a command beginning by + conflicting with the CmdConnect key. We have altered some class attributes, like auto_help . If you want to know what they do and why they have changed here, you can check the documentation on commands . In the command body, we begin by extracting the channel name. Remember that this name should be in the command arguments (that is, in self.args ). Following the same example, if a player enters +something , self.args should contain \"something\" . We use search_channel to see if this channel exists. We then check the access level of the channel, to see if the caller can listen to it (not necessarily use it to speak, mind you, just listen to others speak, as these are two different locks on Evennia). Finally, we connect the caller if he's not already connected to the channel. We use the channel's connect method to do this. Pretty straightforward eh? Now we'll add a command to leave a channel. It's almost the same, turned upside down: class CmdDisconnect(Command): \"\"\" Disconnect from a channel. \"\"\" key = \"-\" help_category = \"Comms\" locks = \"cmd:not pperm(channel_banned)\" auto_help = False def func(self): \"\"\"Implement the command\"\"\" caller = self.caller args = self.args if not args: self.msg(\"Which channel do you want to disconnect from?\") return channelname = self.args channel = search_channel(channelname) if not channel: return # If connected to the channel, try to disconnect if channel.has_connection(caller): if not channel.disconnect(caller): self.msg(\"%s: You are not allowed to disconnect from this channel.\" % channel.key) return else: self.msg(\"You stop listening to the %s channel. \" % channel.key.lower()) else: self.msg(\"You are not connected to the %s channel. \" % channel.key.lower()) So far, you shouldn't have trouble following what this command does: it's pretty much the same as the CmdConnect class in logic, though it accomplishes the opposite. If you are connected to the channel public you could disconnect from it using -public . Remember, you can use channel aliases too ( +pub and -pub will also work, assuming you have the alias pub on the public channel). It's time to test this code, and to do so, you will need to add these two commands. Here is a good time to say it: by default, Evennia connects accounts to channels. Some other games (usually with a higher multisession mode) will want to connect characters instead of accounts, so that several characters in the same account can be connected to various channels. You can definitely add these commands either in the AccountCmdSet or CharacterCmdSet , the caller will be different and the command will add or remove accounts of characters. If you decide to install these commands on the CharacterCmdSet , you might have to disconnect your superuser account (account #1) from the channel before joining it with your characters, as Evennia tends to subscribe all accounts automatically if you don't tell it otherwise. So here's an example of how to add these commands into your AccountCmdSet . Edit the file commands/default_cmdsets.py to change a few things: # In commands/default_cmdsets.py from evennia import default_cmds from commands.comms import CmdConnect, CmdDisconnect # ... Skip to the AccountCmdSet class ... class AccountCmdSet(default_cmds.AccountCmdSet): \"\"\" This is the cmdset available to the Account at all times. It is combined with the `CharacterCmdSet` when the Account puppets a Character. It holds game-account-specific commands, channel commands, etc. \"\"\" key = \"DefaultAccount\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # Channel commands self.add(CmdConnect()) self.add(CmdDisconnect()) Save, reload your game, and you should be able to use +public and -public now!","title":"A command to join, another to leave"},{"location":"Customize-channels.html#a-generic-channel-command-with-switches","text":"It's time to dive a little deeper into channel processing. What happens in Evennia when a player enters public Hello everybody! ? Like exits, channels are a particular command that Evennia automatically creates and attaches to individual channels. So when you enter public message in your game, Evennia calls the public command. But I didn't add any public command... Evennia will just create these commands automatically based on the existing channels. The base command is the command we'll need to edit. Why edit it? It works just fine to talk. Unfortunately, if we want to add switches to our channel names, we'll have to edit this command. It's not too hard, however, we'll just start writing a standard command with minor twitches.","title":"A generic channel command with switches"},{"location":"Customize-channels.html#some-additional-imports","text":"You'll need to add a line of import in your commands/comms.py file. We'll see why this import is important when diving in the command itself: from evennia.comms.models import ChannelDB","title":"Some additional imports"},{"location":"Customize-channels.html#the-class-layout","text":"# In commands/comms.py class ChannelCommand(Command): \"\"\" {channelkey} channel {channeldesc} Usage: {lower_channelkey} <message> {lower_channelkey}/history [start] {lower_channelkey}/me <message> {lower_channelkey}/who Switch: history: View 20 previous messages, either from the end or from <start> number of messages from the end. me: Perform an emote on this channel. who: View who is connected to this channel. Example: {lower_channelkey} Hello World! {lower_channelkey}/history {lower_channelkey}/history 30 {lower_channelkey}/me grins. {lower_channelkey}/who \"\"\" # note that channeldesc and lower_channelkey will be filled # automatically by ChannelHandler # this flag is what identifies this cmd as a channel cmd # and branches off to the system send-to-channel command # (which is customizable by admin) is_channel = True key = \"general\" help_category = \"Channel Names\" obj = None arg_regex = \"\" There are some differences here compared to most common commands. There is something disconcerting in the class docstring. Some information is between curly braces. This is a format-style which is only used for channel commands. {channelkey} will be replaced by the actual channel key (like public). {channeldesc} will be replaced by the channel description (like \"public channel\"). And {lower_channelkey} . We have set is_channel to True in the command class variables. You shouldn't worry too much about that: it just tells Evennia this is a special command just for channels. key is a bit misleading because it will be replaced eventually. So we could set it to virtually anything. The obj class variable is another one we won't detail right now. arg_regex is important: the default arg_regex in the channel command will forbid to use switches (a slash just after the channel name is not allowed). That's why we enforce it here, we allow any syntax. What will become of this command? Well, when we'll be through with it, and once we'll add it as the default command to handle channels, Evennia will create one per existing channel. For instance, the public channel will receive one command of this class, with key set to public and aliases set to the channel aliases (like ['pub'] ). Can I see it work? Not just yet, there's still a lot of code needed. Okay we have the command structure but it's rather empty.","title":"The class layout"},{"location":"Customize-channels.html#the-parse-method","text":"The parse method is called before func in every command. Its job is to parse arguments and in our case, we will analyze switches here. # ... def parse(self): \"\"\" Simple parser \"\"\" # channel-handler sends channame:msg here. channelname, msg = self.args.split(\":\", 1) self.switch = None if msg.startswith(\"/\"): try: switch, msg = msg[1:].split(\" \", 1) except ValueError: switch = msg[1:] msg = \"\" self.switch = switch.lower().strip() self.args = (channelname.strip(), msg.strip()) Reading the comments we see that the channel handler will send the command in a strange way: a string with the channel name, a colon and the actual message entered by the player. So if the player enters \"public hello\", the command args will contain \"public:hello\" . You can look at the way the channel name and message are parsed, this can be used in a lot of different commands. Next we check if there's any switch, that is, if the message starts with a slash. This would be the case if a player entered public/me jumps up and down , for instance. If there is a switch, we save it in self.switch . We alter self.args at the end to contain a tuple with two values: the channel name, and the message (if a switch was used, notice that the switch will be stored in self.switch , not in the second element of self.args ).","title":"The parse method"},{"location":"Customize-channels.html#the-command-func","text":"Finally, let's see the func method in the command class. It will have to handle switches and also the raw message to send if no switch was used. # ... def func(self): \"\"\" Create a new message and send it to channel, using the already formatted input. \"\"\" channelkey, msg = self.args caller = self.caller channel = ChannelDB.objects.get_channel(channelkey) # Check that the channel exists if not channel: self.msg(_(\"Channel '%s' not found.\") % channelkey) return # Check that the caller is connected if not channel.has_connection(caller): string = \"You are not connected to channel '%s'.\" self.msg(string % channelkey) return # Check that the caller has send access if not channel.access(caller, 'send'): string = \"You are not permitted to send to channel '%s'.\" self.msg(string % channelkey) return # Handle the various switches if self.switch == \"me\": if not msg: self.msg(\"What do you want to do on this channel?\") else: msg = \"{} {}\".format(caller.key, msg) channel.msg(msg, online=True) elif self.switch: self.msg(\"{}: Invalid switch {}.\".format(channel.key, self.switch)) elif not msg: self.msg(\"Say what?\") else: if caller in channel.mutelist: self.msg(\"You currently have %s muted.\" % channel) return channel.msg(msg, senders=self.caller, online=True) First of all, we try to get the channel object from the channel name we have in the self.args tuple. We use ChannelDB.objects.get_channel this time because we know the channel name isn't an alias (that was part of the deal, channelname in the parse method contains a command key). We check that the channel does exist. We then check that the caller is connected to the channel. Remember, if the caller isn't connected, we shouldn't allow him to use this command (that includes the switches on channels). We then check that the caller has access to the channel's send lock. This time, we make sure the caller can send messages to the channel, no matter what operation he's trying to perform. Finally we handle switches. We try only one switch: me . This switch would be used if a player entered public/me jumps up and down (to do a channel emote). We handle the case where the switch is unknown and where there's no switch (the player simply wants to talk on this channel). The good news: The code is not too complicated by itself. The bad news is that this is just an abridged version of the code. If you want to handle all the switches mentioned in the command help, you will have more code to write. This is left as an exercise.","title":"The command func"},{"location":"Customize-channels.html#end-of-class","text":"It's almost done, but we need to add a method in this command class that isn't often used. I won't detail it's usage too much, just know that Evennia will use it and will get angry if you don't add it. So at the end of your class, just add: # ... def get_extra_info(self, caller, **kwargs): \"\"\" Let users know that this command is for communicating on a channel. Args: caller (TypedObject): A Character or Account who has entered an ambiguous command. Returns: A string with identifying information to disambiguate the object, conventionally with a preceding space. \"\"\" return \" (channel)\"","title":"End of class"},{"location":"Customize-channels.html#adding-this-channel-command","text":"Contrary to most Evennia commands, we won't add our ChannelCommand to a CmdSet . Instead we need to tell Evennia that it should use the command we just created instead of its default channel-command. In your server/conf/settings.py file, add a new setting: # Channel options CHANNEL_COMMAND_CLASS = \"commands.comms.ChannelCommand\" Then you can reload your game. Try to type public hello and public/me jumps up and down . Don't forget to enter help public to see if your command has truly been added.","title":"Adding this channel command"},{"location":"Customize-channels.html#conclusion-and-full-code","text":"That was some adventure! And there's still things to do! But hopefully, this tutorial will have helped you in designing your own channel system. Here are a few things to do: Add more switches to handle various actions, like changing the description of a channel for instance, or listing the connected participants. Remove the default Evennia commands to handle channels. Alter the behavior of the channel system so it better aligns with what you want to do. As a special bonus, you can find a full, working example of a communication system similar to the one I've shown you: this is a working example, it integrates all switches and does ever some extra checking, but it's also very close from the code I've provided here. Notice, however, that this resource is external to Evennia and not maintained by anyone but the original author of this article. Read the full example on Github","title":"Conclusion and full code"},{"location":"Debugging.html","text":"Sometimes, an error is not trivial to resolve. A few simple print statements is not enough to find the cause of the issue. Running a debugger can then be very helpful and save a lot of time. Debugging means running Evennia under control of a special debugger program. This allows you to stop the action at a given point, view the current state and step forward through the program to see how its logic works. Evennia natively supports these debuggers: Pdb is a part of the Python distribution and available out-of-the-box. PuDB is a third-party debugger that has a slightly more 'graphical', curses-based user interface than pdb. It is installed with pip install pudb . Debugging Evennia \u00b6 To run Evennia with the debugger, follow these steps: Find the point in the code where you want to have more insight. Add the following line at that point. python from evennia import set_trace;set_trace() (Re-)start Evennia in interactive (foreground) mode with evennia istart . This is important - without this step the debugger will not start correctly - it will start in this interactive terminal. Perform the steps that will trigger the line where you added the set_trace() call. The debugger will start in the terminal from which Evennia was interactively started. The evennia.set_trace function takes the following arguments: evennia.set_trace(debugger='auto', term_size=(140, 40)) Here, debugger is one of pdb , pudb or auto . If auto , use pudb if available, otherwise use pdb . The term_size tuple sets the viewport size for pudb only (it's ignored by pdb ). A simple example using pdb \u00b6 The debugger is useful in different cases, but to begin with, let's see it working in a command. Add the following test command (which has a range of deliberate errors) and also add it to your default cmdset. Then restart Evennia in interactive mode with evennia istart . # In file commands/command.py class CmdTest(Command): \"\"\" A test command just to test pdb. Usage: test \"\"\" key = \"test\" def func(self): from evennia import set_trace; set_trace() # <--- start of debugger obj = self.search(self.args) self.msg(\"You've found {}.\".format(obj.get_display_name())) If you type test in your game, everything will freeze. You won't get any feedback from the game, and you won't be able to enter any command (nor anyone else). It's because the debugger has started in your console, and you will find it here. Below is an example with pdb . ... > .../mygame/commands/command.py(79)func() -> obj = self.search(self.args) (Pdb) pdb notes where it has stopped execution and, what line is about to be executed (in our case, obj = self.search(self.args) ), and ask what you would like to do. Listing surrounding lines of code \u00b6 When you have the pdb prompt (Pdb) , you can type in different commands to explore the code. The first one you should know is list (you can type l for short): (Pdb) l 43 44 key = \"test\" 45 46 def func(self): 47 from evennia import set_trace; set_trace() # <--- start of debugger 48 -> obj = self.search(self.args) 49 self.msg(\"You've found {}.\".format(obj.get_display_name())) 50 51 # ------------------------------------------------------------- 52 # 53 # The default commands inherit from (Pdb) Okay, this didn't do anything spectacular, but when you become more confident with pdb and find yourself in lots of different files, you sometimes need to see what's around in code. Notice that there is a little arrow ( -> ) before the line that is about to be executed. This is important: about to be , not has just been . You need to tell pdb to go on (we'll soon see how). Examining variables \u00b6 pdb allows you to examine variables (or really, to run any Python instruction). It is very useful to know the values of variables at a specific line. To see a variable, just type its name (as if you were in the Python interpreter: (Pdb) self <commands.command.CmdTest object at 0x045A0990> (Pdb) self.args u'' (Pdb) self.caller <Character: XXX> (Pdb) If you try to see the variable obj , you'll get an error: (Pdb) obj *** NameError: name 'obj' is not defined (Pdb) That figures, since at this point, we haven't created the variable yet. Examining variable in this way is quite powerful. You can even run Python code and keep on executing, which can help to check that your fix is actually working when you have identified an error. If you have variable names that will conflict with pdb commands (like a list variable), you can prefix your variable with ! , to tell pdb that what follows is Python code. Executing the current line \u00b6 It's time we asked pdb to execute the current line. To do so, use the next command. You can shorten it by just typing n : (Pdb) n AttributeError: \"'CmdTest' object has no attribute 'search'\" > .../mygame/commands/command.py(79)func() -> obj = self.search(self.args) (Pdb) Pdb is complaining that you try to call the search method on a command... whereas there's no search method on commands. The character executing the command is in self.caller , so we might change our line: obj = self.caller.search(self.args) Letting the program run \u00b6 pdb is waiting to execute the same instruction... it provoked an error but it's ready to try again, just in case. We have fixed it in theory, but we need to reload, so we need to enter a command. To tell pdb to terminate and keep on running the program, use the continue (or c ) command: (Pdb) c ... You see an error being caught, that's the error we have fixed... or hope to have. Let's reload the game and try again. You need to run evennia istart again and then run test to get into the command again. > .../mygame/commands/command.py(79)func() -> obj = self.caller.search(self.args) (Pdb) pdb is about to run the line again. (Pdb) n > .../mygame/commands/command.py(80)func() -> self.msg(\"You've found {}.\".format(obj.get_display_name())) (Pdb) This time the line ran without error. Let's see what is in the obj variable: (Pdb) obj (Pdb) print obj None (Pdb) We have entered the test command without parameter, so no object could be found in the search ( self.args is an empty string). Let's allow the command to continue and try to use an object name as parameter (although, we should fix that bug too, it would be better): (Pdb) c ... Notice that you'll have an error in the game this time. Let's try with a valid parameter. I have another character, barkeep , in this room: test barkeep And again, the command freezes, and we have the debugger opened in the console. Let's execute this line right away: > .../mygame/commands/command.py(79)func() -> obj = self.caller.search(self.args) (Pdb) n > .../mygame/commands/command.py(80)func() -> self.msg(\"You've found {}.\".format(obj.get_display_name())) (Pdb) obj <Character: barkeep> (Pdb) At least this time we have found the object. Let's process... (Pdb) n TypeError: 'get_display_name() takes exactly 2 arguments (1 given)' > .../mygame/commands/command.py(80)func() -> self.msg(\"You've found {}.\".format(obj.get_display_name())) (Pdb) As an exercise, fix this error, reload and run the debugger again. Nothing better than some experimenting! Your debugging will often follow the same strategy: Receive an error you don't understand. Put a breaking point BEFORE the error occurs. Run the code again and see the debugger open. Run the program line by line,examining variables, checking the logic of instructions. Continue and try again, each step a bit further toward the truth and the working feature. Stepping through a function \u00b6 n is useful, but it will avoid stepping inside of functions if it can. But most of the time, when we have an error we don't understand, it's because we use functions or methods in a way that wasn't intended by the developer of the API. Perhaps using wrong arguments, or calling the function in a situation that would cause a bug. When we have a line in the debugger that calls a function or method, we can \"step\" to examine it further. For instance, in the previous example, when pdb was about to execute obj = self.caller.search(self.args) , we may want to see what happens inside of the search method. To do so, use the step (or s ) command. This command will show you the definition of the function/method and you can then use n as before to see it line-by-line. In our little example, stepping through a function or method isn't that useful, but when you have an impressive set of commands, functions and so on, it might really be handy to examine some feature and make sure they operate as planned. Cheat-sheet of pdb/pudb commands \u00b6 PuDB and Pdb share the same commands. The only real difference is how it's presented. The look command is not needed much in pudb since it displays the code directly in its user interface. Pdb/PuDB command To do what list (or l) List the lines around the point of execution (not needed for pudb , it will show this directly). print (or p) Display one or several variables. ! Run Python code (using a ! is often optional). continue (or c) Continue execution and terminate the debugger for this time. next (or n) Execute the current line and goes to the next one. step (or s) Step inside of a function or method to examine it. <RETURN> Repeat the last command (don't type n repeatedly, just type it once and then press <RETURN> to repeat it). If you want to learn more about debugging with Pdb, you will find an interesting tutorial on that topic here .","title":"Debugging"},{"location":"Debugging.html#debugging-evennia","text":"To run Evennia with the debugger, follow these steps: Find the point in the code where you want to have more insight. Add the following line at that point. python from evennia import set_trace;set_trace() (Re-)start Evennia in interactive (foreground) mode with evennia istart . This is important - without this step the debugger will not start correctly - it will start in this interactive terminal. Perform the steps that will trigger the line where you added the set_trace() call. The debugger will start in the terminal from which Evennia was interactively started. The evennia.set_trace function takes the following arguments: evennia.set_trace(debugger='auto', term_size=(140, 40)) Here, debugger is one of pdb , pudb or auto . If auto , use pudb if available, otherwise use pdb . The term_size tuple sets the viewport size for pudb only (it's ignored by pdb ).","title":"Debugging Evennia"},{"location":"Debugging.html#a-simple-example-using-pdb","text":"The debugger is useful in different cases, but to begin with, let's see it working in a command. Add the following test command (which has a range of deliberate errors) and also add it to your default cmdset. Then restart Evennia in interactive mode with evennia istart . # In file commands/command.py class CmdTest(Command): \"\"\" A test command just to test pdb. Usage: test \"\"\" key = \"test\" def func(self): from evennia import set_trace; set_trace() # <--- start of debugger obj = self.search(self.args) self.msg(\"You've found {}.\".format(obj.get_display_name())) If you type test in your game, everything will freeze. You won't get any feedback from the game, and you won't be able to enter any command (nor anyone else). It's because the debugger has started in your console, and you will find it here. Below is an example with pdb . ... > .../mygame/commands/command.py(79)func() -> obj = self.search(self.args) (Pdb) pdb notes where it has stopped execution and, what line is about to be executed (in our case, obj = self.search(self.args) ), and ask what you would like to do.","title":"A simple example using pdb"},{"location":"Debugging.html#listing-surrounding-lines-of-code","text":"When you have the pdb prompt (Pdb) , you can type in different commands to explore the code. The first one you should know is list (you can type l for short): (Pdb) l 43 44 key = \"test\" 45 46 def func(self): 47 from evennia import set_trace; set_trace() # <--- start of debugger 48 -> obj = self.search(self.args) 49 self.msg(\"You've found {}.\".format(obj.get_display_name())) 50 51 # ------------------------------------------------------------- 52 # 53 # The default commands inherit from (Pdb) Okay, this didn't do anything spectacular, but when you become more confident with pdb and find yourself in lots of different files, you sometimes need to see what's around in code. Notice that there is a little arrow ( -> ) before the line that is about to be executed. This is important: about to be , not has just been . You need to tell pdb to go on (we'll soon see how).","title":"Listing surrounding lines of code"},{"location":"Debugging.html#examining-variables","text":"pdb allows you to examine variables (or really, to run any Python instruction). It is very useful to know the values of variables at a specific line. To see a variable, just type its name (as if you were in the Python interpreter: (Pdb) self <commands.command.CmdTest object at 0x045A0990> (Pdb) self.args u'' (Pdb) self.caller <Character: XXX> (Pdb) If you try to see the variable obj , you'll get an error: (Pdb) obj *** NameError: name 'obj' is not defined (Pdb) That figures, since at this point, we haven't created the variable yet. Examining variable in this way is quite powerful. You can even run Python code and keep on executing, which can help to check that your fix is actually working when you have identified an error. If you have variable names that will conflict with pdb commands (like a list variable), you can prefix your variable with ! , to tell pdb that what follows is Python code.","title":"Examining variables"},{"location":"Debugging.html#executing-the-current-line","text":"It's time we asked pdb to execute the current line. To do so, use the next command. You can shorten it by just typing n : (Pdb) n AttributeError: \"'CmdTest' object has no attribute 'search'\" > .../mygame/commands/command.py(79)func() -> obj = self.search(self.args) (Pdb) Pdb is complaining that you try to call the search method on a command... whereas there's no search method on commands. The character executing the command is in self.caller , so we might change our line: obj = self.caller.search(self.args)","title":"Executing the current line"},{"location":"Debugging.html#letting-the-program-run","text":"pdb is waiting to execute the same instruction... it provoked an error but it's ready to try again, just in case. We have fixed it in theory, but we need to reload, so we need to enter a command. To tell pdb to terminate and keep on running the program, use the continue (or c ) command: (Pdb) c ... You see an error being caught, that's the error we have fixed... or hope to have. Let's reload the game and try again. You need to run evennia istart again and then run test to get into the command again. > .../mygame/commands/command.py(79)func() -> obj = self.caller.search(self.args) (Pdb) pdb is about to run the line again. (Pdb) n > .../mygame/commands/command.py(80)func() -> self.msg(\"You've found {}.\".format(obj.get_display_name())) (Pdb) This time the line ran without error. Let's see what is in the obj variable: (Pdb) obj (Pdb) print obj None (Pdb) We have entered the test command without parameter, so no object could be found in the search ( self.args is an empty string). Let's allow the command to continue and try to use an object name as parameter (although, we should fix that bug too, it would be better): (Pdb) c ... Notice that you'll have an error in the game this time. Let's try with a valid parameter. I have another character, barkeep , in this room: test barkeep And again, the command freezes, and we have the debugger opened in the console. Let's execute this line right away: > .../mygame/commands/command.py(79)func() -> obj = self.caller.search(self.args) (Pdb) n > .../mygame/commands/command.py(80)func() -> self.msg(\"You've found {}.\".format(obj.get_display_name())) (Pdb) obj <Character: barkeep> (Pdb) At least this time we have found the object. Let's process... (Pdb) n TypeError: 'get_display_name() takes exactly 2 arguments (1 given)' > .../mygame/commands/command.py(80)func() -> self.msg(\"You've found {}.\".format(obj.get_display_name())) (Pdb) As an exercise, fix this error, reload and run the debugger again. Nothing better than some experimenting! Your debugging will often follow the same strategy: Receive an error you don't understand. Put a breaking point BEFORE the error occurs. Run the code again and see the debugger open. Run the program line by line,examining variables, checking the logic of instructions. Continue and try again, each step a bit further toward the truth and the working feature.","title":"Letting the program run"},{"location":"Debugging.html#stepping-through-a-function","text":"n is useful, but it will avoid stepping inside of functions if it can. But most of the time, when we have an error we don't understand, it's because we use functions or methods in a way that wasn't intended by the developer of the API. Perhaps using wrong arguments, or calling the function in a situation that would cause a bug. When we have a line in the debugger that calls a function or method, we can \"step\" to examine it further. For instance, in the previous example, when pdb was about to execute obj = self.caller.search(self.args) , we may want to see what happens inside of the search method. To do so, use the step (or s ) command. This command will show you the definition of the function/method and you can then use n as before to see it line-by-line. In our little example, stepping through a function or method isn't that useful, but when you have an impressive set of commands, functions and so on, it might really be handy to examine some feature and make sure they operate as planned.","title":"Stepping through a function"},{"location":"Debugging.html#cheat-sheet-of-pdbpudb-commands","text":"PuDB and Pdb share the same commands. The only real difference is how it's presented. The look command is not needed much in pudb since it displays the code directly in its user interface. Pdb/PuDB command To do what list (or l) List the lines around the point of execution (not needed for pudb , it will show this directly). print (or p) Display one or several variables. ! Run Python code (using a ! is often optional). continue (or c) Continue execution and terminate the debugger for this time. next (or n) Execute the current line and goes to the next one. step (or s) Step inside of a function or method to examine it. <RETURN> Repeat the last command (don't type n repeatedly, just type it once and then press <RETURN> to repeat it). If you want to learn more about debugging with Pdb, you will find an interesting tutorial on that topic here .","title":"Cheat-sheet of pdb/pudb commands"},{"location":"Default-Command-Help.html","text":"This page is auto-generated. Do not modify - your changes will be lost. Report problems to the issue tracker . The full set of default Evennia commands currently contains 92 commands in 9 source files. Our policy for adding default commands is outlined here . More information about how commands work can be found in the documentation for Commands . A-Z \u00b6 __unloggedin_look_command - look when in unlogged-in state about - show Evennia info access - show your current game access addcom - add a channel alias and/or subscribe to a channel alias - adding permanent aliases for object allcom - perform admin operations on all channels ban - ban an account from the server batchcode - build from batch-code file batchcommands - build from batch-command file boot - kick an account from the server. cboot - kick an account from a channel you control ccreate - create a new channel cdesc - describe a channel you control cdestroy - destroy a channel you created cemit - send an admin message to a channel you control channels - list all channels available to you charcreate - create a new character chardelete - delete a character - this cannot be undone! clock - change channel locks of a channel you control cmdsets - list command sets defined on an object color - testing which colors your client support command - This is a parent class for some of the defining objmanip commands connect - connect to the game copy - copy an object and its properties cpattr - copy attributes between objects create - create a new account account create - create new objects cwho - show who is listening to a channel delcom - remove a channel alias and/or unsubscribe from channel desc - describe an object or the current room. destroy - permanently delete objects dig - build new rooms and connect them to the current location drop - drop something emit - admin command for emitting message to multiple objects examine - get detailed information about an object find - search the database for objects force - forces an object to execute a command get - pick up something give - give away something to someone help - View help or a list of topics help - get help when in unconnected-in state home - move to your character's home location ic - control an object you have permission to puppet inventory - view inventory irc2chan - Link an evennia channel to an external IRC channel link - link existing rooms together with exits lock - assign a lock definition to an object look - look while out-of-character look - look at location or object mvattr - move attributes between objects name - change the name and/or aliases of an object nick - define a personal alias/nick by defining a string to objects - statistics on objects in the database ooc - stop puppeting and go ooc open - open a new exit from the current room option - Set an account option page - send a private message to another account password - change your password perm - set the permissions of an account/object pose - strike a pose py - execute a snippet of python code quell - use character's permissions instead of account's quit - quit the game quit - quit when in unlogged-in state reload - reload the server reset - reset and reboot the server rss2chan - link an evennia channel to an external RSS feed say - speak as your character script - attach a script to an object scripts - list and manage all running scripts server - show server load and memory statistics service - manage system services sessions - check your connected session(s) set - set attribute on an object or account setdesc - describe yourself sethelp - Edit the help database. sethome - set an object's home location shutdown - stop the server completely spawn - spawn objects from prototype style - In-game style options tag - handles the tags of an object tel - teleport object to another location time - show server time statistics tunnel - create new rooms in cardinal directions only typeclass - set or change an object's typeclass unban - remove a ban from an account unlink - remove exit-connections between rooms userpassword - change the password of an account wall - make an announcement to all whisper - Speak privately as your character to another who - list who is currently online wipe - clear all attributes from an object A-Z by source file \u00b6 account.py admin.py batchprocess.py building.py comms.py general.py help.py system.py unloggedin.py Command details \u00b6 These are generated from the auto-documentation and are ordered by their source file location in evennia/commands/default/ account.py \u00b6 View account.py source charcreate (CmdCharCreate) \u00b6 create a new character Usage: charcreate <charname> [= desc] Create a new character, optionally giving it a description. You may use upper-case letters in the name - you will nevertheless always be able to access your character using lower-case letters if you want. key: charcreate aliases: locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdCharCreate in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . chardelete (CmdCharDelete) \u00b6 delete a character - this cannot be undone! Usage: chardelete <charname> Permanently deletes one of your characters. key: chardelete aliases: locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdCharDelete in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . color (CmdColorTest) \u00b6 testing which colors your client support Usage: color ansi||xterm256 Prints a color map along with in-mud color codes to use to produce them. It also tests what is supported in your client. Choices are 16-color ansi (supported in most muds) or the 256-color xterm256 standard. No checking is done to determine your client supports color - if not you will see rubbish appear. key: color aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdColorTest in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . ic (CmdIC) \u00b6 control an object you have permission to puppet Usage: ic <character> Go in-character (IC) as a given Character. This will attempt to \"become\" a different object assuming you have the right to do so. Note that it's the ACCOUNT character that puppets characters/objects and which needs to have the correct permission! You cannot become an object that is already controlled by another account. In principle <character> can be any in-game object as long as you the account have access right to puppet it. key: ic aliases: puppet locks : \"cmd:all()\" help_category : \"General\" Source: class CmdIC in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . look (CmdOOCLook) \u00b6 look while out-of-character Usage: look Look in the ooc state. key: look aliases: ls , l locks : \"cmd:all()\" help_category : \"General\" Source: class CmdOOCLook in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . ooc (CmdOOC) \u00b6 stop puppeting and go ooc Usage: ooc Go out-of-character (OOC). This will leave your current character and put you in a incorporeal OOC state. key: ooc aliases: unpuppet locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdOOC in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . option (CmdOption) \u00b6 Set an account option Usage: option[/save] [name = value] Switches: save - Save the current option settings for future logins. clear - Clear the saved options. This command allows for viewing and setting client interface settings. Note that saved options may not be able to be used if later connecting with a client with different capabilities. key: option aliases: options locks : \"cmd:all()\" help_category : \"General\" Source: class CmdOption in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . password (CmdPassword) \u00b6 change your password Usage: password <old password> = <new password> Changes your password. Make sure to pick a safe one. key: password aliases: locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdPassword in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . quell (CmdQuell) \u00b6 use character's permissions instead of account's Usage: quell unquell Normally the permission level of the Account is used when puppeting a Character/Object to determine access. This command will switch the lock system to make use of the puppeted Object's permissions instead. This is useful mainly for testing. Hierarchical permission quelling only work downwards, thus an Account cannot use a higher-permission Character to escalate their permission level. Use the unquell command to revert back to normal operation. key: quell aliases: unquell locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdQuell in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . quit (CmdQuit) \u00b6 quit the game Usage: quit Switch: all - disconnect all connected sessions Gracefully disconnect your current session from the game. Use the /all switch to disconnect from all sessions. key: quit aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdQuit in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . sessions (CmdSessions) \u00b6 check your connected session(s) Usage: sessions Lists the sessions currently connected to your account. key: sessions aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdSessions in account.py . Belongs to command set 'DefaultSession' of class SessionCmdSet in cmdset_session.py . style (CmdStyle) \u00b6 In-game style options Usage: style style <option> = <value> Configure stylings for in-game display elements like table borders, help entriest etc. Use without arguments to see all available options. key: style aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdStyle in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . who (CmdWho) \u00b6 list who is currently online Usage: who doing Shows who is currently online. Doing is an alias that limits info also for those with all permissions. key: who aliases: doing locks : \"cmd:all()\" help_category : \"General\" Source: class CmdWho in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . admin.py \u00b6 View admin.py source ban (CmdBan) \u00b6 ban an account from the server Usage: ban [<name or ip> [: reason]] Without any arguments, shows numbered list of active bans. This command bans a user from accessing the game. Supply an optional reason to be able to later remember why the ban was put in place. It is often preferable to ban an account from the server than to delete an account with accounts/delete. If banned by name, that account account can no longer be logged into. IP (Internet Protocol) address banning allows blocking all access from a specific address or subnet. Use an asterisk (*) as a wildcard. Examples: ban thomas - ban account 'thomas' ban/ip 134.233.2.111 - ban specific ip address ban/ip 134.233.2.* - ban all in a subnet ban/ip 134.233.*.* - even wider ban A single IP filter can be easy to circumvent by changing computers or requesting a new IP address. Setting a wide IP block filter with wildcards might be tempting, but remember that it may also accidentally block innocent users connecting from the same country or region. key: ban aliases: bans locks : \"cmd:perm(ban) or perm(Developer)\" help_category : \"Admin\" Source: class CmdBan in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . boot (CmdBoot) \u00b6 kick an account from the server. Usage boot[/switches] <account obj> [: reason] Switches: quiet - Silently boot without informing account sid - boot by session id instead of name or dbref Boot an account object from the server. If a reason is supplied it will be echoed to the user unless /quiet is set. key: boot aliases: locks : \"cmd:perm(boot) or perm(Admin)\" help_category : \"Admin\" Source: class CmdBoot in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . emit (CmdEmit) \u00b6 admin command for emitting message to multiple objects Usage: emit[/switches] [<obj>, <obj>, ... =] <message> remit [<obj>, <obj>, ... =] <message> pemit [<obj>, <obj>, ... =] <message> Switches: room - limit emits to rooms only (default) accounts - limit emits to accounts only contents - send to the contents of matched objects too Emits a message to the selected objects or to your immediate surroundings. If the object is a room, send to its contents. remit and pemit are just limited forms of emit, for sending to rooms and to accounts respectively. key: emit aliases: pemit , remit locks : \"cmd:perm(emit) or perm(Builder)\" help_category : \"Admin\" Source: class CmdEmit in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . force (CmdForce) \u00b6 forces an object to execute a command Usage: force <object>=<command string> Example: force bob=get stick key: force aliases: locks : \"cmd:perm(spawn) or perm(Builder)\" help_category : \"Building\" Source: class CmdForce in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . perm (CmdPerm) \u00b6 set the permissions of an account/object Usage: perm[/switch] <object> [= <permission>[,<permission>,...]] perm[/switch] *<account> [= <permission>[,<permission>,...]] Switches: del - delete the given permission from <object> or <account>. account - set permission on an account (same as adding * to name) This command sets/clears individual permission strings on an object or account. If no permission is given, list all permissions on <object>. key: perm aliases: setperm locks : \"cmd:perm(perm) or perm(Developer)\" help_category : \"Admin\" Source: class CmdPerm in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . unban (CmdUnban) \u00b6 remove a ban from an account Usage: unban <banid> This will clear an account name/ip ban previously set with the ban command. Use this command without an argument to view a numbered list of bans. Use the numbers in this list to select which one to unban. key: unban aliases: locks : \"cmd:perm(unban) or perm(Developer)\" help_category : \"Admin\" Source: class CmdUnban in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . userpassword (CmdNewPassword) \u00b6 change the password of an account Usage: userpassword <user obj> = <new password> Set an account's password. key: userpassword aliases: locks : \"cmd:perm(newpassword) or perm(Admin)\" help_category : \"Admin\" Source: class CmdNewPassword in admin.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . wall (CmdWall) \u00b6 make an announcement to all Usage: wall <message> Announces a message to all connected sessions including all currently unlogged in. key: wall aliases: locks : \"cmd:perm(wall) or perm(Admin)\" help_category : \"Admin\" Source: class CmdWall in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . batchprocess.py \u00b6 View batchprocess.py source batchcode (CmdBatchCode) \u00b6 build from batch-code file Usage: batchcode[/interactive] <python path to file> Switch: interactive - this mode will offer more control when executing the batch file, like stepping, skipping, reloading etc. debug - auto-delete all objects that has been marked as deletable in the script file (see example files for syntax). This is useful so as to to not leave multiple object copies behind when testing out the script. Runs batches of commands from a batch-code text file (*.py). key: batchcode aliases: batchcodes locks : \"cmd:superuser()\" help_category : \"Building\" Source: class CmdBatchCode in batchprocess.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . batchcommands (CmdBatchCommands) \u00b6 build from batch-command file Usage: batchcommands[/interactive] <python.path.to.file> Switch: interactive - this mode will offer more control when executing the batch file, like stepping, skipping, reloading etc. Runs batches of commands from a batch-cmd text file (*.ev). key: batchcommands aliases: batchcommand , batchcmd locks : \"cmd:perm(batchcommands) or perm(Developer)\" help_category : \"Building\" Source: class CmdBatchCommands in batchprocess.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . building.py \u00b6 View building.py source alias (CmdSetObjAlias) \u00b6 adding permanent aliases for object Usage: alias <obj> [= [alias[,alias,alias,...]]] alias <obj> = alias/category <obj> = [alias[,alias,...]:<category> Switches: category - requires ending input with :category, to store the given aliases with the given category. Assigns aliases to an object so it can be referenced by more than one name. Assign empty to remove all aliases from object. If assigning a category, all aliases given will be using this category. Observe that this is not the same thing as personal aliases created with the 'nick' command! Aliases set with alias are changing the object in question, making those aliases usable by everyone. key: alias aliases: setobjalias locks : \"cmd:perm(setobjalias) or perm(Builder)\" help_category : \"Building\" Source: class CmdSetObjAlias in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . cmdsets (CmdListCmdSets) \u00b6 list command sets defined on an object Usage: cmdsets <obj> This displays all cmdsets assigned to a user. Defaults to yourself. key: cmdsets aliases: listcmsets locks : \"cmd:perm(listcmdsets) or perm(Builder)\" help_category : \"Building\" Source: class CmdListCmdSets in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . command (ObjManipCommand) \u00b6 This is a parent class for some of the defining objmanip commands since they tend to have some more variables to define new objects. Each object definition can have several components. First is always a name, followed by an optional alias list and finally an some optional data, such as a typeclass or a location. A comma ',' separates different objects. Like this: name1;alias;alias;alias:option, name2;alias;alias ... Spaces between all components are stripped. A second situation is attribute manipulation. Such commands are simpler and offer combinations objname/attr/attr/attr, objname/attr, ... key: command aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class ObjManipCommand in building.py . Belongs to command set ' ' of class <Unknown> in . copy (CmdCopy) \u00b6 copy an object and its properties Usage: copy[/reset] <original obj> [= <new_name>][;alias;alias..] [:<new_location>] [,<new_name2> ...] switch: reset - make a 'clean' copy off the object, thus removing any changes that might have been made to the original since it was first created. Create one or more copies of an object. If you don't supply any targets, one exact copy of the original object will be created with the name *_copy. key: copy aliases: locks : \"cmd:perm(copy) or perm(Builder)\" help_category : \"Building\" Source: class CmdCopy in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . cpattr (CmdCpAttr) \u00b6 copy attributes between objects Usage: cpattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] cpattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...] cpattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] cpattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...] Switches: move - delete the attribute from the source object after copying. Example: cpattr coolness = Anna/chillout, Anna/nicety, Tom/nicety -> copies the coolness attribute (defined on yourself), to attributes on Anna and Tom. Copy the attribute one object to one or more attributes on another object. If you don't supply a source object, yourself is used. key: cpattr aliases: locks : \"cmd:perm(cpattr) or perm(Builder)\" help_category : \"Building\" Source: class CmdCpAttr in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . create (CmdCreate) \u00b6 create new objects Usage: create[/drop] <objname>[;alias;alias...][:typeclass], <objname>... switch: drop - automatically drop the new object into your current location (this is not echoed). This also sets the new object's home to the current location rather than to you. Creates one or more new objects. If typeclass is given, the object is created as a child of this typeclass. The typeclass script is assumed to be located under types/ and any further directory structure is given in Python notation. So if you have a correct typeclass 'RedButton' defined in types/examples/red_button.py, you could create a new object of this type like this: create/drop button;red : examples.red_button.RedButton key: create aliases: locks : \"cmd:perm(create) or perm(Builder)\" help_category : \"Building\" Source: class CmdCreate in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . desc (CmdDesc) \u00b6 describe an object or the current room. Usage: desc [<obj> =] <description> Switches: edit - Open up a line editor for more advanced editing. Sets the \"desc\" attribute on an object. If an object is not given, describe the current room. key: desc aliases: describe locks : \"cmd:perm(desc) or perm(Builder)\" help_category : \"Building\" Source: class CmdDesc in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . destroy (CmdDestroy) \u00b6 permanently delete objects Usage: destroy[/switches] [obj, obj2, obj3, [dbref-dbref], ...] Switches: override - The destroy command will usually avoid accidentally destroying account objects. This switch overrides this safety. force - destroy without confirmation. Examples: destroy house, roof, door, 44-78 destroy 5-10, flower, 45 destroy/force north Destroys one or many objects. If dbrefs are used, a range to delete can be given, e.g. 4-10. Also the end points will be deleted. This command displays a confirmation before destroying, to make sure of your choice. You can specify the /force switch to bypass this confirmation. key: destroy aliases: del , delete locks : \"cmd:perm(destroy) or perm(Builder)\" help_category : \"Building\" Source: class CmdDestroy in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . dig (CmdDig) \u00b6 build new rooms and connect them to the current location Usage: dig[/switches] <roomname>[;alias;alias...][:typeclass] [= <exit_to_there>[;alias][:typeclass]] [, <exit_to_here>[;alias][:typeclass]] Switches: tel or teleport - move yourself to the new room Examples: dig kitchen = north;n, south;s dig house:myrooms.MyHouseTypeclass dig sheer cliff;cliff;sheer = climb up, climb down This command is a convenient way to build rooms quickly; it creates the new room and you can optionally set up exits back and forth between your current room and the new one. You can add as many aliases as you like to the name of the room and the exits in question; an example would be 'north;no;n'. key: dig aliases: locks : \"cmd:perm(dig) or perm(Builder)\" help_category : \"Building\" Source: class CmdDig in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . examine (CmdExamine) \u00b6 get detailed information about an object Usage: examine [<object>[/attrname]] examine [*<account>[/attrname]] Switch: account - examine an Account (same as adding *) object - examine an Object (useful when OOC) The examine command shows detailed game info about an object and optionally a specific attribute on it. If object is not specified, the current location is examined. Append a * before the search string to examine an account. key: examine aliases: ex , exam locks : \"cmd:perm(examine) or perm(Builder)\" help_category : \"Building\" Source: class CmdExamine in building.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . find (CmdFind) \u00b6 search the database for objects Usage: find[/switches] <name or dbref or *account> [= dbrefmin[-dbrefmax]] locate - this is a shorthand for using the /loc switch. Switches: room - only look for rooms (location=None) exit - only look for exits (destination!=None) char - only look for characters (BASE_CHARACTER_TYPECLASS) exact - only exact matches are returned. loc - display object location if exists and match has one result startswith - search for names starting with the string, rather than containing Searches the database for an object of a particular name or exact #dbref. Use *accountname to search for an account. The switches allows for limiting object matches to certain game entities. Dbrefmin and dbrefmax limits matches to within the given dbrefs range, or above/below if only one is given. key: find aliases: locate , search locks : \"cmd:perm(find) or perm(Builder)\" help_category : \"Building\" Source: class CmdFind in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . link (CmdLink) \u00b6 link existing rooms together with exits Usage: link[/switches] <object> = <target> link[/switches] <object> = link[/switches] <object> Switch: twoway - connect two exits. For this to work, BOTH <object> and <target> must be exit objects. If <object> is an exit, set its destination to <target>. Two-way operation instead sets the destination to the *locations* of the respective given arguments. The second form (a lone =) sets the destination to None (same as the unlink command) and the third form (without =) just shows the currently set destination. key: link aliases: locks : \"cmd:perm(link) or perm(Builder)\" help_category : \"Building\" Source: class CmdLink in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . lock (CmdLock) \u00b6 assign a lock definition to an object Usage: lock <object or *account>[ = <lockstring>] or lock[/switch] <object or *account>/<access_type> Switch: del - delete given access type view - view lock associated with given access type (default) If no lockstring is given, shows all locks on object. Lockstring is of the form access_type:[NOT] func1(args)[ AND|OR][ NOT] func2(args) ...] Where func1, func2 ... valid lockfuncs with or without arguments. Separator expressions need not be capitalized. For example: 'get: id(25) or perm(Admin)' The 'get' lock access_type is checked e.g. by the 'get' command. An object locked with this example lock will only be possible to pick up by Admins or by an object with id=25. You can add several access_types after one another by separating them by ';', i.e: 'get:id(25); delete:perm(Builder)' key: lock aliases: locks locks : \"cmd: perm(locks) or perm(Builder)\" help_category : \"Building\" Source: class CmdLock in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . mvattr (CmdMvAttr) \u00b6 move attributes between objects Usage: mvattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] mvattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...] mvattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] mvattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...] Switches: copy - Don't delete the original after moving. Move an attribute from one object to one or more attributes on another object. If you don't supply a source object, yourself is used. key: mvattr aliases: locks : \"cmd:perm(mvattr) or perm(Builder)\" help_category : \"Building\" Source: class CmdMvAttr in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . name (CmdName) \u00b6 change the name and/or aliases of an object Usage: name <obj> = <newname>;alias1;alias2 Rename an object to something new. Use *obj to rename an account. key: name aliases: rename locks : \"cmd:perm(rename) or perm(Builder)\" help_category : \"Building\" Source: class CmdName in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . open (CmdOpen) \u00b6 open a new exit from the current room Usage: open <new exit>[;alias;alias..][:typeclass] [,<return exit>[;alias;..][:typeclass]]] = <destination> Handles the creation of exits. If a destination is given, the exit will point there. The <return exit> argument sets up an exit at the destination leading back to the current room. Destination name can be given both as a #dbref and a name, if that name is globally unique. key: open aliases: locks : \"cmd:perm(open) or perm(Builder)\" help_category : \"Building\" Source: class CmdOpen in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . script (CmdScript) \u00b6 attach a script to an object Usage: script[/switch] <obj> [= script_path or <scriptkey>] Switches: start - start all non-running scripts on object, or a given script only stop - stop all scripts on objects, or a given script only If no script path/key is given, lists all scripts active on the given object. Script path can be given from the base location for scripts as given in settings. If adding a new script, it will be started automatically (no /start switch is needed). Using the /start or /stop switches on an object without specifying a script key/path will start/stop ALL scripts on the object. key: script aliases: addscript locks : \"cmd:perm(script) or perm(Builder)\" help_category : \"Building\" Source: class CmdScript in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . set (CmdSetAttribute) \u00b6 set attribute on an object or account Usage: set <obj>/<attr> = <value> set <obj>/<attr> = set <obj>/<attr> set *<account>/<attr> = <value> Switch: edit: Open the line editor (string values only) script: If we're trying to set an attribute on a script channel: If we're trying to set an attribute on a channel account: If we're trying to set an attribute on an account room: Setting an attribute on a room (global search) exit: Setting an attribute on an exit (global search) char: Setting an attribute on a character (global search) character: Alias for char, as above. Sets attributes on objects. The second example form above clears a previously set attribute while the third form inspects the current value of the attribute (if any). The last one (with the star) is a shortcut for operating on a player Account rather than an Object. The most common data to save with this command are strings and numbers. You can however also set Python primitives such as lists, dictionaries and tuples on objects (this might be important for the functionality of certain custom objects). This is indicated by you starting your value with one of |c'|n, |c\"|n, |c(|n, |c[|n or |c{ |n. Once you have stored a Python primitive as noted above, you can include |c[<key>]|n in <attr> to reference nested values in e.g. a list or dict. Remember that if you use Python primitives like this, you must write proper Python syntax too - notably you must include quotes around your strings or you will get an error. key: set aliases: locks : \"cmd:perm(set) or perm(Builder)\" help_category : \"Building\" Source: class CmdSetAttribute in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . sethome (CmdSetHome) \u00b6 set an object's home location Usage: sethome <obj> [= <home_location>] sethom <obj> The \"home\" location is a \"safety\" location for objects; they will be moved there if their current location ceases to exist. All objects should always have a home location for this reason. It is also a convenient target of the \"home\" command. If no location is given, just view the object's home location. key: sethome aliases: locks : \"cmd:perm(sethome) or perm(Builder)\" help_category : \"Building\" Source: class CmdSetHome in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . spawn (CmdSpawn) \u00b6 spawn objects from prototype Usage: spawn[/noloc] <prototype_key> spawn[/noloc] <prototype_dict> spawn/search [prototype_keykey][;tag[,tag]] spawn/list [tag, tag, ...] spawn/show [<prototype_key>] spawn/update <prototype_key> spawn/save <prototype_dict> spawn/edit [<prototype_key>] olc - equivalent to spawn/edit Switches: noloc - allow location to be None if not specified explicitly. Otherwise, location will default to caller's current location. search - search prototype by name or tags. list - list available prototypes, optionally limit by tags. show, examine - inspect prototype by key. If not given, acts like list. save - save a prototype to the database. It will be listable by /list. delete - remove a prototype from database, if allowed to. update - find existing objects with the same prototype_key and update them with latest version of given prototype. If given with /save, will auto-update all objects with the old version of the prototype without asking first. edit, olc - create/manipulate prototype in a menu interface. Example: spawn GOBLIN spawn {\"key\":\"goblin\", \"typeclass\":\"monster.Monster\", \"location\":\"#2\"} spawn/save {\"key\": \"grunt\", prototype: \"goblin\"};;mobs;edit:all() Dictionary keys: |wprototype_parent |n - name of parent prototype to use. Required if typeclass is not set. Can be a path or a list for multiple inheritance (inherits left to right). If set one of the parents must have a typeclass. |wtypeclass |n - string. Required if prototype_parent is not set. |wkey |n - string, the main object identifier |wlocation |n - this should be a valid object or #dbref |whome |n - valid object or #dbref |wdestination|n - only valid for exits (object or dbref) |wpermissions|n - string or list of permission strings |wlocks |n - a lock-string |waliases |n - string or list of strings. |wndb_|n<name> - value of a nattribute (ndb_ is stripped) |wprototype_key|n - name of this prototype. Unique. Used to store/retrieve from db and update existing prototyped objects if desired. |wprototype_desc|n - desc of this prototype. Used in listings |wprototype_locks|n - locks of this prototype. Limits who may use prototype |wprototype_tags|n - tags of this prototype. Used to find prototype any other keywords are interpreted as Attributes and their values. The available prototypes are defined globally in modules set in settings.PROTOTYPE_MODULES. If spawn is used without arguments it displays a list of available prototypes. key: spawn aliases: olc locks : \"cmd:perm(spawn) or perm(Builder)\" help_category : \"Building\" Source: class CmdSpawn in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . tag (CmdTag) \u00b6 handles the tags of an object Usage: tag[/del] <obj> [= <tag>[:<category>]] tag/search <tag>[:<category] Switches: search - return all objects with a given Tag del - remove the given tag. If no tag is specified, clear all tags on object. Manipulates and lists tags on objects. Tags allow for quick grouping of and searching for objects. If only <obj> is given, list all tags on the object. If /search is used, list objects with the given tag. The category can be used for grouping tags themselves, but it should be used with restrain - tags on their own are usually enough to for most grouping schemes. key: tag aliases: tags locks : \"cmd:perm(tag) or perm(Builder)\" help_category : \"Building\" Source: class CmdTag in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . tel (CmdTeleport) \u00b6 teleport object to another location Usage: tel/switch [<object> to||=] <target location> Examples: tel Limbo tel/quiet box = Limbo tel/tonone box Switches: quiet - don't echo leave/arrive messages to the source/target locations for the move. intoexit - if target is an exit, teleport INTO the exit object instead of to its destination tonone - if set, teleport the object to a None-location. If this switch is set, <target location> is ignored. Note that the only way to retrieve an object from a None location is by direct #dbref reference. A puppeted object cannot be moved to None. loc - teleport object to the target's location instead of its contents Teleports an object somewhere. If no object is given, you yourself is teleported to the target location. key: tel aliases: teleport locks : \"cmd:perm(teleport) or perm(Builder)\" help_category : \"Building\" Source: class CmdTeleport in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . tunnel (CmdTunnel) \u00b6 create new rooms in cardinal directions only Usage: tunnel[/switch] <direction>[:typeclass] [= <roomname>[;alias;alias;...][:typeclass]] Switches: oneway - do not create an exit back to the current location tel - teleport to the newly created room Example: tunnel n tunnel n = house;mike's place;green building This is a simple way to build using pre-defined directions: |wn,ne,e,se,s,sw,w,nw|n (north, northeast etc) |wu,d|n (up and down) |wi,o|n (in and out) The full names (north, in, southwest, etc) will always be put as main name for the exit, using the abbreviation as an alias (so an exit will always be able to be used with both \"north\" as well as \"n\" for example). Opposite directions will automatically be created back from the new room unless the /oneway switch is given. For more flexibility and power in creating rooms, use dig. key: tunnel aliases: tun locks : \"cmd: perm(tunnel) or perm(Builder)\" help_category : \"Building\" Source: class CmdTunnel in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . typeclass (CmdTypeclass) \u00b6 set or change an object's typeclass Usage: typeclass[/switch] <object> [= typeclass.path] type '' parent '' typeclass/list/show [typeclass.path] swap - this is a shorthand for using /force/reset flags. update - this is a shorthand for using the /force/reload flag. Switch: show, examine - display the current typeclass of object (default) or, if given a typeclass path, show the docstring of that typeclass. update - *only* re-run at_object_creation on this object meaning locks or other properties set later may remain. reset - clean out *all* the attributes and properties on the object - basically making this a new clean object. force - change to the typeclass also if the object already has a typeclass of the same name. list - show available typeclasses. Only typeclasses in modules actually imported or used from somewhere in the code will show up here (those typeclasses are still available if you know the path) Example: type button = examples.red_button.RedButton If the typeclass_path is not given, the current object's typeclass is assumed. View or set an object's typeclass. If setting, the creation hooks of the new typeclass will be run on the object. If you have clashing properties on the old class, use /reset. By default you are protected from changing to a typeclass of the same name as the one you already have - use /force to override this protection. The given typeclass must be identified by its location using python dot-notation pointing to the correct module and class. If no typeclass is given (or a wrong typeclass is given). Errors in the path or new typeclass will lead to the old typeclass being kept. The location of the typeclass module is searched from the default typeclass directory, as defined in the server settings. key: typeclass aliases: type , swap , update , parent locks : \"cmd:perm(typeclass) or perm(Builder)\" help_category : \"Building\" Source: class CmdTypeclass in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . unlink (CmdUnLink) \u00b6 remove exit-connections between rooms Usage: unlink <Object> Unlinks an object, for example an exit, disconnecting it from whatever it was connected to. key: unlink aliases: locks : \"cmd:perm(unlink) or perm(Builder)\" help_category : \"Building\" Source: class CmdUnLink in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . wipe (CmdWipe) \u00b6 clear all attributes from an object Usage: wipe <object>[/<attr>[/<attr>...]] Example: wipe box wipe box/colour Wipes all of an object's attributes, or optionally only those matching the given attribute-wildcard search string. key: wipe aliases: locks : \"cmd:perm(wipe) or perm(Builder)\" help_category : \"Building\" Source: class CmdWipe in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . comms.py \u00b6 View comms.py source addcom (CmdAddCom) \u00b6 add a channel alias and/or subscribe to a channel Usage: addcom [alias=] <channel> Joins a given channel. If alias is given, this will allow you to refer to the channel by this alias rather than the full channel name. Subsequent calls of this command can be used to add multiple aliases to an already joined channel. key: addcom aliases: chanalias , aliaschan locks : \"cmd:not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdAddCom in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . allcom (CmdAllCom) \u00b6 perform admin operations on all channels Usage: allcom [on | off | who | destroy] Allows the user to universally turn off or on all channels they are on, as well as perform a 'who' for all channels they are on. Destroy deletes all channels that you control. Without argument, works like comlist. key: allcom aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdAllCom in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . cboot (CmdCBoot) \u00b6 kick an account from a channel you control Usage: cboot[/quiet] <channel> = <account> [:reason] Switch: quiet - don't notify the channel Kicks an account or object from a channel you control. key: cboot aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCBoot in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . ccreate (CmdChannelCreate) \u00b6 create a new channel Usage: ccreate <new channel>[;alias;alias...] = description Creates a new channel owned by you. key: ccreate aliases: channelcreate locks : \"cmd:not pperm(channel_banned) and pperm(Player)\" help_category : \"Comms\" Source: class CmdChannelCreate in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . cdesc (CmdCdesc) \u00b6 describe a channel you control Usage: cdesc <channel> = <description> Changes the description of the channel as shown in channel lists. key: cdesc aliases: locks : \"cmd:not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCdesc in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . cdestroy (CmdCdestroy) \u00b6 destroy a channel you created Usage: cdestroy <channel> Destroys a channel that you control. key: cdestroy aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCdestroy in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . cemit (CmdCemit) \u00b6 send an admin message to a channel you control Usage: cemit[/switches] <channel> = <message> Switches: sendername - attach the sender's name before the message quiet - don't echo the message back to sender Allows the user to broadcast a message over a channel as long as they control it. It does not show the user's name unless they provide the /sendername switch. key: cemit aliases: cmsg locks : \"cmd: not pperm(channel_banned) and pperm(Player)\" help_category : \"Comms\" Source: class CmdCemit in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . channels (CmdChannels) \u00b6 list all channels available to you Usage: channels clist comlist Lists all channels available to you, whether you listen to them or not. Use 'comlist' to only view your current channel subscriptions. Use addcom/delcom to join and leave channels key: channels aliases: comlist , channellist , clist , chanlist , all channels locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdChannels in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . clock (CmdClock) \u00b6 change channel locks of a channel you control Usage: clock <channel> [= <lockstring>] Changes the lock access restrictions of a channel. If no lockstring was given, view the current lock definitions. key: clock aliases: locks : \"cmd:not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdClock in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . cwho (CmdCWho) \u00b6 show who is listening to a channel Usage: cwho <channel> List who is connected to a given channel you have access to. key: cwho aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCWho in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . delcom (CmdDelCom) \u00b6 remove a channel alias and/or unsubscribe from channel Usage: delcom <alias or channel> delcom/all <channel> If the full channel name is given, unsubscribe from the channel. If an alias is given, remove the alias but don't unsubscribe. If the 'all' switch is used, remove all aliases for that channel. key: delcom aliases: delaliaschan , delchanalias locks : \"cmd:not perm(channel_banned)\" help_category : \"Comms\" Source: class CmdDelCom in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . irc2chan (CmdIRC2Chan) \u00b6 Link an evennia channel to an external IRC channel Usage: irc2chan[/switches] <evennia_channel> = <ircnetwork> <port> <#irchannel> <botname>[:typeclass] irc2chan/delete botname|#dbid Switches: /delete - this will delete the bot and remove the irc connection to the channel. Requires the botname or #dbid as input. /remove - alias to /delete /disconnect - alias to /delete /list - show all irc<->evennia mappings /ssl - use an SSL-encrypted connection Example: irc2chan myircchan = irc.dalnet.net 6667 #mychannel evennia-bot irc2chan public = irc.freenode.net 6667 #evgaming #evbot:accounts.mybot.MyBot This creates an IRC bot that connects to a given IRC network and channel. If a custom typeclass path is given, this will be used instead of the default bot class. The bot will relay everything said in the evennia channel to the IRC channel and vice versa. The bot will automatically connect at server start, so this command need only be given once. The /disconnect switch will permanently delete the bot. To only temporarily deactivate it, use the |wservices|n command instead. Provide an optional bot class path to use a custom bot. key: irc2chan aliases: locks : \"cmd:serversetting(IRC_ENABLED) and pperm(Developer)\" help_category : \"Comms\" Source: class CmdIRC2Chan in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . page (CmdPage) \u00b6 send a private message to another account Usage: page[/switches] [<account>,<account>,... = <message>] tell '' page <number> Switch: last - shows who you last messaged list - show your last <number> of tells/pages (default) Send a message to target user (if online). If no argument is given, you will get a list of your latest messages. key: page aliases: tell locks : \"cmd:not pperm(page_banned)\" help_category : \"Comms\" Source: class CmdPage in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . rss2chan (CmdRSS2Chan) \u00b6 link an evennia channel to an external RSS feed Usage: rss2chan[/switches] <evennia_channel> = <rss_url> Switches: /disconnect - this will stop the feed and remove the connection to the channel. /remove - \" /list - show all rss->evennia mappings Example: rss2chan rsschan = http://code.google.com/feeds/p/evennia/updates/basic This creates an RSS reader that connects to a given RSS feed url. Updates will be echoed as a title and news link to the given channel. The rate of updating is set with the RSS_UPDATE_INTERVAL variable in settings (default is every 10 minutes). When disconnecting you need to supply both the channel and url again so as to identify the connection uniquely. key: rss2chan aliases: locks : \"cmd:serversetting(RSS_ENABLED) and pperm(Developer)\" help_category : \"Comms\" Source: class CmdRSS2Chan in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . general.py \u00b6 View general.py source access (CmdAccess) \u00b6 show your current game access Usage: access This command shows you the permission hierarchy and which permission groups you are a member of. key: access aliases: groups , hierarchy locks : \"cmd:all()\" help_category : \"General\" Source: class CmdAccess in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . drop (CmdDrop) \u00b6 drop something Usage: drop <obj> Lets you drop an object from your inventory into the location you are currently in. key: drop aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdDrop in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . get (CmdGet) \u00b6 pick up something Usage: get <obj> Picks up an object from your location and puts it in your inventory. key: get aliases: grab locks : \"cmd:all()\" help_category : \"General\" Source: class CmdGet in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . give (CmdGive) \u00b6 give away something to someone Usage: give <inventory obj> <to||=> <target> Gives an items from your inventory to another character, placing it in their inventory. key: give aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdGive in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . home (CmdHome) \u00b6 move to your character's home location Usage: home Teleports you to your home location. key: home aliases: locks : \"cmd:perm(home) or perm(Builder)\" help_category : \"General\" Source: class CmdHome in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . inventory (CmdInventory) \u00b6 view inventory Usage: inventory inv Shows your inventory. key: inventory aliases: inv , i locks : \"cmd:all()\" help_category : \"General\" Source: class CmdInventory in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . look (CmdLook) \u00b6 look at location or object Usage: look look <obj> look *<account> Observes your location or objects in your vicinity. key: look aliases: ls , l locks : \"cmd:all()\" help_category : \"General\" Source: class CmdLook in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . nick (CmdNick) \u00b6 define a personal alias/nick by defining a string to match and replace it with another on the fly Usage: nick[/switches] <string> [= [replacement_string]] nick[/switches] <template> = <replacement_template> nick/delete <string> or number nicks Switches: inputline - replace on the inputline (default) object - replace on object-lookup account - replace on account-lookup list - show all defined aliases (also \"nicks\" works) delete - remove nick by index in /list clearall - clear all nicks Examples: nick hi = say Hello, I'm Sarah! nick/object tom = the tall man nick build $1 $2 = create/drop $1;$2 nick tell $1 $2=page $1=$2 nick tm?$1=page tallman=$1 nick tm\\=$1=page tallman=$1 A 'nick' is a personal string replacement. Use $1, $2, ... to catch arguments. Put the last $-marker without an ending space to catch all remaining text. You can also use unix-glob matching for the left-hand side <string>: * - matches everything ? - matches 0 or 1 single characters [abcd] - matches these chars in any order [!abcd] - matches everything not among these chars \\= - escape literal '=' you want in your <string> Note that no objects are actually renamed or changed by this command - your nicks are only available to you. If you want to permanently add keywords to an object for everyone to use, you need build privileges and the alias command. key: nick aliases: nickname , nicks locks : \"cmd:all()\" help_category : \"General\" Source: class CmdNick in general.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . pose (CmdPose) \u00b6 strike a pose Usage: pose <pose text> pose's <pose text> Example: pose is standing by the wall, smiling. -> others will see: Tom is standing by the wall, smiling. Describe an action being taken. The pose text will automatically begin with your name. key: pose aliases: emote , : locks : \"cmd:all()\" help_category : \"General\" Source: class CmdPose in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . say (CmdSay) \u00b6 speak as your character Usage: say <message> Talk to those in your current location. key: say aliases: ' , \" locks : \"cmd:all()\" help_category : \"General\" Source: class CmdSay in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . setdesc (CmdSetDesc) \u00b6 describe yourself Usage: setdesc <description> Add a description to yourself. This will be visible to people when they look at you. key: setdesc aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdSetDesc in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . whisper (CmdWhisper) \u00b6 Speak privately as your character to another Usage: whisper <character> = <message> whisper <char1>, <char2> = <message> Talk privately to one or more characters in your current location, without others in the room being informed. key: whisper aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdWhisper in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . help.py \u00b6 View help.py source help (CmdHelp) \u00b6 View help or a list of topics Usage: help <topic or command> help list help all This will search for help on commands and other topics related to the game. key: help aliases: ? locks : \"cmd:all()\" help_category : \"General\" Source: class CmdHelp in help.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . sethelp (CmdSetHelp) \u00b6 Edit the help database. Usage: help[/switches] <topic>[[;alias;alias][,category[,locks]] [= <text>] Switches: edit - open a line editor to edit the topic's help text. replace - overwrite existing help topic. append - add text to the end of existing topic with a newline between. extend - as append, but don't add a newline. delete - remove help topic. Examples: sethelp throw = This throws something at ... sethelp/append pickpocketing,Thievery = This steals ... sethelp/replace pickpocketing, ,attr(is_thief) = This steals ... sethelp/edit thievery This command manipulates the help database. A help entry can be created, appended/merged to and deleted. If you don't assign a category, the \"General\" category will be used. If no lockstring is specified, default is to let everyone read the help file. key: sethelp aliases: locks : \"cmd:perm(Helper)\" help_category : \"Building\" Source: class CmdSetHelp in help.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . system.py \u00b6 View system.py source about (CmdAbout) \u00b6 show Evennia info Usage: about Display info about the game engine. key: about aliases: version locks : \"cmd:all()\" help_category : \"System\" Source: class CmdAbout in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . objects (CmdObjects) \u00b6 statistics on objects in the database Usage: objects [<nr>] Gives statictics on objects in database as well as a list of <nr> latest objects in database. If not given, <nr> defaults to 10. key: objects aliases: listobjs , db , stats , listobjects locks : \"cmd:perm(listobjects) or perm(Builder)\" help_category : \"System\" Source: class CmdObjects in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . py (CmdPy) \u00b6 execute a snippet of python code Usage: py [cmd] py/edit py/time <cmd> py/clientraw <cmd> py/noecho Switches: time - output an approximate execution time for <cmd> edit - open a code editor for multi-line code experimentation clientraw - turn off all client-specific escaping. Note that this may lead to different output depending on prototocol (such as angular brackets being parsed as HTML in the webclient but not in telnet clients) noecho - in Python console mode, turn off the input echo (e.g. if your client does this for you already) Without argument, open a Python console in-game. This is a full console, accepting multi-line Python code for testing and debugging. Type `exit()` to return to the game. If Evennia is reloaded, the console will be closed. Enter a line of instruction after the 'py' command to execute it immediately. Separate multiple commands by ';' or open the code editor using the /edit switch (all lines added in editor will be executed immediately when closing or using the execute command in the editor). A few variables are made available for convenience in order to offer access to the system (you can import more at execution time). Available variables in py environment: self, me : caller here : caller.location evennia : the evennia API inherits_from(obj, parent) : check object inheritance You can explore The evennia API from inside the game by calling the `__doc__` property on entities: py evennia.__doc__ py evennia.managers.__doc__ |rNote: In the wrong hands this command is a severe security risk. It should only be accessible by trusted server admins/superusers.|n key: py aliases: ! locks : \"cmd:perm(py) or perm(Developer)\" help_category : \"System\" Source: class CmdPy in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . reload (CmdReload) \u00b6 reload the server Usage: reload [reason] This restarts the server. The Portal is not affected. Non-persistent scripts will survive a reload (use reset to purge) and at_reload() hooks will be called. key: reload aliases: restart locks : \"cmd:perm(reload) or perm(Developer)\" help_category : \"System\" Source: class CmdReload in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . reset (CmdReset) \u00b6 reset and reboot the server Usage: reset Notes: For normal updating you are recommended to use reload rather than this command. Use shutdown for a complete stop of everything. This emulates a cold reboot of the Server component of Evennia. The difference to shutdown is that the Server will auto-reboot and that it does not affect the Portal, so no users will be disconnected. Contrary to reload however, all shutdown hooks will be called and any non-database saved scripts, ndb-attributes, cmdsets etc will be wiped. key: reset aliases: reboot locks : \"cmd:perm(reload) or perm(Developer)\" help_category : \"System\" Source: class CmdReset in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . scripts (CmdScripts) \u00b6 list and manage all running scripts Usage: scripts[/switches] [#dbref, key, script.path or <obj>] Switches: start - start a script (must supply a script path) stop - stops an existing script kill - kills a script - without running its cleanup hooks validate - run a validation on the script(s) If no switches are given, this command just views all active scripts. The argument can be either an object, at which point it will be searched for all scripts defined on it, or a script name or #dbref. For using the /stop switch, a unique script #dbref is required since whole classes of scripts often have the same name. Use script for managing commands on objects. key: scripts aliases: globalscript , listscripts locks : \"cmd:perm(listscripts) or perm(Admin)\" help_category : \"System\" Source: class CmdScripts in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . server (CmdServerLoad) \u00b6 show server load and memory statistics Usage: server[/mem] Switches: mem - return only a string of the current memory usage flushmem - flush the idmapper cache This command shows server load statistics and dynamic memory usage. It also allows to flush the cache of accessed database objects. Some Important statistics in the table: |wServer load|n is an average of processor usage. It's usually between 0 (no usage) and 1 (100% usage), but may also be temporarily higher if your computer has multiple CPU cores. The |wResident/Virtual memory|n displays the total memory used by the server process. Evennia |wcaches|n all retrieved database entities when they are loaded by use of the idmapper functionality. This allows Evennia to maintain the same instances of an entity and allowing non-persistent storage schemes. The total amount of cached objects are displayed plus a breakdown of database object types. The |wflushmem|n switch allows to flush the object cache. Please note that due to how Python's memory management works, releasing caches may not show you a lower Residual/Virtual memory footprint, the released memory will instead be re-used by the program. key: server aliases: serverload , serverprocess locks : \"cmd:perm(list) or perm(Developer)\" help_category : \"System\" Source: class CmdServerLoad in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . service (CmdService) \u00b6 manage system services Usage: service[/switch] <service> Switches: list - shows all available services (default) start - activates or reactivate a service stop - stops/inactivate a service (can often be restarted) delete - tries to permanently remove a service Service management system. Allows for the listing, starting, and stopping of services. If no switches are given, services will be listed. Note that to operate on the service you have to supply the full (green or red) name as given in the list. key: service aliases: services locks : \"cmd:perm(service) or perm(Developer)\" help_category : \"System\" Source: class CmdService in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . shutdown (CmdShutdown) \u00b6 stop the server completely Usage: shutdown [announcement] Gracefully shut down both Server and Portal. key: shutdown aliases: locks : \"cmd:perm(shutdown) or perm(Developer)\" help_category : \"System\" Source: class CmdShutdown in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py . time (CmdTime) \u00b6 show server time statistics Usage: time List Server time statistics such as uptime and the current time stamp. key: time aliases: uptime locks : \"cmd:perm(time) or perm(Player)\" help_category : \"System\" Source: class CmdTime in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py . unloggedin.py \u00b6 View unloggedin.py source __unloggedin_look_command (CmdUnconnectedLook) \u00b6 look when in unlogged-in state Usage: look This is an unconnected version of the look command for simplicity. This is called by the server and kicks everything in gear. All it does is display the connect screen. key: __unloggedin_look_command aliases: look , l locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedLook in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py . OBS: This is a [[System Command|Commands]]. System commands have fixed keys and are called by the server in specific situations. connect (CmdUnconnectedConnect) \u00b6 connect to the game Usage (at login screen): connect accountname password connect \"account name\" \"pass word\" Use the create command to first create an account before logging in. If you have spaces in your name, enclose it in double quotes. key: connect aliases: conn , con , co locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedConnect in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py . create (CmdUnconnectedCreate) \u00b6 create a new account account Usage (at login screen): create <accountname> <password> create \"account name\" \"pass word\" This creates a new account account. If you have spaces in your name, enclose it in double quotes. key: create aliases: cr , cre locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedCreate in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py . help (CmdUnconnectedHelp) \u00b6 get help when in unconnected-in state Usage: help This is an unconnected version of the help command, for simplicity. It shows a pane of info. key: help aliases: ? , h locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedHelp in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py . quit (CmdUnconnectedQuit) \u00b6 quit when in unlogged-in state Usage: quit We maintain a different version of the quit command here for unconnected accounts for the sake of simplicity. The logged in version is a bit more complicated. key: quit aliases: q , qu locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedQuit in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py .","title":"Default Command Help"},{"location":"Default-Command-Help.html#a-z","text":"__unloggedin_look_command - look when in unlogged-in state about - show Evennia info access - show your current game access addcom - add a channel alias and/or subscribe to a channel alias - adding permanent aliases for object allcom - perform admin operations on all channels ban - ban an account from the server batchcode - build from batch-code file batchcommands - build from batch-command file boot - kick an account from the server. cboot - kick an account from a channel you control ccreate - create a new channel cdesc - describe a channel you control cdestroy - destroy a channel you created cemit - send an admin message to a channel you control channels - list all channels available to you charcreate - create a new character chardelete - delete a character - this cannot be undone! clock - change channel locks of a channel you control cmdsets - list command sets defined on an object color - testing which colors your client support command - This is a parent class for some of the defining objmanip commands connect - connect to the game copy - copy an object and its properties cpattr - copy attributes between objects create - create a new account account create - create new objects cwho - show who is listening to a channel delcom - remove a channel alias and/or unsubscribe from channel desc - describe an object or the current room. destroy - permanently delete objects dig - build new rooms and connect them to the current location drop - drop something emit - admin command for emitting message to multiple objects examine - get detailed information about an object find - search the database for objects force - forces an object to execute a command get - pick up something give - give away something to someone help - View help or a list of topics help - get help when in unconnected-in state home - move to your character's home location ic - control an object you have permission to puppet inventory - view inventory irc2chan - Link an evennia channel to an external IRC channel link - link existing rooms together with exits lock - assign a lock definition to an object look - look while out-of-character look - look at location or object mvattr - move attributes between objects name - change the name and/or aliases of an object nick - define a personal alias/nick by defining a string to objects - statistics on objects in the database ooc - stop puppeting and go ooc open - open a new exit from the current room option - Set an account option page - send a private message to another account password - change your password perm - set the permissions of an account/object pose - strike a pose py - execute a snippet of python code quell - use character's permissions instead of account's quit - quit the game quit - quit when in unlogged-in state reload - reload the server reset - reset and reboot the server rss2chan - link an evennia channel to an external RSS feed say - speak as your character script - attach a script to an object scripts - list and manage all running scripts server - show server load and memory statistics service - manage system services sessions - check your connected session(s) set - set attribute on an object or account setdesc - describe yourself sethelp - Edit the help database. sethome - set an object's home location shutdown - stop the server completely spawn - spawn objects from prototype style - In-game style options tag - handles the tags of an object tel - teleport object to another location time - show server time statistics tunnel - create new rooms in cardinal directions only typeclass - set or change an object's typeclass unban - remove a ban from an account unlink - remove exit-connections between rooms userpassword - change the password of an account wall - make an announcement to all whisper - Speak privately as your character to another who - list who is currently online wipe - clear all attributes from an object","title":"A-Z"},{"location":"Default-Command-Help.html#a-z-by-source-file","text":"account.py admin.py batchprocess.py building.py comms.py general.py help.py system.py unloggedin.py","title":"A-Z by source file"},{"location":"Default-Command-Help.html#command-details","text":"These are generated from the auto-documentation and are ordered by their source file location in evennia/commands/default/","title":"Command details"},{"location":"Default-Command-Help.html#accountpy","text":"View account.py source","title":"account.py"},{"location":"Default-Command-Help.html#charcreate-cmdcharcreate","text":"create a new character Usage: charcreate <charname> [= desc] Create a new character, optionally giving it a description. You may use upper-case letters in the name - you will nevertheless always be able to access your character using lower-case letters if you want. key: charcreate aliases: locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdCharCreate in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"charcreate (CmdCharCreate)"},{"location":"Default-Command-Help.html#chardelete-cmdchardelete","text":"delete a character - this cannot be undone! Usage: chardelete <charname> Permanently deletes one of your characters. key: chardelete aliases: locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdCharDelete in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"chardelete (CmdCharDelete)"},{"location":"Default-Command-Help.html#color-cmdcolortest","text":"testing which colors your client support Usage: color ansi||xterm256 Prints a color map along with in-mud color codes to use to produce them. It also tests what is supported in your client. Choices are 16-color ansi (supported in most muds) or the 256-color xterm256 standard. No checking is done to determine your client supports color - if not you will see rubbish appear. key: color aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdColorTest in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"color (CmdColorTest)"},{"location":"Default-Command-Help.html#ic-cmdic","text":"control an object you have permission to puppet Usage: ic <character> Go in-character (IC) as a given Character. This will attempt to \"become\" a different object assuming you have the right to do so. Note that it's the ACCOUNT character that puppets characters/objects and which needs to have the correct permission! You cannot become an object that is already controlled by another account. In principle <character> can be any in-game object as long as you the account have access right to puppet it. key: ic aliases: puppet locks : \"cmd:all()\" help_category : \"General\" Source: class CmdIC in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"ic (CmdIC)"},{"location":"Default-Command-Help.html#look-cmdooclook","text":"look while out-of-character Usage: look Look in the ooc state. key: look aliases: ls , l locks : \"cmd:all()\" help_category : \"General\" Source: class CmdOOCLook in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"look (CmdOOCLook)"},{"location":"Default-Command-Help.html#ooc-cmdooc","text":"stop puppeting and go ooc Usage: ooc Go out-of-character (OOC). This will leave your current character and put you in a incorporeal OOC state. key: ooc aliases: unpuppet locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdOOC in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"ooc (CmdOOC)"},{"location":"Default-Command-Help.html#option-cmdoption","text":"Set an account option Usage: option[/save] [name = value] Switches: save - Save the current option settings for future logins. clear - Clear the saved options. This command allows for viewing and setting client interface settings. Note that saved options may not be able to be used if later connecting with a client with different capabilities. key: option aliases: options locks : \"cmd:all()\" help_category : \"General\" Source: class CmdOption in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"option (CmdOption)"},{"location":"Default-Command-Help.html#password-cmdpassword","text":"change your password Usage: password <old password> = <new password> Changes your password. Make sure to pick a safe one. key: password aliases: locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdPassword in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"password (CmdPassword)"},{"location":"Default-Command-Help.html#quell-cmdquell","text":"use character's permissions instead of account's Usage: quell unquell Normally the permission level of the Account is used when puppeting a Character/Object to determine access. This command will switch the lock system to make use of the puppeted Object's permissions instead. This is useful mainly for testing. Hierarchical permission quelling only work downwards, thus an Account cannot use a higher-permission Character to escalate their permission level. Use the unquell command to revert back to normal operation. key: quell aliases: unquell locks : \"cmd:pperm(Player)\" help_category : \"General\" Source: class CmdQuell in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"quell (CmdQuell)"},{"location":"Default-Command-Help.html#quit-cmdquit","text":"quit the game Usage: quit Switch: all - disconnect all connected sessions Gracefully disconnect your current session from the game. Use the /all switch to disconnect from all sessions. key: quit aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdQuit in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"quit (CmdQuit)"},{"location":"Default-Command-Help.html#sessions-cmdsessions","text":"check your connected session(s) Usage: sessions Lists the sessions currently connected to your account. key: sessions aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdSessions in account.py . Belongs to command set 'DefaultSession' of class SessionCmdSet in cmdset_session.py .","title":"sessions (CmdSessions)"},{"location":"Default-Command-Help.html#style-cmdstyle","text":"In-game style options Usage: style style <option> = <value> Configure stylings for in-game display elements like table borders, help entriest etc. Use without arguments to see all available options. key: style aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdStyle in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"style (CmdStyle)"},{"location":"Default-Command-Help.html#who-cmdwho","text":"list who is currently online Usage: who doing Shows who is currently online. Doing is an alias that limits info also for those with all permissions. key: who aliases: doing locks : \"cmd:all()\" help_category : \"General\" Source: class CmdWho in account.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"who (CmdWho)"},{"location":"Default-Command-Help.html#adminpy","text":"View admin.py source","title":"admin.py"},{"location":"Default-Command-Help.html#ban-cmdban","text":"ban an account from the server Usage: ban [<name or ip> [: reason]] Without any arguments, shows numbered list of active bans. This command bans a user from accessing the game. Supply an optional reason to be able to later remember why the ban was put in place. It is often preferable to ban an account from the server than to delete an account with accounts/delete. If banned by name, that account account can no longer be logged into. IP (Internet Protocol) address banning allows blocking all access from a specific address or subnet. Use an asterisk (*) as a wildcard. Examples: ban thomas - ban account 'thomas' ban/ip 134.233.2.111 - ban specific ip address ban/ip 134.233.2.* - ban all in a subnet ban/ip 134.233.*.* - even wider ban A single IP filter can be easy to circumvent by changing computers or requesting a new IP address. Setting a wide IP block filter with wildcards might be tempting, but remember that it may also accidentally block innocent users connecting from the same country or region. key: ban aliases: bans locks : \"cmd:perm(ban) or perm(Developer)\" help_category : \"Admin\" Source: class CmdBan in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"ban (CmdBan)"},{"location":"Default-Command-Help.html#boot-cmdboot","text":"kick an account from the server. Usage boot[/switches] <account obj> [: reason] Switches: quiet - Silently boot without informing account sid - boot by session id instead of name or dbref Boot an account object from the server. If a reason is supplied it will be echoed to the user unless /quiet is set. key: boot aliases: locks : \"cmd:perm(boot) or perm(Admin)\" help_category : \"Admin\" Source: class CmdBoot in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"boot (CmdBoot)"},{"location":"Default-Command-Help.html#emit-cmdemit","text":"admin command for emitting message to multiple objects Usage: emit[/switches] [<obj>, <obj>, ... =] <message> remit [<obj>, <obj>, ... =] <message> pemit [<obj>, <obj>, ... =] <message> Switches: room - limit emits to rooms only (default) accounts - limit emits to accounts only contents - send to the contents of matched objects too Emits a message to the selected objects or to your immediate surroundings. If the object is a room, send to its contents. remit and pemit are just limited forms of emit, for sending to rooms and to accounts respectively. key: emit aliases: pemit , remit locks : \"cmd:perm(emit) or perm(Builder)\" help_category : \"Admin\" Source: class CmdEmit in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"emit (CmdEmit)"},{"location":"Default-Command-Help.html#force-cmdforce","text":"forces an object to execute a command Usage: force <object>=<command string> Example: force bob=get stick key: force aliases: locks : \"cmd:perm(spawn) or perm(Builder)\" help_category : \"Building\" Source: class CmdForce in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"force (CmdForce)"},{"location":"Default-Command-Help.html#perm-cmdperm","text":"set the permissions of an account/object Usage: perm[/switch] <object> [= <permission>[,<permission>,...]] perm[/switch] *<account> [= <permission>[,<permission>,...]] Switches: del - delete the given permission from <object> or <account>. account - set permission on an account (same as adding * to name) This command sets/clears individual permission strings on an object or account. If no permission is given, list all permissions on <object>. key: perm aliases: setperm locks : \"cmd:perm(perm) or perm(Developer)\" help_category : \"Admin\" Source: class CmdPerm in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"perm (CmdPerm)"},{"location":"Default-Command-Help.html#unban-cmdunban","text":"remove a ban from an account Usage: unban <banid> This will clear an account name/ip ban previously set with the ban command. Use this command without an argument to view a numbered list of bans. Use the numbers in this list to select which one to unban. key: unban aliases: locks : \"cmd:perm(unban) or perm(Developer)\" help_category : \"Admin\" Source: class CmdUnban in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"unban (CmdUnban)"},{"location":"Default-Command-Help.html#userpassword-cmdnewpassword","text":"change the password of an account Usage: userpassword <user obj> = <new password> Set an account's password. key: userpassword aliases: locks : \"cmd:perm(newpassword) or perm(Admin)\" help_category : \"Admin\" Source: class CmdNewPassword in admin.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"userpassword (CmdNewPassword)"},{"location":"Default-Command-Help.html#wall-cmdwall","text":"make an announcement to all Usage: wall <message> Announces a message to all connected sessions including all currently unlogged in. key: wall aliases: locks : \"cmd:perm(wall) or perm(Admin)\" help_category : \"Admin\" Source: class CmdWall in admin.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"wall (CmdWall)"},{"location":"Default-Command-Help.html#batchprocesspy","text":"View batchprocess.py source","title":"batchprocess.py"},{"location":"Default-Command-Help.html#batchcode-cmdbatchcode","text":"build from batch-code file Usage: batchcode[/interactive] <python path to file> Switch: interactive - this mode will offer more control when executing the batch file, like stepping, skipping, reloading etc. debug - auto-delete all objects that has been marked as deletable in the script file (see example files for syntax). This is useful so as to to not leave multiple object copies behind when testing out the script. Runs batches of commands from a batch-code text file (*.py). key: batchcode aliases: batchcodes locks : \"cmd:superuser()\" help_category : \"Building\" Source: class CmdBatchCode in batchprocess.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"batchcode (CmdBatchCode)"},{"location":"Default-Command-Help.html#batchcommands-cmdbatchcommands","text":"build from batch-command file Usage: batchcommands[/interactive] <python.path.to.file> Switch: interactive - this mode will offer more control when executing the batch file, like stepping, skipping, reloading etc. Runs batches of commands from a batch-cmd text file (*.ev). key: batchcommands aliases: batchcommand , batchcmd locks : \"cmd:perm(batchcommands) or perm(Developer)\" help_category : \"Building\" Source: class CmdBatchCommands in batchprocess.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"batchcommands (CmdBatchCommands)"},{"location":"Default-Command-Help.html#buildingpy","text":"View building.py source","title":"building.py"},{"location":"Default-Command-Help.html#alias-cmdsetobjalias","text":"adding permanent aliases for object Usage: alias <obj> [= [alias[,alias,alias,...]]] alias <obj> = alias/category <obj> = [alias[,alias,...]:<category> Switches: category - requires ending input with :category, to store the given aliases with the given category. Assigns aliases to an object so it can be referenced by more than one name. Assign empty to remove all aliases from object. If assigning a category, all aliases given will be using this category. Observe that this is not the same thing as personal aliases created with the 'nick' command! Aliases set with alias are changing the object in question, making those aliases usable by everyone. key: alias aliases: setobjalias locks : \"cmd:perm(setobjalias) or perm(Builder)\" help_category : \"Building\" Source: class CmdSetObjAlias in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"alias (CmdSetObjAlias)"},{"location":"Default-Command-Help.html#cmdsets-cmdlistcmdsets","text":"list command sets defined on an object Usage: cmdsets <obj> This displays all cmdsets assigned to a user. Defaults to yourself. key: cmdsets aliases: listcmsets locks : \"cmd:perm(listcmdsets) or perm(Builder)\" help_category : \"Building\" Source: class CmdListCmdSets in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"cmdsets (CmdListCmdSets)"},{"location":"Default-Command-Help.html#command-objmanipcommand","text":"This is a parent class for some of the defining objmanip commands since they tend to have some more variables to define new objects. Each object definition can have several components. First is always a name, followed by an optional alias list and finally an some optional data, such as a typeclass or a location. A comma ',' separates different objects. Like this: name1;alias;alias;alias:option, name2;alias;alias ... Spaces between all components are stripped. A second situation is attribute manipulation. Such commands are simpler and offer combinations objname/attr/attr/attr, objname/attr, ... key: command aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class ObjManipCommand in building.py . Belongs to command set ' ' of class <Unknown> in .","title":"command (ObjManipCommand)"},{"location":"Default-Command-Help.html#copy-cmdcopy","text":"copy an object and its properties Usage: copy[/reset] <original obj> [= <new_name>][;alias;alias..] [:<new_location>] [,<new_name2> ...] switch: reset - make a 'clean' copy off the object, thus removing any changes that might have been made to the original since it was first created. Create one or more copies of an object. If you don't supply any targets, one exact copy of the original object will be created with the name *_copy. key: copy aliases: locks : \"cmd:perm(copy) or perm(Builder)\" help_category : \"Building\" Source: class CmdCopy in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"copy (CmdCopy)"},{"location":"Default-Command-Help.html#cpattr-cmdcpattr","text":"copy attributes between objects Usage: cpattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] cpattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...] cpattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] cpattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...] Switches: move - delete the attribute from the source object after copying. Example: cpattr coolness = Anna/chillout, Anna/nicety, Tom/nicety -> copies the coolness attribute (defined on yourself), to attributes on Anna and Tom. Copy the attribute one object to one or more attributes on another object. If you don't supply a source object, yourself is used. key: cpattr aliases: locks : \"cmd:perm(cpattr) or perm(Builder)\" help_category : \"Building\" Source: class CmdCpAttr in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"cpattr (CmdCpAttr)"},{"location":"Default-Command-Help.html#create-cmdcreate","text":"create new objects Usage: create[/drop] <objname>[;alias;alias...][:typeclass], <objname>... switch: drop - automatically drop the new object into your current location (this is not echoed). This also sets the new object's home to the current location rather than to you. Creates one or more new objects. If typeclass is given, the object is created as a child of this typeclass. The typeclass script is assumed to be located under types/ and any further directory structure is given in Python notation. So if you have a correct typeclass 'RedButton' defined in types/examples/red_button.py, you could create a new object of this type like this: create/drop button;red : examples.red_button.RedButton key: create aliases: locks : \"cmd:perm(create) or perm(Builder)\" help_category : \"Building\" Source: class CmdCreate in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"create (CmdCreate)"},{"location":"Default-Command-Help.html#desc-cmddesc","text":"describe an object or the current room. Usage: desc [<obj> =] <description> Switches: edit - Open up a line editor for more advanced editing. Sets the \"desc\" attribute on an object. If an object is not given, describe the current room. key: desc aliases: describe locks : \"cmd:perm(desc) or perm(Builder)\" help_category : \"Building\" Source: class CmdDesc in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"desc (CmdDesc)"},{"location":"Default-Command-Help.html#destroy-cmddestroy","text":"permanently delete objects Usage: destroy[/switches] [obj, obj2, obj3, [dbref-dbref], ...] Switches: override - The destroy command will usually avoid accidentally destroying account objects. This switch overrides this safety. force - destroy without confirmation. Examples: destroy house, roof, door, 44-78 destroy 5-10, flower, 45 destroy/force north Destroys one or many objects. If dbrefs are used, a range to delete can be given, e.g. 4-10. Also the end points will be deleted. This command displays a confirmation before destroying, to make sure of your choice. You can specify the /force switch to bypass this confirmation. key: destroy aliases: del , delete locks : \"cmd:perm(destroy) or perm(Builder)\" help_category : \"Building\" Source: class CmdDestroy in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"destroy (CmdDestroy)"},{"location":"Default-Command-Help.html#dig-cmddig","text":"build new rooms and connect them to the current location Usage: dig[/switches] <roomname>[;alias;alias...][:typeclass] [= <exit_to_there>[;alias][:typeclass]] [, <exit_to_here>[;alias][:typeclass]] Switches: tel or teleport - move yourself to the new room Examples: dig kitchen = north;n, south;s dig house:myrooms.MyHouseTypeclass dig sheer cliff;cliff;sheer = climb up, climb down This command is a convenient way to build rooms quickly; it creates the new room and you can optionally set up exits back and forth between your current room and the new one. You can add as many aliases as you like to the name of the room and the exits in question; an example would be 'north;no;n'. key: dig aliases: locks : \"cmd:perm(dig) or perm(Builder)\" help_category : \"Building\" Source: class CmdDig in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"dig (CmdDig)"},{"location":"Default-Command-Help.html#examine-cmdexamine","text":"get detailed information about an object Usage: examine [<object>[/attrname]] examine [*<account>[/attrname]] Switch: account - examine an Account (same as adding *) object - examine an Object (useful when OOC) The examine command shows detailed game info about an object and optionally a specific attribute on it. If object is not specified, the current location is examined. Append a * before the search string to examine an account. key: examine aliases: ex , exam locks : \"cmd:perm(examine) or perm(Builder)\" help_category : \"Building\" Source: class CmdExamine in building.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"examine (CmdExamine)"},{"location":"Default-Command-Help.html#find-cmdfind","text":"search the database for objects Usage: find[/switches] <name or dbref or *account> [= dbrefmin[-dbrefmax]] locate - this is a shorthand for using the /loc switch. Switches: room - only look for rooms (location=None) exit - only look for exits (destination!=None) char - only look for characters (BASE_CHARACTER_TYPECLASS) exact - only exact matches are returned. loc - display object location if exists and match has one result startswith - search for names starting with the string, rather than containing Searches the database for an object of a particular name or exact #dbref. Use *accountname to search for an account. The switches allows for limiting object matches to certain game entities. Dbrefmin and dbrefmax limits matches to within the given dbrefs range, or above/below if only one is given. key: find aliases: locate , search locks : \"cmd:perm(find) or perm(Builder)\" help_category : \"Building\" Source: class CmdFind in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"find (CmdFind)"},{"location":"Default-Command-Help.html#link-cmdlink","text":"link existing rooms together with exits Usage: link[/switches] <object> = <target> link[/switches] <object> = link[/switches] <object> Switch: twoway - connect two exits. For this to work, BOTH <object> and <target> must be exit objects. If <object> is an exit, set its destination to <target>. Two-way operation instead sets the destination to the *locations* of the respective given arguments. The second form (a lone =) sets the destination to None (same as the unlink command) and the third form (without =) just shows the currently set destination. key: link aliases: locks : \"cmd:perm(link) or perm(Builder)\" help_category : \"Building\" Source: class CmdLink in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"link (CmdLink)"},{"location":"Default-Command-Help.html#lock-cmdlock","text":"assign a lock definition to an object Usage: lock <object or *account>[ = <lockstring>] or lock[/switch] <object or *account>/<access_type> Switch: del - delete given access type view - view lock associated with given access type (default) If no lockstring is given, shows all locks on object. Lockstring is of the form access_type:[NOT] func1(args)[ AND|OR][ NOT] func2(args) ...] Where func1, func2 ... valid lockfuncs with or without arguments. Separator expressions need not be capitalized. For example: 'get: id(25) or perm(Admin)' The 'get' lock access_type is checked e.g. by the 'get' command. An object locked with this example lock will only be possible to pick up by Admins or by an object with id=25. You can add several access_types after one another by separating them by ';', i.e: 'get:id(25); delete:perm(Builder)' key: lock aliases: locks locks : \"cmd: perm(locks) or perm(Builder)\" help_category : \"Building\" Source: class CmdLock in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"lock (CmdLock)"},{"location":"Default-Command-Help.html#mvattr-cmdmvattr","text":"move attributes between objects Usage: mvattr[/switch] <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] mvattr[/switch] <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...] mvattr[/switch] <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...] mvattr[/switch] <attr> = <obj1>[,<obj2>,<obj3>,...] Switches: copy - Don't delete the original after moving. Move an attribute from one object to one or more attributes on another object. If you don't supply a source object, yourself is used. key: mvattr aliases: locks : \"cmd:perm(mvattr) or perm(Builder)\" help_category : \"Building\" Source: class CmdMvAttr in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"mvattr (CmdMvAttr)"},{"location":"Default-Command-Help.html#name-cmdname","text":"change the name and/or aliases of an object Usage: name <obj> = <newname>;alias1;alias2 Rename an object to something new. Use *obj to rename an account. key: name aliases: rename locks : \"cmd:perm(rename) or perm(Builder)\" help_category : \"Building\" Source: class CmdName in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"name (CmdName)"},{"location":"Default-Command-Help.html#open-cmdopen","text":"open a new exit from the current room Usage: open <new exit>[;alias;alias..][:typeclass] [,<return exit>[;alias;..][:typeclass]]] = <destination> Handles the creation of exits. If a destination is given, the exit will point there. The <return exit> argument sets up an exit at the destination leading back to the current room. Destination name can be given both as a #dbref and a name, if that name is globally unique. key: open aliases: locks : \"cmd:perm(open) or perm(Builder)\" help_category : \"Building\" Source: class CmdOpen in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"open (CmdOpen)"},{"location":"Default-Command-Help.html#script-cmdscript","text":"attach a script to an object Usage: script[/switch] <obj> [= script_path or <scriptkey>] Switches: start - start all non-running scripts on object, or a given script only stop - stop all scripts on objects, or a given script only If no script path/key is given, lists all scripts active on the given object. Script path can be given from the base location for scripts as given in settings. If adding a new script, it will be started automatically (no /start switch is needed). Using the /start or /stop switches on an object without specifying a script key/path will start/stop ALL scripts on the object. key: script aliases: addscript locks : \"cmd:perm(script) or perm(Builder)\" help_category : \"Building\" Source: class CmdScript in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"script (CmdScript)"},{"location":"Default-Command-Help.html#set-cmdsetattribute","text":"set attribute on an object or account Usage: set <obj>/<attr> = <value> set <obj>/<attr> = set <obj>/<attr> set *<account>/<attr> = <value> Switch: edit: Open the line editor (string values only) script: If we're trying to set an attribute on a script channel: If we're trying to set an attribute on a channel account: If we're trying to set an attribute on an account room: Setting an attribute on a room (global search) exit: Setting an attribute on an exit (global search) char: Setting an attribute on a character (global search) character: Alias for char, as above. Sets attributes on objects. The second example form above clears a previously set attribute while the third form inspects the current value of the attribute (if any). The last one (with the star) is a shortcut for operating on a player Account rather than an Object. The most common data to save with this command are strings and numbers. You can however also set Python primitives such as lists, dictionaries and tuples on objects (this might be important for the functionality of certain custom objects). This is indicated by you starting your value with one of |c'|n, |c\"|n, |c(|n, |c[|n or |c{ |n. Once you have stored a Python primitive as noted above, you can include |c[<key>]|n in <attr> to reference nested values in e.g. a list or dict. Remember that if you use Python primitives like this, you must write proper Python syntax too - notably you must include quotes around your strings or you will get an error. key: set aliases: locks : \"cmd:perm(set) or perm(Builder)\" help_category : \"Building\" Source: class CmdSetAttribute in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"set (CmdSetAttribute)"},{"location":"Default-Command-Help.html#sethome-cmdsethome","text":"set an object's home location Usage: sethome <obj> [= <home_location>] sethom <obj> The \"home\" location is a \"safety\" location for objects; they will be moved there if their current location ceases to exist. All objects should always have a home location for this reason. It is also a convenient target of the \"home\" command. If no location is given, just view the object's home location. key: sethome aliases: locks : \"cmd:perm(sethome) or perm(Builder)\" help_category : \"Building\" Source: class CmdSetHome in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"sethome (CmdSetHome)"},{"location":"Default-Command-Help.html#spawn-cmdspawn","text":"spawn objects from prototype Usage: spawn[/noloc] <prototype_key> spawn[/noloc] <prototype_dict> spawn/search [prototype_keykey][;tag[,tag]] spawn/list [tag, tag, ...] spawn/show [<prototype_key>] spawn/update <prototype_key> spawn/save <prototype_dict> spawn/edit [<prototype_key>] olc - equivalent to spawn/edit Switches: noloc - allow location to be None if not specified explicitly. Otherwise, location will default to caller's current location. search - search prototype by name or tags. list - list available prototypes, optionally limit by tags. show, examine - inspect prototype by key. If not given, acts like list. save - save a prototype to the database. It will be listable by /list. delete - remove a prototype from database, if allowed to. update - find existing objects with the same prototype_key and update them with latest version of given prototype. If given with /save, will auto-update all objects with the old version of the prototype without asking first. edit, olc - create/manipulate prototype in a menu interface. Example: spawn GOBLIN spawn {\"key\":\"goblin\", \"typeclass\":\"monster.Monster\", \"location\":\"#2\"} spawn/save {\"key\": \"grunt\", prototype: \"goblin\"};;mobs;edit:all() Dictionary keys: |wprototype_parent |n - name of parent prototype to use. Required if typeclass is not set. Can be a path or a list for multiple inheritance (inherits left to right). If set one of the parents must have a typeclass. |wtypeclass |n - string. Required if prototype_parent is not set. |wkey |n - string, the main object identifier |wlocation |n - this should be a valid object or #dbref |whome |n - valid object or #dbref |wdestination|n - only valid for exits (object or dbref) |wpermissions|n - string or list of permission strings |wlocks |n - a lock-string |waliases |n - string or list of strings. |wndb_|n<name> - value of a nattribute (ndb_ is stripped) |wprototype_key|n - name of this prototype. Unique. Used to store/retrieve from db and update existing prototyped objects if desired. |wprototype_desc|n - desc of this prototype. Used in listings |wprototype_locks|n - locks of this prototype. Limits who may use prototype |wprototype_tags|n - tags of this prototype. Used to find prototype any other keywords are interpreted as Attributes and their values. The available prototypes are defined globally in modules set in settings.PROTOTYPE_MODULES. If spawn is used without arguments it displays a list of available prototypes. key: spawn aliases: olc locks : \"cmd:perm(spawn) or perm(Builder)\" help_category : \"Building\" Source: class CmdSpawn in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"spawn (CmdSpawn)"},{"location":"Default-Command-Help.html#tag-cmdtag","text":"handles the tags of an object Usage: tag[/del] <obj> [= <tag>[:<category>]] tag/search <tag>[:<category] Switches: search - return all objects with a given Tag del - remove the given tag. If no tag is specified, clear all tags on object. Manipulates and lists tags on objects. Tags allow for quick grouping of and searching for objects. If only <obj> is given, list all tags on the object. If /search is used, list objects with the given tag. The category can be used for grouping tags themselves, but it should be used with restrain - tags on their own are usually enough to for most grouping schemes. key: tag aliases: tags locks : \"cmd:perm(tag) or perm(Builder)\" help_category : \"Building\" Source: class CmdTag in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"tag (CmdTag)"},{"location":"Default-Command-Help.html#tel-cmdteleport","text":"teleport object to another location Usage: tel/switch [<object> to||=] <target location> Examples: tel Limbo tel/quiet box = Limbo tel/tonone box Switches: quiet - don't echo leave/arrive messages to the source/target locations for the move. intoexit - if target is an exit, teleport INTO the exit object instead of to its destination tonone - if set, teleport the object to a None-location. If this switch is set, <target location> is ignored. Note that the only way to retrieve an object from a None location is by direct #dbref reference. A puppeted object cannot be moved to None. loc - teleport object to the target's location instead of its contents Teleports an object somewhere. If no object is given, you yourself is teleported to the target location. key: tel aliases: teleport locks : \"cmd:perm(teleport) or perm(Builder)\" help_category : \"Building\" Source: class CmdTeleport in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"tel (CmdTeleport)"},{"location":"Default-Command-Help.html#tunnel-cmdtunnel","text":"create new rooms in cardinal directions only Usage: tunnel[/switch] <direction>[:typeclass] [= <roomname>[;alias;alias;...][:typeclass]] Switches: oneway - do not create an exit back to the current location tel - teleport to the newly created room Example: tunnel n tunnel n = house;mike's place;green building This is a simple way to build using pre-defined directions: |wn,ne,e,se,s,sw,w,nw|n (north, northeast etc) |wu,d|n (up and down) |wi,o|n (in and out) The full names (north, in, southwest, etc) will always be put as main name for the exit, using the abbreviation as an alias (so an exit will always be able to be used with both \"north\" as well as \"n\" for example). Opposite directions will automatically be created back from the new room unless the /oneway switch is given. For more flexibility and power in creating rooms, use dig. key: tunnel aliases: tun locks : \"cmd: perm(tunnel) or perm(Builder)\" help_category : \"Building\" Source: class CmdTunnel in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"tunnel (CmdTunnel)"},{"location":"Default-Command-Help.html#typeclass-cmdtypeclass","text":"set or change an object's typeclass Usage: typeclass[/switch] <object> [= typeclass.path] type '' parent '' typeclass/list/show [typeclass.path] swap - this is a shorthand for using /force/reset flags. update - this is a shorthand for using the /force/reload flag. Switch: show, examine - display the current typeclass of object (default) or, if given a typeclass path, show the docstring of that typeclass. update - *only* re-run at_object_creation on this object meaning locks or other properties set later may remain. reset - clean out *all* the attributes and properties on the object - basically making this a new clean object. force - change to the typeclass also if the object already has a typeclass of the same name. list - show available typeclasses. Only typeclasses in modules actually imported or used from somewhere in the code will show up here (those typeclasses are still available if you know the path) Example: type button = examples.red_button.RedButton If the typeclass_path is not given, the current object's typeclass is assumed. View or set an object's typeclass. If setting, the creation hooks of the new typeclass will be run on the object. If you have clashing properties on the old class, use /reset. By default you are protected from changing to a typeclass of the same name as the one you already have - use /force to override this protection. The given typeclass must be identified by its location using python dot-notation pointing to the correct module and class. If no typeclass is given (or a wrong typeclass is given). Errors in the path or new typeclass will lead to the old typeclass being kept. The location of the typeclass module is searched from the default typeclass directory, as defined in the server settings. key: typeclass aliases: type , swap , update , parent locks : \"cmd:perm(typeclass) or perm(Builder)\" help_category : \"Building\" Source: class CmdTypeclass in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"typeclass (CmdTypeclass)"},{"location":"Default-Command-Help.html#unlink-cmdunlink","text":"remove exit-connections between rooms Usage: unlink <Object> Unlinks an object, for example an exit, disconnecting it from whatever it was connected to. key: unlink aliases: locks : \"cmd:perm(unlink) or perm(Builder)\" help_category : \"Building\" Source: class CmdUnLink in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"unlink (CmdUnLink)"},{"location":"Default-Command-Help.html#wipe-cmdwipe","text":"clear all attributes from an object Usage: wipe <object>[/<attr>[/<attr>...]] Example: wipe box wipe box/colour Wipes all of an object's attributes, or optionally only those matching the given attribute-wildcard search string. key: wipe aliases: locks : \"cmd:perm(wipe) or perm(Builder)\" help_category : \"Building\" Source: class CmdWipe in building.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"wipe (CmdWipe)"},{"location":"Default-Command-Help.html#commspy","text":"View comms.py source","title":"comms.py"},{"location":"Default-Command-Help.html#addcom-cmdaddcom","text":"add a channel alias and/or subscribe to a channel Usage: addcom [alias=] <channel> Joins a given channel. If alias is given, this will allow you to refer to the channel by this alias rather than the full channel name. Subsequent calls of this command can be used to add multiple aliases to an already joined channel. key: addcom aliases: chanalias , aliaschan locks : \"cmd:not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdAddCom in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"addcom (CmdAddCom)"},{"location":"Default-Command-Help.html#allcom-cmdallcom","text":"perform admin operations on all channels Usage: allcom [on | off | who | destroy] Allows the user to universally turn off or on all channels they are on, as well as perform a 'who' for all channels they are on. Destroy deletes all channels that you control. Without argument, works like comlist. key: allcom aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdAllCom in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"allcom (CmdAllCom)"},{"location":"Default-Command-Help.html#cboot-cmdcboot","text":"kick an account from a channel you control Usage: cboot[/quiet] <channel> = <account> [:reason] Switch: quiet - don't notify the channel Kicks an account or object from a channel you control. key: cboot aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCBoot in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"cboot (CmdCBoot)"},{"location":"Default-Command-Help.html#ccreate-cmdchannelcreate","text":"create a new channel Usage: ccreate <new channel>[;alias;alias...] = description Creates a new channel owned by you. key: ccreate aliases: channelcreate locks : \"cmd:not pperm(channel_banned) and pperm(Player)\" help_category : \"Comms\" Source: class CmdChannelCreate in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"ccreate (CmdChannelCreate)"},{"location":"Default-Command-Help.html#cdesc-cmdcdesc","text":"describe a channel you control Usage: cdesc <channel> = <description> Changes the description of the channel as shown in channel lists. key: cdesc aliases: locks : \"cmd:not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCdesc in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"cdesc (CmdCdesc)"},{"location":"Default-Command-Help.html#cdestroy-cmdcdestroy","text":"destroy a channel you created Usage: cdestroy <channel> Destroys a channel that you control. key: cdestroy aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCdestroy in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"cdestroy (CmdCdestroy)"},{"location":"Default-Command-Help.html#cemit-cmdcemit","text":"send an admin message to a channel you control Usage: cemit[/switches] <channel> = <message> Switches: sendername - attach the sender's name before the message quiet - don't echo the message back to sender Allows the user to broadcast a message over a channel as long as they control it. It does not show the user's name unless they provide the /sendername switch. key: cemit aliases: cmsg locks : \"cmd: not pperm(channel_banned) and pperm(Player)\" help_category : \"Comms\" Source: class CmdCemit in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"cemit (CmdCemit)"},{"location":"Default-Command-Help.html#channels-cmdchannels","text":"list all channels available to you Usage: channels clist comlist Lists all channels available to you, whether you listen to them or not. Use 'comlist' to only view your current channel subscriptions. Use addcom/delcom to join and leave channels key: channels aliases: comlist , channellist , clist , chanlist , all channels locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdChannels in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"channels (CmdChannels)"},{"location":"Default-Command-Help.html#clock-cmdclock","text":"change channel locks of a channel you control Usage: clock <channel> [= <lockstring>] Changes the lock access restrictions of a channel. If no lockstring was given, view the current lock definitions. key: clock aliases: locks : \"cmd:not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdClock in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"clock (CmdClock)"},{"location":"Default-Command-Help.html#cwho-cmdcwho","text":"show who is listening to a channel Usage: cwho <channel> List who is connected to a given channel you have access to. key: cwho aliases: locks : \"cmd: not pperm(channel_banned)\" help_category : \"Comms\" Source: class CmdCWho in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"cwho (CmdCWho)"},{"location":"Default-Command-Help.html#delcom-cmddelcom","text":"remove a channel alias and/or unsubscribe from channel Usage: delcom <alias or channel> delcom/all <channel> If the full channel name is given, unsubscribe from the channel. If an alias is given, remove the alias but don't unsubscribe. If the 'all' switch is used, remove all aliases for that channel. key: delcom aliases: delaliaschan , delchanalias locks : \"cmd:not perm(channel_banned)\" help_category : \"Comms\" Source: class CmdDelCom in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"delcom (CmdDelCom)"},{"location":"Default-Command-Help.html#irc2chan-cmdirc2chan","text":"Link an evennia channel to an external IRC channel Usage: irc2chan[/switches] <evennia_channel> = <ircnetwork> <port> <#irchannel> <botname>[:typeclass] irc2chan/delete botname|#dbid Switches: /delete - this will delete the bot and remove the irc connection to the channel. Requires the botname or #dbid as input. /remove - alias to /delete /disconnect - alias to /delete /list - show all irc<->evennia mappings /ssl - use an SSL-encrypted connection Example: irc2chan myircchan = irc.dalnet.net 6667 #mychannel evennia-bot irc2chan public = irc.freenode.net 6667 #evgaming #evbot:accounts.mybot.MyBot This creates an IRC bot that connects to a given IRC network and channel. If a custom typeclass path is given, this will be used instead of the default bot class. The bot will relay everything said in the evennia channel to the IRC channel and vice versa. The bot will automatically connect at server start, so this command need only be given once. The /disconnect switch will permanently delete the bot. To only temporarily deactivate it, use the |wservices|n command instead. Provide an optional bot class path to use a custom bot. key: irc2chan aliases: locks : \"cmd:serversetting(IRC_ENABLED) and pperm(Developer)\" help_category : \"Comms\" Source: class CmdIRC2Chan in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"irc2chan (CmdIRC2Chan)"},{"location":"Default-Command-Help.html#page-cmdpage","text":"send a private message to another account Usage: page[/switches] [<account>,<account>,... = <message>] tell '' page <number> Switch: last - shows who you last messaged list - show your last <number> of tells/pages (default) Send a message to target user (if online). If no argument is given, you will get a list of your latest messages. key: page aliases: tell locks : \"cmd:not pperm(page_banned)\" help_category : \"Comms\" Source: class CmdPage in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"page (CmdPage)"},{"location":"Default-Command-Help.html#rss2chan-cmdrss2chan","text":"link an evennia channel to an external RSS feed Usage: rss2chan[/switches] <evennia_channel> = <rss_url> Switches: /disconnect - this will stop the feed and remove the connection to the channel. /remove - \" /list - show all rss->evennia mappings Example: rss2chan rsschan = http://code.google.com/feeds/p/evennia/updates/basic This creates an RSS reader that connects to a given RSS feed url. Updates will be echoed as a title and news link to the given channel. The rate of updating is set with the RSS_UPDATE_INTERVAL variable in settings (default is every 10 minutes). When disconnecting you need to supply both the channel and url again so as to identify the connection uniquely. key: rss2chan aliases: locks : \"cmd:serversetting(RSS_ENABLED) and pperm(Developer)\" help_category : \"Comms\" Source: class CmdRSS2Chan in comms.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"rss2chan (CmdRSS2Chan)"},{"location":"Default-Command-Help.html#generalpy","text":"View general.py source","title":"general.py"},{"location":"Default-Command-Help.html#access-cmdaccess","text":"show your current game access Usage: access This command shows you the permission hierarchy and which permission groups you are a member of. key: access aliases: groups , hierarchy locks : \"cmd:all()\" help_category : \"General\" Source: class CmdAccess in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"access (CmdAccess)"},{"location":"Default-Command-Help.html#drop-cmddrop","text":"drop something Usage: drop <obj> Lets you drop an object from your inventory into the location you are currently in. key: drop aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdDrop in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"drop (CmdDrop)"},{"location":"Default-Command-Help.html#get-cmdget","text":"pick up something Usage: get <obj> Picks up an object from your location and puts it in your inventory. key: get aliases: grab locks : \"cmd:all()\" help_category : \"General\" Source: class CmdGet in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"get (CmdGet)"},{"location":"Default-Command-Help.html#give-cmdgive","text":"give away something to someone Usage: give <inventory obj> <to||=> <target> Gives an items from your inventory to another character, placing it in their inventory. key: give aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdGive in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"give (CmdGive)"},{"location":"Default-Command-Help.html#home-cmdhome","text":"move to your character's home location Usage: home Teleports you to your home location. key: home aliases: locks : \"cmd:perm(home) or perm(Builder)\" help_category : \"General\" Source: class CmdHome in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"home (CmdHome)"},{"location":"Default-Command-Help.html#inventory-cmdinventory","text":"view inventory Usage: inventory inv Shows your inventory. key: inventory aliases: inv , i locks : \"cmd:all()\" help_category : \"General\" Source: class CmdInventory in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"inventory (CmdInventory)"},{"location":"Default-Command-Help.html#look-cmdlook","text":"look at location or object Usage: look look <obj> look *<account> Observes your location or objects in your vicinity. key: look aliases: ls , l locks : \"cmd:all()\" help_category : \"General\" Source: class CmdLook in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"look (CmdLook)"},{"location":"Default-Command-Help.html#nick-cmdnick","text":"define a personal alias/nick by defining a string to match and replace it with another on the fly Usage: nick[/switches] <string> [= [replacement_string]] nick[/switches] <template> = <replacement_template> nick/delete <string> or number nicks Switches: inputline - replace on the inputline (default) object - replace on object-lookup account - replace on account-lookup list - show all defined aliases (also \"nicks\" works) delete - remove nick by index in /list clearall - clear all nicks Examples: nick hi = say Hello, I'm Sarah! nick/object tom = the tall man nick build $1 $2 = create/drop $1;$2 nick tell $1 $2=page $1=$2 nick tm?$1=page tallman=$1 nick tm\\=$1=page tallman=$1 A 'nick' is a personal string replacement. Use $1, $2, ... to catch arguments. Put the last $-marker without an ending space to catch all remaining text. You can also use unix-glob matching for the left-hand side <string>: * - matches everything ? - matches 0 or 1 single characters [abcd] - matches these chars in any order [!abcd] - matches everything not among these chars \\= - escape literal '=' you want in your <string> Note that no objects are actually renamed or changed by this command - your nicks are only available to you. If you want to permanently add keywords to an object for everyone to use, you need build privileges and the alias command. key: nick aliases: nickname , nicks locks : \"cmd:all()\" help_category : \"General\" Source: class CmdNick in general.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"nick (CmdNick)"},{"location":"Default-Command-Help.html#pose-cmdpose","text":"strike a pose Usage: pose <pose text> pose's <pose text> Example: pose is standing by the wall, smiling. -> others will see: Tom is standing by the wall, smiling. Describe an action being taken. The pose text will automatically begin with your name. key: pose aliases: emote , : locks : \"cmd:all()\" help_category : \"General\" Source: class CmdPose in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"pose (CmdPose)"},{"location":"Default-Command-Help.html#say-cmdsay","text":"speak as your character Usage: say <message> Talk to those in your current location. key: say aliases: ' , \" locks : \"cmd:all()\" help_category : \"General\" Source: class CmdSay in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"say (CmdSay)"},{"location":"Default-Command-Help.html#setdesc-cmdsetdesc","text":"describe yourself Usage: setdesc <description> Add a description to yourself. This will be visible to people when they look at you. key: setdesc aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdSetDesc in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"setdesc (CmdSetDesc)"},{"location":"Default-Command-Help.html#whisper-cmdwhisper","text":"Speak privately as your character to another Usage: whisper <character> = <message> whisper <char1>, <char2> = <message> Talk privately to one or more characters in your current location, without others in the room being informed. key: whisper aliases: locks : \"cmd:all()\" help_category : \"General\" Source: class CmdWhisper in general.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"whisper (CmdWhisper)"},{"location":"Default-Command-Help.html#helppy","text":"View help.py source","title":"help.py"},{"location":"Default-Command-Help.html#help-cmdhelp","text":"View help or a list of topics Usage: help <topic or command> help list help all This will search for help on commands and other topics related to the game. key: help aliases: ? locks : \"cmd:all()\" help_category : \"General\" Source: class CmdHelp in help.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"help (CmdHelp)"},{"location":"Default-Command-Help.html#sethelp-cmdsethelp","text":"Edit the help database. Usage: help[/switches] <topic>[[;alias;alias][,category[,locks]] [= <text>] Switches: edit - open a line editor to edit the topic's help text. replace - overwrite existing help topic. append - add text to the end of existing topic with a newline between. extend - as append, but don't add a newline. delete - remove help topic. Examples: sethelp throw = This throws something at ... sethelp/append pickpocketing,Thievery = This steals ... sethelp/replace pickpocketing, ,attr(is_thief) = This steals ... sethelp/edit thievery This command manipulates the help database. A help entry can be created, appended/merged to and deleted. If you don't assign a category, the \"General\" category will be used. If no lockstring is specified, default is to let everyone read the help file. key: sethelp aliases: locks : \"cmd:perm(Helper)\" help_category : \"Building\" Source: class CmdSetHelp in help.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"sethelp (CmdSetHelp)"},{"location":"Default-Command-Help.html#systempy","text":"View system.py source","title":"system.py"},{"location":"Default-Command-Help.html#about-cmdabout","text":"show Evennia info Usage: about Display info about the game engine. key: about aliases: version locks : \"cmd:all()\" help_category : \"System\" Source: class CmdAbout in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"about (CmdAbout)"},{"location":"Default-Command-Help.html#objects-cmdobjects","text":"statistics on objects in the database Usage: objects [<nr>] Gives statictics on objects in database as well as a list of <nr> latest objects in database. If not given, <nr> defaults to 10. key: objects aliases: listobjs , db , stats , listobjects locks : \"cmd:perm(listobjects) or perm(Builder)\" help_category : \"System\" Source: class CmdObjects in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"objects (CmdObjects)"},{"location":"Default-Command-Help.html#py-cmdpy","text":"execute a snippet of python code Usage: py [cmd] py/edit py/time <cmd> py/clientraw <cmd> py/noecho Switches: time - output an approximate execution time for <cmd> edit - open a code editor for multi-line code experimentation clientraw - turn off all client-specific escaping. Note that this may lead to different output depending on prototocol (such as angular brackets being parsed as HTML in the webclient but not in telnet clients) noecho - in Python console mode, turn off the input echo (e.g. if your client does this for you already) Without argument, open a Python console in-game. This is a full console, accepting multi-line Python code for testing and debugging. Type `exit()` to return to the game. If Evennia is reloaded, the console will be closed. Enter a line of instruction after the 'py' command to execute it immediately. Separate multiple commands by ';' or open the code editor using the /edit switch (all lines added in editor will be executed immediately when closing or using the execute command in the editor). A few variables are made available for convenience in order to offer access to the system (you can import more at execution time). Available variables in py environment: self, me : caller here : caller.location evennia : the evennia API inherits_from(obj, parent) : check object inheritance You can explore The evennia API from inside the game by calling the `__doc__` property on entities: py evennia.__doc__ py evennia.managers.__doc__ |rNote: In the wrong hands this command is a severe security risk. It should only be accessible by trusted server admins/superusers.|n key: py aliases: ! locks : \"cmd:perm(py) or perm(Developer)\" help_category : \"System\" Source: class CmdPy in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"py (CmdPy)"},{"location":"Default-Command-Help.html#reload-cmdreload","text":"reload the server Usage: reload [reason] This restarts the server. The Portal is not affected. Non-persistent scripts will survive a reload (use reset to purge) and at_reload() hooks will be called. key: reload aliases: restart locks : \"cmd:perm(reload) or perm(Developer)\" help_category : \"System\" Source: class CmdReload in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"reload (CmdReload)"},{"location":"Default-Command-Help.html#reset-cmdreset","text":"reset and reboot the server Usage: reset Notes: For normal updating you are recommended to use reload rather than this command. Use shutdown for a complete stop of everything. This emulates a cold reboot of the Server component of Evennia. The difference to shutdown is that the Server will auto-reboot and that it does not affect the Portal, so no users will be disconnected. Contrary to reload however, all shutdown hooks will be called and any non-database saved scripts, ndb-attributes, cmdsets etc will be wiped. key: reset aliases: reboot locks : \"cmd:perm(reload) or perm(Developer)\" help_category : \"System\" Source: class CmdReset in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"reset (CmdReset)"},{"location":"Default-Command-Help.html#scripts-cmdscripts","text":"list and manage all running scripts Usage: scripts[/switches] [#dbref, key, script.path or <obj>] Switches: start - start a script (must supply a script path) stop - stops an existing script kill - kills a script - without running its cleanup hooks validate - run a validation on the script(s) If no switches are given, this command just views all active scripts. The argument can be either an object, at which point it will be searched for all scripts defined on it, or a script name or #dbref. For using the /stop switch, a unique script #dbref is required since whole classes of scripts often have the same name. Use script for managing commands on objects. key: scripts aliases: globalscript , listscripts locks : \"cmd:perm(listscripts) or perm(Admin)\" help_category : \"System\" Source: class CmdScripts in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"scripts (CmdScripts)"},{"location":"Default-Command-Help.html#server-cmdserverload","text":"show server load and memory statistics Usage: server[/mem] Switches: mem - return only a string of the current memory usage flushmem - flush the idmapper cache This command shows server load statistics and dynamic memory usage. It also allows to flush the cache of accessed database objects. Some Important statistics in the table: |wServer load|n is an average of processor usage. It's usually between 0 (no usage) and 1 (100% usage), but may also be temporarily higher if your computer has multiple CPU cores. The |wResident/Virtual memory|n displays the total memory used by the server process. Evennia |wcaches|n all retrieved database entities when they are loaded by use of the idmapper functionality. This allows Evennia to maintain the same instances of an entity and allowing non-persistent storage schemes. The total amount of cached objects are displayed plus a breakdown of database object types. The |wflushmem|n switch allows to flush the object cache. Please note that due to how Python's memory management works, releasing caches may not show you a lower Residual/Virtual memory footprint, the released memory will instead be re-used by the program. key: server aliases: serverload , serverprocess locks : \"cmd:perm(list) or perm(Developer)\" help_category : \"System\" Source: class CmdServerLoad in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"server (CmdServerLoad)"},{"location":"Default-Command-Help.html#service-cmdservice","text":"manage system services Usage: service[/switch] <service> Switches: list - shows all available services (default) start - activates or reactivate a service stop - stops/inactivate a service (can often be restarted) delete - tries to permanently remove a service Service management system. Allows for the listing, starting, and stopping of services. If no switches are given, services will be listed. Note that to operate on the service you have to supply the full (green or red) name as given in the list. key: service aliases: services locks : \"cmd:perm(service) or perm(Developer)\" help_category : \"System\" Source: class CmdService in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"service (CmdService)"},{"location":"Default-Command-Help.html#shutdown-cmdshutdown","text":"stop the server completely Usage: shutdown [announcement] Gracefully shut down both Server and Portal. key: shutdown aliases: locks : \"cmd:perm(shutdown) or perm(Developer)\" help_category : \"System\" Source: class CmdShutdown in system.py . Belongs to command set 'DefaultAccount' of class AccountCmdSet in cmdset_account.py .","title":"shutdown (CmdShutdown)"},{"location":"Default-Command-Help.html#time-cmdtime","text":"show server time statistics Usage: time List Server time statistics such as uptime and the current time stamp. key: time aliases: uptime locks : \"cmd:perm(time) or perm(Player)\" help_category : \"System\" Source: class CmdTime in system.py . Belongs to command set 'DefaultCharacter' of class CharacterCmdSet in cmdset_character.py .","title":"time (CmdTime)"},{"location":"Default-Command-Help.html#unloggedinpy","text":"View unloggedin.py source","title":"unloggedin.py"},{"location":"Default-Command-Help.html#__unloggedin_look_command-cmdunconnectedlook","text":"look when in unlogged-in state Usage: look This is an unconnected version of the look command for simplicity. This is called by the server and kicks everything in gear. All it does is display the connect screen. key: __unloggedin_look_command aliases: look , l locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedLook in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py . OBS: This is a [[System Command|Commands]]. System commands have fixed keys and are called by the server in specific situations.","title":"__unloggedin_look_command (CmdUnconnectedLook)"},{"location":"Default-Command-Help.html#connect-cmdunconnectedconnect","text":"connect to the game Usage (at login screen): connect accountname password connect \"account name\" \"pass word\" Use the create command to first create an account before logging in. If you have spaces in your name, enclose it in double quotes. key: connect aliases: conn , con , co locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedConnect in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py .","title":"connect (CmdUnconnectedConnect)"},{"location":"Default-Command-Help.html#create-cmdunconnectedcreate","text":"create a new account account Usage (at login screen): create <accountname> <password> create \"account name\" \"pass word\" This creates a new account account. If you have spaces in your name, enclose it in double quotes. key: create aliases: cr , cre locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedCreate in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py .","title":"create (CmdUnconnectedCreate)"},{"location":"Default-Command-Help.html#help-cmdunconnectedhelp","text":"get help when in unconnected-in state Usage: help This is an unconnected version of the help command, for simplicity. It shows a pane of info. key: help aliases: ? , h locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedHelp in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py .","title":"help (CmdUnconnectedHelp)"},{"location":"Default-Command-Help.html#quit-cmdunconnectedquit","text":"quit when in unlogged-in state Usage: quit We maintain a different version of the quit command here for unconnected accounts for the sake of simplicity. The logged in version is a bit more complicated. key: quit aliases: q , qu locks : \"cmd:all()\" help_category : \"General\" Source: class CmdUnconnectedQuit in unloggedin.py . Belongs to command set 'DefaultUnloggedin' of class UnloggedinCmdSet in cmdset_unloggedin.py .","title":"quit (CmdUnconnectedQuit)"},{"location":"Default-Exit-Errors.html","text":"Evennia allows for exits to have any name. The command \"kitchen\" is a valid exit name as well as \"jump out the window\" or \"north\". An exit actually consists of two parts: an Exit Object and an Exit Command stored on said exit object. The command has the same key and aliases as the object, which is why you can see the exit in the room and just write its name to traverse it. If you try to enter the name of a non-existing exit, it is thus the same as trying a non-exising command; Evennia doesn't care about the difference: > jump out the window Command 'jump out the window' is not available. Type \"help\" for help. Many games don't need this type of freedom however. They define only the cardinal directions as valid exit names (Evennia's @tunnel command also offers this functionality). In this case, the error starts to look less logical: > west Command 'west' is not available. Maybe you meant \"@set\" or \"@reset\"? Since we for our particular game know that west is an exit direction, it would be better if the error message just told us that we couldn't go there. Adding default error commands \u00b6 To solve this you need to be aware of how to write and add new commands . What you need to do is to create new commands for all directions you want to support in your game. In this example all we'll do is echo an error message, but you could certainly consider more advanced uses. You add these commands to the default command set. Here is an example of such a set of commands: # for example in a file mygame/commands/movecommands.py from evennia import default_cmds class CmdExitError(default_cmds.MuxCommand): \"Parent class for all exit-errors.\" locks = \"cmd:all()\" arg_regex = r\"\\s|$\" auto_help = False def func(self): \"returns the error\" self.caller.msg(\"You cannot move %s.\" % self.key) class CmdExitErrorNorth(CmdExitError): key = \"north\" aliases = [\"n\"] class CmdExitErrorEast(CmdExitError): key = \"east\" aliases = [\"e\"] class CmdExitErrorSouth(CmdExitError): key = \"south\" aliases = [\"s\"] class CmdExitErrorWest(CmdExitError): key = \"west\" aliases = [\"w\"] Make sure to add the directional commands (not their parent) to the CharacterCmdSet class in mygame/commands/default_cmdsets.py : # in mygame/commands/default_cmdsets.py from commands import movecommands # [...] class CharacterCmdSet(default_cmds.CharacterCmdSet): # [...] def at_cmdset_creation(self): # [...] self.add(movecommands.CmdExitErrorNorth()) self.add(movecommands.CmdExitErrorEast()) self.add(movecommands.CmdExitErrorSouth()) self.add(movecommands.CmdExitErrorWest()) After a @reload these commands (assuming you don't get any errors - check your log) will be loaded. What happens henceforth is that if you are in a room with an Exitobject (let's say it's \"north\"), the proper Exit-command will overload your error command (also named \"north\"). But if you enter an direction without having a matching exit for it, you will fallback to your default error commands: > east You cannot move east. Further expansions by the exit system (including manipulating the way the Exit command itself is created) can be done by modifying the Exit typeclass directly. Additional Comments \u00b6 So why didn't we create a single error command above? Something like this: class CmdExitError(default_cmds.MuxCommand): \"Handles all exit-errors.\" key = \"error_cmd\" aliases = [\"north\", \"n\", \"east\", \"e\", \"south\", \"s\", \"west\", \"w\"] #[...] The anwer is that this would not work and understanding why is important in order to not be confused when working with commands and command sets. The reason it doesn't work is because Evennia's command system compares commands both by key and by aliases . If either of those match, the two commands are considered identical as far as cmdset merging system is concerned. So the above example would work fine as long as there were no Exits at all in the room. But what happens when we enter a room with an exit \"north\"? The Exit's cmdset is merged onto the default one, and since there is an alias match, the system determines our CmdExitError to be identical. It is thus overloaded by the Exit command (which also correctly defaults to a higher priority). The result is that you can go through the north exit normally but none of the error messages for the other directions are available since the single error command was completely overloaded by the single matching \"north\" exit-command.","title":"Default Exit Errors"},{"location":"Default-Exit-Errors.html#adding-default-error-commands","text":"To solve this you need to be aware of how to write and add new commands . What you need to do is to create new commands for all directions you want to support in your game. In this example all we'll do is echo an error message, but you could certainly consider more advanced uses. You add these commands to the default command set. Here is an example of such a set of commands: # for example in a file mygame/commands/movecommands.py from evennia import default_cmds class CmdExitError(default_cmds.MuxCommand): \"Parent class for all exit-errors.\" locks = \"cmd:all()\" arg_regex = r\"\\s|$\" auto_help = False def func(self): \"returns the error\" self.caller.msg(\"You cannot move %s.\" % self.key) class CmdExitErrorNorth(CmdExitError): key = \"north\" aliases = [\"n\"] class CmdExitErrorEast(CmdExitError): key = \"east\" aliases = [\"e\"] class CmdExitErrorSouth(CmdExitError): key = \"south\" aliases = [\"s\"] class CmdExitErrorWest(CmdExitError): key = \"west\" aliases = [\"w\"] Make sure to add the directional commands (not their parent) to the CharacterCmdSet class in mygame/commands/default_cmdsets.py : # in mygame/commands/default_cmdsets.py from commands import movecommands # [...] class CharacterCmdSet(default_cmds.CharacterCmdSet): # [...] def at_cmdset_creation(self): # [...] self.add(movecommands.CmdExitErrorNorth()) self.add(movecommands.CmdExitErrorEast()) self.add(movecommands.CmdExitErrorSouth()) self.add(movecommands.CmdExitErrorWest()) After a @reload these commands (assuming you don't get any errors - check your log) will be loaded. What happens henceforth is that if you are in a room with an Exitobject (let's say it's \"north\"), the proper Exit-command will overload your error command (also named \"north\"). But if you enter an direction without having a matching exit for it, you will fallback to your default error commands: > east You cannot move east. Further expansions by the exit system (including manipulating the way the Exit command itself is created) can be done by modifying the Exit typeclass directly.","title":"Adding default error commands"},{"location":"Default-Exit-Errors.html#additional-comments","text":"So why didn't we create a single error command above? Something like this: class CmdExitError(default_cmds.MuxCommand): \"Handles all exit-errors.\" key = \"error_cmd\" aliases = [\"north\", \"n\", \"east\", \"e\", \"south\", \"s\", \"west\", \"w\"] #[...] The anwer is that this would not work and understanding why is important in order to not be confused when working with commands and command sets. The reason it doesn't work is because Evennia's command system compares commands both by key and by aliases . If either of those match, the two commands are considered identical as far as cmdset merging system is concerned. So the above example would work fine as long as there were no Exits at all in the room. But what happens when we enter a room with an exit \"north\"? The Exit's cmdset is merged onto the default one, and since there is an alias match, the system determines our CmdExitError to be identical. It is thus overloaded by the Exit command (which also correctly defaults to a higher priority). The result is that you can go through the north exit normally but none of the error messages for the other directions are available since the single error command was completely overloaded by the single matching \"north\" exit-command.","title":"Additional Comments"},{"location":"Developer-Central.html","text":"This page serves as a central nexus for information on using Evennia as well as developing the library itself. General Evennia development information \u00b6 Introduction to coding with Evennia Evennia Licensing FAQ Contributing to Evennia Code Style Guide (Important!) Policy for 'MUX-like' default commands Setting up a Git environment for coding Getting started with Travis and Github for continuous integration testing Planning your own Evennia game First steps coding Evennia Translating Evennia Evennia Quirks to keep in mind. Directions for configuring PyCharm with Evennia on Windows Evennia API \u00b6 Directory Overview evennia - the flat API Running and Testing Python code Core components and protocols \u00b6 Server and Portal Sessions Configuration and module plugins The message path OOB - Out-of-band communication Inputfuncs Adding new protocols (client APIs) and services Adding new database models Running and writing unit tests Running profiling Debugging your code In-game Commands \u00b6 Command System overview Commands Command Sets Command Auto-help Typeclasses and related concepts \u00b6 General about Typeclasses Objects Characters Rooms Exits Accounts Communications Channels Scripts Global Scripts TickerHandler utils.delay MonitorHandler Attributes Nicks Tags Tags for Aliases and Permissions Other systems \u00b6 Locks Permissions Help System Signals Web Web tutorials General coding utilities Utils in evennia.utils.utils Game time Game Menus (EvMenu) Text paging/scrolling (EvMore) Text Line Editor (EvEditor) Text Tables (EvTable) Text Form generation (EvForm) Spawner and Prototypes Inlinefuncs Asynchronous execution Developer brainstorms and whitepages \u00b6 API refactoring , discussing what parts of the Evennia API needs a refactoring/cleanup/simplification Docs refactoring , discussing how to reorganize and structure this wiki/docs better going forward Webclient brainstorm , some ideas for a future webclient gui Roadmap , a tentative list of future major features Change log of big Evennia updates over time","title":"Game Development"},{"location":"Developer-Central.html#general-evennia-development-information","text":"Introduction to coding with Evennia Evennia Licensing FAQ Contributing to Evennia Code Style Guide (Important!) Policy for 'MUX-like' default commands Setting up a Git environment for coding Getting started with Travis and Github for continuous integration testing Planning your own Evennia game First steps coding Evennia Translating Evennia Evennia Quirks to keep in mind. Directions for configuring PyCharm with Evennia on Windows","title":"General Evennia development information"},{"location":"Developer-Central.html#evennia-api","text":"Directory Overview evennia - the flat API Running and Testing Python code","title":"Evennia API"},{"location":"Developer-Central.html#core-components-and-protocols","text":"Server and Portal Sessions Configuration and module plugins The message path OOB - Out-of-band communication Inputfuncs Adding new protocols (client APIs) and services Adding new database models Running and writing unit tests Running profiling Debugging your code","title":"Core components and protocols"},{"location":"Developer-Central.html#in-game-commands","text":"Command System overview Commands Command Sets Command Auto-help","title":"In-game Commands"},{"location":"Developer-Central.html#typeclasses-and-related-concepts","text":"General about Typeclasses Objects Characters Rooms Exits Accounts Communications Channels Scripts Global Scripts TickerHandler utils.delay MonitorHandler Attributes Nicks Tags Tags for Aliases and Permissions","title":"Typeclasses and related concepts"},{"location":"Developer-Central.html#other-systems","text":"Locks Permissions Help System Signals Web Web tutorials General coding utilities Utils in evennia.utils.utils Game time Game Menus (EvMenu) Text paging/scrolling (EvMore) Text Line Editor (EvEditor) Text Tables (EvTable) Text Form generation (EvForm) Spawner and Prototypes Inlinefuncs Asynchronous execution","title":"Other systems"},{"location":"Developer-Central.html#developer-brainstorms-and-whitepages","text":"API refactoring , discussing what parts of the Evennia API needs a refactoring/cleanup/simplification Docs refactoring , discussing how to reorganize and structure this wiki/docs better going forward Webclient brainstorm , some ideas for a future webclient gui Roadmap , a tentative list of future major features Change log of big Evennia updates over time","title":"Developer brainstorms and whitepages"},{"location":"Dialogues-in-events.html","text":"Next tutorial: adding a voice-operated elevator with events . This tutorial will walk you through the steps to create several dialogues with characters, using the in-game Python system . This tutorial assumes the in-game Python system is installed in your game. If it isn't, you can follow the installation steps given in the documentation on in-game Python , and come back on this tutorial once the system is installed. You do not need to read the entire documentation, it's a good reference, but not the easiest way to learn about it. Hence these tutorials. The in-game Python system allows to run code on individual objects in some situations. You don't have to modify the source code to add these features, past the installation. The entire system makes it easy to add specific features to some objects, but not all. This is why it can be very useful to create a dialogue system taking advantage of the in-game Python system. What will we try to do? In this tutorial, we are going to create a basic dialogue to have several characters automatically respond to specific messages said by others. A first example with a first character \u00b6 Let's create a character to begin with. @charcreate a merchant This will create a merchant in the room where you currently are. It doesn't have anything, like a description, you can decorate it a bit if you like. As said above, the in-game Python system consists in linking objects with arbitrary code. This code will be executed in some circumstances. Here, the circumstance is \"when someone says something in the same room\", and might be more specific like \"when someone says hello\". We'll decide what code to run (we'll actually type the code in-game). Using the vocabulary of the in-game Python system, we'll create a callback: a callback is just a set of lines of code that will run under some conditions. You can have an overview of every \"conditions\" in which callbacks can be created using the @call command (short for @callback ). You need to give it an object as argument. Here for instance, we could do: @call a merchant You should see a table with three columns, showing the list of events existing on our newly-created merchant. There are quite a lot of them, as it is, althougn no line of code has been set yet. For our system, you might be more interested by the line describing the say event: | say | 0 (0) | After another character has said something in | | | | the character's room. | We'll create a callback on the say event, called when we say \"hello\" in the merchant's room: @call/add a merchant = say hello Before seeing what this command displays, let's see the command syntax itself: @call is the command name, /add is a switch. You can read the help of the command to get the help of available switches and a brief overview of syntax. We then enter the object's name, here \"a merchant\". You can enter the ID too (\"#3\" in my case), which is useful to edit the object when you're not in the same room. You can even enter part of the name, as usual. An equal sign, a simple separator. The event's name. Here, it's \"say\". The available events are displayed when you use @call without switch. After a space, we enter the conditions in which this callback should be called. Here, the conditions represent what the other character should say. We enter \"hello\". Meaning that if someone says something containing \"hello\" in the room, the callback we are now creating will be called. When you enter this command, you should see something like this: After another character has said something in the character's room. This event is called right after another character has said something in the same location. The action cannot be prevented at this moment. Instead, this event is ideal to create keywords that would trigger a character (like a NPC) in doing something if a specific phrase is spoken in the same location. To use this event, you have to specify a list of keywords as parameters that should be present, as separate words, in the spoken phrase. For instance, you can set a callback that would fire if the phrase spoken by the character contains \"menu\" or \"dinner\" or \"lunch\": @call/add ... = say menu, dinner, lunch Then if one of the words is present in what the character says, this callback will fire. Variables you can use in this event: speaker: the character speaking in this room. character: the character connected to this event. message: the text having been spoken by the character. That's some list of information. What's most important to us now is: The \"say\" event is called whenever someone else speaks in the room. We can set callbacks to fire when specific keywords are present in the phrase by putting them as additional parameters. Here we have set this parameter to \"hello\". We can have several keywords separated by a comma (we'll see this in more details later). We have three default variables we can use in this callback: speaker which contains the character who speaks, character which contains the character who's modified by the in-game Python system (here, or merchant), and message which contains the spoken phrase. This concept of variables is important. If it makes things more simple to you, think of them as parameters in a function: they can be used inside of the function body because they have been set when the function was called. This command has opened an editor where we can type our Python code. ----------Line Editor [Callback say of a merchant]-------------------------------- 01| ----------[l:01 w:000 c:0000]------------(:h for help)---------------------------- For our first test, let's type something like: character.location.msg_contents(\"{character} shrugs and says: 'well, yes, hello to you!'\", mapping=dict(character=character)) Once you have entered this line, you can type :wq to save the editor and quit it. And now if you use the \"say\" command with a message containing \"hello\": You say, \"Hello sir merchant!\" a merchant(#3) shrugs and says: 'well, yes, hello to you!' If you say something that doesn't contain \"hello\", our callback won't execute. In summary : When we say something in the room, using the \"say\" command, the \"say\" event of all characters (except us) is called. The in-game Python system looks at what we have said, and checks whether one of our callbacks in the \"say\" event contains a keyword that we have spoken. If so, call it, defining the event variables as we have seen. The callback is then executed as normal Python code. Here we have called the msg_contents method on the character's location (probably a room) to display a message to the entire room. We have also used mapping to easily display the character's name. This is not specific to the in-game Python system. If you feel overwhelmed by the code we've used, just shorten it and use something more simple, for instance: speaker.msg(\"You have said something to me.\") The same callback for several keywords \u00b6 It's easy to create a callback that will be triggered if the sentence contains one of several keywords. @call/add merchant = say trade, trader, goods And in the editor that opens: character.location.msg_contents(\"{character} says: 'Ho well, trade's fine as long as roads are safe.'\", mapping=dict(character=character)) Then you can say something with either \"trade\", \"trader\" or \"goods\" in your sentence, which should call the callback: You say, \"and how is your trade going?\" a merchant(#3) says: 'Ho well, trade's fine as long as roads are safe.' We can set several keywords when adding the callback. We just need to separate them with commas. A longer callback \u00b6 So far, we have only set one line in our callbacks. Which is useful, but we often need more. For an entire dialogue, you might want to do a bit more than that. @call/add merchant = say bandit, bandits And in the editor you can paste the following lines: character.location.msg_contents(\"{character} says: 'Bandits he?'\", mapping=dict(character=character)) character.location.msg_contents(\"{character} scratches his head, considering.\", mapping=dict(character=character)) character.location.msg_contents(\"{character} whispers: 'Aye, saw some of them, north from here. No trouble o' mine, but...'\", mapping=dict(character=character)) speaker.msg(\"{character} looks at you more closely.\".format(character=character.get_display_name(speaker))) speaker.msg(\"{character} continues in a low voice: 'Ain't my place to say, but if you need to find 'em, they're encamped some distance away from the road, I guess near a cave or something.'.\".format(character=character.get_display_name(speaker))) Now try to ask the merchant about bandits: You say, \"have you seen bandits?\" a merchant(#3) says: 'Bandits he?' a merchant(#3) scratches his head, considering. a merchant(#3) whispers: 'Aye, saw some of them, north from here. No trouble o' mine, but...' a merchant(#3) looks at you more closely. a merchant(#3) continues in a low voice: 'Ain't my place to say, but if you need to find 'em, they're encamped some distance away from the road, I guess near a cave or something.'. Notice here that the first lines of dialogue are spoken to the entire room, but then the merchant is talking directly to the speaker, and only the speaker hears it. There's no real limit to what you can do with this. You can set a mood system, storing attributes in the NPC itself to tell you in what mood he is, which will influence the information he will give... perhaps the accuracy of it as well. You can add random phrases spoken in some context. You can use other actions (you're not limited to having the merchant say something, you can ask him to move, gives you something, attack if you have a combat system, or whatever else). The callbacks are in pure Python, so you can write conditions or loops. You can add in \"pauses\" between some instructions using chained events. This tutorial won't describe how to do that however. You already have a lot to play with. Tutorial F.A.Q. \u00b6 Q: can I create several characters who would answer to specific dialogue? A: of course. Te in-game Python system is so powerful because you can set unique code for various objects. You can have several characters answering to different things. You can even have different characters in the room answering to greetings. All callbacks will be executed one after another. Q: can I have two characters answering to the same dialogue in exactly the same way? A: It's possible but not so easy to do. Usually, event grouping is set in code, and depends on different games. However, if it is for some infrequent occurrences, it's easy to do using chained events . Q: is it possible to deploy callbacks on all characters sharing the same prototype? A: not out of the box. This depends on individual settings in code. One can imagine that all characters of some type would share some events, but this is game-specific. Rooms of the same zone could share the same events as well. It is possible to do but requires modification of the source code. Next tutorial: adding a voice-operated elevator with events .","title":"Dialogues in events"},{"location":"Dialogues-in-events.html#a-first-example-with-a-first-character","text":"Let's create a character to begin with. @charcreate a merchant This will create a merchant in the room where you currently are. It doesn't have anything, like a description, you can decorate it a bit if you like. As said above, the in-game Python system consists in linking objects with arbitrary code. This code will be executed in some circumstances. Here, the circumstance is \"when someone says something in the same room\", and might be more specific like \"when someone says hello\". We'll decide what code to run (we'll actually type the code in-game). Using the vocabulary of the in-game Python system, we'll create a callback: a callback is just a set of lines of code that will run under some conditions. You can have an overview of every \"conditions\" in which callbacks can be created using the @call command (short for @callback ). You need to give it an object as argument. Here for instance, we could do: @call a merchant You should see a table with three columns, showing the list of events existing on our newly-created merchant. There are quite a lot of them, as it is, althougn no line of code has been set yet. For our system, you might be more interested by the line describing the say event: | say | 0 (0) | After another character has said something in | | | | the character's room. | We'll create a callback on the say event, called when we say \"hello\" in the merchant's room: @call/add a merchant = say hello Before seeing what this command displays, let's see the command syntax itself: @call is the command name, /add is a switch. You can read the help of the command to get the help of available switches and a brief overview of syntax. We then enter the object's name, here \"a merchant\". You can enter the ID too (\"#3\" in my case), which is useful to edit the object when you're not in the same room. You can even enter part of the name, as usual. An equal sign, a simple separator. The event's name. Here, it's \"say\". The available events are displayed when you use @call without switch. After a space, we enter the conditions in which this callback should be called. Here, the conditions represent what the other character should say. We enter \"hello\". Meaning that if someone says something containing \"hello\" in the room, the callback we are now creating will be called. When you enter this command, you should see something like this: After another character has said something in the character's room. This event is called right after another character has said something in the same location. The action cannot be prevented at this moment. Instead, this event is ideal to create keywords that would trigger a character (like a NPC) in doing something if a specific phrase is spoken in the same location. To use this event, you have to specify a list of keywords as parameters that should be present, as separate words, in the spoken phrase. For instance, you can set a callback that would fire if the phrase spoken by the character contains \"menu\" or \"dinner\" or \"lunch\": @call/add ... = say menu, dinner, lunch Then if one of the words is present in what the character says, this callback will fire. Variables you can use in this event: speaker: the character speaking in this room. character: the character connected to this event. message: the text having been spoken by the character. That's some list of information. What's most important to us now is: The \"say\" event is called whenever someone else speaks in the room. We can set callbacks to fire when specific keywords are present in the phrase by putting them as additional parameters. Here we have set this parameter to \"hello\". We can have several keywords separated by a comma (we'll see this in more details later). We have three default variables we can use in this callback: speaker which contains the character who speaks, character which contains the character who's modified by the in-game Python system (here, or merchant), and message which contains the spoken phrase. This concept of variables is important. If it makes things more simple to you, think of them as parameters in a function: they can be used inside of the function body because they have been set when the function was called. This command has opened an editor where we can type our Python code. ----------Line Editor [Callback say of a merchant]-------------------------------- 01| ----------[l:01 w:000 c:0000]------------(:h for help)---------------------------- For our first test, let's type something like: character.location.msg_contents(\"{character} shrugs and says: 'well, yes, hello to you!'\", mapping=dict(character=character)) Once you have entered this line, you can type :wq to save the editor and quit it. And now if you use the \"say\" command with a message containing \"hello\": You say, \"Hello sir merchant!\" a merchant(#3) shrugs and says: 'well, yes, hello to you!' If you say something that doesn't contain \"hello\", our callback won't execute. In summary : When we say something in the room, using the \"say\" command, the \"say\" event of all characters (except us) is called. The in-game Python system looks at what we have said, and checks whether one of our callbacks in the \"say\" event contains a keyword that we have spoken. If so, call it, defining the event variables as we have seen. The callback is then executed as normal Python code. Here we have called the msg_contents method on the character's location (probably a room) to display a message to the entire room. We have also used mapping to easily display the character's name. This is not specific to the in-game Python system. If you feel overwhelmed by the code we've used, just shorten it and use something more simple, for instance: speaker.msg(\"You have said something to me.\")","title":"A first example with a first character"},{"location":"Dialogues-in-events.html#the-same-callback-for-several-keywords","text":"It's easy to create a callback that will be triggered if the sentence contains one of several keywords. @call/add merchant = say trade, trader, goods And in the editor that opens: character.location.msg_contents(\"{character} says: 'Ho well, trade's fine as long as roads are safe.'\", mapping=dict(character=character)) Then you can say something with either \"trade\", \"trader\" or \"goods\" in your sentence, which should call the callback: You say, \"and how is your trade going?\" a merchant(#3) says: 'Ho well, trade's fine as long as roads are safe.' We can set several keywords when adding the callback. We just need to separate them with commas.","title":"The same callback for several keywords"},{"location":"Dialogues-in-events.html#a-longer-callback","text":"So far, we have only set one line in our callbacks. Which is useful, but we often need more. For an entire dialogue, you might want to do a bit more than that. @call/add merchant = say bandit, bandits And in the editor you can paste the following lines: character.location.msg_contents(\"{character} says: 'Bandits he?'\", mapping=dict(character=character)) character.location.msg_contents(\"{character} scratches his head, considering.\", mapping=dict(character=character)) character.location.msg_contents(\"{character} whispers: 'Aye, saw some of them, north from here. No trouble o' mine, but...'\", mapping=dict(character=character)) speaker.msg(\"{character} looks at you more closely.\".format(character=character.get_display_name(speaker))) speaker.msg(\"{character} continues in a low voice: 'Ain't my place to say, but if you need to find 'em, they're encamped some distance away from the road, I guess near a cave or something.'.\".format(character=character.get_display_name(speaker))) Now try to ask the merchant about bandits: You say, \"have you seen bandits?\" a merchant(#3) says: 'Bandits he?' a merchant(#3) scratches his head, considering. a merchant(#3) whispers: 'Aye, saw some of them, north from here. No trouble o' mine, but...' a merchant(#3) looks at you more closely. a merchant(#3) continues in a low voice: 'Ain't my place to say, but if you need to find 'em, they're encamped some distance away from the road, I guess near a cave or something.'. Notice here that the first lines of dialogue are spoken to the entire room, but then the merchant is talking directly to the speaker, and only the speaker hears it. There's no real limit to what you can do with this. You can set a mood system, storing attributes in the NPC itself to tell you in what mood he is, which will influence the information he will give... perhaps the accuracy of it as well. You can add random phrases spoken in some context. You can use other actions (you're not limited to having the merchant say something, you can ask him to move, gives you something, attack if you have a combat system, or whatever else). The callbacks are in pure Python, so you can write conditions or loops. You can add in \"pauses\" between some instructions using chained events. This tutorial won't describe how to do that however. You already have a lot to play with.","title":"A longer callback"},{"location":"Dialogues-in-events.html#tutorial-faq","text":"Q: can I create several characters who would answer to specific dialogue? A: of course. Te in-game Python system is so powerful because you can set unique code for various objects. You can have several characters answering to different things. You can even have different characters in the room answering to greetings. All callbacks will be executed one after another. Q: can I have two characters answering to the same dialogue in exactly the same way? A: It's possible but not so easy to do. Usually, event grouping is set in code, and depends on different games. However, if it is for some infrequent occurrences, it's easy to do using chained events . Q: is it possible to deploy callbacks on all characters sharing the same prototype? A: not out of the box. This depends on individual settings in code. One can imagine that all characters of some type would share some events, but this is game-specific. Rooms of the same zone could share the same events as well. It is possible to do but requires modification of the source code. Next tutorial: adding a voice-operated elevator with events .","title":"Tutorial F.A.Q."},{"location":"Directory-Overview.html","text":"This is an overview of the directories relevant to Evennia coding. The Game directory \u00b6 The game directory is created with evennia --init <name> . In the Evennia documentation we always assume it's called mygame . Apart from the server/ subfolder within, you could reorganize this folder if you preferred a different code structure for your game. mygame/ commands/ - Overload default Commands or add your own Commands/ Command sets here. server / - The structure of this folder should not change since Evennia expects it. conf/ - All server configuration files sits here. The most important file is settings.py . logs/ - Portal log files are stored here (Server is logging to the terminal by default) typeclasses/ - this folder contains empty templates for overloading default game entities of Evennia. Evennia will automatically use the changes in those templates for the game entities it creates. web/ - This holds the Web features of your game. world/ - this is a \"miscellaneous\" folder holding everything related to the world you are building, such as build scripts and rules modules that don't fit with one of the other folders. Evennia library layout: \u00b6 If you cloned the GIT repo following the instructions, you will have a folder named evennia . The top level of it contains Python package specific stuff such as a readme file, setup.py etc. It also has two subfolders bin/ and evennia/ (again). The bin/ directory holds OS-specific binaries that will be used when installing Evennia with pip as per the Getting started instructions. The library itself is in the evennia subfolder. From your code you will access this subfolder simply by import evennia . evennia __init__.py - The \"flat API\" of Evennia resides here. commands/ - The command parser and handler. default/ - The default commands and cmdsets. comms/ - Systems for communicating in-game. contrib/ - Optional plugins too game-specific for core Evennia. game_template/ - Copied to become the \"game directory\" when using evennia --init . help/ - Handles the storage and creation of help entries. locale/ - Language files ( i18n ). locks/ - Lock system for restricting access to in-game entities. objects/ - In-game entities (all types of items and Characters). prototypes/ - Object Prototype/spawning system and OLC menu accounts/ - Out-of-game Session-controlled entities (accounts, bots etc) scripts/ - Out-of-game entities equivalence to Objects, also with timer support. server/ - Core server code and Session handling. portal/ - Portal proxy and connection protocols. settings_default.py - Root settings of Evennia. Copy settings from here to mygame/server/settings.py file. typeclasses/ - Abstract classes for the typeclass storage and database system. utils/ - Various miscellaneous useful coding resources. web/ - Web resources and webserver. Partly copied into game directory on initialization. All directories contain files ending in .py . These are Python modules and are the basic units of Python code. The roots of directories also have (usually empty) files named __init__.py . These are required by Python so as to be able to find and import modules in other directories. When you have run Evennia at least once you will find that there will also be .pyc files appearing, these are pre-compiled binary versions of the .py files to speed up execution. The root of the evennia folder has an __init__.py file containing the \" flat API \". This holds shortcuts to various subfolders in the evennia library. It is provided to make it easier to find things; it allows you to just import evennia and access things from that rather than having to import from their actual locations inside the source tree.","title":"Directory Overview"},{"location":"Directory-Overview.html#the-game-directory","text":"The game directory is created with evennia --init <name> . In the Evennia documentation we always assume it's called mygame . Apart from the server/ subfolder within, you could reorganize this folder if you preferred a different code structure for your game. mygame/ commands/ - Overload default Commands or add your own Commands/ Command sets here. server / - The structure of this folder should not change since Evennia expects it. conf/ - All server configuration files sits here. The most important file is settings.py . logs/ - Portal log files are stored here (Server is logging to the terminal by default) typeclasses/ - this folder contains empty templates for overloading default game entities of Evennia. Evennia will automatically use the changes in those templates for the game entities it creates. web/ - This holds the Web features of your game. world/ - this is a \"miscellaneous\" folder holding everything related to the world you are building, such as build scripts and rules modules that don't fit with one of the other folders.","title":"The Game directory"},{"location":"Directory-Overview.html#evennia-library-layout","text":"If you cloned the GIT repo following the instructions, you will have a folder named evennia . The top level of it contains Python package specific stuff such as a readme file, setup.py etc. It also has two subfolders bin/ and evennia/ (again). The bin/ directory holds OS-specific binaries that will be used when installing Evennia with pip as per the Getting started instructions. The library itself is in the evennia subfolder. From your code you will access this subfolder simply by import evennia . evennia __init__.py - The \"flat API\" of Evennia resides here. commands/ - The command parser and handler. default/ - The default commands and cmdsets. comms/ - Systems for communicating in-game. contrib/ - Optional plugins too game-specific for core Evennia. game_template/ - Copied to become the \"game directory\" when using evennia --init . help/ - Handles the storage and creation of help entries. locale/ - Language files ( i18n ). locks/ - Lock system for restricting access to in-game entities. objects/ - In-game entities (all types of items and Characters). prototypes/ - Object Prototype/spawning system and OLC menu accounts/ - Out-of-game Session-controlled entities (accounts, bots etc) scripts/ - Out-of-game entities equivalence to Objects, also with timer support. server/ - Core server code and Session handling. portal/ - Portal proxy and connection protocols. settings_default.py - Root settings of Evennia. Copy settings from here to mygame/server/settings.py file. typeclasses/ - Abstract classes for the typeclass storage and database system. utils/ - Various miscellaneous useful coding resources. web/ - Web resources and webserver. Partly copied into game directory on initialization. All directories contain files ending in .py . These are Python modules and are the basic units of Python code. The roots of directories also have (usually empty) files named __init__.py . These are required by Python so as to be able to find and import modules in other directories. When you have run Evennia at least once you will find that there will also be .pyc files appearing, these are pre-compiled binary versions of the .py files to speed up execution. The root of the evennia folder has an __init__.py file containing the \" flat API \". This holds shortcuts to various subfolders in the evennia library. It is provided to make it easier to find things; it allows you to just import evennia and access things from that rather than having to import from their actual locations inside the source tree.","title":"Evennia library layout:"},{"location":"Docs-refactoring.html","text":"This is a whitepage for free discussion about the wiki docs and refactorings needed. Note that this is not a forum. To keep things clean, each opinion text should ideally present a clear argument or lay out a suggestion. Asking for clarification and any side-discussions should be held in chat or forum. Griatch (Aug 13, 2019) \u00b6 This is how to make a discussion entry for the whitepage. Use any markdown formatting you need. Also remember to copy your work to the clipboard before saving the page since if someone else edited the page since you started, you'll have to reload and write again. (Sept 23, 2019) \u00b6 This (now closed) issue by DamnedScholar gives the following suggestion: I think it would be useful for the pages that explain how to use various features of Evennia to have explicit and easily visible links to the respective API entry or entries. Some pages do, but not all. I imagine this as a single entry at the top of the page [...]. This (now closed) issue by taladan gives the following suggestion: It would help me (and probably a couple of others) if there is a way to show the file path where a particular thing exists. Maybe up under the 'last edited' line we could have a line like: evennia/locks/lockhandler.py This would help in development to quickly refer to where a resource is located. Kovitikus (Sept. 11, 2019) \u00b6 Batch Code should have a link in the developer area. It is currently only listed in the tutorials section as an afterthought to a tutorial title. In regards to the general structure of each wiki page: I'd like to see a table of contents at the top of each one, so that it can be quickly navigated and is immediately apparent what sections are covered on the page. Similar to the current Getting Started page. The structuring of the page should also include a quick reference cheatsheet for certain aspects. Such as Tags including a quick reference section at the top that lists an example of every available method you can use in a clear and consistent format, along with a comment. Readers shouldn't have to decipher the article to gather such basic information and it should instead be available at first glance. Example of a quick reference: Tags # Add a tag. obj.tags.add(\"label\") # Remove a tag. obj.tags.remove(\"label\") # Remove all tags. obj.tags.clear() # Search for a tag. Evennia must be imported first. store_result = evennia.search_tag(\"label\") # Return a list of all tags. obj.tags.all() Aliases # Add an alias. obj.aliases.add(\"label\") ETC... In regards to comment structure, I often find that smushing together lines with comments to be too obscure. White space should be used to clearly delineate what information the comment is for. I understand that the current format is that a comment references whatever is below it, but newbies may not know that until they realize it. Example of poor formatting: #comment command/code #comment command/code Example of good formatting: # Comment. command/code # Comment. command/code","title":"Docs refactoring"},{"location":"Docs-refactoring.html#griatch-aug-13-2019","text":"This is how to make a discussion entry for the whitepage. Use any markdown formatting you need. Also remember to copy your work to the clipboard before saving the page since if someone else edited the page since you started, you'll have to reload and write again.","title":"Griatch (Aug 13, 2019)"},{"location":"Docs-refactoring.html#sept-23-2019","text":"This (now closed) issue by DamnedScholar gives the following suggestion: I think it would be useful for the pages that explain how to use various features of Evennia to have explicit and easily visible links to the respective API entry or entries. Some pages do, but not all. I imagine this as a single entry at the top of the page [...]. This (now closed) issue by taladan gives the following suggestion: It would help me (and probably a couple of others) if there is a way to show the file path where a particular thing exists. Maybe up under the 'last edited' line we could have a line like: evennia/locks/lockhandler.py This would help in development to quickly refer to where a resource is located.","title":"(Sept 23, 2019)"},{"location":"Docs-refactoring.html#kovitikus-sept-11-2019","text":"Batch Code should have a link in the developer area. It is currently only listed in the tutorials section as an afterthought to a tutorial title. In regards to the general structure of each wiki page: I'd like to see a table of contents at the top of each one, so that it can be quickly navigated and is immediately apparent what sections are covered on the page. Similar to the current Getting Started page. The structuring of the page should also include a quick reference cheatsheet for certain aspects. Such as Tags including a quick reference section at the top that lists an example of every available method you can use in a clear and consistent format, along with a comment. Readers shouldn't have to decipher the article to gather such basic information and it should instead be available at first glance. Example of a quick reference: Tags # Add a tag. obj.tags.add(\"label\") # Remove a tag. obj.tags.remove(\"label\") # Remove all tags. obj.tags.clear() # Search for a tag. Evennia must be imported first. store_result = evennia.search_tag(\"label\") # Return a list of all tags. obj.tags.all() Aliases # Add an alias. obj.aliases.add(\"label\") ETC... In regards to comment structure, I often find that smushing together lines with comments to be too obscure. White space should be used to clearly delineate what information the comment is for. I understand that the current format is that a comment references whatever is below it, but newbies may not know that until they realize it. Example of poor formatting: #comment command/code #comment command/code Example of good formatting: # Comment. command/code # Comment. command/code","title":"Kovitikus (Sept. 11, 2019)"},{"location":"Dynamic-In-Game-Map.html","text":"Introduction \u00b6 An often desired feature in a MUD is to show an in-game map to help navigation. The Static in-game map tutorial solves this by creating a static map, meaning the map is pre-drawn once and for all - the rooms are then created to match that map. When walking around, parts of the static map is then cut out and displayed next to the room description. In this tutorial we'll instead do it the other way around; We will dynamically draw the map based on the relationships we find between already existing rooms. The Grid of Rooms \u00b6 There are at least two requirements needed for this tutorial to work. The structure of your mud has to follow a logical layout. Evennia supports the layout of your world to be 'logically' impossible with rooms looping to themselves or exits leading to the other side of the map. Exits can also be named anything, from \"jumping out the window\" to \"into the fifth dimension\". This tutorial assumes you can only move in the cardinal directions (N, E, S and W). Rooms must be connected and linked together for the map to be generated correctly. Vanilla Evennia comes with a admin command @tunnel that allows a user to create rooms in the cardinal directions, but additional work is needed to assure that rooms are connected. For example, if you @tunnel east and then immediately do @tunnel west you'll find that you have created two completely stand-alone rooms. So care is needed if you want to create a \"logical\" layout. In this tutorial we assume you have such a grid of rooms that we can generate the map from. Concept \u00b6 Before getting into the code, it is beneficial to understand and conceptualize how this is going to work. The idea is analogous to a worm that starts at your current position. It chooses a direction and 'walks' outward from it, mapping its route as it goes. Once it has traveled a pre-set distance it stops and starts over in another direction. An important note is that we want a system which is easily callable and not too complicated. Therefore we will wrap this entire code into a custom Python class (not a typeclass as this doesn't use any core objects from evennia itself). We are going to create something that displays like this when you type 'look': Hallway [.] [.] [@][.][.][.][.] [.] [.] [.] The distant echoes of the forgotten wail throughout the empty halls. Exits: North, East, South Your current location is defined by [@] while the [.] s are other rooms that the \"worm\" has seen since departing from your location. Setting up the Map Display \u00b6 First we must define the components for displaying the map. For the \"worm\" to know what symbol to draw on the map we will have it check an Attribute on the room it visits called sector_type . For this tutorial we understand two symbols - a normal room and the room with us in it. We also define a fallback symbol for rooms without said Attribute - that way the map will still work even if we didn't prepare the room correctly. Assuming your game folder is named mygame , we create this code in mygame/world/map.py. # in mygame/world/map.py # the symbol is identified with a key \"sector_type\" on the # Room. Keys None and \"you\" must always exist. SYMBOLS = { None : ' . ', # for rooms without sector_type Attribute 'you' : '[@]', 'SECT_INSIDE': '[.]' } Since trying to access an unset Attribute returns None , this means rooms without the sector_type Atttribute will show as . . Next we start building the custom class Map . It will hold all methods we need. # in mygame/world/map.py class Map(object): def __init__(self, caller, max_width=9, max_length=9): self.caller = caller self.max_width = max_width self.max_length = max_length self.worm_has_mapped = {} self.curX = None self.curY = None self.caller is normally your Character object, the one using the map. self.max_width/length determine the max width and length of the map that will be generated. Note that it's important that these variables are set to odd numbers to make sure the display area has a center point. self.worm_has_mapped is building off the worm analogy above. This dictionary will store all rooms the \"worm\" has mapped as well as its relative position within the grid. This is the most important variable as it acts as a 'checker' and 'address book' that is able to tell us where the worm has been and what it has mapped so far. self.curX/Y are coordinates representing the worm's current location on the grid. Before any sort of mapping can actually be done we need to create an empty display area and do some sanity checks on it by using the following methods. # in mygame/world/map.py class Map(object): # [... continued] def create_grid(self): # This method simply creates an empty grid/display area # with the specified variables from __init__(self): board = [] for row in range(self.max_width): board.append([]) for column in range(self.max_length): board[row].append(' ') return board def check_grid(self): # this method simply checks the grid to make sure # that both max_l and max_w are odd numbers. return True if self.max_length % 2 != 0 or self.max_width % 2 != 0\\ else False Before we can set our worm on its way, we need to know some of the computer science behind all this called 'Graph Traversing'. In Pseudo code what we are trying to accomplish is this: # pseudo code def draw_room_on_map(room, max_distance): self.draw(room) if max_distance == 0: return for exit in room.exits: if self.has_drawn(exit.destination): # skip drawing if we already visited the destination continue else: # first time here! self.draw_room_on_map(exit.destination, max_distance - 1) The beauty of Python is that our actual code of doing this doesn't differ much if at all from this Pseudo code example. max_distance is a variable indicating to our Worm how many rooms AWAY from your current location will it map. Obviously the larger the number the more time it will take if your current location has many many rooms around you. The first hurdle here is what value to use for 'max_distance'. There is no reason for the worm to travel further than what is actually displayed to you. For example, if your current location is placed in the center of a display area of size max_length = max_width = 9 , then the worm need only go 4 spaces in either direction: [.][.][.][.][@][.][.][.][.] 4 3 2 1 0 1 2 3 4 The max_distance can be set dynamically based on the size of the display area. As your width/length changes it becomes a simple algebraic linear relationship which is simply max_distance = (min(max_width, max_length) -1) / 2 . Building the Mapper \u00b6 Now we can start to fill our Map object with some methods. We are still missing a few methods that are very important: self.draw(self, room) - responsible for actually drawing room to grid. self.has_drawn(self, room) - checks to see if the room has been mapped and worm has already been here. self.median(self, number) - a simple utility method that finds the median (middle point) from 0, n self.update_pos(self, room, exit_name) - updates the worm's physical position by reassigning self.curX/Y. .accordingly self.start_loc_on_grid(self) - the very first initial draw on the grid representing your location in the middle of the grid 'self.show_map - after everything is done convert the map into a readable string self.draw_room_on_map(self, room, max_distance) - the main method that ties it all together.` Now that we know which methods we need, let's refine our initial __init__(self) to pass some conditional statements and set it up to start building the display. #mygame/world/map.py class Map(object): def __init__(self, caller, max_width=9, max_length=9): self.caller = caller self.max_width = max_width self.max_length = max_length self.worm_has_mapped = {} self.curX = None self.curY = None if self.check_grid(): # we have to store the grid into a variable self.grid = self.create_grid() # we use the algebraic relationship self.draw_room_on_map(caller.location, ((min(max_width, max_length) -1 ) / 2) Here we check to see if the parameters for the grid are okay, then we create an empty canvas and map our initial location as the first room! As mentioned above, the code for the self.draw_room_on_map() is not much different than the Pseudo code. The method is shown below: # in mygame/world/map.py, in the Map class def draw_room_on_map(self, room, max_distance): self.draw(room) if max_distance == 0: return for exit in room.exits: if exit.name not in (\"north\", \"east\", \"west\", \"south\"): # we only map in the cardinal directions. Mapping up/down would be # an interesting learning project for someone who wanted to try it. continue if self.has_drawn(exit.destination): # we've been to the destination already, skip ahead. continue self.update_pos(room, exit.name.lower()) self.draw_room_on_map(exit.destination, max_distance - 1) The first thing the \"worm\" does is to draw your current location in self.draw . Lets define that... #in mygame/word/map.py, in the Map class def draw(self, room): # draw initial ch location on map first! if room == self.caller.location: self.start_loc_on_grid() self.worm_has_mapped[room] = [self.curX, self.curY] else: # map all other rooms self.worm_has_mapped[room] = [self.curX, self.curY] # this will use the sector_type Attribute or None if not set. self.grid[self.curX][self.curY] = SYMBOLS[room.db.sector_type] In self.start_loc_on_grid() : def median(self, num): lst = sorted(range(0, num)) n = len(lst) m = n -1 return (lst[n//2] + lst[m//2]) / 2.0 def start_loc_on_grid(self): x = self.median(self.max_width) y = self.median(self.max_length) # x and y are floats by default, can't index lists with float types x, y = int(x), int(y) self.grid[x][y] = SYMBOLS['you'] self.curX, self.curY = x, y # updating worms current location After the system has drawn the current map it checks to see if the max_distance is 0 (since this is the inital start phase it is not). Now we handle the iteration once we have each individual exit in the room. The first thing it does is check if the room the Worm is in has been mapped already.. lets define that... def has_drawn(self, room): return True if room in self.worm_has_mapped.keys() else False If has_drawn returns False that means the worm has found a room that hasn't been mapped yet. It will then 'move' there. The self.curX/Y sort of lags behind, so we have to make sure to track the position of the worm; we do this in self.update_pos() below. def update_pos(self, room, exit_name): # this ensures the coordinates stays up to date # to where the worm is currently at. self.curX, self.curY = \\ self.worm_has_mapped[room][0], self.worm_has_mapped[room][1] # now we have to actually move the pointer # variables depending on which 'exit' it found if exit_name == 'east': self.curY += 1 elif exit_name == 'west': self.curY -= 1 elif exit_name == 'north': self.curX -= 1 elif exit_name == 'south': self.curX += 1 Once the system updates the position of the worm it feeds the new room back into the original draw_room_on_map() and starts the process all over again.. That is essentially the entire thing. The final method is to bring it all together and make a nice presentational string out of it using the self.show_map() method. def show_map(self): map_string = \"\" for row in self.grid: map_string += \" \".join(row) map_string += \"\\n\" return map_string Using the Map \u00b6 In order for the map to get triggered we store it on the Room typeclass. If we put it in return_appearance we will get the map back every time we look at the room. return_appearance is a default Evennia hook available on all objects; it is called e.g. by the look command to get the description of something (the room in this case). # in mygame/typeclasses/rooms.py from evennia import DefaultRoom from world.map import Map class Room(DefaultRoom): def return_appearance(self, looker): # [...] string = \"%s\\n\" % Map(looker).show_map() # Add all the normal stuff like room description, # contents, exits etc. string += \"\\n\" + super().return_appearance(looker) return string Obviously this method of generating maps doesn't take into account of any doors or exits that are hidden.. etc.. but hopefully it serves as a good base to start with. Like previously mentioned, it is very important to have a solid foundation on rooms before implementing this. You can try this on vanilla evennia by using @tunnel and essentially you can just create a long straight/edgy non-looping rooms that will show on your in-game map. The above example will display the map above the room description. You could also use an EvTable to place description and map next to each other. Some other things you can do is to have a Command that displays with a larger radius, maybe with a legend and other features. Below is the whole map.py for your reference. You need to update your Room typeclass (see above) to actually call it. Remember that to see different symbols for a location you also need to set the sector_type Attribute on the room to one of the keys in the SYMBOLS dictionary. So in this example, to make a room be mapped as [.] you would set the room's sector_type to \"SECT_INSIDE\" . Try it out with @set here/sector_type = \"SECT_INSIDE\" . If you wanted all new rooms to have a given sector symbol, you could change the default in the SYMBOLS\u00b4 dictionary below, or you could add the Attribute in the Room's at_object_creation` method. #mygame/world/map.py # These are keys set with the Attribute sector_type on the room. # The keys None and \"you\" must always exist. SYMBOLS = { None : ' . ', # for rooms without a sector_type attr 'you' : '[@]', 'SECT_INSIDE': '[.]' } class Map(object): def __init__(self, caller, max_width=9, max_length=9): self.caller = caller self.max_width = max_width self.max_length = max_length self.worm_has_mapped = {} self.curX = None self.curY = None if self.check_grid(): # we actually have to store the grid into a variable self.grid = self.create_grid() self.draw_room_on_map(caller.location, ((min(max_width, max_length) -1 ) / 2)) def update_pos(self, room, exit_name): # this ensures the pointer variables always # stays up to date to where the worm is currently at. self.curX, self.curY = \\ self.worm_has_mapped[room][0], self.worm_has_mapped[room][1] # now we have to actually move the pointer # variables depending on which 'exit' it found if exit_name == 'east': self.curY += 1 elif exit_name == 'west': self.curY -= 1 elif exit_name == 'north': self.curX -= 1 elif exit_name == 'south': self.curX += 1 def draw_room_on_map(self, room, max_distance): self.draw(room) if max_distance == 0: return for exit in room.exits: if exit.name not in (\"north\", \"east\", \"west\", \"south\"): # we only map in the cardinal directions. Mapping up/down would be # an interesting learning project for someone who wanted to try it. continue if self.has_drawn(exit.destination): # we've been to the destination already, skip ahead. continue self.update_pos(room, exit.name.lower()) self.draw_room_on_map(exit.destination, max_distance - 1) def draw(self, room): # draw initial caller location on map first! if room == self.caller.location: self.start_loc_on_grid() self.worm_has_mapped[room] = [self.curX, self.curY] else: # map all other rooms self.worm_has_mapped[room] = [self.curX, self.curY] # this will use the sector_type Attribute or None if not set. self.grid[self.curX][self.curY] = SYMBOLS[room.db.sector_type] def median(self, num): lst = sorted(range(0, num)) n = len(lst) m = n -1 return (lst[n//2] + lst[m//2]) / 2.0 def start_loc_on_grid(self): x = self.median(self.max_width) y = self.median(self.max_length) # x and y are floats by default, can't index lists with float types x, y = int(x), int(y) self.grid[x][y] = SYMBOLS['you'] self.curX, self.curY = x, y # updating worms current location def has_drawn(self, room): return True if room in self.worm_has_mapped.keys() else False def create_grid(self): # This method simply creates an empty grid # with the specified variables from __init__(self): board = [] for row in range(self.max_width): board.append([]) for column in range(self.max_length): board[row].append(' ') return board def check_grid(self): # this method simply checks the grid to make sure # both max_l and max_w are odd numbers return True if self.max_length % 2 != 0 or \\ self.max_width % 2 != 0 else False def show_map(self): map_string = \"\" for row in self.grid: map_string += \" \".join(row) map_string += \"\\n\" return map_string Final Comments \u00b6 The Dynamic map could be expanded with further capabilities. For example, it could mark exits or allow NE, SE etc directions as well. It could have colors for different terrain types. One could also look into up/down directions and figure out how to display that in a good way.","title":"Dynamic In Game Map"},{"location":"Dynamic-In-Game-Map.html#introduction","text":"An often desired feature in a MUD is to show an in-game map to help navigation. The Static in-game map tutorial solves this by creating a static map, meaning the map is pre-drawn once and for all - the rooms are then created to match that map. When walking around, parts of the static map is then cut out and displayed next to the room description. In this tutorial we'll instead do it the other way around; We will dynamically draw the map based on the relationships we find between already existing rooms.","title":"Introduction"},{"location":"Dynamic-In-Game-Map.html#the-grid-of-rooms","text":"There are at least two requirements needed for this tutorial to work. The structure of your mud has to follow a logical layout. Evennia supports the layout of your world to be 'logically' impossible with rooms looping to themselves or exits leading to the other side of the map. Exits can also be named anything, from \"jumping out the window\" to \"into the fifth dimension\". This tutorial assumes you can only move in the cardinal directions (N, E, S and W). Rooms must be connected and linked together for the map to be generated correctly. Vanilla Evennia comes with a admin command @tunnel that allows a user to create rooms in the cardinal directions, but additional work is needed to assure that rooms are connected. For example, if you @tunnel east and then immediately do @tunnel west you'll find that you have created two completely stand-alone rooms. So care is needed if you want to create a \"logical\" layout. In this tutorial we assume you have such a grid of rooms that we can generate the map from.","title":"The Grid of Rooms"},{"location":"Dynamic-In-Game-Map.html#concept","text":"Before getting into the code, it is beneficial to understand and conceptualize how this is going to work. The idea is analogous to a worm that starts at your current position. It chooses a direction and 'walks' outward from it, mapping its route as it goes. Once it has traveled a pre-set distance it stops and starts over in another direction. An important note is that we want a system which is easily callable and not too complicated. Therefore we will wrap this entire code into a custom Python class (not a typeclass as this doesn't use any core objects from evennia itself). We are going to create something that displays like this when you type 'look': Hallway [.] [.] [@][.][.][.][.] [.] [.] [.] The distant echoes of the forgotten wail throughout the empty halls. Exits: North, East, South Your current location is defined by [@] while the [.] s are other rooms that the \"worm\" has seen since departing from your location.","title":"Concept"},{"location":"Dynamic-In-Game-Map.html#setting-up-the-map-display","text":"First we must define the components for displaying the map. For the \"worm\" to know what symbol to draw on the map we will have it check an Attribute on the room it visits called sector_type . For this tutorial we understand two symbols - a normal room and the room with us in it. We also define a fallback symbol for rooms without said Attribute - that way the map will still work even if we didn't prepare the room correctly. Assuming your game folder is named mygame , we create this code in mygame/world/map.py. # in mygame/world/map.py # the symbol is identified with a key \"sector_type\" on the # Room. Keys None and \"you\" must always exist. SYMBOLS = { None : ' . ', # for rooms without sector_type Attribute 'you' : '[@]', 'SECT_INSIDE': '[.]' } Since trying to access an unset Attribute returns None , this means rooms without the sector_type Atttribute will show as . . Next we start building the custom class Map . It will hold all methods we need. # in mygame/world/map.py class Map(object): def __init__(self, caller, max_width=9, max_length=9): self.caller = caller self.max_width = max_width self.max_length = max_length self.worm_has_mapped = {} self.curX = None self.curY = None self.caller is normally your Character object, the one using the map. self.max_width/length determine the max width and length of the map that will be generated. Note that it's important that these variables are set to odd numbers to make sure the display area has a center point. self.worm_has_mapped is building off the worm analogy above. This dictionary will store all rooms the \"worm\" has mapped as well as its relative position within the grid. This is the most important variable as it acts as a 'checker' and 'address book' that is able to tell us where the worm has been and what it has mapped so far. self.curX/Y are coordinates representing the worm's current location on the grid. Before any sort of mapping can actually be done we need to create an empty display area and do some sanity checks on it by using the following methods. # in mygame/world/map.py class Map(object): # [... continued] def create_grid(self): # This method simply creates an empty grid/display area # with the specified variables from __init__(self): board = [] for row in range(self.max_width): board.append([]) for column in range(self.max_length): board[row].append(' ') return board def check_grid(self): # this method simply checks the grid to make sure # that both max_l and max_w are odd numbers. return True if self.max_length % 2 != 0 or self.max_width % 2 != 0\\ else False Before we can set our worm on its way, we need to know some of the computer science behind all this called 'Graph Traversing'. In Pseudo code what we are trying to accomplish is this: # pseudo code def draw_room_on_map(room, max_distance): self.draw(room) if max_distance == 0: return for exit in room.exits: if self.has_drawn(exit.destination): # skip drawing if we already visited the destination continue else: # first time here! self.draw_room_on_map(exit.destination, max_distance - 1) The beauty of Python is that our actual code of doing this doesn't differ much if at all from this Pseudo code example. max_distance is a variable indicating to our Worm how many rooms AWAY from your current location will it map. Obviously the larger the number the more time it will take if your current location has many many rooms around you. The first hurdle here is what value to use for 'max_distance'. There is no reason for the worm to travel further than what is actually displayed to you. For example, if your current location is placed in the center of a display area of size max_length = max_width = 9 , then the worm need only go 4 spaces in either direction: [.][.][.][.][@][.][.][.][.] 4 3 2 1 0 1 2 3 4 The max_distance can be set dynamically based on the size of the display area. As your width/length changes it becomes a simple algebraic linear relationship which is simply max_distance = (min(max_width, max_length) -1) / 2 .","title":"Setting up the Map Display"},{"location":"Dynamic-In-Game-Map.html#building-the-mapper","text":"Now we can start to fill our Map object with some methods. We are still missing a few methods that are very important: self.draw(self, room) - responsible for actually drawing room to grid. self.has_drawn(self, room) - checks to see if the room has been mapped and worm has already been here. self.median(self, number) - a simple utility method that finds the median (middle point) from 0, n self.update_pos(self, room, exit_name) - updates the worm's physical position by reassigning self.curX/Y. .accordingly self.start_loc_on_grid(self) - the very first initial draw on the grid representing your location in the middle of the grid 'self.show_map - after everything is done convert the map into a readable string self.draw_room_on_map(self, room, max_distance) - the main method that ties it all together.` Now that we know which methods we need, let's refine our initial __init__(self) to pass some conditional statements and set it up to start building the display. #mygame/world/map.py class Map(object): def __init__(self, caller, max_width=9, max_length=9): self.caller = caller self.max_width = max_width self.max_length = max_length self.worm_has_mapped = {} self.curX = None self.curY = None if self.check_grid(): # we have to store the grid into a variable self.grid = self.create_grid() # we use the algebraic relationship self.draw_room_on_map(caller.location, ((min(max_width, max_length) -1 ) / 2) Here we check to see if the parameters for the grid are okay, then we create an empty canvas and map our initial location as the first room! As mentioned above, the code for the self.draw_room_on_map() is not much different than the Pseudo code. The method is shown below: # in mygame/world/map.py, in the Map class def draw_room_on_map(self, room, max_distance): self.draw(room) if max_distance == 0: return for exit in room.exits: if exit.name not in (\"north\", \"east\", \"west\", \"south\"): # we only map in the cardinal directions. Mapping up/down would be # an interesting learning project for someone who wanted to try it. continue if self.has_drawn(exit.destination): # we've been to the destination already, skip ahead. continue self.update_pos(room, exit.name.lower()) self.draw_room_on_map(exit.destination, max_distance - 1) The first thing the \"worm\" does is to draw your current location in self.draw . Lets define that... #in mygame/word/map.py, in the Map class def draw(self, room): # draw initial ch location on map first! if room == self.caller.location: self.start_loc_on_grid() self.worm_has_mapped[room] = [self.curX, self.curY] else: # map all other rooms self.worm_has_mapped[room] = [self.curX, self.curY] # this will use the sector_type Attribute or None if not set. self.grid[self.curX][self.curY] = SYMBOLS[room.db.sector_type] In self.start_loc_on_grid() : def median(self, num): lst = sorted(range(0, num)) n = len(lst) m = n -1 return (lst[n//2] + lst[m//2]) / 2.0 def start_loc_on_grid(self): x = self.median(self.max_width) y = self.median(self.max_length) # x and y are floats by default, can't index lists with float types x, y = int(x), int(y) self.grid[x][y] = SYMBOLS['you'] self.curX, self.curY = x, y # updating worms current location After the system has drawn the current map it checks to see if the max_distance is 0 (since this is the inital start phase it is not). Now we handle the iteration once we have each individual exit in the room. The first thing it does is check if the room the Worm is in has been mapped already.. lets define that... def has_drawn(self, room): return True if room in self.worm_has_mapped.keys() else False If has_drawn returns False that means the worm has found a room that hasn't been mapped yet. It will then 'move' there. The self.curX/Y sort of lags behind, so we have to make sure to track the position of the worm; we do this in self.update_pos() below. def update_pos(self, room, exit_name): # this ensures the coordinates stays up to date # to where the worm is currently at. self.curX, self.curY = \\ self.worm_has_mapped[room][0], self.worm_has_mapped[room][1] # now we have to actually move the pointer # variables depending on which 'exit' it found if exit_name == 'east': self.curY += 1 elif exit_name == 'west': self.curY -= 1 elif exit_name == 'north': self.curX -= 1 elif exit_name == 'south': self.curX += 1 Once the system updates the position of the worm it feeds the new room back into the original draw_room_on_map() and starts the process all over again.. That is essentially the entire thing. The final method is to bring it all together and make a nice presentational string out of it using the self.show_map() method. def show_map(self): map_string = \"\" for row in self.grid: map_string += \" \".join(row) map_string += \"\\n\" return map_string","title":"Building the Mapper"},{"location":"Dynamic-In-Game-Map.html#using-the-map","text":"In order for the map to get triggered we store it on the Room typeclass. If we put it in return_appearance we will get the map back every time we look at the room. return_appearance is a default Evennia hook available on all objects; it is called e.g. by the look command to get the description of something (the room in this case). # in mygame/typeclasses/rooms.py from evennia import DefaultRoom from world.map import Map class Room(DefaultRoom): def return_appearance(self, looker): # [...] string = \"%s\\n\" % Map(looker).show_map() # Add all the normal stuff like room description, # contents, exits etc. string += \"\\n\" + super().return_appearance(looker) return string Obviously this method of generating maps doesn't take into account of any doors or exits that are hidden.. etc.. but hopefully it serves as a good base to start with. Like previously mentioned, it is very important to have a solid foundation on rooms before implementing this. You can try this on vanilla evennia by using @tunnel and essentially you can just create a long straight/edgy non-looping rooms that will show on your in-game map. The above example will display the map above the room description. You could also use an EvTable to place description and map next to each other. Some other things you can do is to have a Command that displays with a larger radius, maybe with a legend and other features. Below is the whole map.py for your reference. You need to update your Room typeclass (see above) to actually call it. Remember that to see different symbols for a location you also need to set the sector_type Attribute on the room to one of the keys in the SYMBOLS dictionary. So in this example, to make a room be mapped as [.] you would set the room's sector_type to \"SECT_INSIDE\" . Try it out with @set here/sector_type = \"SECT_INSIDE\" . If you wanted all new rooms to have a given sector symbol, you could change the default in the SYMBOLS\u00b4 dictionary below, or you could add the Attribute in the Room's at_object_creation` method. #mygame/world/map.py # These are keys set with the Attribute sector_type on the room. # The keys None and \"you\" must always exist. SYMBOLS = { None : ' . ', # for rooms without a sector_type attr 'you' : '[@]', 'SECT_INSIDE': '[.]' } class Map(object): def __init__(self, caller, max_width=9, max_length=9): self.caller = caller self.max_width = max_width self.max_length = max_length self.worm_has_mapped = {} self.curX = None self.curY = None if self.check_grid(): # we actually have to store the grid into a variable self.grid = self.create_grid() self.draw_room_on_map(caller.location, ((min(max_width, max_length) -1 ) / 2)) def update_pos(self, room, exit_name): # this ensures the pointer variables always # stays up to date to where the worm is currently at. self.curX, self.curY = \\ self.worm_has_mapped[room][0], self.worm_has_mapped[room][1] # now we have to actually move the pointer # variables depending on which 'exit' it found if exit_name == 'east': self.curY += 1 elif exit_name == 'west': self.curY -= 1 elif exit_name == 'north': self.curX -= 1 elif exit_name == 'south': self.curX += 1 def draw_room_on_map(self, room, max_distance): self.draw(room) if max_distance == 0: return for exit in room.exits: if exit.name not in (\"north\", \"east\", \"west\", \"south\"): # we only map in the cardinal directions. Mapping up/down would be # an interesting learning project for someone who wanted to try it. continue if self.has_drawn(exit.destination): # we've been to the destination already, skip ahead. continue self.update_pos(room, exit.name.lower()) self.draw_room_on_map(exit.destination, max_distance - 1) def draw(self, room): # draw initial caller location on map first! if room == self.caller.location: self.start_loc_on_grid() self.worm_has_mapped[room] = [self.curX, self.curY] else: # map all other rooms self.worm_has_mapped[room] = [self.curX, self.curY] # this will use the sector_type Attribute or None if not set. self.grid[self.curX][self.curY] = SYMBOLS[room.db.sector_type] def median(self, num): lst = sorted(range(0, num)) n = len(lst) m = n -1 return (lst[n//2] + lst[m//2]) / 2.0 def start_loc_on_grid(self): x = self.median(self.max_width) y = self.median(self.max_length) # x and y are floats by default, can't index lists with float types x, y = int(x), int(y) self.grid[x][y] = SYMBOLS['you'] self.curX, self.curY = x, y # updating worms current location def has_drawn(self, room): return True if room in self.worm_has_mapped.keys() else False def create_grid(self): # This method simply creates an empty grid # with the specified variables from __init__(self): board = [] for row in range(self.max_width): board.append([]) for column in range(self.max_length): board[row].append(' ') return board def check_grid(self): # this method simply checks the grid to make sure # both max_l and max_w are odd numbers return True if self.max_length % 2 != 0 or \\ self.max_width % 2 != 0 else False def show_map(self): map_string = \"\" for row in self.grid: map_string += \" \".join(row) map_string += \"\\n\" return map_string","title":"Using the Map"},{"location":"Dynamic-In-Game-Map.html#final-comments","text":"The Dynamic map could be expanded with further capabilities. For example, it could mark exits or allow NE, SE etc directions as well. It could have colors for different terrain types. One could also look into up/down directions and figure out how to display that in a good way.","title":"Final Comments"},{"location":"EvEditor.html","text":"Evennia offers a powerful in-game line editor in evennia.utils.eveditor.EvEditor . This editor, mimicking the well-known VI line editor. It offers line-by-line editing, undo/redo, line deletes, search/replace, fill, dedent and more. Launching the editor \u00b6 The editor is created as follows: from evennia.utils.eveditor import EvEditor EvEditor(caller, loadfunc=None, savefunc=None, quitfunc=None, key=\"\") caller (Object or Account): The user of the editor. loadfunc (callable, optional): This is a function called when the editor is first started. It is called with caller as its only argument. The return value from this function is used as the starting text in the editor buffer. savefunc (callable, optional): This is called when the user saves their buffer in the editor is called with two arguments, caller and buffer , where buffer is the current buffer. quitfunc (callable, optional): This is called when the user quits the editor. If given, all cleanup and exit messages to the user must be handled by this function. key (str, optional): This text will be displayed as an identifier and reminder while editing. It has no other mechanical function. persistent (default False ): if set to True , the editor will survive a reboot. Example of usage \u00b6 This is an example command for setting a specific Attribute using the editor. from evennia import Command from evennia.utils import eveditor class CmdSetTestAttr(Command): \"\"\" Set the \"test\" Attribute using the line editor. Usage: settestattr \"\"\" key = \"settestattr\" def func(self): \"Set up the callbacks and launch the editor\" def load(caller): \"get the current value\" return caller.attributes.get(\"test\") def save(caller, buffer): \"save the buffer\" caller.attributes.set(\"test\", buffer) def quit(caller): \"Since we define it, we must handle messages\" caller.msg(\"Editor exited\") key = \"%s/test\" % self.caller # launch the editor eveditor.EvEditor(self.caller, loadfunc=load, savefunc=save, quitfunc=quit, key=key) Persistent editor \u00b6 If you set the persistent keyword to True when creating the editor, it will remain open even when reloading the game. In order to be persistent, an editor needs to have its callback functions ( loadfunc , savefunc and quitfunc ) as top-level functions defined in the module. Since these functions will be stored, Python will need to find them. from evennia import Command from evennia.utils import eveditor def load(caller): \"get the current value\" return caller.attributes.get(\"test\") def save(caller, buffer): \"save the buffer\" caller.attributes.set(\"test\", buffer) def quit(caller): \"Since we define it, we must handle messages\" caller.msg(\"Editor exited\") class CmdSetTestAttr(Command): \"\"\" Set the \"test\" Attribute using the line editor. Usage: settestattr \"\"\" key = \"settestattr\" def func(self): \"Set up the callbacks and launch the editor\" key = \"%s/test\" % self.caller # launch the editor eveditor.EvEditor(self.caller, loadfunc=load, savefunc=save, quitfunc=quit, key=key, persistent=True) Line editor usage \u00b6 The editor mimics the VIM editor as best as possible. The below is an excerpt of the return from the in-editor help command ( :h ). <txt> - any non-command is appended to the end of the buffer. : <l> - view buffer or only line <l> :: <l> - view buffer without line numbers or other parsing ::: - print a ':' as the only character on the line... :h - this help. :w - save the buffer (don't quit) :wq - save buffer and quit :q - quit (will be asked to save if buffer was changed) :q! - quit without saving, no questions asked :u - (undo) step backwards in undo history :uu - (redo) step forward in undo history :UU - reset all changes back to initial state :dd <l> - delete line <n> :dw <l> <w> - delete word or regex <w> in entire buffer or on line <l> :DD - clear buffer :y <l> - yank (copy) line <l> to the copy buffer :x <l> - cut line <l> and store it in the copy buffer :p <l> - put (paste) previously copied line directly after <l> :i <l> <txt> - insert new text <txt> at line <l>. Old line will move down :r <l> <txt> - replace line <l> with text <txt> :I <l> <txt> - insert text at the beginning of line <l> :A <l> <txt> - append text after the end of line <l> :s <l> <w> <txt> - search/replace word or regex <w> in buffer or on line <l> :f <l> - flood-fill entire buffer or line <l> :fi <l> - indent entire buffer or line <l> :fd <l> - de-indent entire buffer or line <l> :echo - turn echoing of the input on/off (helpful for some clients) Legend: <l> - line numbers, or range lstart:lend, e.g. '3:7'. <w> - one word or several enclosed in quotes. <txt> - longer string, usually not needed to be enclosed in quotes. The EvEditor to edit code \u00b6 The EvEditor is also used to edit some Python code in Evennia. The @py command supports an /edit switch that will open the EvEditor in code mode. This mode isn't significantly different from the standard one, except it handles automatic indentation of blocks and a few options to control this behavior. :< to remove a level of indentation for the future lines. :+ to add a level of indentation for the future lines. := to disable automatic indentation altogether. Automatic indentation is there to make code editing more simple. Python needs correct indentation, not as an aesthetic addition, but as a requirement to determine beginning and ending of blocks. The EvEditor will try to guess the next level of indentation. If you type a block \"if\", for instance, the EvEditor will propose you an additional level of indentation at the next line. This feature cannot be perfect, however, and sometimes, you will have to use the above options to handle indentation. := can be used to turn automatic indentation off completely. This can be very useful when trying to paste several lines of code that are already correctly indented, for instance. To see the EvEditor in code mode, you can use the @py/edit command. Type in your code (on one or several lines). You can then use the :w option (save without quitting) and the code you have typed will be executed. The :! will do the same thing. Executing code while not closing the editor can be useful if you want to test the code you have typed but add new lines after your test.","title":"EvEditor"},{"location":"EvEditor.html#launching-the-editor","text":"The editor is created as follows: from evennia.utils.eveditor import EvEditor EvEditor(caller, loadfunc=None, savefunc=None, quitfunc=None, key=\"\") caller (Object or Account): The user of the editor. loadfunc (callable, optional): This is a function called when the editor is first started. It is called with caller as its only argument. The return value from this function is used as the starting text in the editor buffer. savefunc (callable, optional): This is called when the user saves their buffer in the editor is called with two arguments, caller and buffer , where buffer is the current buffer. quitfunc (callable, optional): This is called when the user quits the editor. If given, all cleanup and exit messages to the user must be handled by this function. key (str, optional): This text will be displayed as an identifier and reminder while editing. It has no other mechanical function. persistent (default False ): if set to True , the editor will survive a reboot.","title":"Launching the editor"},{"location":"EvEditor.html#example-of-usage","text":"This is an example command for setting a specific Attribute using the editor. from evennia import Command from evennia.utils import eveditor class CmdSetTestAttr(Command): \"\"\" Set the \"test\" Attribute using the line editor. Usage: settestattr \"\"\" key = \"settestattr\" def func(self): \"Set up the callbacks and launch the editor\" def load(caller): \"get the current value\" return caller.attributes.get(\"test\") def save(caller, buffer): \"save the buffer\" caller.attributes.set(\"test\", buffer) def quit(caller): \"Since we define it, we must handle messages\" caller.msg(\"Editor exited\") key = \"%s/test\" % self.caller # launch the editor eveditor.EvEditor(self.caller, loadfunc=load, savefunc=save, quitfunc=quit, key=key)","title":"Example of usage"},{"location":"EvEditor.html#persistent-editor","text":"If you set the persistent keyword to True when creating the editor, it will remain open even when reloading the game. In order to be persistent, an editor needs to have its callback functions ( loadfunc , savefunc and quitfunc ) as top-level functions defined in the module. Since these functions will be stored, Python will need to find them. from evennia import Command from evennia.utils import eveditor def load(caller): \"get the current value\" return caller.attributes.get(\"test\") def save(caller, buffer): \"save the buffer\" caller.attributes.set(\"test\", buffer) def quit(caller): \"Since we define it, we must handle messages\" caller.msg(\"Editor exited\") class CmdSetTestAttr(Command): \"\"\" Set the \"test\" Attribute using the line editor. Usage: settestattr \"\"\" key = \"settestattr\" def func(self): \"Set up the callbacks and launch the editor\" key = \"%s/test\" % self.caller # launch the editor eveditor.EvEditor(self.caller, loadfunc=load, savefunc=save, quitfunc=quit, key=key, persistent=True)","title":"Persistent editor"},{"location":"EvEditor.html#line-editor-usage","text":"The editor mimics the VIM editor as best as possible. The below is an excerpt of the return from the in-editor help command ( :h ). <txt> - any non-command is appended to the end of the buffer. : <l> - view buffer or only line <l> :: <l> - view buffer without line numbers or other parsing ::: - print a ':' as the only character on the line... :h - this help. :w - save the buffer (don't quit) :wq - save buffer and quit :q - quit (will be asked to save if buffer was changed) :q! - quit without saving, no questions asked :u - (undo) step backwards in undo history :uu - (redo) step forward in undo history :UU - reset all changes back to initial state :dd <l> - delete line <n> :dw <l> <w> - delete word or regex <w> in entire buffer or on line <l> :DD - clear buffer :y <l> - yank (copy) line <l> to the copy buffer :x <l> - cut line <l> and store it in the copy buffer :p <l> - put (paste) previously copied line directly after <l> :i <l> <txt> - insert new text <txt> at line <l>. Old line will move down :r <l> <txt> - replace line <l> with text <txt> :I <l> <txt> - insert text at the beginning of line <l> :A <l> <txt> - append text after the end of line <l> :s <l> <w> <txt> - search/replace word or regex <w> in buffer or on line <l> :f <l> - flood-fill entire buffer or line <l> :fi <l> - indent entire buffer or line <l> :fd <l> - de-indent entire buffer or line <l> :echo - turn echoing of the input on/off (helpful for some clients) Legend: <l> - line numbers, or range lstart:lend, e.g. '3:7'. <w> - one word or several enclosed in quotes. <txt> - longer string, usually not needed to be enclosed in quotes.","title":"Line editor usage"},{"location":"EvEditor.html#the-eveditor-to-edit-code","text":"The EvEditor is also used to edit some Python code in Evennia. The @py command supports an /edit switch that will open the EvEditor in code mode. This mode isn't significantly different from the standard one, except it handles automatic indentation of blocks and a few options to control this behavior. :< to remove a level of indentation for the future lines. :+ to add a level of indentation for the future lines. := to disable automatic indentation altogether. Automatic indentation is there to make code editing more simple. Python needs correct indentation, not as an aesthetic addition, but as a requirement to determine beginning and ending of blocks. The EvEditor will try to guess the next level of indentation. If you type a block \"if\", for instance, the EvEditor will propose you an additional level of indentation at the next line. This feature cannot be perfect, however, and sometimes, you will have to use the above options to handle indentation. := can be used to turn automatic indentation off completely. This can be very useful when trying to paste several lines of code that are already correctly indented, for instance. To see the EvEditor in code mode, you can use the @py/edit command. Type in your code (on one or several lines). You can then use the :w option (save without quitting) and the code you have typed will be executed. The :! will do the same thing. Executing code while not closing the editor can be useful if you want to test the code you have typed but add new lines after your test.","title":"The EvEditor to edit code"},{"location":"EvMenu.html","text":"Introduction \u00b6 The EvMenu utility class is located in evennia/utils/evmenu.py . It allows for easily adding interactive menus to the game; for example to implement Character creation, building commands or similar. Below is an example of offering NPC conversation choices: The guard looks at you suspiciously. \"No one is supposed to be in here ...\" he says, a hand on his weapon. _______________________________________________ 1. Try to bribe him [Cha + 10 gold] 2. Convince him you work here [Int] 3. Appeal to his vanity [Cha] 4. Try to knock him out [Luck + Dex] 5. Try to run away [Dex] This is an example of a menu node . Think of a node as a point where the menu stops printing text and waits for user to give some input. By jumping to different nodes depending on the input, a menu is constructed. To create the menu, EvMenu uses normal Python functions, one per node. It will load all those functions/nodes either from a module or by being passed a dictionary mapping the node's names to said functions, like {\"nodename\": <function>, ...} Launching the menu \u00b6 Initializing the menu is done using a call to the evennia.utils.evmenu.EvMenu class. This is the most common way to do so - from inside a Command : # in, for example gamedir/commands/command.py from evennia.utils.evmenu import EvMenu class CmdTestMenu(Command): key = \"testcommand\" def func(self): EvMenu(caller, \"world.mymenu\") When running this command, the menu will start using the menu nodes loaded from mygame/world/mymenu.py . See next section on how to define menu nodes. The EvMenu has the following optional callsign: EvMenu(caller, menu_data, startnode=\"start\", cmdset_mergetype=\"Replace\", cmdset_priority=1, auto_quit=True, auto_look=True, auto_help=True, cmd_on_exit=\"look\", persistent=False, startnode_input=\"\", session=None, debug=False, **kwargs) caller (Object or Account): is a reference to the object using the menu. This object will get a new CmdSet assigned to it, for handling the menu. menu_data (str, module or dict): is a module or python path to a module where the global-level functions will each be considered to be a menu node. Their names in the module will be the names by which they are referred to in the module. Importantly, function names starting with an underscore _ will be ignored by the loader. Alternatively, this can be a direct mapping {\"nodename\":function, ...} . startnode (str): is the name of the menu-node to start the menu at. Changing this means that you can jump into a menu tree at different positions depending on circumstance and thus possibly re-use menu entries. cmdset_mergetype (str): This is usually one of \"Replace\" or \"Union\" (see CmdSets . The first means that the menu is exclusive - the user has no access to any other commands while in the menu. The Union mergetype means the menu co-exists with previous commands (and may overload them, so be careful as to what to name your menu entries in this case). cmdset_priority (int): The priority with which to merge in the menu cmdset. This allows for advanced usage. auto_quit , auto_look , auto_help (bool): If either of these are True , the menu automatically makes a quit , look or help command available to the user. The main reason why you'd want to turn this off is if you want to use the aliases \"q\", \"l\" or \"h\" for something in your menu. Nevertheless, at least quit is highly recommend - if False , the menu must itself supply an \"exit node\" (a node without any options), or the user will be stuck in the menu until the server reloads (or eternally if the menu is persistent )! cmd_on_exit (str): This command string will be executed right after the menu has closed down. From experience, it's useful to trigger a \"look\" command to make sure the user is aware of the change of state; but any command can be used. If set to None , no command will be triggered after exiting the menu. persistent (bool) - if True , the menu will survive a reload (so the user will not be kicked out by the reload - make sure they can exit on their own!) startnode_input (str or (str, dict) tuple): Pass an input text or a input text + kwargs to the start node as if it was entered on a fictional previous node. This can be very useful in order to start a menu differently depending on the Command's arguments in which it was initialized. session (Session): Useful when calling the menu from an Account in MULTISESSION_MODDE higher than 2, to make sure only the right Session sees the menu output. debug (bool): If set, the menudebug command will be made available in the menu. Use it to list the current state of the menu and use menudebug <variable> to inspect a specific state variable from the list. All other keyword arguments will be available as initial data for the nodes. They will be available in all nodes as properties on caller.ndb._menutree (see below). These will also survive a @reload if the menu is persistent . You don't need to store the EvMenu instance anywhere - the very act of initializing it will store it as caller.ndb._menutree on the caller . This object will be deleted automatically when the menu is exited and you can also use it to store your own temporary variables for access throughout the menu. Temporary variables you store on a persistent _menutree as it runs will not survive a @reload , only those you set as part of the original EvMenu call. The Menu nodes \u00b6 The EvMenu nodes consist of functions on one of these forms. def menunodename1(caller): # code return text, options def menunodename2(caller, raw_string): # code return text, options def menunodename3(caller, raw_string, **kwargs): # code return text, options While all of the above forms are okay, it's recommended to stick to the third and last form since it gives the most flexibility. The previous forms are mainly there for backwards compatibility with existing menus from a time when EvMenu was less able. Input arguments to the node \u00b6 caller (Object or Account): The object using the menu - usually a Character but could also be a Session or Account depending on where the menu is used. raw_string (str): If this is given, it will be set to the exact text the user entered on the previous node (that is, the command entered to get to this node). On the starting-node of the menu, this will be an empty string, unless startnode_input was set. kwargs (dict): These extra keyword arguments are extra optional arguments passed to the node when the user makes a choice on the previous node. This may include things like status flags and details about which exact option was chosen (which can be impossible to determine from raw_string alone). Just what is passed in kwargs is up to you when you create the previous node. Return values from the node \u00b6 Each function must return two variables, text and options . text \u00b6 The text variable is a string or tuple. This text is what will be displayed when the user reaches this node. If this is a tuple, then the first element of the tuple will be considered the displayed text and the second the help-text to display when the user enters the help command on this node. text = (\"This is the text to display\", \"This is the help text for this node\") Returning a None text is allowed and simply leads to a node with no text and only options. If the help text is not given, the menu will give a generic error message when using help . options \u00b6 The options list describe all the choices available to the user when viewing this node. If options is returned as None , it means that this node is an Exit node - any text is displayed and then the menu immediately exits, running the exit_cmd if given. Otherwise, options should be a list (or tuple) of dictionaries, one for each option. If only one option is available, a single dictionary can also be returned. This is how it could look: def node_test(caller, raw_string, **kwargs): text = \"A goblin attacks you!\" options = ( {\"key\": (\"Attack\", \"a\", \"att\"), \"desc\": \"Strike the enemy with all your might\", \"goto\": \"node_attack\"}, {\"key\": (\"Defend\", \"d\", \"def\"), \"desc\": \"Hold back and defend yourself\", \"goto\": (_defend, {\"str\": 10, \"enemyname\": \"Goblin\"})}) return text, options This will produce a menu node looking like this: A goblin attacks you! ________________________________ Attack: Strike the enemy with all your might Defend: Hold back and defend yourself option-key 'key' \u00b6 The option's key is what the user should enter in order to choose that option. If given as a tuple, the first string of that tuple will be what is shown on-screen while the rest are aliases for picking that option. In the above example, the user could enter \"Attack\" (or \"attack\", it's not case-sensitive), \"a\" or \"att\" in order to attack the goblin. Aliasing is useful for adding custom coloring to the choice. The first element of the aliasing tuple should then be the colored version, followed by a version without color - since otherwise the user would have to enter the color codes to select that choice. Note that the key is optional . If no key is given, it will instead automatically be replaced with a running number starting from 1 . If removing the key part of each option, the resulting menu node would look like this instead: A goblin attacks you! ________________________________ 1: Strike the enemy with all your might 2: Hold back and defend yourself Whether you want to use a key or rely on numbers is mostly a matter of style and the type of menu. EvMenu accepts one important special key given only as \"_default\" . This key is used when a user enters something that does not match any other fixed keys. It is particularly useful for getting user input: def node_readuser(caller, raw_string, **kwargs): text = \"Please enter your name\" options = {\"key\": \"_default\", \"goto\": \"node_parse_input\"} return text, options A \"_default\" option does not show up in the menu, so the above will just be a node saying \"Please enter your name\" . The name they entered will appear as raw_string in the next node. option-key 'desc' \u00b6 This simply contains the description as to what happens when selecting the menu option. For \"_default\" options or if the key is already long or descriptive, it is not strictly needed. But usually it's better to keep the key short and put more detail in desc . option-key 'goto' \u00b6 This is the operational part of the option and fires only when the user chooses said option. Here are three ways to write it def _action_two(caller, raw_string, **kwargs): # do things ... return calculated_node_to_go_to def _action_three(caller, raw_string, **kwargs): # do things ... return \"node_four\", {\"mode\": 4} def node_select(caller, raw_string, **kwargs): text = (\"select one\", \"help: they all do different things ...\") options = ({\"desc\": \"Option one\", \"goto\": \"node_one\"}, {\"desc\": \"Option two\", \"goto\": _action_two} {\"desc\": \"Option three\", \"goto\": (_action_three, {\"key\": 1, \"key2\": 2}) return text, options As seen above, goto could just be pointing to a single nodename string - the name of the node to go to. When given like this, EvMenu will look for a node named like this and call its associated function as nodename(caller, raw_string, **kwargs)` Here, raw_string is always the input the user entered to make that choice and kwargs are the same as those kwargs that already entered the current node (they are passed on). Alternatively the goto could point to a \"goto-callable\". Such callables are usually defined in the same module as the menu nodes and given names starting with _ (to avoid being parsed as nodes themselves). These callables will be called the same as a node function - callable(caller, raw_string, **kwargs) , where raw_string is what the user entered on this node and **kwargs is forwarded from the node's own input. The goto option key could also point to a tuple (callable, kwargs) - this allows for customizing the kwargs passed into the goto-callable, for example you could use the same callable but change the kwargs passed into it depending on which option was actually chosen. The \"goto callable\" must either return a string \"nodename\" or a tuple (\"nodename\", mykwargs) . This will lead to the next node being called as either nodename(caller, raw_string, **kwargs) or nodename(caller, raw_string, **mykwargs) - so this allows changing (or replacing) the options going into the next node depending on what option was chosen. There is one important case - if the goto-callable returns None for a nodename , the current node will run again , possibly with different kwargs. This makes it very easy to re-use a node over and over, for example allowing different options to update some text form being passed and manipulated for every iteration. The EvMenu also supports the exec option key. This allows for running a callable before the goto-callable. This functionality comes from a time before goto could be a callable and is deprecated as of Evennia 0.8. Use goto for all functionality where you'd before use exec . Temporary storage \u00b6 When the menu starts, the EvMenu instance is stored on the caller as caller.ndb._menutree . Through this object you can in principle reach the menu's internal state if you know what you are doing. This is also a good place to store temporary, more global variables that may be cumbersome to keep passing from node to node via the **kwargs . The _menutree will be deleted automatically when the menu closes, meaning you don't need to worry about cleaning anything up. If you want permanent state storage, it's instead better to use an Attribute on caller . Remember that this will remain after the menu closes though, so you need to handle any needed cleanup yourself. Customizing Menu formatting \u00b6 The EvMenu display of nodes, options etc are controlled by a series of formatting methods on the EvMenu class. To customize these, simply create a new child class of EvMenu and override as needed. Here is an example: from evennia.utils.evmenu import EvMenu class MyEvMenu(EvMenu): def nodetext_formatter(self, nodetext): \"\"\" Format the node text itself. Args: nodetext (str): The full node text (the text describing the node). Returns: nodetext (str): The formatted node text. \"\"\" def helptext_formatter(self, helptext): \"\"\" Format the node's help text Args: helptext (str): The unformatted help text for the node. Returns: helptext (str): The formatted help text. \"\"\" def options_formatter(self, optionlist): \"\"\" Formats the option block. Args: optionlist (list): List of (key, description) tuples for every option related to this node. caller (Object, Account or None, optional): The caller of the node. Returns: options (str): The formatted option display. \"\"\" def node_formatter(self, nodetext, optionstext): \"\"\" Formats the entirety of the node. Args: nodetext (str): The node text as returned by `self.nodetext_formatter`. optionstext (str): The options display as returned by `self.options_formatter`. caller (Object, Account or None, optional): The caller of the node. Returns: node (str): The formatted node to display. \"\"\" See evennia/utils/evmenu.py for the details of their default implementations. Examples: \u00b6 Simple branching menu - choose from options Dynamic goto - jumping to different nodes based on response Set caller properties - a menu that changes things Getting arbitrary input - entering text Storing data between nodes - keeping states and information while in the menu Repeating the same node - validating within the node before moving to the next Full Menu : a complete example Yes/No prompt - entering text with limited possible responses (this is not using EvMenu but the conceptually similar yet technically unrelated get_input helper function accessed as evennia.utils.evmenu.get_input ). Example: Simple branching menu \u00b6 Below is an example of a simple branching menu node leading to different other nodes depending on choice: # in mygame/world/mychargen.py def define_character(caller): text = \\ \"\"\" What aspect of your character do you want to change next? \"\"\" options = ({\"desc\": \"Change the name\", \"goto\": \"set_name\"}, {\"desc\": \"Change the description\", \"goto\": \"set_description\"}) return text, options EvMenu(caller, \"world.mychargen\", startnode=\"define_character\") This will result in the following node display: What aspect of your character do you want to change next? _________________________ 1: Change the name 2: Change the description Note that since we didn't specify the \"name\" key, EvMenu will let the user enter numbers instead. In the following examples we will not include the EvMenu call but just show nodes running inside the menu. Also, since EvMenu also takes a dictionary to describe the menu, we could have called it like this instead in the example: EvMenu(caller, {\"define_character\": define_character}, startnode=\"define_character\") Example: Dynamic goto \u00b6 def _is_in_mage_guild(caller, raw_string, **kwargs): if caller.tags.get('mage', category=\"guild_member\"): return \"mage_guild_welcome\" else: return \"mage_guild_blocked\" def enter_guild: text = 'You say to the mage guard:' options ({'desc': 'I need to get in there.', 'goto': _is_in_mage_guild}, {'desc': 'Never mind', 'goto': 'end_conversation'}) return text, options This simple callable goto will analyse what happens depending on who the caller is. The enter_guild node will give you a choice of what to say to the guard. If you try to enter, you will end up in different nodes depending on (in this example) if you have the right Tag set on yourself or not. Note that since we don't include any 'key's in the option dictionary, you will just get to pick between numbers. Example: Set caller properties \u00b6 Here is an example of passing arguments into the goto callable and use that to influence which node it should go to next: def _set_attribute(caller, raw_string, **kwargs): \"Get which attribute to modify and set it\" attrname, value = kwargs.get(\"attr\", (None, None)) next_node = kwargs.get(\"next_node\") caller.attributes.add(attrname, attrvalue) return next_node def node_background(caller): text = \\ \"\"\" {} experienced a traumatic event in their childhood. What was it? \"\"\".format(caller.key} options = ({\"key\": \"death\", \"desc\": \"A violent death in the family\", \"goto\": (_set_attribute, {\"attr\": (\"experienced_violence\", True), \"next_node\": \"node_violent_background\"})}, {\"key\": \"betrayal\", \"desc\": \"The betrayal of a trusted grown-up\", \"goto\": (_set_attribute, {\"attr\": (\"experienced_betrayal\", True), \"next_node\": \"node_betrayal_background\"})}) return text, options This will give the following output: Kovash the magnificent experienced a traumatic event in their childhood. What was it? ____________________________________________________ death: A violent death in the family betrayal: The betrayal of a trusted grown-up Note above how we use the _set_attribute helper function to set the attribute depending on the User's choice. In thie case the helper function doesn't know anything about what node called it - we even tell it which nodename it should return, so the choices leads to different paths in the menu. We could also imagine the helper function analyzing what other choices Example: Get arbitrary input \u00b6 An example of the menu asking the user for input - any input. def _set_name(caller, raw_string, **kwargs): inp = raw_string.strip() prev_entry = kwargs.get(\"prev_entry\") if not inp: # a blank input either means OK or Abort if prev_entry: caller.key = prev_entry caller.msg(\"Set name to {}.\".format(prev_entry)) return \"node_background\" else: caller.msg(\"Aborted.\") return \"node_exit\" else: # re-run old node, but pass in the name given return None, {\"prev_entry\": inp} def enter_name(caller, raw_string, **kwargs): # check if we already entered a name before prev_entry = kwargs.get(\"prev_entry\") if prev_entry: text = \"Current name: {}.\\nEnter another name or <return> to accept.\" else: text = \"Enter your character's name or <return> to abort.\" options = {\"key\": \"_default\", \"goto\": (_set_name, {\"prev_entry\": prev_entry})} return text, options This will display as Enter your character's name or <return> to abort. > Gandalf Current name: Gandalf Enter another name or <return> to accept. > Set name to Gandalf. Here we re-use the same node twice for reading the input data from the user. Whatever we enter will be caught by the _default option and passed into the helper function. We also pass along whatever name we have entered before. This allows us to react correctly on an \"empty\" input - continue to the node named \"node_background\" if we accept the input or go to an exit node if we presses Return without entering anything. By returning None from the helper function we automatically re-run the previous node, but updating its ingoing kwargs to tell it to display a different text. Example: Storing data between nodes \u00b6 A convenient way to store data is to store it on the caller.ndb._menutree which you can reach from every node. The advantage of doing this is that the _menutree NAttribute will be deleted automatically when you exit the menu. def _set_name(caller, raw_string, **kwargs): caller.ndb._menutree.charactersheet = {} caller.ndb._menutree.charactersheet['name'] = raw_string caller.msg(\"You set your name to {}\".format(raw_string) return \"background\" def node_set_name(caller): text = 'Enter your name:' options = {'key': '_default', 'goto': _set_name} return text, options ... def node_view_sheet(caller): text = \"Character sheet:\\n {}\".format(self.ndb._menutree.charactersheet) options = ({\"key\": \"Accept\", \"goto\": \"finish_chargen\"}, {\"key\": \"Decline\", \"goto\": \"start_over\"}) return text, options Instead of passing the character sheet along from node to node through the kwargs we instead set it up temporarily on caller.ndb._menutree.charactersheet . This makes it easy to reach from all nodes. At the end we look at it and, if we accept the character the menu will likely save the result to permanent storage and exit. One point to remember though is that storage on caller.ndb._menutree is not persistent across @reloads . If you are using a persistent menu (using EvMenu(..., persistent=True) you should use caller.db to store in-menu data like this as well. You must then yourself make sure to clean it when the user exits the menu. Example: Repeating the same node \u00b6 Sometimes you want to make a chain of menu nodes one after another, but you don't want the user to be able to continue to the next node until you have verified that what they input in the previous node is ok. A common example is a login menu: def _check_username(caller, raw_string, **kwargs): # we assume lookup_username() exists if not lookup_username(raw_string): # re-run current node by returning `None` caller.msg(\"|rUsername not found. Try again.\") return None else: # username ok - continue to next node return \"node_password\" def node_username(caller): text = \"Please enter your user name.\" options = {\"key\": \"_default\", \"goto\": _check_username} return text, options def _check_password(caller, raw_string, **kwargs): nattempts = kwargs.get(\"nattempts\", 0) if nattempts > 3: caller.msg(\"Too many failed attempts. Logging out\") return \"node_abort\" elif not validate_password(raw_string): caller.msg(\"Password error. Try again.\") return None, {\"nattempts\", nattempts + 1} else: # password accepted return \"node_login\" def node_password(caller, raw_string, **kwargs): text = \"Enter your password.\" options = {\"key\": \"_default\", \"goto\": _check_password} return text, options This will display something like --------------------------- Please enter your username. --------------------------- > Fo ------------------------------ Username not found. Try again. ______________________________ abort: (back to start) ------------------------------ > Foo --------------------------- Please enter your password. --------------------------- > Bar -------------------------- Password error. Try again. -------------------------- And so on. Here the goto-callables will return to the previous node if there is an error. In the case of password attempts, this will tick up the nattempts argument that will get passed on from iteration to iteration until too many attempts have been made. Defining nodes in a dictionary \u00b6 You can also define your nodes directly in a dictionary to feed into the EvMenu creator. def mynode(caller): # a normal menu node function return text, options menu_data = {\"node1\": mynode, \"node2\": lambda caller: ( \"This is the node text\", ({\"key\": \"lambda node 1\", \"desc\": \"go to node 1 (mynode)\", \"goto\": \"node1\"}, {\"key\": \"lambda node 2\", \"desc\": \"go to thirdnode\", \"goto\": \"node3\"})), \"node3\": lambda caller, raw_string: ( # ... etc ) } # start menu, assuming 'caller' is available from earlier EvMenu(caller, menu_data, startnode=\"node1\") The keys of the dictionary become the node identifiers. You can use any callable on the right form to describe each node. If you use Python lambda expressions you can make nodes really on the fly. If you do, the lambda expression must accept one or two arguments and always return a tuple with two elements (the text of the node and its options), same as any menu node function. Creating menus like this is one way to present a menu that changes with the circumstances - you could for example remove or add nodes before launching the menu depending on some criteria. The drawback is that a lambda expression is much more limited than a full function - for example you can't use other Python keywords like if inside the body of the lambda . Unless you are dealing with a relatively simple dynamic menu, defining menus with lambda's is probably more work than it's worth: You can create dynamic menus by instead making each node function more clever. See the NPC shop tutorial for an example of this. Ask for simple input \u00b6 This describes two ways for asking for simple questions from the user. Using Python's raw_string will not work in Evennia. raw_string will block the entire server for everyone until that one player has entered their text, which is not what you want. The yield way \u00b6 In the func method of your Commands (only) you can use Python's built-in yield command to request input in a similar way to raw_string . It looks like this: result = yield(\"Please enter your answer:\") This will send \"Please enter your answer\" to the Command's self.caller and then pause at that point. All other players at the server will be unaffected. Once caller enteres a reply, the code execution will continue and you can do stuff with the result . Here is an example: from evennia import Command class CmdTestInput(Command): key = \"test\" def func(self): result = yield(\"Please enter something:\") self.caller.msg(f\"You entered {result}.\") result2 = yield(\"Now enter something else:\") self.caller.msg(f\"You now entered {result2}.\") Using yield is simple and intuitive, but it will only access input from self.caller and you cannot abort or time out the pause until the player has responded. Under the hood, it is actually just a wrapper calling get_input described in the following section. Important Note: In Python you cannot mix yield and return <value> in the same method . It has to do with yield turning the method into a generator . A return without an argument works, you can just not do return <value> . This is usually not something you need to do in func() anyway, but worth keeping in mind. The get_input way \u00b6 The evmenu module offers a helper function named get_input . This is wrapped by the yield statement which is often easier and more intuitive to use. But get_input offers more flexibility and power if you need it. While in the same module as EvMenu , get_input is technically unrelated to it. The get_input allows you to ask and receive simple one-line input from the user without launching the full power of a menu to do so. To use, call get_input like this: get_input(caller, prompt, callback) Here caller is the entity that should receive the prompt for input given as prompt . The callback is a callable function(caller, prompt, user_input) that you define to handle the answer from the user. When run, the caller will see prompt appear on their screens and any text they enter will be sent into the callback for whatever processing you want. Below is a fully explained callback and example call: from evennia import Command from evennia.utils.evmenu import get_input def callback(caller, prompt, user_input): \"\"\" This is a callback you define yourself. Args: caller (Account or Object): The one being asked for input prompt (str): A copy of the current prompt user_input (str): The input from the account. Returns: repeat (bool): If not set or False, exit the input prompt and clean up. If returning anything True, stay in the prompt, which means this callback will be called again with the next user input. \"\"\" caller.msg(f\"When asked '{prompt}', you answered '{user_input}'.\") get_input(caller, \"Write something! \", callback) This will show as Write something! > Hello When asked 'Write something!', you answered 'Hello'. Normally, the get_input function quits after any input, but as seen in the example docs, you could return True from the callback to repeat the prompt until you pass whatever check you want. Note: You cannot link consecutive questions by putting a new get_input call inside the callback If you want that you should use an EvMenu instead (see the Repeating the same node example above). Otherwise you can either peek at the implementation of get_input and implement your own mechanism (it's just using cmdset nesting) or you can look at this extension suggested on the mailing list . Example: Yes/No prompt \u00b6 Below is an example of a Yes/No prompt using the get_input function: def yesno(caller, prompt, result): if result.lower() in (\"y\", \"yes\", \"n\", \"no\"): # do stuff to handle the yes/no answer # ... # if we return None/False the prompt state # will quit after this else: # the answer is not on the right yes/no form caller.msg(\"Please answer Yes or No. \\n{prompt}\") @ # returning True will make sure the prompt state is not exited return True # ask the question get_input(caller, \"Is Evennia great (Yes/No)?\", yesno) The @list_node decorator \u00b6 The evennia.utils.evmenu.list_node is an advanced decorator for use with EvMenu node functions. It is used to quickly create menus for manipulating large numbers of items. text here ______________________________________________ 1. option1 7. option7 13. option13 2. option2 8. option8 14. option14 3. option3 9. option9 [p]revius page 4. option4 10. option10 page 2 5. option5 11. option11 [n]ext page 6. option6 12. option12 The menu will automatically create an multi-page option listing that one can flip through. One can inpect each entry and then select them with prev/next. This is how it is used: from evennia.utils.evmenu import list_node ... _options(caller): return ['option1', 'option2', ... 'option100'] _select(caller, menuchoice, available_choices): # analyze choice return \"next_node\" @list_node(options, select=_select, pagesize=10) def node_mylist(caller, raw_string, **kwargs): ... return text, options The options argument to list_node is either a list, a generator or a callable returning a list of strings for each option that should be displayed in the node. The select is a callable in the example above but could also be the name of a menu node. If a callable, the menuchoice argument holds the selection done and available_choices holds all the options available. The callable should return the menu to go to depending on the selection (or None to rerun the same node). If the name of a menu node, the selection will be passed as selection kwarg to that node. The decorated node itself should return text to display in the node. It must return at least an empty dictionary for its options. It returning options, those will supplement the options auto-created by the list_node decorator. Assorted notes \u00b6 The EvMenu is implemented using Commands . When you start a new EvMenu, the user of the menu will be assigned a CmdSet with the commands they need to navigate the menu. This means that if you were to, from inside the menu, assign a new command set to the caller, you may override the Menu Cmdset and kill the menu . If you want to assign cmdsets to the caller as part of the menu, you should store the cmdset on caller.ndb._menutree and wait to actually assign it until the exit node.","title":"EvMenu"},{"location":"EvMenu.html#introduction","text":"The EvMenu utility class is located in evennia/utils/evmenu.py . It allows for easily adding interactive menus to the game; for example to implement Character creation, building commands or similar. Below is an example of offering NPC conversation choices: The guard looks at you suspiciously. \"No one is supposed to be in here ...\" he says, a hand on his weapon. _______________________________________________ 1. Try to bribe him [Cha + 10 gold] 2. Convince him you work here [Int] 3. Appeal to his vanity [Cha] 4. Try to knock him out [Luck + Dex] 5. Try to run away [Dex] This is an example of a menu node . Think of a node as a point where the menu stops printing text and waits for user to give some input. By jumping to different nodes depending on the input, a menu is constructed. To create the menu, EvMenu uses normal Python functions, one per node. It will load all those functions/nodes either from a module or by being passed a dictionary mapping the node's names to said functions, like {\"nodename\": <function>, ...}","title":"Introduction"},{"location":"EvMenu.html#launching-the-menu","text":"Initializing the menu is done using a call to the evennia.utils.evmenu.EvMenu class. This is the most common way to do so - from inside a Command : # in, for example gamedir/commands/command.py from evennia.utils.evmenu import EvMenu class CmdTestMenu(Command): key = \"testcommand\" def func(self): EvMenu(caller, \"world.mymenu\") When running this command, the menu will start using the menu nodes loaded from mygame/world/mymenu.py . See next section on how to define menu nodes. The EvMenu has the following optional callsign: EvMenu(caller, menu_data, startnode=\"start\", cmdset_mergetype=\"Replace\", cmdset_priority=1, auto_quit=True, auto_look=True, auto_help=True, cmd_on_exit=\"look\", persistent=False, startnode_input=\"\", session=None, debug=False, **kwargs) caller (Object or Account): is a reference to the object using the menu. This object will get a new CmdSet assigned to it, for handling the menu. menu_data (str, module or dict): is a module or python path to a module where the global-level functions will each be considered to be a menu node. Their names in the module will be the names by which they are referred to in the module. Importantly, function names starting with an underscore _ will be ignored by the loader. Alternatively, this can be a direct mapping {\"nodename\":function, ...} . startnode (str): is the name of the menu-node to start the menu at. Changing this means that you can jump into a menu tree at different positions depending on circumstance and thus possibly re-use menu entries. cmdset_mergetype (str): This is usually one of \"Replace\" or \"Union\" (see CmdSets . The first means that the menu is exclusive - the user has no access to any other commands while in the menu. The Union mergetype means the menu co-exists with previous commands (and may overload them, so be careful as to what to name your menu entries in this case). cmdset_priority (int): The priority with which to merge in the menu cmdset. This allows for advanced usage. auto_quit , auto_look , auto_help (bool): If either of these are True , the menu automatically makes a quit , look or help command available to the user. The main reason why you'd want to turn this off is if you want to use the aliases \"q\", \"l\" or \"h\" for something in your menu. Nevertheless, at least quit is highly recommend - if False , the menu must itself supply an \"exit node\" (a node without any options), or the user will be stuck in the menu until the server reloads (or eternally if the menu is persistent )! cmd_on_exit (str): This command string will be executed right after the menu has closed down. From experience, it's useful to trigger a \"look\" command to make sure the user is aware of the change of state; but any command can be used. If set to None , no command will be triggered after exiting the menu. persistent (bool) - if True , the menu will survive a reload (so the user will not be kicked out by the reload - make sure they can exit on their own!) startnode_input (str or (str, dict) tuple): Pass an input text or a input text + kwargs to the start node as if it was entered on a fictional previous node. This can be very useful in order to start a menu differently depending on the Command's arguments in which it was initialized. session (Session): Useful when calling the menu from an Account in MULTISESSION_MODDE higher than 2, to make sure only the right Session sees the menu output. debug (bool): If set, the menudebug command will be made available in the menu. Use it to list the current state of the menu and use menudebug <variable> to inspect a specific state variable from the list. All other keyword arguments will be available as initial data for the nodes. They will be available in all nodes as properties on caller.ndb._menutree (see below). These will also survive a @reload if the menu is persistent . You don't need to store the EvMenu instance anywhere - the very act of initializing it will store it as caller.ndb._menutree on the caller . This object will be deleted automatically when the menu is exited and you can also use it to store your own temporary variables for access throughout the menu. Temporary variables you store on a persistent _menutree as it runs will not survive a @reload , only those you set as part of the original EvMenu call.","title":"Launching the menu"},{"location":"EvMenu.html#the-menu-nodes","text":"The EvMenu nodes consist of functions on one of these forms. def menunodename1(caller): # code return text, options def menunodename2(caller, raw_string): # code return text, options def menunodename3(caller, raw_string, **kwargs): # code return text, options While all of the above forms are okay, it's recommended to stick to the third and last form since it gives the most flexibility. The previous forms are mainly there for backwards compatibility with existing menus from a time when EvMenu was less able.","title":"The Menu nodes"},{"location":"EvMenu.html#input-arguments-to-the-node","text":"caller (Object or Account): The object using the menu - usually a Character but could also be a Session or Account depending on where the menu is used. raw_string (str): If this is given, it will be set to the exact text the user entered on the previous node (that is, the command entered to get to this node). On the starting-node of the menu, this will be an empty string, unless startnode_input was set. kwargs (dict): These extra keyword arguments are extra optional arguments passed to the node when the user makes a choice on the previous node. This may include things like status flags and details about which exact option was chosen (which can be impossible to determine from raw_string alone). Just what is passed in kwargs is up to you when you create the previous node.","title":"Input arguments to the node"},{"location":"EvMenu.html#return-values-from-the-node","text":"Each function must return two variables, text and options .","title":"Return values from the node"},{"location":"EvMenu.html#text","text":"The text variable is a string or tuple. This text is what will be displayed when the user reaches this node. If this is a tuple, then the first element of the tuple will be considered the displayed text and the second the help-text to display when the user enters the help command on this node. text = (\"This is the text to display\", \"This is the help text for this node\") Returning a None text is allowed and simply leads to a node with no text and only options. If the help text is not given, the menu will give a generic error message when using help .","title":"text"},{"location":"EvMenu.html#options","text":"The options list describe all the choices available to the user when viewing this node. If options is returned as None , it means that this node is an Exit node - any text is displayed and then the menu immediately exits, running the exit_cmd if given. Otherwise, options should be a list (or tuple) of dictionaries, one for each option. If only one option is available, a single dictionary can also be returned. This is how it could look: def node_test(caller, raw_string, **kwargs): text = \"A goblin attacks you!\" options = ( {\"key\": (\"Attack\", \"a\", \"att\"), \"desc\": \"Strike the enemy with all your might\", \"goto\": \"node_attack\"}, {\"key\": (\"Defend\", \"d\", \"def\"), \"desc\": \"Hold back and defend yourself\", \"goto\": (_defend, {\"str\": 10, \"enemyname\": \"Goblin\"})}) return text, options This will produce a menu node looking like this: A goblin attacks you! ________________________________ Attack: Strike the enemy with all your might Defend: Hold back and defend yourself","title":"options"},{"location":"EvMenu.html#option-key-key","text":"The option's key is what the user should enter in order to choose that option. If given as a tuple, the first string of that tuple will be what is shown on-screen while the rest are aliases for picking that option. In the above example, the user could enter \"Attack\" (or \"attack\", it's not case-sensitive), \"a\" or \"att\" in order to attack the goblin. Aliasing is useful for adding custom coloring to the choice. The first element of the aliasing tuple should then be the colored version, followed by a version without color - since otherwise the user would have to enter the color codes to select that choice. Note that the key is optional . If no key is given, it will instead automatically be replaced with a running number starting from 1 . If removing the key part of each option, the resulting menu node would look like this instead: A goblin attacks you! ________________________________ 1: Strike the enemy with all your might 2: Hold back and defend yourself Whether you want to use a key or rely on numbers is mostly a matter of style and the type of menu. EvMenu accepts one important special key given only as \"_default\" . This key is used when a user enters something that does not match any other fixed keys. It is particularly useful for getting user input: def node_readuser(caller, raw_string, **kwargs): text = \"Please enter your name\" options = {\"key\": \"_default\", \"goto\": \"node_parse_input\"} return text, options A \"_default\" option does not show up in the menu, so the above will just be a node saying \"Please enter your name\" . The name they entered will appear as raw_string in the next node.","title":"option-key 'key'"},{"location":"EvMenu.html#option-key-desc","text":"This simply contains the description as to what happens when selecting the menu option. For \"_default\" options or if the key is already long or descriptive, it is not strictly needed. But usually it's better to keep the key short and put more detail in desc .","title":"option-key 'desc'"},{"location":"EvMenu.html#option-key-goto","text":"This is the operational part of the option and fires only when the user chooses said option. Here are three ways to write it def _action_two(caller, raw_string, **kwargs): # do things ... return calculated_node_to_go_to def _action_three(caller, raw_string, **kwargs): # do things ... return \"node_four\", {\"mode\": 4} def node_select(caller, raw_string, **kwargs): text = (\"select one\", \"help: they all do different things ...\") options = ({\"desc\": \"Option one\", \"goto\": \"node_one\"}, {\"desc\": \"Option two\", \"goto\": _action_two} {\"desc\": \"Option three\", \"goto\": (_action_three, {\"key\": 1, \"key2\": 2}) return text, options As seen above, goto could just be pointing to a single nodename string - the name of the node to go to. When given like this, EvMenu will look for a node named like this and call its associated function as nodename(caller, raw_string, **kwargs)` Here, raw_string is always the input the user entered to make that choice and kwargs are the same as those kwargs that already entered the current node (they are passed on). Alternatively the goto could point to a \"goto-callable\". Such callables are usually defined in the same module as the menu nodes and given names starting with _ (to avoid being parsed as nodes themselves). These callables will be called the same as a node function - callable(caller, raw_string, **kwargs) , where raw_string is what the user entered on this node and **kwargs is forwarded from the node's own input. The goto option key could also point to a tuple (callable, kwargs) - this allows for customizing the kwargs passed into the goto-callable, for example you could use the same callable but change the kwargs passed into it depending on which option was actually chosen. The \"goto callable\" must either return a string \"nodename\" or a tuple (\"nodename\", mykwargs) . This will lead to the next node being called as either nodename(caller, raw_string, **kwargs) or nodename(caller, raw_string, **mykwargs) - so this allows changing (or replacing) the options going into the next node depending on what option was chosen. There is one important case - if the goto-callable returns None for a nodename , the current node will run again , possibly with different kwargs. This makes it very easy to re-use a node over and over, for example allowing different options to update some text form being passed and manipulated for every iteration. The EvMenu also supports the exec option key. This allows for running a callable before the goto-callable. This functionality comes from a time before goto could be a callable and is deprecated as of Evennia 0.8. Use goto for all functionality where you'd before use exec .","title":"option-key 'goto'"},{"location":"EvMenu.html#temporary-storage","text":"When the menu starts, the EvMenu instance is stored on the caller as caller.ndb._menutree . Through this object you can in principle reach the menu's internal state if you know what you are doing. This is also a good place to store temporary, more global variables that may be cumbersome to keep passing from node to node via the **kwargs . The _menutree will be deleted automatically when the menu closes, meaning you don't need to worry about cleaning anything up. If you want permanent state storage, it's instead better to use an Attribute on caller . Remember that this will remain after the menu closes though, so you need to handle any needed cleanup yourself.","title":"Temporary storage"},{"location":"EvMenu.html#customizing-menu-formatting","text":"The EvMenu display of nodes, options etc are controlled by a series of formatting methods on the EvMenu class. To customize these, simply create a new child class of EvMenu and override as needed. Here is an example: from evennia.utils.evmenu import EvMenu class MyEvMenu(EvMenu): def nodetext_formatter(self, nodetext): \"\"\" Format the node text itself. Args: nodetext (str): The full node text (the text describing the node). Returns: nodetext (str): The formatted node text. \"\"\" def helptext_formatter(self, helptext): \"\"\" Format the node's help text Args: helptext (str): The unformatted help text for the node. Returns: helptext (str): The formatted help text. \"\"\" def options_formatter(self, optionlist): \"\"\" Formats the option block. Args: optionlist (list): List of (key, description) tuples for every option related to this node. caller (Object, Account or None, optional): The caller of the node. Returns: options (str): The formatted option display. \"\"\" def node_formatter(self, nodetext, optionstext): \"\"\" Formats the entirety of the node. Args: nodetext (str): The node text as returned by `self.nodetext_formatter`. optionstext (str): The options display as returned by `self.options_formatter`. caller (Object, Account or None, optional): The caller of the node. Returns: node (str): The formatted node to display. \"\"\" See evennia/utils/evmenu.py for the details of their default implementations.","title":"Customizing Menu formatting"},{"location":"EvMenu.html#examples","text":"Simple branching menu - choose from options Dynamic goto - jumping to different nodes based on response Set caller properties - a menu that changes things Getting arbitrary input - entering text Storing data between nodes - keeping states and information while in the menu Repeating the same node - validating within the node before moving to the next Full Menu : a complete example Yes/No prompt - entering text with limited possible responses (this is not using EvMenu but the conceptually similar yet technically unrelated get_input helper function accessed as evennia.utils.evmenu.get_input ).","title":"Examples:"},{"location":"EvMenu.html#example-simple-branching-menu","text":"Below is an example of a simple branching menu node leading to different other nodes depending on choice: # in mygame/world/mychargen.py def define_character(caller): text = \\ \"\"\" What aspect of your character do you want to change next? \"\"\" options = ({\"desc\": \"Change the name\", \"goto\": \"set_name\"}, {\"desc\": \"Change the description\", \"goto\": \"set_description\"}) return text, options EvMenu(caller, \"world.mychargen\", startnode=\"define_character\") This will result in the following node display: What aspect of your character do you want to change next? _________________________ 1: Change the name 2: Change the description Note that since we didn't specify the \"name\" key, EvMenu will let the user enter numbers instead. In the following examples we will not include the EvMenu call but just show nodes running inside the menu. Also, since EvMenu also takes a dictionary to describe the menu, we could have called it like this instead in the example: EvMenu(caller, {\"define_character\": define_character}, startnode=\"define_character\")","title":"Example: Simple branching menu"},{"location":"EvMenu.html#example-dynamic-goto","text":"def _is_in_mage_guild(caller, raw_string, **kwargs): if caller.tags.get('mage', category=\"guild_member\"): return \"mage_guild_welcome\" else: return \"mage_guild_blocked\" def enter_guild: text = 'You say to the mage guard:' options ({'desc': 'I need to get in there.', 'goto': _is_in_mage_guild}, {'desc': 'Never mind', 'goto': 'end_conversation'}) return text, options This simple callable goto will analyse what happens depending on who the caller is. The enter_guild node will give you a choice of what to say to the guard. If you try to enter, you will end up in different nodes depending on (in this example) if you have the right Tag set on yourself or not. Note that since we don't include any 'key's in the option dictionary, you will just get to pick between numbers.","title":"Example: Dynamic goto"},{"location":"EvMenu.html#example-set-caller-properties","text":"Here is an example of passing arguments into the goto callable and use that to influence which node it should go to next: def _set_attribute(caller, raw_string, **kwargs): \"Get which attribute to modify and set it\" attrname, value = kwargs.get(\"attr\", (None, None)) next_node = kwargs.get(\"next_node\") caller.attributes.add(attrname, attrvalue) return next_node def node_background(caller): text = \\ \"\"\" {} experienced a traumatic event in their childhood. What was it? \"\"\".format(caller.key} options = ({\"key\": \"death\", \"desc\": \"A violent death in the family\", \"goto\": (_set_attribute, {\"attr\": (\"experienced_violence\", True), \"next_node\": \"node_violent_background\"})}, {\"key\": \"betrayal\", \"desc\": \"The betrayal of a trusted grown-up\", \"goto\": (_set_attribute, {\"attr\": (\"experienced_betrayal\", True), \"next_node\": \"node_betrayal_background\"})}) return text, options This will give the following output: Kovash the magnificent experienced a traumatic event in their childhood. What was it? ____________________________________________________ death: A violent death in the family betrayal: The betrayal of a trusted grown-up Note above how we use the _set_attribute helper function to set the attribute depending on the User's choice. In thie case the helper function doesn't know anything about what node called it - we even tell it which nodename it should return, so the choices leads to different paths in the menu. We could also imagine the helper function analyzing what other choices","title":"Example: Set caller properties"},{"location":"EvMenu.html#example-get-arbitrary-input","text":"An example of the menu asking the user for input - any input. def _set_name(caller, raw_string, **kwargs): inp = raw_string.strip() prev_entry = kwargs.get(\"prev_entry\") if not inp: # a blank input either means OK or Abort if prev_entry: caller.key = prev_entry caller.msg(\"Set name to {}.\".format(prev_entry)) return \"node_background\" else: caller.msg(\"Aborted.\") return \"node_exit\" else: # re-run old node, but pass in the name given return None, {\"prev_entry\": inp} def enter_name(caller, raw_string, **kwargs): # check if we already entered a name before prev_entry = kwargs.get(\"prev_entry\") if prev_entry: text = \"Current name: {}.\\nEnter another name or <return> to accept.\" else: text = \"Enter your character's name or <return> to abort.\" options = {\"key\": \"_default\", \"goto\": (_set_name, {\"prev_entry\": prev_entry})} return text, options This will display as Enter your character's name or <return> to abort. > Gandalf Current name: Gandalf Enter another name or <return> to accept. > Set name to Gandalf. Here we re-use the same node twice for reading the input data from the user. Whatever we enter will be caught by the _default option and passed into the helper function. We also pass along whatever name we have entered before. This allows us to react correctly on an \"empty\" input - continue to the node named \"node_background\" if we accept the input or go to an exit node if we presses Return without entering anything. By returning None from the helper function we automatically re-run the previous node, but updating its ingoing kwargs to tell it to display a different text.","title":"Example: Get arbitrary input"},{"location":"EvMenu.html#example-storing-data-between-nodes","text":"A convenient way to store data is to store it on the caller.ndb._menutree which you can reach from every node. The advantage of doing this is that the _menutree NAttribute will be deleted automatically when you exit the menu. def _set_name(caller, raw_string, **kwargs): caller.ndb._menutree.charactersheet = {} caller.ndb._menutree.charactersheet['name'] = raw_string caller.msg(\"You set your name to {}\".format(raw_string) return \"background\" def node_set_name(caller): text = 'Enter your name:' options = {'key': '_default', 'goto': _set_name} return text, options ... def node_view_sheet(caller): text = \"Character sheet:\\n {}\".format(self.ndb._menutree.charactersheet) options = ({\"key\": \"Accept\", \"goto\": \"finish_chargen\"}, {\"key\": \"Decline\", \"goto\": \"start_over\"}) return text, options Instead of passing the character sheet along from node to node through the kwargs we instead set it up temporarily on caller.ndb._menutree.charactersheet . This makes it easy to reach from all nodes. At the end we look at it and, if we accept the character the menu will likely save the result to permanent storage and exit. One point to remember though is that storage on caller.ndb._menutree is not persistent across @reloads . If you are using a persistent menu (using EvMenu(..., persistent=True) you should use caller.db to store in-menu data like this as well. You must then yourself make sure to clean it when the user exits the menu.","title":"Example: Storing data between nodes"},{"location":"EvMenu.html#example-repeating-the-same-node","text":"Sometimes you want to make a chain of menu nodes one after another, but you don't want the user to be able to continue to the next node until you have verified that what they input in the previous node is ok. A common example is a login menu: def _check_username(caller, raw_string, **kwargs): # we assume lookup_username() exists if not lookup_username(raw_string): # re-run current node by returning `None` caller.msg(\"|rUsername not found. Try again.\") return None else: # username ok - continue to next node return \"node_password\" def node_username(caller): text = \"Please enter your user name.\" options = {\"key\": \"_default\", \"goto\": _check_username} return text, options def _check_password(caller, raw_string, **kwargs): nattempts = kwargs.get(\"nattempts\", 0) if nattempts > 3: caller.msg(\"Too many failed attempts. Logging out\") return \"node_abort\" elif not validate_password(raw_string): caller.msg(\"Password error. Try again.\") return None, {\"nattempts\", nattempts + 1} else: # password accepted return \"node_login\" def node_password(caller, raw_string, **kwargs): text = \"Enter your password.\" options = {\"key\": \"_default\", \"goto\": _check_password} return text, options This will display something like --------------------------- Please enter your username. --------------------------- > Fo ------------------------------ Username not found. Try again. ______________________________ abort: (back to start) ------------------------------ > Foo --------------------------- Please enter your password. --------------------------- > Bar -------------------------- Password error. Try again. -------------------------- And so on. Here the goto-callables will return to the previous node if there is an error. In the case of password attempts, this will tick up the nattempts argument that will get passed on from iteration to iteration until too many attempts have been made.","title":"Example: Repeating the same node"},{"location":"EvMenu.html#defining-nodes-in-a-dictionary","text":"You can also define your nodes directly in a dictionary to feed into the EvMenu creator. def mynode(caller): # a normal menu node function return text, options menu_data = {\"node1\": mynode, \"node2\": lambda caller: ( \"This is the node text\", ({\"key\": \"lambda node 1\", \"desc\": \"go to node 1 (mynode)\", \"goto\": \"node1\"}, {\"key\": \"lambda node 2\", \"desc\": \"go to thirdnode\", \"goto\": \"node3\"})), \"node3\": lambda caller, raw_string: ( # ... etc ) } # start menu, assuming 'caller' is available from earlier EvMenu(caller, menu_data, startnode=\"node1\") The keys of the dictionary become the node identifiers. You can use any callable on the right form to describe each node. If you use Python lambda expressions you can make nodes really on the fly. If you do, the lambda expression must accept one or two arguments and always return a tuple with two elements (the text of the node and its options), same as any menu node function. Creating menus like this is one way to present a menu that changes with the circumstances - you could for example remove or add nodes before launching the menu depending on some criteria. The drawback is that a lambda expression is much more limited than a full function - for example you can't use other Python keywords like if inside the body of the lambda . Unless you are dealing with a relatively simple dynamic menu, defining menus with lambda's is probably more work than it's worth: You can create dynamic menus by instead making each node function more clever. See the NPC shop tutorial for an example of this.","title":"Defining nodes in a dictionary"},{"location":"EvMenu.html#ask-for-simple-input","text":"This describes two ways for asking for simple questions from the user. Using Python's raw_string will not work in Evennia. raw_string will block the entire server for everyone until that one player has entered their text, which is not what you want.","title":"Ask for simple input"},{"location":"EvMenu.html#the-yield-way","text":"In the func method of your Commands (only) you can use Python's built-in yield command to request input in a similar way to raw_string . It looks like this: result = yield(\"Please enter your answer:\") This will send \"Please enter your answer\" to the Command's self.caller and then pause at that point. All other players at the server will be unaffected. Once caller enteres a reply, the code execution will continue and you can do stuff with the result . Here is an example: from evennia import Command class CmdTestInput(Command): key = \"test\" def func(self): result = yield(\"Please enter something:\") self.caller.msg(f\"You entered {result}.\") result2 = yield(\"Now enter something else:\") self.caller.msg(f\"You now entered {result2}.\") Using yield is simple and intuitive, but it will only access input from self.caller and you cannot abort or time out the pause until the player has responded. Under the hood, it is actually just a wrapper calling get_input described in the following section. Important Note: In Python you cannot mix yield and return <value> in the same method . It has to do with yield turning the method into a generator . A return without an argument works, you can just not do return <value> . This is usually not something you need to do in func() anyway, but worth keeping in mind.","title":"The yield way"},{"location":"EvMenu.html#the-get_input-way","text":"The evmenu module offers a helper function named get_input . This is wrapped by the yield statement which is often easier and more intuitive to use. But get_input offers more flexibility and power if you need it. While in the same module as EvMenu , get_input is technically unrelated to it. The get_input allows you to ask and receive simple one-line input from the user without launching the full power of a menu to do so. To use, call get_input like this: get_input(caller, prompt, callback) Here caller is the entity that should receive the prompt for input given as prompt . The callback is a callable function(caller, prompt, user_input) that you define to handle the answer from the user. When run, the caller will see prompt appear on their screens and any text they enter will be sent into the callback for whatever processing you want. Below is a fully explained callback and example call: from evennia import Command from evennia.utils.evmenu import get_input def callback(caller, prompt, user_input): \"\"\" This is a callback you define yourself. Args: caller (Account or Object): The one being asked for input prompt (str): A copy of the current prompt user_input (str): The input from the account. Returns: repeat (bool): If not set or False, exit the input prompt and clean up. If returning anything True, stay in the prompt, which means this callback will be called again with the next user input. \"\"\" caller.msg(f\"When asked '{prompt}', you answered '{user_input}'.\") get_input(caller, \"Write something! \", callback) This will show as Write something! > Hello When asked 'Write something!', you answered 'Hello'. Normally, the get_input function quits after any input, but as seen in the example docs, you could return True from the callback to repeat the prompt until you pass whatever check you want. Note: You cannot link consecutive questions by putting a new get_input call inside the callback If you want that you should use an EvMenu instead (see the Repeating the same node example above). Otherwise you can either peek at the implementation of get_input and implement your own mechanism (it's just using cmdset nesting) or you can look at this extension suggested on the mailing list .","title":"The get_input way"},{"location":"EvMenu.html#example-yesno-prompt","text":"Below is an example of a Yes/No prompt using the get_input function: def yesno(caller, prompt, result): if result.lower() in (\"y\", \"yes\", \"n\", \"no\"): # do stuff to handle the yes/no answer # ... # if we return None/False the prompt state # will quit after this else: # the answer is not on the right yes/no form caller.msg(\"Please answer Yes or No. \\n{prompt}\") @ # returning True will make sure the prompt state is not exited return True # ask the question get_input(caller, \"Is Evennia great (Yes/No)?\", yesno)","title":"Example: Yes/No prompt"},{"location":"EvMenu.html#the-list_node-decorator","text":"The evennia.utils.evmenu.list_node is an advanced decorator for use with EvMenu node functions. It is used to quickly create menus for manipulating large numbers of items. text here ______________________________________________ 1. option1 7. option7 13. option13 2. option2 8. option8 14. option14 3. option3 9. option9 [p]revius page 4. option4 10. option10 page 2 5. option5 11. option11 [n]ext page 6. option6 12. option12 The menu will automatically create an multi-page option listing that one can flip through. One can inpect each entry and then select them with prev/next. This is how it is used: from evennia.utils.evmenu import list_node ... _options(caller): return ['option1', 'option2', ... 'option100'] _select(caller, menuchoice, available_choices): # analyze choice return \"next_node\" @list_node(options, select=_select, pagesize=10) def node_mylist(caller, raw_string, **kwargs): ... return text, options The options argument to list_node is either a list, a generator or a callable returning a list of strings for each option that should be displayed in the node. The select is a callable in the example above but could also be the name of a menu node. If a callable, the menuchoice argument holds the selection done and available_choices holds all the options available. The callable should return the menu to go to depending on the selection (or None to rerun the same node). If the name of a menu node, the selection will be passed as selection kwarg to that node. The decorated node itself should return text to display in the node. It must return at least an empty dictionary for its options. It returning options, those will supplement the options auto-created by the list_node decorator.","title":"The @list_node decorator"},{"location":"EvMenu.html#assorted-notes","text":"The EvMenu is implemented using Commands . When you start a new EvMenu, the user of the menu will be assigned a CmdSet with the commands they need to navigate the menu. This means that if you were to, from inside the menu, assign a new command set to the caller, you may override the Menu Cmdset and kill the menu . If you want to assign cmdsets to the caller as part of the menu, you should store the cmdset on caller.ndb._menutree and wait to actually assign it until the exit node.","title":"Assorted notes"},{"location":"EvMore.html","text":"When sending a very long text to a user client, it might scroll beyond of the height of the client window. The evennia.utils.evmore.EvMore class gives the user the in-game ability to only view one page of text at a time. It is usually used via its access function, evmore.msg . The name comes from the famous unix pager utility more which performs just this function. Using EvMore \u00b6 To use the pager, just pass the long text through it: from evennia.utils import evmore evmore.msg(receiver, long_text) Where receiver is an Object or a Account . If the text is longer than the client's screen height (as determined by the NAWS handshake or by settings.CLIENT_DEFAULT_HEIGHT ) the pager will show up, something like this: [...] aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. ( more [1/6] retur n | b ack| t op| e nd| a bort) where the user will be able to hit the return key to move to the next page, or use the suggested commands to jump to previous pages, to the top or bottom of the document as well as abort the paging. The pager takes several more keyword arguments for controlling the message output. See the evmore-API for more info.","title":"EvMore"},{"location":"EvMore.html#using-evmore","text":"To use the pager, just pass the long text through it: from evennia.utils import evmore evmore.msg(receiver, long_text) Where receiver is an Object or a Account . If the text is longer than the client's screen height (as determined by the NAWS handshake or by settings.CLIENT_DEFAULT_HEIGHT ) the pager will show up, something like this: [...] aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. ( more [1/6] retur n | b ack| t op| e nd| a bort) where the user will be able to hit the return key to move to the next page, or use the suggested commands to jump to previous pages, to the top or bottom of the document as well as abort the paging. The pager takes several more keyword arguments for controlling the message output. See the evmore-API for more info.","title":"Using EvMore"},{"location":"Evennia-API.html","text":"Evennia makes much of its programming tools available directly from the top-level evennia package. This is often referred to as Evennia's \"flat\" Application Programming Interface (API). The flat API tries to collect and bring the most commonly used resources to the front in a way where everything is available at a glance (in a flat display), making it a good place to start to learn Evennia. Evennia's flat (and full) API can be perused through the auto-generated API Library refence . A good, interactive way to explore the flat API is to use IPython , a more flexible version of the default Python shell. Inside your virtual environment you can install IPython simply by pip install ipython Windows users should also install PyReadline : pip install pyreadline With IPython installed, go to your game directory and run evennia shell This should give you the IPython shell automatically. Inside IPython you then do import evennia Followed by evennia.<TAB> That is, write evennia. and press the TAB key. What pops up is the contents of the evennia top-level package - in other words the \"flat\" API . evennia.DefaultObject? Starting to write the name of an API entity and pressing <TAB> will auto-complete the name. Adding a question mark ( ? ) to its name will show you its documentation. Append ?? to get the actual source code. This way you can quickly explore Evennia and see what is available. To remember when importing from evennia \u00b6 Properties on the root of the evennia package are not modules in their own right. They are just shortcut properties stored in the evennia/__init__.py module. That means that you cannot use dot-notation to import nested module-names over evennia . The rule of thumb is that you cannot use import for more than one level down. Hence you can do import evennia print(evennia.default_cmds.CmdLook) or import one level down from evennia import default_cmds print(default_cmds.CmdLook) but you cannot import two levels down from evennia.default_cmds import CmdLook # error! This will give you an ImportError telling you that the module default_cmds cannot be found - this is becasue default_cmds is just a variable stored in evennia.__init__.py ; this cannot be imported from. If you really want full control over which level of package you import you can always bypass the root package and import directly from from the real location. For example evennia.DefaultObject is a shortcut to evennia.objects.objects.DefaultObject . Using this full path will have the import mechanism work normally. See evennia/__init__.py to see where the package imports from.","title":"Evennia API"},{"location":"Evennia-API.html#to-remember-when-importing-from-evennia","text":"Properties on the root of the evennia package are not modules in their own right. They are just shortcut properties stored in the evennia/__init__.py module. That means that you cannot use dot-notation to import nested module-names over evennia . The rule of thumb is that you cannot use import for more than one level down. Hence you can do import evennia print(evennia.default_cmds.CmdLook) or import one level down from evennia import default_cmds print(default_cmds.CmdLook) but you cannot import two levels down from evennia.default_cmds import CmdLook # error! This will give you an ImportError telling you that the module default_cmds cannot be found - this is becasue default_cmds is just a variable stored in evennia.__init__.py ; this cannot be imported from. If you really want full control over which level of package you import you can always bypass the root package and import directly from from the real location. For example evennia.DefaultObject is a shortcut to evennia.objects.objects.DefaultObject . Using this full path will have the import mechanism work normally. See evennia/__init__.py to see where the package imports from.","title":"To remember when importing from evennia"},{"location":"Evennia-Game-Index.html","text":"The Evennia game index is a list of games built or being built with Evennia. Anyone is allowed to add their game to the index - also if you have just started development and don't yet accept external players. It's a chance for us to know you are out there and for you to make us intrigued about or excited for your upcoming game! All we ask is that you check so your game-name does not collide with one already in the list - be nice! Connect with the wizard \u00b6 From your game dir, run evennia connections This will start the Evennia Connection wizard . From the menu, select to add your game to the Evennia Game Index. Follow the prompts and don't forget to save your new settings in the end. Use quit at any time if you change your mind. The wizard will create a new file mygame/server/conf/connection_settings.py with the settings you chose. This is imported from the end of your main settings file and will thus override it. You can edit this new file if you want, but remember that if you run the wizard again, your changes may get over-written. Manual Settings \u00b6 If you don't want to use the wizard (maybe because you already have the client installed from an earlier version), you can also configure your index entry in your settings file ( mygame/server/conf/settings.py ). Add the following: GAME_INDEX_ENABLED = True GAME_INDEX_LISTING = { # required 'game_status': 'pre-alpha', # pre-alpha, alpha, beta, launched 'listing_contact': \"dummy@dummy.com\", # not publicly shown. 'short_description': 'Short blurb', # optional 'long_description': \"Longer description that can use Markdown like *bold*, _italic_\" \"and [linkname](http://link.com). Use \\n for line breaks.\" 'telnet_hostname': 'dummy.com', 'telnet_port': '1234', 'web_client_url': 'dummy.com/webclient', 'game_website': 'dummy.com', # 'game_name': 'MyGame', # set only if different than settings.SERVERNAME } Of these, the game_status , short_description and listing_contact are required. The listing_contact is not publicly visible and is only meant as a last resort if we need to get in touch with you over any listing issue/bug (so far this has never happened). If game_name is not set, the settings.SERVERNAME will be used. Use empty strings ( '' ) for optional fields you don't want to specify at this time. Non-public games \u00b6 If you don't specify neither telnet_hostname + port nor web_client_url , the Game index will list your game as Not yet public . Non-public games are moved to the bottom of the index since there is no way for people to try them out. But it's a good way to show you are out there, even if you are not ready for players yet.","title":"Evennia Game Index"},{"location":"Evennia-Game-Index.html#connect-with-the-wizard","text":"From your game dir, run evennia connections This will start the Evennia Connection wizard . From the menu, select to add your game to the Evennia Game Index. Follow the prompts and don't forget to save your new settings in the end. Use quit at any time if you change your mind. The wizard will create a new file mygame/server/conf/connection_settings.py with the settings you chose. This is imported from the end of your main settings file and will thus override it. You can edit this new file if you want, but remember that if you run the wizard again, your changes may get over-written.","title":"Connect with the wizard"},{"location":"Evennia-Game-Index.html#manual-settings","text":"If you don't want to use the wizard (maybe because you already have the client installed from an earlier version), you can also configure your index entry in your settings file ( mygame/server/conf/settings.py ). Add the following: GAME_INDEX_ENABLED = True GAME_INDEX_LISTING = { # required 'game_status': 'pre-alpha', # pre-alpha, alpha, beta, launched 'listing_contact': \"dummy@dummy.com\", # not publicly shown. 'short_description': 'Short blurb', # optional 'long_description': \"Longer description that can use Markdown like *bold*, _italic_\" \"and [linkname](http://link.com). Use \\n for line breaks.\" 'telnet_hostname': 'dummy.com', 'telnet_port': '1234', 'web_client_url': 'dummy.com/webclient', 'game_website': 'dummy.com', # 'game_name': 'MyGame', # set only if different than settings.SERVERNAME } Of these, the game_status , short_description and listing_contact are required. The listing_contact is not publicly visible and is only meant as a last resort if we need to get in touch with you over any listing issue/bug (so far this has never happened). If game_name is not set, the settings.SERVERNAME will be used. Use empty strings ( '' ) for optional fields you don't want to specify at this time.","title":"Manual Settings"},{"location":"Evennia-Game-Index.html#non-public-games","text":"If you don't specify neither telnet_hostname + port nor web_client_url , the Game index will list your game as Not yet public . Non-public games are moved to the bottom of the index since there is no way for people to try them out. But it's a good way to show you are out there, even if you are not ready for players yet.","title":"Non-public games"},{"location":"Evennia-Introduction.html","text":"A MUD (originally Multi-User Dungeon, with later variants Multi-User Dimension and Multi-User Domain) is a multiplayer real-time virtual world described primarily in text. MUDs combine elements of role-playing games, hack and slash, player versus player, interactive fiction and online chat. Players can read or view descriptions of rooms, objects, other players, non-player characters, and actions performed in the virtual world. Players typically interact with each other and the world by typing commands that resemble a natural language. - Wikipedia If you are reading this, it's quite likely you are dreaming of creating and running a text-based massively-multiplayer game ( MUD/MUX/MUSH etc) of your very own. You might just be starting to think about it, or you might have lugged around that perfect game in your mind for years ... you know just how good it would be, if you could only make it come to reality. We know how you feel. That is, after all, why Evennia came to be. Evennia is in principle a MUD-building system: a bare-bones Python codebase and server intended to be highly extendable for any style of game. \"Bare-bones\" in this context means that we try to impose as few game-specific things on you as possible. So whereas we for convenience offer basic building blocks like objects, characters, rooms, default commands for building and administration etc, we don't prescribe any combat rules, mob AI, races, skills, character classes or other things that will be different from game to game anyway. It is possible that we will offer some such systems as contributions in the future, but these will in that case all be optional. What we do however, is to provide a solid foundation for all the boring database, networking, and behind-the-scenes administration stuff that all online games need whether they like it or not. Evennia is fully persistent , that means things you drop on the ground somewhere will still be there a dozen server reboots later. Through Django we support a large variety of different database systems (a database is created for you automatically if you use the defaults). Using the full power of Python throughout the server offers some distinct advantages. All your coding, from object definitions and custom commands to AI scripts and economic systems is done in normal Python modules rather than some ad-hoc scripting language. The fact that you script the game in the same high-level language that you code it in allows for very powerful and custom game implementations indeed. The server ships with a default set of player commands that are similar to the MUX command set. We do not aim specifically to be a MUX server, but we had to pick some default to go with (see this for more about our original motivations). It's easy to remove or add commands, or to have the command syntax mimic other systems, like Diku, LP, MOO and so on. Or why not create a new and better command system of your own design. Can I test it somewhere? \u00b6 Evennia's demo server can be found at demo.evennia.com . If you prefer to connect to the demo via your own telnet client you can do so at silvren.com , port 4280 . Here is a screenshot . Once you installed Evennia yourself it comes with its own tutorial - this shows off some of the possibilities and gives you a small single-player quest to play. The tutorial takes only one single in-game command to install as explained here . Brief summary of features \u00b6 Technical \u00b6 Game development is done by the server importing your normal Python modules. Specific server features are implemented by overloading hooks that the engine calls appropriately. All game entities are simply Python classes that handle database negotiations behind the scenes without you needing to worry. Command sets are stored on individual objects (including characters) to offer unique functionality and object-specific commands. Sets can be updated and modified on the fly to expand/limit player input options during play. Scripts are used to offer asynchronous/timed execution abilities. Scripts can also be persistent. There are easy mechanisms to thread particularly long-running processes and built-in ways to start \"tickers\" for games that wants them. In-game communication channels are modular and can be modified to any functionality, including mailing systems and full logging of all messages. Server can be fully rebooted/reloaded without users disconnecting. An Account can freely connect/disconnect from game-objects, offering an easy way to implement multi-character systems and puppeting. Each Account can optionally control multiple Characters/Objects at the same time using the same login information. Spawning of individual objects via a prototypes-like system. Tagging can be used to implement zones and object groupings. All source code is extensively documented. Unit-testing suite, including tests of default commands and plugins. Default content \u00b6 Basic classes for Objects, Characters, Rooms and Exits Basic login system, using the Account's login name as their in-game Character's name for simplicity \"MUX-like\" command set with administration, building, puppeting, channels and social commands In-game Tutorial Contributions folder with working, but optional, code such as alternative login, menus, character generation and more Standards/Protocols supported \u00b6 TCP/websocket HTML5 browser web client, with ajax/comet fallback for older browsers Telnet and Telnet + SSL with mud-specific extensions ( MCCP , MSSP , TTYPE , MSDP , GMCP , MXP links) ANSI and xterm256 colours SSH HTTP - Website served by in-built webserver and connected to same database as game. IRC - external IRC channels can be connected to in-game chat channels RSS feeds can be echoed to in-game channels (things like Twitter can easily be added) Several different databases supported (SQLite3, MySQL, PostgreSQL, ...) For more extensive feature information, see the Developer Central . What you need to know to work with Evennia \u00b6 Assuming you have Evennia working (see the quick start instructions ) and have gotten as far as to start the server and connect to it with the client of your choice, here's what you need to know depending on your skills and needs. I don't know (or don't want to do) any programming - I just want to run a game! \u00b6 Evennia comes with a default set of commands for the Python newbies and for those who need to get a game running now . Stock Evennia is enough for running a simple 'Talker'-type game - you can build and describe rooms and basic objects, have chat channels, do emotes and other things suitable for a social or free-form MU*. Combat, mobs and other game elements are not included, so you'll have a very basic game indeed if you are not willing to do at least some coding. I know basic Python, or I am willing to learn \u00b6 Evennia's source code is extensively documented and is viewable online . We also have a comprehensive online manual with lots of examples. But while Python is considered a very easy programming language to get into, you do have a learning curve to climb if you are new to programming. You should probably sit down with a Python beginner's tutorial (there are plenty of them on the web if you look around) so you at least know what you are seeing. See also our link page for some reading suggestions. To efficiently code your dream game in Evennia you don't need to be a Python guru, but you do need to be able to read example code containing at least these basic Python features: Importing and using python modules Using variables , conditional statements , loops and functions Using lists, dictionaries and list comprehensions Doing string handling and formatting Have a basic understanding of object-oriented programming , using Classes , their methods and properties Obviously, the more things you feel comfortable with, the easier time you'll have to find your way. With just basic knowledge you should be able to define your own Commands , create custom Objects as well as make your world come alive with basic Scripts . You can definitely build a whole advanced and customized game from extending Evennia's examples only. I know my Python stuff and I am willing to use it! \u00b6 Even if you started out as a Python beginner, you will likely get to this point after working on your game for a while. With more general knowledge in Python the full power of Evennia opens up for you. Apart from modifying commands, objects and scripts, you can develop everything from advanced mob AI and economic systems, through sophisticated combat and social mini games, to redefining how commands, players, rooms or channels themselves work. Since you code your game by importing normal Python modules, there are few limits to what you can accomplish. If you also happen to know some web programming (HTML, CSS, Javascript) there is also a web presence (a website and a mud web client) to play around with ... Where to from here? \u00b6 From here you can continue browsing the online documentation to find more info about Evennia. Or you can jump into the Tutorials and get your hands dirty with code right away. You can also read the developer's dev blog for many tidbits and snippets about Evennia's development and structure. Some more hints: Get engaged in the community. Make an introductory post to our mailing list/forum and get to know people. It's also highly recommended you hop onto our Developer chat on IRC. This allows you to chat directly with other developers new and old as well as with the devs of Evennia itself. This chat is logged (you can find links on http://www.evennia.com) and can also be searched from the same place for discussion topics you are interested in. Read the Game Planning wiki page. It gives some ideas for your work flow and the state of mind you should aim for - including cutting down the scope of your game for its first release. Do the Tutorial for basic MUSH-like game carefully from beginning to end and try to understand what does what. Even if you are not interested in a MUSH for your own game, you will end up with a small (very small) game that you can build or learn from.","title":"Evennia Introduction"},{"location":"Evennia-Introduction.html#can-i-test-it-somewhere","text":"Evennia's demo server can be found at demo.evennia.com . If you prefer to connect to the demo via your own telnet client you can do so at silvren.com , port 4280 . Here is a screenshot . Once you installed Evennia yourself it comes with its own tutorial - this shows off some of the possibilities and gives you a small single-player quest to play. The tutorial takes only one single in-game command to install as explained here .","title":"Can I test it somewhere?"},{"location":"Evennia-Introduction.html#brief-summary-of-features","text":"","title":"Brief summary of features"},{"location":"Evennia-Introduction.html#technical","text":"Game development is done by the server importing your normal Python modules. Specific server features are implemented by overloading hooks that the engine calls appropriately. All game entities are simply Python classes that handle database negotiations behind the scenes without you needing to worry. Command sets are stored on individual objects (including characters) to offer unique functionality and object-specific commands. Sets can be updated and modified on the fly to expand/limit player input options during play. Scripts are used to offer asynchronous/timed execution abilities. Scripts can also be persistent. There are easy mechanisms to thread particularly long-running processes and built-in ways to start \"tickers\" for games that wants them. In-game communication channels are modular and can be modified to any functionality, including mailing systems and full logging of all messages. Server can be fully rebooted/reloaded without users disconnecting. An Account can freely connect/disconnect from game-objects, offering an easy way to implement multi-character systems and puppeting. Each Account can optionally control multiple Characters/Objects at the same time using the same login information. Spawning of individual objects via a prototypes-like system. Tagging can be used to implement zones and object groupings. All source code is extensively documented. Unit-testing suite, including tests of default commands and plugins.","title":"Technical"},{"location":"Evennia-Introduction.html#default-content","text":"Basic classes for Objects, Characters, Rooms and Exits Basic login system, using the Account's login name as their in-game Character's name for simplicity \"MUX-like\" command set with administration, building, puppeting, channels and social commands In-game Tutorial Contributions folder with working, but optional, code such as alternative login, menus, character generation and more","title":"Default content"},{"location":"Evennia-Introduction.html#standardsprotocols-supported","text":"TCP/websocket HTML5 browser web client, with ajax/comet fallback for older browsers Telnet and Telnet + SSL with mud-specific extensions ( MCCP , MSSP , TTYPE , MSDP , GMCP , MXP links) ANSI and xterm256 colours SSH HTTP - Website served by in-built webserver and connected to same database as game. IRC - external IRC channels can be connected to in-game chat channels RSS feeds can be echoed to in-game channels (things like Twitter can easily be added) Several different databases supported (SQLite3, MySQL, PostgreSQL, ...) For more extensive feature information, see the Developer Central .","title":"Standards/Protocols supported"},{"location":"Evennia-Introduction.html#what-you-need-to-know-to-work-with-evennia","text":"Assuming you have Evennia working (see the quick start instructions ) and have gotten as far as to start the server and connect to it with the client of your choice, here's what you need to know depending on your skills and needs.","title":"What you need to know to work with Evennia"},{"location":"Evennia-Introduction.html#i-dont-know-or-dont-want-to-do-any-programming-i-just-want-to-run-a-game","text":"Evennia comes with a default set of commands for the Python newbies and for those who need to get a game running now . Stock Evennia is enough for running a simple 'Talker'-type game - you can build and describe rooms and basic objects, have chat channels, do emotes and other things suitable for a social or free-form MU*. Combat, mobs and other game elements are not included, so you'll have a very basic game indeed if you are not willing to do at least some coding.","title":"I don't know (or don't want to do) any programming - I just want to run a game!"},{"location":"Evennia-Introduction.html#i-know-basic-python-or-i-am-willing-to-learn","text":"Evennia's source code is extensively documented and is viewable online . We also have a comprehensive online manual with lots of examples. But while Python is considered a very easy programming language to get into, you do have a learning curve to climb if you are new to programming. You should probably sit down with a Python beginner's tutorial (there are plenty of them on the web if you look around) so you at least know what you are seeing. See also our link page for some reading suggestions. To efficiently code your dream game in Evennia you don't need to be a Python guru, but you do need to be able to read example code containing at least these basic Python features: Importing and using python modules Using variables , conditional statements , loops and functions Using lists, dictionaries and list comprehensions Doing string handling and formatting Have a basic understanding of object-oriented programming , using Classes , their methods and properties Obviously, the more things you feel comfortable with, the easier time you'll have to find your way. With just basic knowledge you should be able to define your own Commands , create custom Objects as well as make your world come alive with basic Scripts . You can definitely build a whole advanced and customized game from extending Evennia's examples only.","title":"I know basic Python, or I am willing to learn"},{"location":"Evennia-Introduction.html#i-know-my-python-stuff-and-i-am-willing-to-use-it","text":"Even if you started out as a Python beginner, you will likely get to this point after working on your game for a while. With more general knowledge in Python the full power of Evennia opens up for you. Apart from modifying commands, objects and scripts, you can develop everything from advanced mob AI and economic systems, through sophisticated combat and social mini games, to redefining how commands, players, rooms or channels themselves work. Since you code your game by importing normal Python modules, there are few limits to what you can accomplish. If you also happen to know some web programming (HTML, CSS, Javascript) there is also a web presence (a website and a mud web client) to play around with ...","title":"I know my Python stuff and I am willing to use it!"},{"location":"Evennia-Introduction.html#where-to-from-here","text":"From here you can continue browsing the online documentation to find more info about Evennia. Or you can jump into the Tutorials and get your hands dirty with code right away. You can also read the developer's dev blog for many tidbits and snippets about Evennia's development and structure. Some more hints: Get engaged in the community. Make an introductory post to our mailing list/forum and get to know people. It's also highly recommended you hop onto our Developer chat on IRC. This allows you to chat directly with other developers new and old as well as with the devs of Evennia itself. This chat is logged (you can find links on http://www.evennia.com) and can also be searched from the same place for discussion topics you are interested in. Read the Game Planning wiki page. It gives some ideas for your work flow and the state of mind you should aim for - including cutting down the scope of your game for its first release. Do the Tutorial for basic MUSH-like game carefully from beginning to end and try to understand what does what. Even if you are not interested in a MUSH for your own game, you will end up with a small (very small) game that you can build or learn from.","title":"Where to from here?"},{"location":"Evennia-for-Diku-Users.html","text":"Evennia represents a learning curve for those who used to code on Diku type MUDs. While coding in Python is easy if you already know C, the main effort is to get rid of old C programming habits. Trying to code Python the way you code C will not only look ugly, it will lead to less optimal and harder to maintain code. Reading Evennia example code is a good way to get a feel for how different problems are approached in Python. Overall, Python offers an extensive library of resources, safe memory management and excellent handling of errors. While Python code does not run as fast as raw C code does, the difference is not all that important for a text-based game. The main advantage of Python is an extremely fast development cycle with and easy ways to create game systems that would take many times more code and be much harder to make stable and maintainable in C. Core Differences \u00b6 As mentioned, the main difference between Evennia and a Diku-derived codebase is that Evennia is written purely in Python. Since Python is an interpreted language there is no compile stage. It is modified and extended by the server loading Python modules at run-time. It also runs on all computer platforms Python runs on (which is basically everywhere). Vanilla Diku type engines save their data in custom flat file type storage solutions. By contrast, Evennia stores all game data in one of several supported SQL databases. Whereas flat files have the advantage of being easier to implement, they (normally) lack many expected safety features and ways to effectively extract subsets of the stored data. For example, if the server loses power while writing to a flatfile it may become corrupt and the data lost. A proper database solution is not susceptible to this - at no point is the data in a state where it cannot be recovered. Databases are also highly optimized for querying large data sets efficiently. Some Familiar Things \u00b6 Diku expresses the character object referenced normally by: struct char ch* then all character-related fields can be accessed by ch-> . In Evennia, one must pay attention to what object you are using, and when you are accessing another through back-handling, that you are accessing the right object. In Diku C, accessing character object is normally done by: /* creating pointer of both character and room struct */ void(struct char ch*, struct room room*){ int dam; if (ROOM_FLAGGED(room, ROOM_LAVA)){ dam = 100 ch->damage_taken = dam }; }; As an example for creating Commands in Evennia via the from evennia import Command the character object that calls the command is denoted by a class property as self.caller . In this example self.caller is essentially the 'object' that has called the Command, but most of the time it is an Account object. For a more familiar Diku feel, create a variable that becomes the account object as: #mygame/commands/command.py from evennia import Command class CmdMyCmd(Command): \"\"\" This is a Command Evennia Object \"\"\" [...] def func(self): ch = self.caller # then you can access the account object directly by using the familiar ch. ch.msg(\"...\") account_name = ch.name race = ch.db.race As mentioned above, care must be taken what specific object you are working with. If focused on a room object and you need to access the account object: #mygame/typeclasses/room.py from evennia import DefaultRoom class MyRoom(DefaultRoom): [...] def is_account_object(self, object): # a test to see if object is an account [...] def myMethod(self): #self.caller would not make any sense, since self refers to the # object of 'DefaultRoom', you must find the character obj first: for ch in self.contents: if self.is_account_object(ch): # now you can access the account object with ch: account_name = ch.name race = ch.db.race Emulating Evennia to Look and Feel Like A Diku/ROM \u00b6 To emulate a Diku Mud on Evennia some work has to be done before hand. If there is anything that all coders and builders remember from Diku/Rom days is the presence of VNUMs. Essentially all data was saved in flat files and indexed by VNUMs for easy access. Evennia has the ability to emulate VNUMS to the extent of categorising rooms/mobs/objs/trigger/zones[...] into vnum ranges. Evennia has objects that are called Scripts. As defined, they are the 'out of game' instances that exist within the mud, but never directly interacted with. Scripts can be used for timers, mob AI, and even a stand alone databases. Because of their wonderful structure all mob, room, zone, triggers, etc.. data can be saved in independently created global scripts. Here is a sample mob file from a Diku Derived flat file. #0 mob0~ mob0~ mob0 ~ Mob0 ~ 10 0 0 0 0 0 0 0 0 E 1 20 9 0d0+10 1d2+0 10 100 8 8 0 E #1 Puff dragon fractal~ Puff~ Puff the Fractal Dragon is here, contemplating a higher reality. ~ Is that some type of differential curve involving some strange, and unknown calculus that she seems to be made out of? ~ 516106 0 0 0 2128 0 0 0 1000 E 34 9 -10 6d6+340 5d5+5 340 115600 8 8 2 BareHandAttack: 12 E T 95 Each line represents something that the MUD reads in and does something with it. This isn't easy to read, but let's see if we can emulate this as a dictionary to be stored on a database script created in Evennia. First, let's create a global script that does absolutely nothing and isn't attached to anything. You can either create this directly in-game with the @py command or create it in another file to do some checks and balances if for whatever reason the script needs to be created again. Progmatically it can be done like so: from evennia import create_script mob_db = create_script(\"typeclasses.scripts.DefaultScript\", key=\"mobdb\", persistent=True, obj=None) mob_db.db.vnums = {} Just by creating a simple script object and assigning it a 'vnums' attribute as a type dictionary. Next we have to create the mob layout.. # vnum : mob_data mob_vnum_1 = { 'key' : 'puff', 'sdesc' : 'puff the fractal dragon', 'ldesc' : 'Puff the Fractal Dragon is here, ' \\ 'contemplating a higher reality.', 'ddesc' : ' Is that some type of differential curve ' \\ 'involving some strange, and unknown calculus ' \\ 'that she seems to be made out of?', [...] } # Then saving it to the data, assuming you have the script obj stored in a variable. mob_db.db.vnums[1] = mob_vnum_1 This is a very 'caveman' example, but it gets the idea across. You can use the keys in the mob_db.vnums to act as the mob vnum while the rest contains the data.. Much simpler to read and edit. If you plan on taking this route, you must keep in mind that by default evennia 'looks' at different properties when using the look command for instance. If you create an instance of this mob and make its self.key = 1 , by default evennia will say Here is : 1 You must restructure all default commands so that the mud looks at different properties defined on your mob.","title":"Evennia for Diku Users"},{"location":"Evennia-for-Diku-Users.html#core-differences","text":"As mentioned, the main difference between Evennia and a Diku-derived codebase is that Evennia is written purely in Python. Since Python is an interpreted language there is no compile stage. It is modified and extended by the server loading Python modules at run-time. It also runs on all computer platforms Python runs on (which is basically everywhere). Vanilla Diku type engines save their data in custom flat file type storage solutions. By contrast, Evennia stores all game data in one of several supported SQL databases. Whereas flat files have the advantage of being easier to implement, they (normally) lack many expected safety features and ways to effectively extract subsets of the stored data. For example, if the server loses power while writing to a flatfile it may become corrupt and the data lost. A proper database solution is not susceptible to this - at no point is the data in a state where it cannot be recovered. Databases are also highly optimized for querying large data sets efficiently.","title":"Core Differences"},{"location":"Evennia-for-Diku-Users.html#some-familiar-things","text":"Diku expresses the character object referenced normally by: struct char ch* then all character-related fields can be accessed by ch-> . In Evennia, one must pay attention to what object you are using, and when you are accessing another through back-handling, that you are accessing the right object. In Diku C, accessing character object is normally done by: /* creating pointer of both character and room struct */ void(struct char ch*, struct room room*){ int dam; if (ROOM_FLAGGED(room, ROOM_LAVA)){ dam = 100 ch->damage_taken = dam }; }; As an example for creating Commands in Evennia via the from evennia import Command the character object that calls the command is denoted by a class property as self.caller . In this example self.caller is essentially the 'object' that has called the Command, but most of the time it is an Account object. For a more familiar Diku feel, create a variable that becomes the account object as: #mygame/commands/command.py from evennia import Command class CmdMyCmd(Command): \"\"\" This is a Command Evennia Object \"\"\" [...] def func(self): ch = self.caller # then you can access the account object directly by using the familiar ch. ch.msg(\"...\") account_name = ch.name race = ch.db.race As mentioned above, care must be taken what specific object you are working with. If focused on a room object and you need to access the account object: #mygame/typeclasses/room.py from evennia import DefaultRoom class MyRoom(DefaultRoom): [...] def is_account_object(self, object): # a test to see if object is an account [...] def myMethod(self): #self.caller would not make any sense, since self refers to the # object of 'DefaultRoom', you must find the character obj first: for ch in self.contents: if self.is_account_object(ch): # now you can access the account object with ch: account_name = ch.name race = ch.db.race","title":"Some Familiar Things"},{"location":"Evennia-for-Diku-Users.html#emulating-evennia-to-look-and-feel-like-a-dikurom","text":"To emulate a Diku Mud on Evennia some work has to be done before hand. If there is anything that all coders and builders remember from Diku/Rom days is the presence of VNUMs. Essentially all data was saved in flat files and indexed by VNUMs for easy access. Evennia has the ability to emulate VNUMS to the extent of categorising rooms/mobs/objs/trigger/zones[...] into vnum ranges. Evennia has objects that are called Scripts. As defined, they are the 'out of game' instances that exist within the mud, but never directly interacted with. Scripts can be used for timers, mob AI, and even a stand alone databases. Because of their wonderful structure all mob, room, zone, triggers, etc.. data can be saved in independently created global scripts. Here is a sample mob file from a Diku Derived flat file. #0 mob0~ mob0~ mob0 ~ Mob0 ~ 10 0 0 0 0 0 0 0 0 E 1 20 9 0d0+10 1d2+0 10 100 8 8 0 E #1 Puff dragon fractal~ Puff~ Puff the Fractal Dragon is here, contemplating a higher reality. ~ Is that some type of differential curve involving some strange, and unknown calculus that she seems to be made out of? ~ 516106 0 0 0 2128 0 0 0 1000 E 34 9 -10 6d6+340 5d5+5 340 115600 8 8 2 BareHandAttack: 12 E T 95 Each line represents something that the MUD reads in and does something with it. This isn't easy to read, but let's see if we can emulate this as a dictionary to be stored on a database script created in Evennia. First, let's create a global script that does absolutely nothing and isn't attached to anything. You can either create this directly in-game with the @py command or create it in another file to do some checks and balances if for whatever reason the script needs to be created again. Progmatically it can be done like so: from evennia import create_script mob_db = create_script(\"typeclasses.scripts.DefaultScript\", key=\"mobdb\", persistent=True, obj=None) mob_db.db.vnums = {} Just by creating a simple script object and assigning it a 'vnums' attribute as a type dictionary. Next we have to create the mob layout.. # vnum : mob_data mob_vnum_1 = { 'key' : 'puff', 'sdesc' : 'puff the fractal dragon', 'ldesc' : 'Puff the Fractal Dragon is here, ' \\ 'contemplating a higher reality.', 'ddesc' : ' Is that some type of differential curve ' \\ 'involving some strange, and unknown calculus ' \\ 'that she seems to be made out of?', [...] } # Then saving it to the data, assuming you have the script obj stored in a variable. mob_db.db.vnums[1] = mob_vnum_1 This is a very 'caveman' example, but it gets the idea across. You can use the keys in the mob_db.vnums to act as the mob vnum while the rest contains the data.. Much simpler to read and edit. If you plan on taking this route, you must keep in mind that by default evennia 'looks' at different properties when using the look command for instance. If you create an instance of this mob and make its self.key = 1 , by default evennia will say Here is : 1 You must restructure all default commands so that the mud looks at different properties defined on your mob.","title":"Emulating Evennia to Look and Feel Like A Diku/ROM"},{"location":"Evennia-for-MUSH-Users.html","text":"This page is adopted from an article originally posted for the MUSH community here on musoapbox.net . MUSH es are text multiplayer games traditionally used for heavily roleplay-focused game styles. They are often (but not always) utilizing game masters and human oversight over code automation. MUSHes are traditionally built on the TinyMUSH-family of game servers, like PennMUSH, TinyMUSH, TinyMUX and RhostMUSH. Also their siblings MUCK and MOO are often mentioned together with MUSH since they all inherit from the same TinyMUD base. A major feature is the ability to modify and program the game world from inside the game by using a custom scripting language. We will refer to this online scripting as softcode here. Evennia works quite differently from a MUSH both in its overall design and under the hood. The same things are achievable, just in a different way. Here are some fundamental differences to keep in mind if you are coming from the MUSH world. Developers vs Players \u00b6 In MUSH, users tend to code and expand all aspects of the game from inside it using softcode. A MUSH can thus be said to be managed solely by Players with different levels of access. Evennia on the other hand, differentiates between the role of the Player and the Developer . An Evennia Developer works in Python from outside the game, in what MUSH would consider \u201chardcode\u201d. Developers implement larger-scale code changes and can fundamentally change how the game works. They then load their changes into the running Evennia server. Such changes will usually not drop any connected players. An Evennia Player operates from inside the game. Some staff-level players are likely to double as developers. Depending on access level, players can modify and expand the game's world by digging new rooms, creating new objects, alias commands, customize their experience and so on. Trusted staff may get access to Python via the @py command, but this would be a security risk for normal Players to use. So the Player usually operates by making use of the tools prepared for them by the Developer - tools that can be as rigid or flexible as the developer desires. Collaborating on a game - Python vs Softcode \u00b6 For a Player , collaborating on a game need not be too different between MUSH and Evennia. The building and description of the game world can still happen mostly in-game using build commands, using text tags and inline functions to prettify and customize the experience. Evennia offers external ways to build a world but those are optional. There is also nothing in principle stopping a Developer from offering a softcode-like language to Players if that is deemed necessary. For Developers of the game, the difference is larger: Code is mainly written outside the game in Python modules rather than in-game on the command line. Python is a very popular and well-supported language with tons of documentation and help to be found. The Python standard library is also a great help for not having to reinvent the wheel. But that said, while Python is considered one of the easier languages to learn and use it is undoubtedly very different from MUSH softcode. While softcode allows collaboration in-game, Evennia's external coding instead opens up the possibility for collaboration using professional version control tools and bug tracking using websites like github (or bitbucket for a free private repo). Source code can be written in proper text editors and IDEs with refactoring, syntax highlighting and all other conveniences. In short, collaborative development of an Evennia game is done in the same way most professional collaborative development is done in the world, meaning all the best tools can be used. @parent vs @typeclass and @spawn \u00b6 Inheritance works differently in Python than in softcode. Evennia has no concept of a \"master object\" that other objects inherit from. There is in fact no reason at all to introduce \"virtual objects\" in the game world - code and data are kept separate from one another. In Python (which is an object oriented language) one instead creates classes - these are like blueprints from which you spawn any number of object instances . Evennia also adds the extra feature that every instance is persistent in the database (this means no SQL is ever needed). To take one example, a unique character in Evennia is an instances of the class Character . One parallel to MUSH's @parent command may be Evennia's @typeclass command, which changes which class an already existing object is an instance of. This way you can literally turn a Character into a Flowerpot on the spot. if you are new to object oriented design it's important to note that all object instances of a class does not have to be identical. If they did, all Characters would be named the same. Evennia allows to customize individual objects in many different ways. One way is through Attributes , which are database-bound properties that can be linked to any object. For example, you could have an Orc class that defines all the stuff an Orc should be able to do (probably in turn inheriting from some Monster class shared by all monsters). Setting different Attributes on different instances (different strength, equipment, looks etc) would make each Orc unique despite all sharing the same class. The @spawn command allows one to conveniently choose between different \"sets\" of Attributes to put on each new Orc (like the \"warrior\" set or \"shaman\" set) . Such sets can even inherit one another which is again somewhat remniscent at least of the effect of @parent and the object-based inheritance of MUSH. There are other differences for sure, but that should give some feel for things. Enough with the theory. Let's get down to more practical matters next. To install, see the Getting Started instructions . A first step making things more familiar \u00b6 We will here give two examples of customizing Evennia to be more familiar to a MUSH Player . Activating a multi-descer \u00b6 By default Evennia\u2019s desc command updates your description and that\u2019s it. There is a more feature-rich optional \u201cmulti-descer\u201d in evennia/contrib/multidesc.py though. This alternative allows for managing and combining a multitude of keyed descriptions. To activate the multi-descer, cd to your game folder and into the commands sub-folder. There you\u2019ll find the file default_cmdsets.py . In Python lingo all *.py files are called modules . Open the module in a text editor. We won\u2019t go into Evennia in-game Commands and Command sets further here, but suffice to say Evennia allows you to change which commands (or versions of commands) are available to the player from moment to moment depending on circumstance. Add two new lines to the module as seen below: # the file mygame/commands/default_cmdsets.py # [...] from evennia.contrib import multidescer # <- added now class CharacterCmdSet(default_cmds.CharacterCmdSet): \"\"\" The CharacterCmdSet contains general in-game commands like look, get etc available on in-game Character objects. It is merged with the AccountCmdSet when an Account puppets a Character. \"\"\" key = \"DefaultCharacter\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # # any commands you add below will overload the default ones. # self.add(multidescer.CmdMultiDesc()) # <- added now # [...] Note that Python cares about indentation, so make sure to indent with the same number of spaces as shown above! So what happens above? We import the module evennia/contrib/multidescer.py at the top. Once imported we can access stuff inside that module using full stop ( . ). The multidescer is defined as a class CmdMultiDesc (we could find this out by opening said module in a text editor). At the bottom we create a new instance of this class and add it to the CharacterCmdSet class. For the sake of this tutorial we only need to know that CharacterCmdSet contains all commands that should be be available to the Character by default. This whole thing will be triggered when the command set is first created, which happens on server start. So we need to reload Evennia with @reload - no one will be disconnected by doing this. If all went well you should now be able to use desc (or +desc ) and find that you have more possibilities: > help +desc # get help on the command > +desc eyes = His eyes are blue. > +desc basic = A big guy. > +desc/set basic + + eyes # we add an extra space between > look me A big guy. His eyes are blue. If there are errors, a traceback will show in the server log - several lines of text showing where the error occurred. Find where the error is by locating the line number related to the default_cmdsets.py file (it's the only one you've changed so far). Most likely you mis-spelled something or missed the indentation. Fix it and either @reload again or run evennia start as needed. Customizing the multidescer syntax \u00b6 As seen above the multidescer uses syntax like this (where |/ are Evennia's tags for line breaks) : > +desc/set basic + |/|/ + cape + footwear + |/|/ + attitude This use of + was prescribed by the Developer that coded this +desc command. What if the Player doesn\u2019t like this syntax though? Do players need to pester the dev to change it? Not necessarily. While Evennia does not allow the player to build their own multi-descer on the command line, it does allow for re-mapping the command syntax to one they prefer. This is done using the nick command. Here\u2019s a nick that changes how to input the command above: > nick setdesc $1 $2 $3 $4 = +desc/set $1 + |/|/ + $2 + $3 + |/|/ + $4 The string on the left will be matched against your input and if matching, it will be replaced with the string on the right. The $ -type tags will store space-separated arguments and put them into the replacement. The nick allows shell-like wildcards , so you can use * , ? , [...] , [!...] etc to match parts of the input. The same description as before can now be set as > setdesc basic cape footwear attitude With the nick functionality players can mitigate a lot of syntax dislikes even without the developer changing the underlying Python code. Next steps \u00b6 If you are a Developer and are interested in making a more MUSH-like Evennia game, a good start is to look into the Evennia Tutorial for a first MUSH-like game . That steps through building a simple little game from scratch and helps to acquaint you with the various corners of Evennia. There is also the Tutorial for running roleplaying sessions that can be of interest. An important aspect of making things more familiar for Players is adding new and tweaking existing commands. How this is done is covered by the Tutorial on adding new commands . You may also find it useful to shop through the evennia/contrib/ folder. The Tutorial world is a small single-player quest you can try (it\u2019s not very MUSH-like but it does show many Evennia concepts in action). Beyond that there are many more tutorials to try out. If you feel you want a more visual overview you can also look at Evennia in pictures . \u2026 And of course, if you need further help you can always drop into the Evennia chatroom or post a question in our forum/mailing list !","title":"Evennia for MUSH Users"},{"location":"Evennia-for-MUSH-Users.html#developers-vs-players","text":"In MUSH, users tend to code and expand all aspects of the game from inside it using softcode. A MUSH can thus be said to be managed solely by Players with different levels of access. Evennia on the other hand, differentiates between the role of the Player and the Developer . An Evennia Developer works in Python from outside the game, in what MUSH would consider \u201chardcode\u201d. Developers implement larger-scale code changes and can fundamentally change how the game works. They then load their changes into the running Evennia server. Such changes will usually not drop any connected players. An Evennia Player operates from inside the game. Some staff-level players are likely to double as developers. Depending on access level, players can modify and expand the game's world by digging new rooms, creating new objects, alias commands, customize their experience and so on. Trusted staff may get access to Python via the @py command, but this would be a security risk for normal Players to use. So the Player usually operates by making use of the tools prepared for them by the Developer - tools that can be as rigid or flexible as the developer desires.","title":"Developers vs Players"},{"location":"Evennia-for-MUSH-Users.html#collaborating-on-a-game-python-vs-softcode","text":"For a Player , collaborating on a game need not be too different between MUSH and Evennia. The building and description of the game world can still happen mostly in-game using build commands, using text tags and inline functions to prettify and customize the experience. Evennia offers external ways to build a world but those are optional. There is also nothing in principle stopping a Developer from offering a softcode-like language to Players if that is deemed necessary. For Developers of the game, the difference is larger: Code is mainly written outside the game in Python modules rather than in-game on the command line. Python is a very popular and well-supported language with tons of documentation and help to be found. The Python standard library is also a great help for not having to reinvent the wheel. But that said, while Python is considered one of the easier languages to learn and use it is undoubtedly very different from MUSH softcode. While softcode allows collaboration in-game, Evennia's external coding instead opens up the possibility for collaboration using professional version control tools and bug tracking using websites like github (or bitbucket for a free private repo). Source code can be written in proper text editors and IDEs with refactoring, syntax highlighting and all other conveniences. In short, collaborative development of an Evennia game is done in the same way most professional collaborative development is done in the world, meaning all the best tools can be used.","title":"Collaborating on a game - Python vs Softcode"},{"location":"Evennia-for-MUSH-Users.html#parent-vs-typeclass-and-spawn","text":"Inheritance works differently in Python than in softcode. Evennia has no concept of a \"master object\" that other objects inherit from. There is in fact no reason at all to introduce \"virtual objects\" in the game world - code and data are kept separate from one another. In Python (which is an object oriented language) one instead creates classes - these are like blueprints from which you spawn any number of object instances . Evennia also adds the extra feature that every instance is persistent in the database (this means no SQL is ever needed). To take one example, a unique character in Evennia is an instances of the class Character . One parallel to MUSH's @parent command may be Evennia's @typeclass command, which changes which class an already existing object is an instance of. This way you can literally turn a Character into a Flowerpot on the spot. if you are new to object oriented design it's important to note that all object instances of a class does not have to be identical. If they did, all Characters would be named the same. Evennia allows to customize individual objects in many different ways. One way is through Attributes , which are database-bound properties that can be linked to any object. For example, you could have an Orc class that defines all the stuff an Orc should be able to do (probably in turn inheriting from some Monster class shared by all monsters). Setting different Attributes on different instances (different strength, equipment, looks etc) would make each Orc unique despite all sharing the same class. The @spawn command allows one to conveniently choose between different \"sets\" of Attributes to put on each new Orc (like the \"warrior\" set or \"shaman\" set) . Such sets can even inherit one another which is again somewhat remniscent at least of the effect of @parent and the object-based inheritance of MUSH. There are other differences for sure, but that should give some feel for things. Enough with the theory. Let's get down to more practical matters next. To install, see the Getting Started instructions .","title":"@parent vs @typeclass and @spawn"},{"location":"Evennia-for-MUSH-Users.html#a-first-step-making-things-more-familiar","text":"We will here give two examples of customizing Evennia to be more familiar to a MUSH Player .","title":"A first step making things more familiar"},{"location":"Evennia-for-MUSH-Users.html#activating-a-multi-descer","text":"By default Evennia\u2019s desc command updates your description and that\u2019s it. There is a more feature-rich optional \u201cmulti-descer\u201d in evennia/contrib/multidesc.py though. This alternative allows for managing and combining a multitude of keyed descriptions. To activate the multi-descer, cd to your game folder and into the commands sub-folder. There you\u2019ll find the file default_cmdsets.py . In Python lingo all *.py files are called modules . Open the module in a text editor. We won\u2019t go into Evennia in-game Commands and Command sets further here, but suffice to say Evennia allows you to change which commands (or versions of commands) are available to the player from moment to moment depending on circumstance. Add two new lines to the module as seen below: # the file mygame/commands/default_cmdsets.py # [...] from evennia.contrib import multidescer # <- added now class CharacterCmdSet(default_cmds.CharacterCmdSet): \"\"\" The CharacterCmdSet contains general in-game commands like look, get etc available on in-game Character objects. It is merged with the AccountCmdSet when an Account puppets a Character. \"\"\" key = \"DefaultCharacter\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # # any commands you add below will overload the default ones. # self.add(multidescer.CmdMultiDesc()) # <- added now # [...] Note that Python cares about indentation, so make sure to indent with the same number of spaces as shown above! So what happens above? We import the module evennia/contrib/multidescer.py at the top. Once imported we can access stuff inside that module using full stop ( . ). The multidescer is defined as a class CmdMultiDesc (we could find this out by opening said module in a text editor). At the bottom we create a new instance of this class and add it to the CharacterCmdSet class. For the sake of this tutorial we only need to know that CharacterCmdSet contains all commands that should be be available to the Character by default. This whole thing will be triggered when the command set is first created, which happens on server start. So we need to reload Evennia with @reload - no one will be disconnected by doing this. If all went well you should now be able to use desc (or +desc ) and find that you have more possibilities: > help +desc # get help on the command > +desc eyes = His eyes are blue. > +desc basic = A big guy. > +desc/set basic + + eyes # we add an extra space between > look me A big guy. His eyes are blue. If there are errors, a traceback will show in the server log - several lines of text showing where the error occurred. Find where the error is by locating the line number related to the default_cmdsets.py file (it's the only one you've changed so far). Most likely you mis-spelled something or missed the indentation. Fix it and either @reload again or run evennia start as needed.","title":"Activating a multi-descer"},{"location":"Evennia-for-MUSH-Users.html#customizing-the-multidescer-syntax","text":"As seen above the multidescer uses syntax like this (where |/ are Evennia's tags for line breaks) : > +desc/set basic + |/|/ + cape + footwear + |/|/ + attitude This use of + was prescribed by the Developer that coded this +desc command. What if the Player doesn\u2019t like this syntax though? Do players need to pester the dev to change it? Not necessarily. While Evennia does not allow the player to build their own multi-descer on the command line, it does allow for re-mapping the command syntax to one they prefer. This is done using the nick command. Here\u2019s a nick that changes how to input the command above: > nick setdesc $1 $2 $3 $4 = +desc/set $1 + |/|/ + $2 + $3 + |/|/ + $4 The string on the left will be matched against your input and if matching, it will be replaced with the string on the right. The $ -type tags will store space-separated arguments and put them into the replacement. The nick allows shell-like wildcards , so you can use * , ? , [...] , [!...] etc to match parts of the input. The same description as before can now be set as > setdesc basic cape footwear attitude With the nick functionality players can mitigate a lot of syntax dislikes even without the developer changing the underlying Python code.","title":"Customizing the multidescer syntax"},{"location":"Evennia-for-MUSH-Users.html#next-steps","text":"If you are a Developer and are interested in making a more MUSH-like Evennia game, a good start is to look into the Evennia Tutorial for a first MUSH-like game . That steps through building a simple little game from scratch and helps to acquaint you with the various corners of Evennia. There is also the Tutorial for running roleplaying sessions that can be of interest. An important aspect of making things more familiar for Players is adding new and tweaking existing commands. How this is done is covered by the Tutorial on adding new commands . You may also find it useful to shop through the evennia/contrib/ folder. The Tutorial world is a small single-player quest you can try (it\u2019s not very MUSH-like but it does show many Evennia concepts in action). Beyond that there are many more tutorials to try out. If you feel you want a more visual overview you can also look at Evennia in pictures . \u2026 And of course, if you need further help you can always drop into the Evennia chatroom or post a question in our forum/mailing list !","title":"Next steps"},{"location":"Evennia-for-roleplaying-sessions.html","text":"This tutorial will explain how to set up a realtime or play-by-post tabletop style game using a fresh Evennia server. The scenario is thus: You and a bunch of friends want to play a tabletop role playing game online. One of you will be the game master and you are all okay with playing using written text. You want both the ability to role play in real-time (when people happen to be online at the same time) as well as the ability for people to post when they can and catch up on what happened since they were last online. This is the functionality we will be needing and using: The ability to make one of you the GM (game master), with special abilities. A Character sheet that players can create, view and fill in. It can also be locked so only the GM can modify it. A dice roller mechanism, for whatever type of dice the RPG rules require. Rooms , to give a sense of location and to compartmentalize play going on- This means both Character movements from location to location and GM explicitly moving them around. Channels , for easily sending text to all subscribing accounts, regardless of location. Account-to-Account messaging capability, including sending to multiple recipients simultaneously, regardless of location. We will find most of these things are already part of vanilla Evennia, but that we can expand on the defaults for our particular use-case. Below we will flesh out these components from start to finish. Starting out \u00b6 We will assume you start from scratch. You need Evennia installed, as per the Getting Started instructions. Initialize a new game directory with evennia init <gamedirname> . In this tutorial we assume your game dir is simply named mygame . You can use the default database and keep all other settings to default for now. Familiarize yourself with the mygame folder before continuing. You might want to browse the First Steps Coding tutorial, just to see roughly where things are modified. The Game Master role \u00b6 Short version \u00b6 Simplest way: Being an admin, just give one account Admins permission using the standard @perm command. Better but more work: Make a custom command to set/unset the above, while tweaking the Character to show your renewed GM status to the other accounts. The permission hierarchy \u00b6 Evennia has the following permission hierarchy out of the box: Players, Helpers, Builders, Admins and finally Developers . We could change these but then we'd need to update our Default commands to use the changes. We want to keep this simple, so instead we map our different roles on top of this permission ladder. Players is the permission set on normal players. This is the default for anyone creating a new account on the server. Helpers are like Players except they also have the ability to create/edit new help entries. This could be granted to players who are willing to help with writing lore or custom logs for everyone. Builders is not used in our case since the GM should be the only world-builder. Admins is the permission level the GM should have. Admins can do everything builders can (create/describe rooms etc) but also kick accounts, rename them and things like that. Developers -level permission are the server administrators, the ones with the ability to restart/shutdown the server as well as changing the permission levels. The superuser is not part of the hierarchy and actually completely bypasses it. We'll assume server admin(s) will \"just\" be Developers. How to grant permissions \u00b6 Only Developers can (by default) change permission level. Only they have access to the @perm command: > @perm Yvonne Permissions on Yvonne: accounts > @perm Yvonne = Admins > @perm Yvonne Permissions on Yvonne: accounts, admins > @perm/del Yvonne = Admins > @perm Yvonne Permissions on Yvonne: accounts There is no need to remove the basic Players permission when adding the higher permission: the highest will be used. Permission level names are not case sensitive. You can also use both plural and singular, so \"Admins\" gives the same powers as \"Admin\". Optional: Making a GM-granting command \u00b6 Use of @perm works out of the box, but it's really the bare minimum. Would it not be nice if other accounts could tell at a glance who the GM is? Also, we shouldn't really need to remember that the permission level is called \"Admins\". It would be easier if we could just do @gm <account> and @notgm <account> and at the same time change something make the new GM status apparent. So let's make this possible. This is what we'll do: We'll customize the default Character class. If an object of this class has a particular flag, its name will have the string (GM) added to the end. We'll add a new command, for the server admin to assign the GM-flag properly. Character modification \u00b6 Let's first start by customizing the Character. We recommend you browse the beginning of the Account page to make sure you know how Evennia differentiates between the OOC \"Account objects\" (not to be confused with the Accounts permission, which is just a string specifying your access) and the IC \"Character objects\". Open mygame/typeclasses/characters.py and modify the default Character class: # in mygame/typeclasses/characters.py # [...] class Character(DefaultCharacter): # [...] def get_display_name(self, looker, **kwargs): \"\"\" This method customizes how character names are displayed. We assume only permissions of types \"Developers\" and \"Admins\" require special attention. \"\"\" name = self.key selfaccount = self.account # will be None if we are not puppeted lookaccount = looker.account # - \" - if selfaccount and selfaccount.db.is_gm: # A GM. Show name as name(GM) name = \"%s(GM)\" % name if lookaccount and \\ (lookaccount.permissions.get(\"Developers\") or lookaccount.db.is_gm): # Developers/GMs see name(#dbref) or name(GM)(#dbref) return \"%s(#%s)\" % (name, self.id) else: return name Above, we change how the Character's name is displayed: If the account controlling this Character is a GM, we attach the string (GM) to the Character's name so everyone can tell who's the boss. If we ourselves are Developers or GM's we will see database ids attached to Characters names, which can help if doing database searches against Characters of exactly the same name. We base the \"gm-ingness\" on having an flag (an Attribute ) named is_gm . We'll make sure new GM's actually get this flag below. Extra exercise: This will only show the (GM) text on Characters puppeted by a GM account, that is, it will show only to those in the same location. If we wanted it to also pop up in, say, who listings and channels, we'd need to make a similar change to the Account typeclass in mygame/typeclasses/accounts.py . We leave this as an exercise to the reader. New @gm/@ungm command \u00b6 We will describe in some detail how to create and add an Evennia command here with the hope that we don't need to be as detailed when adding commands in the future. We will build on Evennia's default \"mux-like\" commands here. Open mygame/commands/command.py and add a new Command class at the bottom: # in mygame/commands/command.py from evennia import default_cmds # [...] import evennia class CmdMakeGM(default_cmds.MuxCommand): \"\"\" Change an account's GM status Usage: @gm <account> @ungm <account> \"\"\" # note using the key without @ means both @gm !gm etc will work key = \"gm\" aliases = \"ungm\" locks = \"cmd:perm(Developers)\" help_category = \"RP\" def func(self): \"Implement the command\" caller = self.caller if not self.args: caller.msg(\"Usage: @gm account or @ungm account\") return accountlist = evennia.search_account(self.args) # returns a list if not accountlist: caller.msg(\"Could not find account '%s'\" % self.args) return elif len(accountlist) > 1: caller.msg(\"Multiple matches for '%s': %s\" % (self.args, accountlist)) return else: account = accountlist[0] if self.cmdstring == \"gm\": # turn someone into a GM if account.permissions.get(\"Admins\"): caller.msg(\"Account %s is already a GM.\" % account) else: account.permissions.add(\"Admins\") caller.msg(\"Account %s is now a GM.\" % account) account.msg(\"You are now a GM (changed by %s).\" % caller) account.character.db.is_gm = True else: # @ungm was entered - revoke GM status from someone if not account.permissions.get(\"Admins\"): caller.msg(\"Account %s is not a GM.\" % account) else: account.permissions.remove(\"Admins\") caller.msg(\"Account %s is no longer a GM.\" % account) account.msg(\"You are no longer a GM (changed by %s).\" % caller) del account.character.db.is_gm All the command does is to locate the account target and assign it the Admins permission if we used @gm or revoke it if using the @ungm alias. We also set/unset the is_gm Attribute that is expected by our new Character.get_display_name method from earlier. We could have made this into two separate commands or opted for a syntax like @gm/revoke <accountname> . Instead we examine how this command was called (stored in self.cmdstring ) in order to act accordingly. Either way works, practicality and coding style decides which to go with. To actually make this command available (only to Developers, due to the lock on it), we add it to the default Account command set. Open the file mygame/commands/default_cmdsets.py and find the AccountCmdSet class: # mygame/commands/default_cmdsets.py # [...] from commands.command import CmdMakeGM class AccountCmdSet(default_cmds.AccountCmdSet): # [...] def at_cmdset_creation(self): # [...] self.add(CmdMakeGM()) Finally, issue the @reload command to update the server to your changes. Developer-level players (or the superuser) should now have the @gm/@ungm command available. Character sheet \u00b6 Short version \u00b6 Use Evennia's EvTable/EvForm to build a Character sheet Tie individual sheets to a given Character. Add new commands to modify the Character sheet, both by Accounts and GMs. Make the Character sheet lockable by a GM, so the Player can no longer modify it. Building a Character sheet \u00b6 There are many ways to build a Character sheet in text, from manually pasting strings together to more automated ways. Exactly what is the best/easiest way depends on the sheet one tries to create. We will here show two examples using the EvTable and EvForm utilities.Later we will create Commands to edit and display the output from those utilities. Note that due to the limitations of the wiki, no color is used in any of the examples. See the text tag documentation for how to add color to the tables and forms. Making a sheet with EvTable \u00b6 EvTable is a text-table generator. It helps with displaying text in ordered rows and columns. This is an example of using it in code: # this can be tried out in a Python shell like iPython from evennia.utils import evtable # we hardcode these for now, we'll get them as input later STR, CON, DEX, INT, WIS, CHA = 12, 13, 8, 10, 9, 13 table = evtable.EvTable(\"Attr\", \"Value\", table = [ [\"STR\", \"CON\", \"DEX\", \"INT\", \"WIS\", \"CHA\"], [STR, CON, DEX, INT, WIS, CHA] ], align='r', border=\"incols\") Above, we create a two-column table by supplying the two columns directly. We also tell the table to be right-aligned and to use the \"incols\" border type (borders drawns only in between columns). The EvTable class takes a lot of arguments for customizing its look, you can see some of the possible keyword arguments here . Once you have the table you could also retroactively add new columns and rows to it with table.add_row() and table.add_column() : if necessary the table will expand with empty rows/columns to always remain rectangular. The result from printing the above table will be table_string = str(table) print(table_string) Attr | Value ~~~~~~+~~~~~~~ STR | 12 CON | 13 DEX | 8 INT | 10 WIS | 9 CHA | 13 This is a minimalistic but effective Character sheet. By combining the table_string with other strings one could build up a reasonably full graphical representation of a Character. For more advanced layouts we'll look into EvForm next. Making a sheet with EvForm \u00b6 EvForm allows the creation of a two-dimensional \"graphic\" made by text characters. On this surface, one marks and tags rectangular regions (\"cells\") to be filled with content. This content can be either normal strings or EvTable instances (see the previous section, one such instance would be the table variable in that example). In the case of a Character sheet, these cells would be comparable to a line or box where you could enter the name of your character or their strength score. EvMenu also easily allows to update the content of those fields in code (it use EvTables so you rebuild the table first before re-sending it to EvForm). The drawback of EvForm is that its shape is static; if you try to put more text in a region than it was sized for, the text will be cropped. Similarly, if you try to put an EvTable instance in a field too small for it, the EvTable will do its best to try to resize to fit, but will eventually resort to cropping its data or even give an error if too small to fit any data. An EvForm is defined in a Python module. Create a new file mygame/world/charsheetform.py and modify it thus: #coding=utf-8 # in mygame/world/charsheetform.py FORMCHAR = \"x\" TABLECHAR = \"c\" FORM = \"\"\" .--------------------------------------. | | | Name: xxxxxxxxxxxxxx1xxxxxxxxxxxxxxx | | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx | | | >------------------------------------< | | | ccccccccccc Advantages: | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | ccccccccccc xxxxxxxxxx3xxxxxxxxxxx | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | ccccc2ccccc Disadvantages: | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | ccccccccccc xxxxxxxxxx4xxxxxxxxxxx | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | | +--------------------------------------+ \"\"\" The #coding statement (which must be put on the very first line to work) tells Python to use the utf-8 encoding for the file. Using the FORMCHAR and TABLECHAR we define what single-character we want to use to \"mark\" the regions of the character sheet holding cells and tables respectively. Within each block (which must be separated from one another by at least one non-marking character) we embed identifiers 1-4 to identify each block. The identifier could be any single character except for the FORMCHAR and TABLECHAR You can still use FORMCHAR and TABLECHAR elsewhere in your sheet, but not in a way that it would identify a cell/table. The smallest identifiable cell/table area is 3 characters wide including the identifier (for example x2x ). Now we will map content to this form. # again, this can be tested in a Python shell # hard-code this info here, later we'll ask the # account for this info. We will re-use the 'table' # variable from the EvTable example. NAME = \"John, the wise old admin with a chip on his shoulder\" ADVANTAGES = \"Language-wiz, Intimidation, Firebreathing\" DISADVANTAGES = \"Bad body odor, Poor eyesight, Troubled history\" from evennia.utils import evform # load the form from the module form = evform.EvForm(\"world/charsheetform.py\") # map the data to the form form.map(cells={\"1\":NAME, \"3\": ADVANTAGES, \"4\": DISADVANTAGES}, tables={\"2\":table}) We create some RP-sounding input and re-use the table variable from the previous EvTable example. Note, that if you didn't want to create the form in a separate module you could also load it directly into the EvForm call like this: EvForm(form={\"FORMCHAR\":\"x\", \"TABLECHAR\":\"c\", \"FORM\": formstring}) where FORM specifies the form as a string in the same way as listed in the module above. Note however that the very first line of the FORM string is ignored, so start with a \\n . We then map those to the cells of the form: print(form) .--------------------------------------. | | | Name: John, the wise old admin with | | a chip on his shoulder | | | >------------------------------------< | | | Attr|Value Advantages: | | ~~~~~+~~~~~ Language-wiz, | | STR| 12 Intimidation, | | CON| 13 Firebreathing | | DEX| 8 Disadvantages: | | INT| 10 Bad body odor, Poor | | WIS| 9 eyesight, Troubled | | CHA| 13 history | | | +--------------------------------------+ As seen, the texts and tables have been slotted into the text areas and line breaks have been added where needed. We chose to just enter the Advantages/Disadvantages as plain strings here, meaning long names ended up split between rows. If we wanted more control over the display we could have inserted \\n line breaks after each line or used a borderless EvTable to display those as well. Tie a Character sheet to a Character \u00b6 We will assume we go with the EvForm example above. We now need to attach this to a Character so it can be modified. For this we will modify our Character class a little more: # mygame/typeclasses/character.py from evennia.utils import evform, evtable [...] class Character(DefaultCharacter): [...] def at_object_creation(self): \"called only once, when object is first created\" # we will use this to stop account from changing sheet self.db.sheet_locked = False # we store these so we can build these on demand self.db.chardata = {\"str\": 0, \"con\": 0, \"dex\": 0, \"int\": 0, \"wis\": 0, \"cha\": 0, \"advantages\": \"\", \"disadvantages\": \"\"} self.db.charsheet = evform.EvForm(\"world/charsheetform.py\") self.update_charsheet() def update_charsheet(self): \"\"\" Call this to update the sheet after any of the ingoing data has changed. \"\"\" data = self.db.chardata table = evtable.EvTable(\"Attr\", \"Value\", table = [ [\"STR\", \"CON\", \"DEX\", \"INT\", \"WIS\", \"CHA\"], [data[\"str\"], data[\"con\"], data[\"dex\"], data[\"int\"], data[\"wis\"], data[\"cha\"]]], align='r', border=\"incols\") self.db.charsheet.map(tables={\"2\": table}, cells={\"1\":self.key, \"3\":data[\"advantages\"], \"4\":data[\"disadvantages\"]}) Use @reload to make this change available to all newly created Characters. Already existing Characters will not have the charsheet defined, since at_object_creation is only called once. The easiest to force an existing Character to re-fire its at_object_creation is to use the @typeclass command in-game: @typeclass/force <Character Name> Command for Account to change Character sheet \u00b6 We will add a command to edit the sections of our Character sheet. Open mygame/commands/command.py . # at the end of mygame/commands/command.py ALLOWED_ATTRS = (\"str\", \"con\", \"dex\", \"int\", \"wis\", \"cha\") ALLOWED_FIELDNAMES = ALLOWED_ATTRS + \\ (\"name\", \"advantages\", \"disadvantages\") def _validate_fieldname(caller, fieldname): \"Helper function to validate field names.\" if fieldname not in ALLOWED_FIELDNAMES: err = \"Allowed field names: %s\" % (\", \".join(ALLOWED_FIELDNAMES)) caller.msg(err) return False if fieldname in ALLOWED_ATTRS and not value.isdigit(): caller.msg(\"%s must receive a number.\" % fieldname) return False return True class CmdSheet(MuxCommand): \"\"\" Edit a field on the character sheet Usage: @sheet field value Examples: @sheet name Ulrik the Warrior @sheet dex 12 @sheet advantages Super strength, Night vision If given without arguments, will view the current character sheet. Allowed field names are: name, str, con, dex, int, wis, cha, advantages, disadvantages \"\"\" key = \"sheet\" aliases = \"editsheet\" locks = \"cmd: perm(Players)\" help_category = \"RP\" def func(self): caller = self.caller if not self.args or len(self.args) < 2: # not enough arguments. Display the sheet if sheet: caller.msg(caller.db.charsheet) else: caller.msg(\"You have no character sheet.\") return # if caller.db.sheet_locked: caller.msg(\"Your character sheet is locked.\") return # split input by whitespace, once fieldname, value = self.args.split(None, 1) fieldname = fieldname.lower() # ignore case if not _validate_fieldnames(caller, fieldname): return if fieldname == \"name\": self.key = value else: caller.chardata[fieldname] = value caller.update_charsheet() caller.msg(\"%s was set to %s.\" % (fieldname, value)) Most of this command is error-checking to make sure the right type of data was input. Note how the sheet_locked Attribute is checked and will return if not set. This command you import into mygame/commands/default_cmdsets.py and add to the CharacterCmdSet , in the same way the @gm command was added to the AccountCmdSet earlier. Commands for GM to change Character sheet \u00b6 Game masters use basically the same input as Players do to edit a character sheet, except they can do it on other players than themselves. They are also not stopped by any sheet_locked flags. # continuing in mygame/commands/command.py class CmdGMsheet(MuxCommand): \"\"\" GM-modification of char sheets Usage: @gmsheet character [= fieldname value] Switches: lock - lock the character sheet so the account can no longer edit it (GM's still can) unlock - unlock character sheet for Account editing. Examples: @gmsheet Tom @gmsheet Anna = str 12 @gmsheet/lock Tom \"\"\" key = \"gmsheet\" locks = \"cmd: perm(Admins)\" help_category = \"RP\" def func(self): caller = self.caller if not self.args: caller.msg(\"Usage: @gmsheet character [= fieldname value]\") if self.rhs: # rhs (right-hand-side) is set only if a '=' # was given. if len(self.rhs) < 2: caller.msg(\"You must specify both a fieldname and value.\") return fieldname, value = self.rhs.split(None, 1) fieldname = fieldname.lower() if not _validate_fieldname(caller, fieldname): return charname = self.lhs else: # no '=', so we must be aiming to look at a charsheet fieldname, value = None, None charname = self.args.strip() character = caller.search(charname, global_search=True) if not character: return if \"lock\" in self.switches: if character.db.sheet_locked: caller.msg(\"The character sheet is already locked.\") else: character.db.sheet_locked = True caller.msg(\"%s can no longer edit their character sheet.\" % character.key) elif \"unlock\" in self.switches: if not character.db.sheet_locked: caller.msg(\"The character sheet is already unlocked.\") else: character.db.sheet_locked = False caller.msg(\"%s can now edit their character sheet.\" % character.key) if fieldname: if fieldname == \"name\": character.key = value else: character.db.chardata[fieldname] = value character.update_charsheet() caller.msg(\"You set %s's %s to %s.\" % (character.key, fieldname, value) else: # just display caller.msg(character.db.charsheet) The @gmsheet command takes an additional argument to specify which Character's character sheet to edit. It also takes /lock and /unlock switches to block the Player from tweaking their sheet. Before this can be used, it should be added to the default CharacterCmdSet in the same way as the normal @sheet . Due to the lock set on it, this command will only be available to Admins (i.e. GMs) or higher permission levels. Dice roller \u00b6 Evennia's contrib folder already comes with a full dice roller. To add it to the game, simply import contrib.dice.CmdDice into mygame/commands/default_cmdsets.py and add CmdDice to the CharacterCmdset as done with other commands in this tutorial. After a @reload you will be able to roll dice using normal RPG-style format: roll 2d6 + 3 7 Use help dice to see what syntax is supported or look at evennia/contrib/dice.py to see how it's implemented. Rooms \u00b6 Evennia comes with rooms out of the box, so no extra work needed. A GM will automatically have all needed building commands available. A fuller go-through is found in the Building tutorial . Here are some useful highlights: @dig roomname;alias = exit_there;alias, exit_back;alias - this is the basic command for digging a new room. You can specify any exit-names and just enter the name of that exit to go there. @tunnel direction = roomname - this is a specialized command that only accepts directions in the cardinal directions (n,ne,e,se,s,sw,w,nw) as well as in/out and up/down. It also automatically builds \"matching\" exits back in the opposite direction. @create/drop objectname - this creates and drops a new simple object in the current location. @desc obj - change the look-description of the object. @tel object = location - teleport an object to a named location. @search objectname - locate an object in the database. TODO: Describe how to add a logging room, that logs says and poses to a log file that people can access after the fact. Channels \u00b6 Evennia comes with Channels in-built and they are described fully in the documentation. For brevity, here are the relevant commands for normal use: @ccreate new_channel;alias;alias = short description - Creates a new channel. addcom channel - join an existing channel. Use addcom alias = channel to add a new alias you can use to talk to the channel, as many as desired. delcom alias or channel - remove an alias from a channel or, if the real channel name is given, unsubscribe completely. @channels lists all available channels, including your subscriptions and any aliases you have set up for them. You can read channel history: if you for example are chatting on the public channel you can do public/history to see the 20 last posts to that channel or public/history 32 to view twenty posts backwards, starting with the 32nd from the end. PMs \u00b6 To send PMs to one another, players can use the @page (or tell ) command: page recipient = message page recipient, recipient, ... = message Players can use page alone to see the latest messages. This also works if they were not online when the message was sent.","title":"Evennia for roleplaying sessions"},{"location":"Evennia-for-roleplaying-sessions.html#starting-out","text":"We will assume you start from scratch. You need Evennia installed, as per the Getting Started instructions. Initialize a new game directory with evennia init <gamedirname> . In this tutorial we assume your game dir is simply named mygame . You can use the default database and keep all other settings to default for now. Familiarize yourself with the mygame folder before continuing. You might want to browse the First Steps Coding tutorial, just to see roughly where things are modified.","title":"Starting out"},{"location":"Evennia-for-roleplaying-sessions.html#the-game-master-role","text":"","title":"The Game Master role"},{"location":"Evennia-for-roleplaying-sessions.html#short-version","text":"Simplest way: Being an admin, just give one account Admins permission using the standard @perm command. Better but more work: Make a custom command to set/unset the above, while tweaking the Character to show your renewed GM status to the other accounts.","title":"Short version"},{"location":"Evennia-for-roleplaying-sessions.html#the-permission-hierarchy","text":"Evennia has the following permission hierarchy out of the box: Players, Helpers, Builders, Admins and finally Developers . We could change these but then we'd need to update our Default commands to use the changes. We want to keep this simple, so instead we map our different roles on top of this permission ladder. Players is the permission set on normal players. This is the default for anyone creating a new account on the server. Helpers are like Players except they also have the ability to create/edit new help entries. This could be granted to players who are willing to help with writing lore or custom logs for everyone. Builders is not used in our case since the GM should be the only world-builder. Admins is the permission level the GM should have. Admins can do everything builders can (create/describe rooms etc) but also kick accounts, rename them and things like that. Developers -level permission are the server administrators, the ones with the ability to restart/shutdown the server as well as changing the permission levels. The superuser is not part of the hierarchy and actually completely bypasses it. We'll assume server admin(s) will \"just\" be Developers.","title":"The permission hierarchy"},{"location":"Evennia-for-roleplaying-sessions.html#how-to-grant-permissions","text":"Only Developers can (by default) change permission level. Only they have access to the @perm command: > @perm Yvonne Permissions on Yvonne: accounts > @perm Yvonne = Admins > @perm Yvonne Permissions on Yvonne: accounts, admins > @perm/del Yvonne = Admins > @perm Yvonne Permissions on Yvonne: accounts There is no need to remove the basic Players permission when adding the higher permission: the highest will be used. Permission level names are not case sensitive. You can also use both plural and singular, so \"Admins\" gives the same powers as \"Admin\".","title":"How to grant permissions"},{"location":"Evennia-for-roleplaying-sessions.html#optional-making-a-gm-granting-command","text":"Use of @perm works out of the box, but it's really the bare minimum. Would it not be nice if other accounts could tell at a glance who the GM is? Also, we shouldn't really need to remember that the permission level is called \"Admins\". It would be easier if we could just do @gm <account> and @notgm <account> and at the same time change something make the new GM status apparent. So let's make this possible. This is what we'll do: We'll customize the default Character class. If an object of this class has a particular flag, its name will have the string (GM) added to the end. We'll add a new command, for the server admin to assign the GM-flag properly.","title":"Optional: Making a GM-granting command"},{"location":"Evennia-for-roleplaying-sessions.html#character-modification","text":"Let's first start by customizing the Character. We recommend you browse the beginning of the Account page to make sure you know how Evennia differentiates between the OOC \"Account objects\" (not to be confused with the Accounts permission, which is just a string specifying your access) and the IC \"Character objects\". Open mygame/typeclasses/characters.py and modify the default Character class: # in mygame/typeclasses/characters.py # [...] class Character(DefaultCharacter): # [...] def get_display_name(self, looker, **kwargs): \"\"\" This method customizes how character names are displayed. We assume only permissions of types \"Developers\" and \"Admins\" require special attention. \"\"\" name = self.key selfaccount = self.account # will be None if we are not puppeted lookaccount = looker.account # - \" - if selfaccount and selfaccount.db.is_gm: # A GM. Show name as name(GM) name = \"%s(GM)\" % name if lookaccount and \\ (lookaccount.permissions.get(\"Developers\") or lookaccount.db.is_gm): # Developers/GMs see name(#dbref) or name(GM)(#dbref) return \"%s(#%s)\" % (name, self.id) else: return name Above, we change how the Character's name is displayed: If the account controlling this Character is a GM, we attach the string (GM) to the Character's name so everyone can tell who's the boss. If we ourselves are Developers or GM's we will see database ids attached to Characters names, which can help if doing database searches against Characters of exactly the same name. We base the \"gm-ingness\" on having an flag (an Attribute ) named is_gm . We'll make sure new GM's actually get this flag below. Extra exercise: This will only show the (GM) text on Characters puppeted by a GM account, that is, it will show only to those in the same location. If we wanted it to also pop up in, say, who listings and channels, we'd need to make a similar change to the Account typeclass in mygame/typeclasses/accounts.py . We leave this as an exercise to the reader.","title":"Character modification"},{"location":"Evennia-for-roleplaying-sessions.html#new-gmungm-command","text":"We will describe in some detail how to create and add an Evennia command here with the hope that we don't need to be as detailed when adding commands in the future. We will build on Evennia's default \"mux-like\" commands here. Open mygame/commands/command.py and add a new Command class at the bottom: # in mygame/commands/command.py from evennia import default_cmds # [...] import evennia class CmdMakeGM(default_cmds.MuxCommand): \"\"\" Change an account's GM status Usage: @gm <account> @ungm <account> \"\"\" # note using the key without @ means both @gm !gm etc will work key = \"gm\" aliases = \"ungm\" locks = \"cmd:perm(Developers)\" help_category = \"RP\" def func(self): \"Implement the command\" caller = self.caller if not self.args: caller.msg(\"Usage: @gm account or @ungm account\") return accountlist = evennia.search_account(self.args) # returns a list if not accountlist: caller.msg(\"Could not find account '%s'\" % self.args) return elif len(accountlist) > 1: caller.msg(\"Multiple matches for '%s': %s\" % (self.args, accountlist)) return else: account = accountlist[0] if self.cmdstring == \"gm\": # turn someone into a GM if account.permissions.get(\"Admins\"): caller.msg(\"Account %s is already a GM.\" % account) else: account.permissions.add(\"Admins\") caller.msg(\"Account %s is now a GM.\" % account) account.msg(\"You are now a GM (changed by %s).\" % caller) account.character.db.is_gm = True else: # @ungm was entered - revoke GM status from someone if not account.permissions.get(\"Admins\"): caller.msg(\"Account %s is not a GM.\" % account) else: account.permissions.remove(\"Admins\") caller.msg(\"Account %s is no longer a GM.\" % account) account.msg(\"You are no longer a GM (changed by %s).\" % caller) del account.character.db.is_gm All the command does is to locate the account target and assign it the Admins permission if we used @gm or revoke it if using the @ungm alias. We also set/unset the is_gm Attribute that is expected by our new Character.get_display_name method from earlier. We could have made this into two separate commands or opted for a syntax like @gm/revoke <accountname> . Instead we examine how this command was called (stored in self.cmdstring ) in order to act accordingly. Either way works, practicality and coding style decides which to go with. To actually make this command available (only to Developers, due to the lock on it), we add it to the default Account command set. Open the file mygame/commands/default_cmdsets.py and find the AccountCmdSet class: # mygame/commands/default_cmdsets.py # [...] from commands.command import CmdMakeGM class AccountCmdSet(default_cmds.AccountCmdSet): # [...] def at_cmdset_creation(self): # [...] self.add(CmdMakeGM()) Finally, issue the @reload command to update the server to your changes. Developer-level players (or the superuser) should now have the @gm/@ungm command available.","title":"New @gm/@ungm command"},{"location":"Evennia-for-roleplaying-sessions.html#character-sheet","text":"","title":"Character sheet"},{"location":"Evennia-for-roleplaying-sessions.html#short-version_1","text":"Use Evennia's EvTable/EvForm to build a Character sheet Tie individual sheets to a given Character. Add new commands to modify the Character sheet, both by Accounts and GMs. Make the Character sheet lockable by a GM, so the Player can no longer modify it.","title":"Short version"},{"location":"Evennia-for-roleplaying-sessions.html#building-a-character-sheet","text":"There are many ways to build a Character sheet in text, from manually pasting strings together to more automated ways. Exactly what is the best/easiest way depends on the sheet one tries to create. We will here show two examples using the EvTable and EvForm utilities.Later we will create Commands to edit and display the output from those utilities. Note that due to the limitations of the wiki, no color is used in any of the examples. See the text tag documentation for how to add color to the tables and forms.","title":"Building a Character sheet"},{"location":"Evennia-for-roleplaying-sessions.html#making-a-sheet-with-evtable","text":"EvTable is a text-table generator. It helps with displaying text in ordered rows and columns. This is an example of using it in code: # this can be tried out in a Python shell like iPython from evennia.utils import evtable # we hardcode these for now, we'll get them as input later STR, CON, DEX, INT, WIS, CHA = 12, 13, 8, 10, 9, 13 table = evtable.EvTable(\"Attr\", \"Value\", table = [ [\"STR\", \"CON\", \"DEX\", \"INT\", \"WIS\", \"CHA\"], [STR, CON, DEX, INT, WIS, CHA] ], align='r', border=\"incols\") Above, we create a two-column table by supplying the two columns directly. We also tell the table to be right-aligned and to use the \"incols\" border type (borders drawns only in between columns). The EvTable class takes a lot of arguments for customizing its look, you can see some of the possible keyword arguments here . Once you have the table you could also retroactively add new columns and rows to it with table.add_row() and table.add_column() : if necessary the table will expand with empty rows/columns to always remain rectangular. The result from printing the above table will be table_string = str(table) print(table_string) Attr | Value ~~~~~~+~~~~~~~ STR | 12 CON | 13 DEX | 8 INT | 10 WIS | 9 CHA | 13 This is a minimalistic but effective Character sheet. By combining the table_string with other strings one could build up a reasonably full graphical representation of a Character. For more advanced layouts we'll look into EvForm next.","title":"Making a sheet with EvTable"},{"location":"Evennia-for-roleplaying-sessions.html#making-a-sheet-with-evform","text":"EvForm allows the creation of a two-dimensional \"graphic\" made by text characters. On this surface, one marks and tags rectangular regions (\"cells\") to be filled with content. This content can be either normal strings or EvTable instances (see the previous section, one such instance would be the table variable in that example). In the case of a Character sheet, these cells would be comparable to a line or box where you could enter the name of your character or their strength score. EvMenu also easily allows to update the content of those fields in code (it use EvTables so you rebuild the table first before re-sending it to EvForm). The drawback of EvForm is that its shape is static; if you try to put more text in a region than it was sized for, the text will be cropped. Similarly, if you try to put an EvTable instance in a field too small for it, the EvTable will do its best to try to resize to fit, but will eventually resort to cropping its data or even give an error if too small to fit any data. An EvForm is defined in a Python module. Create a new file mygame/world/charsheetform.py and modify it thus: #coding=utf-8 # in mygame/world/charsheetform.py FORMCHAR = \"x\" TABLECHAR = \"c\" FORM = \"\"\" .--------------------------------------. | | | Name: xxxxxxxxxxxxxx1xxxxxxxxxxxxxxx | | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx | | | >------------------------------------< | | | ccccccccccc Advantages: | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | ccccccccccc xxxxxxxxxx3xxxxxxxxxxx | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | ccccc2ccccc Disadvantages: | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | ccccccccccc xxxxxxxxxx4xxxxxxxxxxx | | ccccccccccc xxxxxxxxxxxxxxxxxxxxxx | | | +--------------------------------------+ \"\"\" The #coding statement (which must be put on the very first line to work) tells Python to use the utf-8 encoding for the file. Using the FORMCHAR and TABLECHAR we define what single-character we want to use to \"mark\" the regions of the character sheet holding cells and tables respectively. Within each block (which must be separated from one another by at least one non-marking character) we embed identifiers 1-4 to identify each block. The identifier could be any single character except for the FORMCHAR and TABLECHAR You can still use FORMCHAR and TABLECHAR elsewhere in your sheet, but not in a way that it would identify a cell/table. The smallest identifiable cell/table area is 3 characters wide including the identifier (for example x2x ). Now we will map content to this form. # again, this can be tested in a Python shell # hard-code this info here, later we'll ask the # account for this info. We will re-use the 'table' # variable from the EvTable example. NAME = \"John, the wise old admin with a chip on his shoulder\" ADVANTAGES = \"Language-wiz, Intimidation, Firebreathing\" DISADVANTAGES = \"Bad body odor, Poor eyesight, Troubled history\" from evennia.utils import evform # load the form from the module form = evform.EvForm(\"world/charsheetform.py\") # map the data to the form form.map(cells={\"1\":NAME, \"3\": ADVANTAGES, \"4\": DISADVANTAGES}, tables={\"2\":table}) We create some RP-sounding input and re-use the table variable from the previous EvTable example. Note, that if you didn't want to create the form in a separate module you could also load it directly into the EvForm call like this: EvForm(form={\"FORMCHAR\":\"x\", \"TABLECHAR\":\"c\", \"FORM\": formstring}) where FORM specifies the form as a string in the same way as listed in the module above. Note however that the very first line of the FORM string is ignored, so start with a \\n . We then map those to the cells of the form: print(form) .--------------------------------------. | | | Name: John, the wise old admin with | | a chip on his shoulder | | | >------------------------------------< | | | Attr|Value Advantages: | | ~~~~~+~~~~~ Language-wiz, | | STR| 12 Intimidation, | | CON| 13 Firebreathing | | DEX| 8 Disadvantages: | | INT| 10 Bad body odor, Poor | | WIS| 9 eyesight, Troubled | | CHA| 13 history | | | +--------------------------------------+ As seen, the texts and tables have been slotted into the text areas and line breaks have been added where needed. We chose to just enter the Advantages/Disadvantages as plain strings here, meaning long names ended up split between rows. If we wanted more control over the display we could have inserted \\n line breaks after each line or used a borderless EvTable to display those as well.","title":"Making a sheet with EvForm"},{"location":"Evennia-for-roleplaying-sessions.html#tie-a-character-sheet-to-a-character","text":"We will assume we go with the EvForm example above. We now need to attach this to a Character so it can be modified. For this we will modify our Character class a little more: # mygame/typeclasses/character.py from evennia.utils import evform, evtable [...] class Character(DefaultCharacter): [...] def at_object_creation(self): \"called only once, when object is first created\" # we will use this to stop account from changing sheet self.db.sheet_locked = False # we store these so we can build these on demand self.db.chardata = {\"str\": 0, \"con\": 0, \"dex\": 0, \"int\": 0, \"wis\": 0, \"cha\": 0, \"advantages\": \"\", \"disadvantages\": \"\"} self.db.charsheet = evform.EvForm(\"world/charsheetform.py\") self.update_charsheet() def update_charsheet(self): \"\"\" Call this to update the sheet after any of the ingoing data has changed. \"\"\" data = self.db.chardata table = evtable.EvTable(\"Attr\", \"Value\", table = [ [\"STR\", \"CON\", \"DEX\", \"INT\", \"WIS\", \"CHA\"], [data[\"str\"], data[\"con\"], data[\"dex\"], data[\"int\"], data[\"wis\"], data[\"cha\"]]], align='r', border=\"incols\") self.db.charsheet.map(tables={\"2\": table}, cells={\"1\":self.key, \"3\":data[\"advantages\"], \"4\":data[\"disadvantages\"]}) Use @reload to make this change available to all newly created Characters. Already existing Characters will not have the charsheet defined, since at_object_creation is only called once. The easiest to force an existing Character to re-fire its at_object_creation is to use the @typeclass command in-game: @typeclass/force <Character Name>","title":"Tie a Character sheet to a Character"},{"location":"Evennia-for-roleplaying-sessions.html#command-for-account-to-change-character-sheet","text":"We will add a command to edit the sections of our Character sheet. Open mygame/commands/command.py . # at the end of mygame/commands/command.py ALLOWED_ATTRS = (\"str\", \"con\", \"dex\", \"int\", \"wis\", \"cha\") ALLOWED_FIELDNAMES = ALLOWED_ATTRS + \\ (\"name\", \"advantages\", \"disadvantages\") def _validate_fieldname(caller, fieldname): \"Helper function to validate field names.\" if fieldname not in ALLOWED_FIELDNAMES: err = \"Allowed field names: %s\" % (\", \".join(ALLOWED_FIELDNAMES)) caller.msg(err) return False if fieldname in ALLOWED_ATTRS and not value.isdigit(): caller.msg(\"%s must receive a number.\" % fieldname) return False return True class CmdSheet(MuxCommand): \"\"\" Edit a field on the character sheet Usage: @sheet field value Examples: @sheet name Ulrik the Warrior @sheet dex 12 @sheet advantages Super strength, Night vision If given without arguments, will view the current character sheet. Allowed field names are: name, str, con, dex, int, wis, cha, advantages, disadvantages \"\"\" key = \"sheet\" aliases = \"editsheet\" locks = \"cmd: perm(Players)\" help_category = \"RP\" def func(self): caller = self.caller if not self.args or len(self.args) < 2: # not enough arguments. Display the sheet if sheet: caller.msg(caller.db.charsheet) else: caller.msg(\"You have no character sheet.\") return # if caller.db.sheet_locked: caller.msg(\"Your character sheet is locked.\") return # split input by whitespace, once fieldname, value = self.args.split(None, 1) fieldname = fieldname.lower() # ignore case if not _validate_fieldnames(caller, fieldname): return if fieldname == \"name\": self.key = value else: caller.chardata[fieldname] = value caller.update_charsheet() caller.msg(\"%s was set to %s.\" % (fieldname, value)) Most of this command is error-checking to make sure the right type of data was input. Note how the sheet_locked Attribute is checked and will return if not set. This command you import into mygame/commands/default_cmdsets.py and add to the CharacterCmdSet , in the same way the @gm command was added to the AccountCmdSet earlier.","title":"Command for Account to change Character sheet"},{"location":"Evennia-for-roleplaying-sessions.html#commands-for-gm-to-change-character-sheet","text":"Game masters use basically the same input as Players do to edit a character sheet, except they can do it on other players than themselves. They are also not stopped by any sheet_locked flags. # continuing in mygame/commands/command.py class CmdGMsheet(MuxCommand): \"\"\" GM-modification of char sheets Usage: @gmsheet character [= fieldname value] Switches: lock - lock the character sheet so the account can no longer edit it (GM's still can) unlock - unlock character sheet for Account editing. Examples: @gmsheet Tom @gmsheet Anna = str 12 @gmsheet/lock Tom \"\"\" key = \"gmsheet\" locks = \"cmd: perm(Admins)\" help_category = \"RP\" def func(self): caller = self.caller if not self.args: caller.msg(\"Usage: @gmsheet character [= fieldname value]\") if self.rhs: # rhs (right-hand-side) is set only if a '=' # was given. if len(self.rhs) < 2: caller.msg(\"You must specify both a fieldname and value.\") return fieldname, value = self.rhs.split(None, 1) fieldname = fieldname.lower() if not _validate_fieldname(caller, fieldname): return charname = self.lhs else: # no '=', so we must be aiming to look at a charsheet fieldname, value = None, None charname = self.args.strip() character = caller.search(charname, global_search=True) if not character: return if \"lock\" in self.switches: if character.db.sheet_locked: caller.msg(\"The character sheet is already locked.\") else: character.db.sheet_locked = True caller.msg(\"%s can no longer edit their character sheet.\" % character.key) elif \"unlock\" in self.switches: if not character.db.sheet_locked: caller.msg(\"The character sheet is already unlocked.\") else: character.db.sheet_locked = False caller.msg(\"%s can now edit their character sheet.\" % character.key) if fieldname: if fieldname == \"name\": character.key = value else: character.db.chardata[fieldname] = value character.update_charsheet() caller.msg(\"You set %s's %s to %s.\" % (character.key, fieldname, value) else: # just display caller.msg(character.db.charsheet) The @gmsheet command takes an additional argument to specify which Character's character sheet to edit. It also takes /lock and /unlock switches to block the Player from tweaking their sheet. Before this can be used, it should be added to the default CharacterCmdSet in the same way as the normal @sheet . Due to the lock set on it, this command will only be available to Admins (i.e. GMs) or higher permission levels.","title":"Commands for GM to change Character sheet"},{"location":"Evennia-for-roleplaying-sessions.html#dice-roller","text":"Evennia's contrib folder already comes with a full dice roller. To add it to the game, simply import contrib.dice.CmdDice into mygame/commands/default_cmdsets.py and add CmdDice to the CharacterCmdset as done with other commands in this tutorial. After a @reload you will be able to roll dice using normal RPG-style format: roll 2d6 + 3 7 Use help dice to see what syntax is supported or look at evennia/contrib/dice.py to see how it's implemented.","title":"Dice roller"},{"location":"Evennia-for-roleplaying-sessions.html#rooms","text":"Evennia comes with rooms out of the box, so no extra work needed. A GM will automatically have all needed building commands available. A fuller go-through is found in the Building tutorial . Here are some useful highlights: @dig roomname;alias = exit_there;alias, exit_back;alias - this is the basic command for digging a new room. You can specify any exit-names and just enter the name of that exit to go there. @tunnel direction = roomname - this is a specialized command that only accepts directions in the cardinal directions (n,ne,e,se,s,sw,w,nw) as well as in/out and up/down. It also automatically builds \"matching\" exits back in the opposite direction. @create/drop objectname - this creates and drops a new simple object in the current location. @desc obj - change the look-description of the object. @tel object = location - teleport an object to a named location. @search objectname - locate an object in the database. TODO: Describe how to add a logging room, that logs says and poses to a log file that people can access after the fact.","title":"Rooms"},{"location":"Evennia-for-roleplaying-sessions.html#channels","text":"Evennia comes with Channels in-built and they are described fully in the documentation. For brevity, here are the relevant commands for normal use: @ccreate new_channel;alias;alias = short description - Creates a new channel. addcom channel - join an existing channel. Use addcom alias = channel to add a new alias you can use to talk to the channel, as many as desired. delcom alias or channel - remove an alias from a channel or, if the real channel name is given, unsubscribe completely. @channels lists all available channels, including your subscriptions and any aliases you have set up for them. You can read channel history: if you for example are chatting on the public channel you can do public/history to see the 20 last posts to that channel or public/history 32 to view twenty posts backwards, starting with the 32nd from the end.","title":"Channels"},{"location":"Evennia-for-roleplaying-sessions.html#pms","text":"To send PMs to one another, players can use the @page (or tell ) command: page recipient = message page recipient, recipient, ... = message Players can use page alone to see the latest messages. This also works if they were not online when the message was sent.","title":"PMs"},{"location":"Execute-Python-Code.html","text":"The @py command supplied with the default command set of Evennia allows you to execute Python commands directly from inside the game. An alias to @py is simply \" ! \". Access to the @py command should be severely restricted . This is no joke - being able to execute arbitrary Python code on the server is not something you should entrust to just anybody. @py 1+2 <<< 3 Available variables \u00b6 A few local variables are made available when running @py . These offer entry into the running system. self / me - the calling object (i.e. you) here - the current caller's location obj - a dummy Object instance evennia - Evennia's flat API - through this you can access all of Evennia. For accessing other objects in the same room you need to use self.search(name) . For objects in other locations, use one of the evennia.search_* methods. See below . Returning output \u00b6 This is an example where we import and test one of Evennia's utilities found in src/utils/utils.py , but also accessible through ev.utils : @py from ev import utils; utils.time_format(33333) <<< Done. Note that we didn't get any return value, all we where told is that the code finished executing without error. This is often the case in more complex pieces of code which has no single obvious return value. To see the output from the time_format() function we need to tell the system to echo it to us explicitly with self.msg() . @py from ev import utils; self.msg(str(utils.time_format(33333))) 09:15 <<< Done. Warning: When using the msg function wrap our argument in str() to convert it into a string above. This is not strictly necessary for most types of data (Evennia will usually convert to a string behind the scenes for you). But for lists and tuples you will be confused by the output if you don't wrap them in str() : only the first item of the iterable will be returned. This is because doing msg(text) is actually just a convenience shortcut; the full argument that msg accepts is something called an outputfunc on the form (cmdname, (args), {kwargs}) (see the message path for more info). Sending a list/tuple confuses Evennia to think you are sending such a structure. Converting it to a string however makes it clear it should just be displayed as-is. If you were to use Python's standard print , you will see the result in your current stdout (your terminal by default, otherwise your log file). Finding objects \u00b6 A common use for @py is to explore objects in the database, for debugging and performing specific operations that are not covered by a particular command. Locating an object is best done using self.search() : @py self.search(\"red_ball\") <<< Ball @py self.search(\"red_ball\").db.color = \"red\" <<< Done. @py self.search(\"red_ball\").db.color <<< red self.search() is by far the most used case, but you can also search other database tables for other Evennia entities like scripts or configuration entities. To do this you can use the generic search entries found in ev.search_* . @py evennia.search_script(\"sys_game_time\") <<< [<src.utils.gametime.GameTime object at 0x852be2c>] (Note that since this becomes a simple statement, we don't have to wrap it in self.msg() to get the output). You can also use the database model managers directly (accessible through the objects properties of database models or as evennia.managers.* ). This is a bit more flexible since it gives you access to the full range of database search methods defined in each manager. @py evennia.managers.scripts.script_search(\"sys_game_time\") <<< [<src.utils.gametime.GameTime object at 0x852be2c>] The managers are useful for all sorts of database studies. @py ev.managers.configvalues.all() <<< [<ConfigValue: default_home]>, <ConfigValue:site_name>, ...] Testing code outside the game \u00b6 @py has the advantage of operating inside a running server (sharing the same process), where you can test things in real time. Much of this can be done from the outside too though. In a terminal, cd to the top of your game directory (this bit is important since we need access to your config file) and run evennia shell Your default Python interpreter will start up, configured to be able to work with and import all modules of your Evennia installation. From here you can explore the database and test-run individual modules as desired. It's recommended that you get a more fully featured Python interpreter like iPython . If you use a virtual environment, you can just get it with pip install ipython . IPython allows you to better work over several lines, and also has a lot of other editing features, such as tab-completion and __doc__ -string reading. $ evennia shell IPython 0.10 -- An enhanced Interactive Python ... In [1]: import evennia In [2]: evennia.managers.objects.all() Out[3]: [<ObjectDB: Harry>, <ObjectDB: Limbo>, ...] See the page about the Evennia-API for more things to explore.","title":"Execute Python Code"},{"location":"Execute-Python-Code.html#available-variables","text":"A few local variables are made available when running @py . These offer entry into the running system. self / me - the calling object (i.e. you) here - the current caller's location obj - a dummy Object instance evennia - Evennia's flat API - through this you can access all of Evennia. For accessing other objects in the same room you need to use self.search(name) . For objects in other locations, use one of the evennia.search_* methods. See below .","title":"Available variables"},{"location":"Execute-Python-Code.html#returning-output","text":"This is an example where we import and test one of Evennia's utilities found in src/utils/utils.py , but also accessible through ev.utils : @py from ev import utils; utils.time_format(33333) <<< Done. Note that we didn't get any return value, all we where told is that the code finished executing without error. This is often the case in more complex pieces of code which has no single obvious return value. To see the output from the time_format() function we need to tell the system to echo it to us explicitly with self.msg() . @py from ev import utils; self.msg(str(utils.time_format(33333))) 09:15 <<< Done. Warning: When using the msg function wrap our argument in str() to convert it into a string above. This is not strictly necessary for most types of data (Evennia will usually convert to a string behind the scenes for you). But for lists and tuples you will be confused by the output if you don't wrap them in str() : only the first item of the iterable will be returned. This is because doing msg(text) is actually just a convenience shortcut; the full argument that msg accepts is something called an outputfunc on the form (cmdname, (args), {kwargs}) (see the message path for more info). Sending a list/tuple confuses Evennia to think you are sending such a structure. Converting it to a string however makes it clear it should just be displayed as-is. If you were to use Python's standard print , you will see the result in your current stdout (your terminal by default, otherwise your log file).","title":"Returning output"},{"location":"Execute-Python-Code.html#finding-objects","text":"A common use for @py is to explore objects in the database, for debugging and performing specific operations that are not covered by a particular command. Locating an object is best done using self.search() : @py self.search(\"red_ball\") <<< Ball @py self.search(\"red_ball\").db.color = \"red\" <<< Done. @py self.search(\"red_ball\").db.color <<< red self.search() is by far the most used case, but you can also search other database tables for other Evennia entities like scripts or configuration entities. To do this you can use the generic search entries found in ev.search_* . @py evennia.search_script(\"sys_game_time\") <<< [<src.utils.gametime.GameTime object at 0x852be2c>] (Note that since this becomes a simple statement, we don't have to wrap it in self.msg() to get the output). You can also use the database model managers directly (accessible through the objects properties of database models or as evennia.managers.* ). This is a bit more flexible since it gives you access to the full range of database search methods defined in each manager. @py evennia.managers.scripts.script_search(\"sys_game_time\") <<< [<src.utils.gametime.GameTime object at 0x852be2c>] The managers are useful for all sorts of database studies. @py ev.managers.configvalues.all() <<< [<ConfigValue: default_home]>, <ConfigValue:site_name>, ...]","title":"Finding objects"},{"location":"Execute-Python-Code.html#testing-code-outside-the-game","text":"@py has the advantage of operating inside a running server (sharing the same process), where you can test things in real time. Much of this can be done from the outside too though. In a terminal, cd to the top of your game directory (this bit is important since we need access to your config file) and run evennia shell Your default Python interpreter will start up, configured to be able to work with and import all modules of your Evennia installation. From here you can explore the database and test-run individual modules as desired. It's recommended that you get a more fully featured Python interpreter like iPython . If you use a virtual environment, you can just get it with pip install ipython . IPython allows you to better work over several lines, and also has a lot of other editing features, such as tab-completion and __doc__ -string reading. $ evennia shell IPython 0.10 -- An enhanced Interactive Python ... In [1]: import evennia In [2]: evennia.managers.objects.all() Out[3]: [<ObjectDB: Harry>, <ObjectDB: Limbo>, ...] See the page about the Evennia-API for more things to explore.","title":"Testing code outside the game"},{"location":"First-Steps-Coding.html","text":"This section gives a brief step-by-step introduction on how to set up Evennia for the first time so you can modify and overload the defaults easily. You should only need to do these steps once. It also walks through you making your first few tweaks. Before continuing, make sure you have Evennia installed and running by following the Getting Started instructions. You should have initialized a new game folder with the evennia --init foldername command. We will in the following assume this folder is called \"mygame\". It might be a good idea to eye through the brief Coding Introduction too (especially the recommendations in the section about the evennia \"flat\" API and about using evennia shell will help you here and in the future). To follow this tutorial you also need to know the basics of operating your computer's terminal/command line. You also need to have a text editor to edit and create source text files. There are plenty of online tutorials on how to use the terminal and plenty of good free text editors. We will assume these things are already familiar to you henceforth. Your First Changes \u00b6 Below are some first things to try with your new custom modules. You can test these to get a feel for the system. See also Tutorials for more step-by-step help and special cases. Tweak Default Character \u00b6 We will add some simple rpg attributes to our default Character. In the next section we will follow up with a new command to view those attributes. Edit mygame/typeclasses/characters.py and modify the Character class. The at_object_creation method also exists on the DefaultCharacter parent and will overload it. The get_abilities method is unique to our version of Character . ```python class Character(DefaultCharacter): # [...] def at_object_creation(self): \"\"\" Called only at initial creation. This is a rather silly example since ability scores should vary from Character to Character and is usually set during some character generation step instead. \"\"\" #set persistent attributes self.db.strength = 5 self.db.agility = 4 self.db.magic = 2 def get_abilities(self): \"\"\" Simple access method to return ability scores as a tuple (str,agi,mag) \"\"\" return self.db.strength, self.db.agility, self.db.magic ``` Reload the server (you will still be connected to the game after doing this). Note that if you examine yourself you will not see any new Attributes appear yet. Read the next section to understand why. Updating Yourself \u00b6 It's important to note that the new Attributes we added above will only be stored on newly created characters. The reason for this is simple: The at_object_creation method, where we added those Attributes, is per definition only called when the object is first created , then never again. This is usually a good thing since those Attributes may change over time - calling that hook would reset them back to start values. But it also means that your existing character doesn't have them yet. You can see this by calling the get_abilities hook on yourself at this point: # (you have to be superuser to use @py) @py self.get_abilities() <<< (None, None, None) This is easily remedied. @update self This will (only) re-run at_object_creation on yourself. You should henceforth be able to get the abilities successfully: @py self.get_abilities() <<< (5, 4, 2) This is something to keep in mind if you start building your world before your code is stable - startup-hooks will not (and should not) automatically run on existing objects - you have to update your existing objects manually. Luckily this is a one-time thing and pretty simple to do. If the typeclass you want to update is in typeclasses.myclass.MyClass , you can do the following (e.g. from evennia shell ): from typeclasses.myclass import MyClass # loop over all MyClass instances in the database # and call .swap_typeclass on them for obj in MyClass.objects.all(): obj.swap_typeclass(MyClass, run_start_hooks=\"at_object_creation\") Using swap_typeclass to the same typeclass we already have will re-run the creation hooks (this is what the @update command does under the hood). From in-game you can do the same with @py : @py typeclasses.myclass import MyClass;[obj.swap_typeclass(MyClass) for obj in MyClass.objects.all()] See the Object Typeclass tutorial for more help and the Typeclasses and Attributes page for detailed documentation about Typeclasses and Attributes. Troubleshooting: Updating Yourself \u00b6 One may experience errors for a number of reasons. Common beginner errors are spelling mistakes, wrong indentations or code omissions leading to a SyntaxError . Let's say you leave out a colon from the end of a class function like so: def at_object_creation(self) . The client will reload without issue. However , if you look at the terminal/console (i.e. not in-game), you will see Evennia complaining (this is called a traceback ): Traceback (most recent call last): File \"C:\\mygame\\typeclasses\\characters.py\", line 33 def at_object_creation(self) ^ SyntaxError: invalid syntax Evennia will still be restarting and following the tutorial, doing @py self.get_abilities() will return the right response (None, None, None) . But when attempting to @typeclass/force self you will get this response: AttributeError: 'DefaultObject' object has no attribute 'get_abilities' The full error will show in the terminal/console but this is confusing since you did add get_abilities before. Note however what the error says - you ( self ) should be a Character but the error talks about DefaultObject . What has happened is that due to your unhandled SyntaxError earlier, Evennia could not load the character.py module at all (it's not valid Python). Rather than crashing, Evennia handles this by temporarily falling back to a safe default - DefaultObject - in order to keep your MUD running. Fix the original SyntaxError and reload the server. Evennia will then be able to use your modified Character class again and things should work. Note: Learning how to interpret an error traceback is a critical skill for anyone learning Python. Full tracebacks will appear in the terminal/Console you started Evennia from. The traceback text can sometimes be quite long, but you are usually just looking for the last few lines: The description of the error and the filename + line number for where the error occurred. In the example above, we see it's a SyntaxError happening at line 33 of mygame\\typeclasses\\characters.py . In this case it even points out where on the line it encountered the error (the missing colon). Learn to read tracebacks and you'll be able to resolve the vast majority of common errors easily. Add a New Default Command \u00b6 The @py command used above is only available to privileged users. We want any player to be able to see their stats. Let's add a new command to list the abilities we added in the previous section. Open mygame/commands/command.py . You could in principle put your command anywhere but this module has all the imports already set up along with some useful documentation. Make a new class at the bottom of this file: ```python class CmdAbilities(Command): \"\"\" List abilities Usage: abilities Displays a list of your current ability values. \"\"\" key = \"abilities\" aliases = [\"abi\"] lock = \"cmd:all()\" help_category = \"General\" def func(self): \"implements the actual functionality\" str, agi, mag = self.caller.get_abilities() string = \"STR: %s, AGI: %s, MAG: %s\" % (str, agi, mag) self.caller.msg(string) ``` Next you edit mygame/commands/default_cmdsets.py and add a new import to it near the top: python from commands.command import CmdAbilities In the CharacterCmdSet class, add the following near the bottom (it says where): python self.add(CmdAbilities()) Reload the server (noone will be disconnected by doing this). You (and anyone else) should now be able to use abilities (or its alias abi ) as part of your normal commands in-game: abilities STR: 5, AGI: 4, MAG: 2 See the Adding a Command tutorial for more examples and the Commands section for detailed documentation about the Command system. Make a New Type of Object \u00b6 Let's test to make a new type of object. This example is an \"wise stone\" object that returns some random comment when you look at it, like this: > look stone A very wise stone This is a very wise old stone. It grumbles and says: 'The world is like a rock of chocolate.' Create a new module in mygame/typeclasses/ . Name it wiseobject.py for this example. In the module import the base Object ( typeclasses.objects.Object ). This is empty by default, meaning it is just a proxy for the default evennia.DefaultObject . Make a new class in your module inheriting from Object . Overload hooks on it to add new functionality. Here is an example of how the file could look: ```python from random import choice from typeclasses.objects import Object class WiseObject(Object): \"\"\" An object speaking when someone looks at it. We assume it looks like a stone in this example. \"\"\" def at_object_creation(self): \"Called when object is first created\" self.db.wise_texts = \\ [\"Stones have feelings too.\", \"To live like a stone is to not have lived at all.\", \"The world is like a rock of chocolate.\"] def return_appearance(self, looker): \"\"\" Called by the look command. We want to return a wisdom when we get looked at. \"\"\" # first get the base string from the # parent's return_appearance. string = super().return_appearance(looker) wisewords = \"\\n\\nIt grumbles and says: '%s'\" wisewords = wisewords % choice(self.db.wise_texts) return string + wisewords ``` Check your code for bugs. Tracebacks will appear on your command line or log. If you have a grave Syntax Error in your code, the source file itself will fail to load which can cause issues with the entire cmdset. If so, fix your bug and reload the server from the command line (noone will be disconnected by doing this). Use @create/drop stone:wiseobject.WiseObject to create a talkative stone. If the @create command spits out a warning or cannot find the typeclass (it will tell you which paths it searched), re-check your code for bugs and that you gave the correct path. The @create command starts looking for Typeclasses in mygame/typeclasses/ . Use look stone to test. You will see the default description (\"You see nothing special\") followed by a random message of stony wisdom. Use @desc stone = This is a wise old stone. to make it look nicer. See the Builder Docs for more information. Note that at_object_creation is only called once, when the stone is first created. If you make changes to this method later, already existing stones will not see those changes. As with the Character example above you can use @typeclass/force to tell the stone to re-run its initialization. The at_object_creation is a special case though. Changing most other aspects of the typeclass does not require manual updating like this - you just need to @reload to have all changes applied automatically to all existing objects. Where to Go From Here? \u00b6 There are more Tutorials , including one for building a whole little MUSH-like game - that is instructive also if you have no interest in MUSHes per se. A good idea is to also get onto the IRC chat and the mailing list to get in touch with the community and other developers.","title":"First Steps Coding"},{"location":"First-Steps-Coding.html#your-first-changes","text":"Below are some first things to try with your new custom modules. You can test these to get a feel for the system. See also Tutorials for more step-by-step help and special cases.","title":"Your First Changes"},{"location":"First-Steps-Coding.html#tweak-default-character","text":"We will add some simple rpg attributes to our default Character. In the next section we will follow up with a new command to view those attributes. Edit mygame/typeclasses/characters.py and modify the Character class. The at_object_creation method also exists on the DefaultCharacter parent and will overload it. The get_abilities method is unique to our version of Character . ```python class Character(DefaultCharacter): # [...] def at_object_creation(self): \"\"\" Called only at initial creation. This is a rather silly example since ability scores should vary from Character to Character and is usually set during some character generation step instead. \"\"\" #set persistent attributes self.db.strength = 5 self.db.agility = 4 self.db.magic = 2 def get_abilities(self): \"\"\" Simple access method to return ability scores as a tuple (str,agi,mag) \"\"\" return self.db.strength, self.db.agility, self.db.magic ``` Reload the server (you will still be connected to the game after doing this). Note that if you examine yourself you will not see any new Attributes appear yet. Read the next section to understand why.","title":"Tweak Default Character"},{"location":"First-Steps-Coding.html#updating-yourself","text":"It's important to note that the new Attributes we added above will only be stored on newly created characters. The reason for this is simple: The at_object_creation method, where we added those Attributes, is per definition only called when the object is first created , then never again. This is usually a good thing since those Attributes may change over time - calling that hook would reset them back to start values. But it also means that your existing character doesn't have them yet. You can see this by calling the get_abilities hook on yourself at this point: # (you have to be superuser to use @py) @py self.get_abilities() <<< (None, None, None) This is easily remedied. @update self This will (only) re-run at_object_creation on yourself. You should henceforth be able to get the abilities successfully: @py self.get_abilities() <<< (5, 4, 2) This is something to keep in mind if you start building your world before your code is stable - startup-hooks will not (and should not) automatically run on existing objects - you have to update your existing objects manually. Luckily this is a one-time thing and pretty simple to do. If the typeclass you want to update is in typeclasses.myclass.MyClass , you can do the following (e.g. from evennia shell ): from typeclasses.myclass import MyClass # loop over all MyClass instances in the database # and call .swap_typeclass on them for obj in MyClass.objects.all(): obj.swap_typeclass(MyClass, run_start_hooks=\"at_object_creation\") Using swap_typeclass to the same typeclass we already have will re-run the creation hooks (this is what the @update command does under the hood). From in-game you can do the same with @py : @py typeclasses.myclass import MyClass;[obj.swap_typeclass(MyClass) for obj in MyClass.objects.all()] See the Object Typeclass tutorial for more help and the Typeclasses and Attributes page for detailed documentation about Typeclasses and Attributes.","title":"Updating Yourself"},{"location":"First-Steps-Coding.html#troubleshooting-updating-yourself","text":"One may experience errors for a number of reasons. Common beginner errors are spelling mistakes, wrong indentations or code omissions leading to a SyntaxError . Let's say you leave out a colon from the end of a class function like so: def at_object_creation(self) . The client will reload without issue. However , if you look at the terminal/console (i.e. not in-game), you will see Evennia complaining (this is called a traceback ): Traceback (most recent call last): File \"C:\\mygame\\typeclasses\\characters.py\", line 33 def at_object_creation(self) ^ SyntaxError: invalid syntax Evennia will still be restarting and following the tutorial, doing @py self.get_abilities() will return the right response (None, None, None) . But when attempting to @typeclass/force self you will get this response: AttributeError: 'DefaultObject' object has no attribute 'get_abilities' The full error will show in the terminal/console but this is confusing since you did add get_abilities before. Note however what the error says - you ( self ) should be a Character but the error talks about DefaultObject . What has happened is that due to your unhandled SyntaxError earlier, Evennia could not load the character.py module at all (it's not valid Python). Rather than crashing, Evennia handles this by temporarily falling back to a safe default - DefaultObject - in order to keep your MUD running. Fix the original SyntaxError and reload the server. Evennia will then be able to use your modified Character class again and things should work. Note: Learning how to interpret an error traceback is a critical skill for anyone learning Python. Full tracebacks will appear in the terminal/Console you started Evennia from. The traceback text can sometimes be quite long, but you are usually just looking for the last few lines: The description of the error and the filename + line number for where the error occurred. In the example above, we see it's a SyntaxError happening at line 33 of mygame\\typeclasses\\characters.py . In this case it even points out where on the line it encountered the error (the missing colon). Learn to read tracebacks and you'll be able to resolve the vast majority of common errors easily.","title":"Troubleshooting: Updating Yourself"},{"location":"First-Steps-Coding.html#add-a-new-default-command","text":"The @py command used above is only available to privileged users. We want any player to be able to see their stats. Let's add a new command to list the abilities we added in the previous section. Open mygame/commands/command.py . You could in principle put your command anywhere but this module has all the imports already set up along with some useful documentation. Make a new class at the bottom of this file: ```python class CmdAbilities(Command): \"\"\" List abilities Usage: abilities Displays a list of your current ability values. \"\"\" key = \"abilities\" aliases = [\"abi\"] lock = \"cmd:all()\" help_category = \"General\" def func(self): \"implements the actual functionality\" str, agi, mag = self.caller.get_abilities() string = \"STR: %s, AGI: %s, MAG: %s\" % (str, agi, mag) self.caller.msg(string) ``` Next you edit mygame/commands/default_cmdsets.py and add a new import to it near the top: python from commands.command import CmdAbilities In the CharacterCmdSet class, add the following near the bottom (it says where): python self.add(CmdAbilities()) Reload the server (noone will be disconnected by doing this). You (and anyone else) should now be able to use abilities (or its alias abi ) as part of your normal commands in-game: abilities STR: 5, AGI: 4, MAG: 2 See the Adding a Command tutorial for more examples and the Commands section for detailed documentation about the Command system.","title":"Add a New Default Command"},{"location":"First-Steps-Coding.html#make-a-new-type-of-object","text":"Let's test to make a new type of object. This example is an \"wise stone\" object that returns some random comment when you look at it, like this: > look stone A very wise stone This is a very wise old stone. It grumbles and says: 'The world is like a rock of chocolate.' Create a new module in mygame/typeclasses/ . Name it wiseobject.py for this example. In the module import the base Object ( typeclasses.objects.Object ). This is empty by default, meaning it is just a proxy for the default evennia.DefaultObject . Make a new class in your module inheriting from Object . Overload hooks on it to add new functionality. Here is an example of how the file could look: ```python from random import choice from typeclasses.objects import Object class WiseObject(Object): \"\"\" An object speaking when someone looks at it. We assume it looks like a stone in this example. \"\"\" def at_object_creation(self): \"Called when object is first created\" self.db.wise_texts = \\ [\"Stones have feelings too.\", \"To live like a stone is to not have lived at all.\", \"The world is like a rock of chocolate.\"] def return_appearance(self, looker): \"\"\" Called by the look command. We want to return a wisdom when we get looked at. \"\"\" # first get the base string from the # parent's return_appearance. string = super().return_appearance(looker) wisewords = \"\\n\\nIt grumbles and says: '%s'\" wisewords = wisewords % choice(self.db.wise_texts) return string + wisewords ``` Check your code for bugs. Tracebacks will appear on your command line or log. If you have a grave Syntax Error in your code, the source file itself will fail to load which can cause issues with the entire cmdset. If so, fix your bug and reload the server from the command line (noone will be disconnected by doing this). Use @create/drop stone:wiseobject.WiseObject to create a talkative stone. If the @create command spits out a warning or cannot find the typeclass (it will tell you which paths it searched), re-check your code for bugs and that you gave the correct path. The @create command starts looking for Typeclasses in mygame/typeclasses/ . Use look stone to test. You will see the default description (\"You see nothing special\") followed by a random message of stony wisdom. Use @desc stone = This is a wise old stone. to make it look nicer. See the Builder Docs for more information. Note that at_object_creation is only called once, when the stone is first created. If you make changes to this method later, already existing stones will not see those changes. As with the Character example above you can use @typeclass/force to tell the stone to re-run its initialization. The at_object_creation is a special case though. Changing most other aspects of the typeclass does not require manual updating like this - you just need to @reload to have all changes applied automatically to all existing objects.","title":"Make a New Type of Object"},{"location":"First-Steps-Coding.html#where-to-go-from-here","text":"There are more Tutorials , including one for building a whole little MUSH-like game - that is instructive also if you have no interest in MUSHes per se. A good idea is to also get onto the IRC chat and the mailing list to get in touch with the community and other developers.","title":"Where to Go From Here?"},{"location":"Game-Planning.html","text":"So you have Evennia up and running. You have a great game idea in mind. Now it's time to start cracking! But where to start? Here are some ideas for a workflow. Note that the suggestions on this page are just that - suggestions. Also, they are primarily aimed at a lone hobby designer or a small team developing a game in their free time. There is an article in the Imaginary Realities e-zine which was written by the Evennia lead dev. It focuses more on you finding out your motivations for making a game - you can read the article here . Below are some minimal steps for getting the first version of a new game world going with players. It's worth to at least make the attempt to do these steps in order even if you are itching to jump ahead in the development cycle. On the other hand, you should also make sure to keep your work fun for you, or motivation will falter. Making a full game is a lot of work as it is, you'll need all your motivation to make it a reality. Remember that 99.99999% of all great game ideas never lead to a game . Especially not to an online game that people can actually play and enjoy. So our first all overshadowing goal is to beat those odds and get something out the door! Even if it's a scaled-down version of your dream game, lacking many \"must-have\" features! It's better to get it out there and expand on it later than to code in isolation forever until you burn out, lose interest or your hard drive crashes. Like is common with online games, getting a game out the door does not mean you are going to be \"finished\" with the game - most MUDs add features gradually over the course of years - it's often part of the fun! Planning (step 1) \u00b6 This is what you do before having coded a single line or built a single room. Many prospective game developers are very good at parts of this process, namely in defining what their world is \"about\": The theme, the world concept, cool monsters and so on. It is by all means very important to define what is the unique appeal of your game. But it's unfortunately not enough to make your game a reality. To do that you must also have an idea of how to actually map those great ideas onto Evennia. A good start is to begin by planning out the basic primitives of the game and what they need to be able to do. Below are a far-from-complete list of examples (and for your first version you should definitely try for a much shorter list): Systems \u00b6 These are the behind-the-scenes features that exist in your game, often without being represented by a specific in-game object. Should your game rules be enforced by coded systems or are you planning for human game masters to run and arbitrate rules? What are the actual mechanical game rules? How do you decide if an action succeeds or fails? What \"rolls\" does the game need to be able to do? Do you base your game off an existing system or make up your own? Does the flow of time matter in your game - does night and day change? What about seasons? Maybe your magic system is affected by the phase of the moon? Do you want changing, global weather? This might need to operate in tandem over a large number of rooms. Do you want a game-wide economy or just a simple barter system? Or no formal economy at all? Should characters be able to send mail to each other in-game? Should players be able to post on Bulletin boards? What is the staff hierarchy in your game? What powers do you want your staff to have? What should a Builder be able to build and what commands do they need in order to do that? etc. Rooms \u00b6 Consider the most basic room in your game. Is a simple description enough or should the description be able to change (such as with time, by light conditions, weather or season)? Should the room have different statuses? Can it have smells, sounds? Can it be affected by dramatic weather, fire or magical effects? If so, how would this affect things in the room? Or are these things something admins/game masters should handle manually? Can objects be hidden in the room? Can a person hide in the room? How does the room display this? etc. Objects \u00b6 Consider the most basic (non-player-controlled) object in your game. How numerous are your objects? Do you want large loot-lists or are objects just role playing props created on demand? Does the game use money? If so, is each coin a separate object or do you just store a bank account value? What about multiple identical objects? Do they form stacks and how are those stacks handled in that case? Does an object have weight or volume (so you cannot carry an infinite amount of them)? Can objects be broken? If so, does it have a health value? Is burning it causing the same damage as smashing it? Can it be repaired? Is a weapon a specific type of object or are you supposed to be able to fight with a chair too? Can you fight with a flower or piece of paper as well? NPCs/mobs are also objects. Should they just stand around or should they have some sort of AI? Are NPCs/mobs differet entities? How is an Orc different from a Kobold, in code - are they the same object with different names or completely different types of objects, with custom code? Should there be NPCs giving quests? If so, how would you track quest status and what happens when multiple players try to do the same quest? Do you use instances or some other mechanism? etc. Characters \u00b6 These are the objects controlled directly by Players. Can players have more than one Character active at a time or are they allowed to multi-play? How does a Player create their Character? A Character-creation screen? Answering questions? Filling in a form? Do you want to use classes (like \"Thief\", \"Warrior\" etc) or some other system, like Skill-based? How do you implement different \"classes\" or \"races\"? Are they separate types of objects or do you simply load different stats on a basic object depending on what the Player wants? If a Character can hide in a room, what skill will decide if they are detected? What skill allows a Character to wield a weapon and hit? Do they need a special skill to wield a chair rather than a sword? Does a Character need a Strength attribute to tell how much they can carry or which objects they can smash? What does the skill tree look like? Can a Character gain experience to improve? By killing enemies? Solving quests? By roleplaying? etc. A MUD's a lot more involved than you would think and these things hang together in a complex web. It can easily become overwhelming and it's tempting to want all functionality right out of the door. Try to identify the basic things that \"make\" your game and focus only on them for your first release. Make a list. Keep future expansions in mind but limit yourself. Coding (step 2) \u00b6 This is the actual work of creating the \"game\" part of your game. Many \"game-designer\" types tend to gloss over this bit and jump directly to World Building . Vice versa, many \"game-coder\" types tend to jump directly to this part without doing the Planning first. Neither way is good and will lead to you having to redo all your hard work at least once, probably more. Evennia's Developer Central tries to help you with this bit of development. We also have a slew of Tutorials with worked examples. Evennia tries hard to make this part easier for you, but there is no way around the fact that if you want anything but a very basic Talker-type game you will have to bite the bullet and code your game (or find a coder willing to do it for you). Even if you won't code anything yourself, as a designer you need to at least understand the basic paradigms of Evennia, such as Objects , Commands and Scripts and how they hang together. We recommend you go through the Tutorial World in detail (as well as glancing at its code) to get at least a feel for what is involved behind the scenes. You could also look through the tutorial for building a game from scratch . During Coding you look back at the things you wanted during the Planning phase and try to implement them. Don't be shy to update your plans if you find things easier/harder than you thought. The earlier you revise problems, the easier they will be to fix. A good idea is to host your code online (publicly or privately) using version control. Not only will this make it easy for multiple coders to collaborate (and have a bug-tracker etc), it also means your work is backed up at all times. The Version Control tutorial has instructions for setting up a sane developer environment with proper version control. \"Tech Demo\" Building \u00b6 This is an integral part of your Coding. It might seem obvious to experienced coders, but it cannot be emphasized enough that you should test things on a small scale before putting your untested code into a large game-world. The earlier you test, the easier and cheaper it will be to fix bugs and even rework things that didn't work out the way you thought they would. You might even have to go back to the Planning phase if your ideas can't handle their meet with reality. This means building singular in-game examples. Make one room and one object of each important type and test so they work correctly in isolation. Then add more if they are supposed to interact with each other in some way. Build a small series of rooms to test how mobs move around ... and so on. In short, a test-bed for your growing code. It should be done gradually until you have a fully functioning (if not guaranteed bug-free) miniature tech demo that shows all the features you want in the first release of your game. There does not need to be any game play or even a theme to your tests, this is only for you and your co-coders to see. The more testing you do on this small scale, the less headaches you will have in the next phase. World Building (step 3) \u00b6 Up until this point we've only had a few tech-demo objects in the database. This step is the act of populating the database with a larger, thematic world. Too many would-be developers jump to this stage too soon (skipping the Coding or even Planning stages). What if the rooms you build now doesn't include all the nice weather messages the code grows to support? Or the way you store data changes under the hood? Your building work would at best require some rework and at worst you would have to redo the whole thing. And whereas Evennia's typeclass system does allow you to edit the properties of existing objects, some hooks are only called at object creation ... Suffice to say you are in for a lot of unnecessary work if you build stuff en masse without having the underlying code systems in some reasonable shape first. So before starting to build, the \"game\" bit ( Coding + Testing ) should be more or less complete , at least to the level of your initial release . Before starting to build, you should also plan ahead again. Make sure it is clear to yourself and your eventual builders just which parts of the world you want for your initial release. Establish for everyone which style, quality and level of detail you expect. Your goal should not be to complete your entire world in one go. You want just enough to make the game's \"feel\" come across. You want a minimal but functioning world where the intended game play can be tested and roughly balanced. You can always add new areas later. During building you get free and extensive testing of whatever custom build commands and systems you have made at this point. Since Building often involves different people than those Coding, you also get a chance to hear if some things are hard to understand or non-intuitive. Make sure to respond to this feedback. Alpha Release \u00b6 As mentioned, don't hold onto your world more than necessary. Get it out there with a huge Alpha flag and let people try it! Call upon your alpha-players to try everything - they will find ways to break your game in ways that you never could have imagined. In Alpha you might be best off to focus on inviting friends and maybe other MUD developers, people who you can pester to give proper feedback and bug reports (there will be bugs, there is no way around it). Follow the quick instructions for Online Setup to make your game visible online. If you hadn't already, make sure to put up your game on the Evennia game index so people know it's in the works (actually, even pre-alpha games are allowed in the index so don't be shy)! Beta Release/Perpetual Beta \u00b6 Once things stabilize in Alpha you can move to Beta and let more people in. Many MUDs are in perpetual beta , meaning they are never considered \"finished\", but just repeat the cycle of Planning, Coding, Testing and Building over and over as new features get implemented or Players come with suggestions. As the game designer it is now up to you to gradually perfect your vision. Congratulate yourself! \u00b6 You are worthy of a celebration since at this point you have joined the small, exclusive crowd who have made their dream game a reality!","title":"Game Planning"},{"location":"Game-Planning.html#planning-step-1","text":"This is what you do before having coded a single line or built a single room. Many prospective game developers are very good at parts of this process, namely in defining what their world is \"about\": The theme, the world concept, cool monsters and so on. It is by all means very important to define what is the unique appeal of your game. But it's unfortunately not enough to make your game a reality. To do that you must also have an idea of how to actually map those great ideas onto Evennia. A good start is to begin by planning out the basic primitives of the game and what they need to be able to do. Below are a far-from-complete list of examples (and for your first version you should definitely try for a much shorter list):","title":"Planning (step 1)"},{"location":"Game-Planning.html#systems","text":"These are the behind-the-scenes features that exist in your game, often without being represented by a specific in-game object. Should your game rules be enforced by coded systems or are you planning for human game masters to run and arbitrate rules? What are the actual mechanical game rules? How do you decide if an action succeeds or fails? What \"rolls\" does the game need to be able to do? Do you base your game off an existing system or make up your own? Does the flow of time matter in your game - does night and day change? What about seasons? Maybe your magic system is affected by the phase of the moon? Do you want changing, global weather? This might need to operate in tandem over a large number of rooms. Do you want a game-wide economy or just a simple barter system? Or no formal economy at all? Should characters be able to send mail to each other in-game? Should players be able to post on Bulletin boards? What is the staff hierarchy in your game? What powers do you want your staff to have? What should a Builder be able to build and what commands do they need in order to do that? etc.","title":"Systems"},{"location":"Game-Planning.html#rooms","text":"Consider the most basic room in your game. Is a simple description enough or should the description be able to change (such as with time, by light conditions, weather or season)? Should the room have different statuses? Can it have smells, sounds? Can it be affected by dramatic weather, fire or magical effects? If so, how would this affect things in the room? Or are these things something admins/game masters should handle manually? Can objects be hidden in the room? Can a person hide in the room? How does the room display this? etc.","title":"Rooms"},{"location":"Game-Planning.html#objects","text":"Consider the most basic (non-player-controlled) object in your game. How numerous are your objects? Do you want large loot-lists or are objects just role playing props created on demand? Does the game use money? If so, is each coin a separate object or do you just store a bank account value? What about multiple identical objects? Do they form stacks and how are those stacks handled in that case? Does an object have weight or volume (so you cannot carry an infinite amount of them)? Can objects be broken? If so, does it have a health value? Is burning it causing the same damage as smashing it? Can it be repaired? Is a weapon a specific type of object or are you supposed to be able to fight with a chair too? Can you fight with a flower or piece of paper as well? NPCs/mobs are also objects. Should they just stand around or should they have some sort of AI? Are NPCs/mobs differet entities? How is an Orc different from a Kobold, in code - are they the same object with different names or completely different types of objects, with custom code? Should there be NPCs giving quests? If so, how would you track quest status and what happens when multiple players try to do the same quest? Do you use instances or some other mechanism? etc.","title":"Objects"},{"location":"Game-Planning.html#characters","text":"These are the objects controlled directly by Players. Can players have more than one Character active at a time or are they allowed to multi-play? How does a Player create their Character? A Character-creation screen? Answering questions? Filling in a form? Do you want to use classes (like \"Thief\", \"Warrior\" etc) or some other system, like Skill-based? How do you implement different \"classes\" or \"races\"? Are they separate types of objects or do you simply load different stats on a basic object depending on what the Player wants? If a Character can hide in a room, what skill will decide if they are detected? What skill allows a Character to wield a weapon and hit? Do they need a special skill to wield a chair rather than a sword? Does a Character need a Strength attribute to tell how much they can carry or which objects they can smash? What does the skill tree look like? Can a Character gain experience to improve? By killing enemies? Solving quests? By roleplaying? etc. A MUD's a lot more involved than you would think and these things hang together in a complex web. It can easily become overwhelming and it's tempting to want all functionality right out of the door. Try to identify the basic things that \"make\" your game and focus only on them for your first release. Make a list. Keep future expansions in mind but limit yourself.","title":"Characters"},{"location":"Game-Planning.html#coding-step-2","text":"This is the actual work of creating the \"game\" part of your game. Many \"game-designer\" types tend to gloss over this bit and jump directly to World Building . Vice versa, many \"game-coder\" types tend to jump directly to this part without doing the Planning first. Neither way is good and will lead to you having to redo all your hard work at least once, probably more. Evennia's Developer Central tries to help you with this bit of development. We also have a slew of Tutorials with worked examples. Evennia tries hard to make this part easier for you, but there is no way around the fact that if you want anything but a very basic Talker-type game you will have to bite the bullet and code your game (or find a coder willing to do it for you). Even if you won't code anything yourself, as a designer you need to at least understand the basic paradigms of Evennia, such as Objects , Commands and Scripts and how they hang together. We recommend you go through the Tutorial World in detail (as well as glancing at its code) to get at least a feel for what is involved behind the scenes. You could also look through the tutorial for building a game from scratch . During Coding you look back at the things you wanted during the Planning phase and try to implement them. Don't be shy to update your plans if you find things easier/harder than you thought. The earlier you revise problems, the easier they will be to fix. A good idea is to host your code online (publicly or privately) using version control. Not only will this make it easy for multiple coders to collaborate (and have a bug-tracker etc), it also means your work is backed up at all times. The Version Control tutorial has instructions for setting up a sane developer environment with proper version control.","title":"Coding (step 2)"},{"location":"Game-Planning.html#tech-demo-building","text":"This is an integral part of your Coding. It might seem obvious to experienced coders, but it cannot be emphasized enough that you should test things on a small scale before putting your untested code into a large game-world. The earlier you test, the easier and cheaper it will be to fix bugs and even rework things that didn't work out the way you thought they would. You might even have to go back to the Planning phase if your ideas can't handle their meet with reality. This means building singular in-game examples. Make one room and one object of each important type and test so they work correctly in isolation. Then add more if they are supposed to interact with each other in some way. Build a small series of rooms to test how mobs move around ... and so on. In short, a test-bed for your growing code. It should be done gradually until you have a fully functioning (if not guaranteed bug-free) miniature tech demo that shows all the features you want in the first release of your game. There does not need to be any game play or even a theme to your tests, this is only for you and your co-coders to see. The more testing you do on this small scale, the less headaches you will have in the next phase.","title":"\"Tech Demo\" Building"},{"location":"Game-Planning.html#world-building-step-3","text":"Up until this point we've only had a few tech-demo objects in the database. This step is the act of populating the database with a larger, thematic world. Too many would-be developers jump to this stage too soon (skipping the Coding or even Planning stages). What if the rooms you build now doesn't include all the nice weather messages the code grows to support? Or the way you store data changes under the hood? Your building work would at best require some rework and at worst you would have to redo the whole thing. And whereas Evennia's typeclass system does allow you to edit the properties of existing objects, some hooks are only called at object creation ... Suffice to say you are in for a lot of unnecessary work if you build stuff en masse without having the underlying code systems in some reasonable shape first. So before starting to build, the \"game\" bit ( Coding + Testing ) should be more or less complete , at least to the level of your initial release . Before starting to build, you should also plan ahead again. Make sure it is clear to yourself and your eventual builders just which parts of the world you want for your initial release. Establish for everyone which style, quality and level of detail you expect. Your goal should not be to complete your entire world in one go. You want just enough to make the game's \"feel\" come across. You want a minimal but functioning world where the intended game play can be tested and roughly balanced. You can always add new areas later. During building you get free and extensive testing of whatever custom build commands and systems you have made at this point. Since Building often involves different people than those Coding, you also get a chance to hear if some things are hard to understand or non-intuitive. Make sure to respond to this feedback.","title":"World Building (step 3)"},{"location":"Game-Planning.html#alpha-release","text":"As mentioned, don't hold onto your world more than necessary. Get it out there with a huge Alpha flag and let people try it! Call upon your alpha-players to try everything - they will find ways to break your game in ways that you never could have imagined. In Alpha you might be best off to focus on inviting friends and maybe other MUD developers, people who you can pester to give proper feedback and bug reports (there will be bugs, there is no way around it). Follow the quick instructions for Online Setup to make your game visible online. If you hadn't already, make sure to put up your game on the Evennia game index so people know it's in the works (actually, even pre-alpha games are allowed in the index so don't be shy)!","title":"Alpha Release"},{"location":"Game-Planning.html#beta-releaseperpetual-beta","text":"Once things stabilize in Alpha you can move to Beta and let more people in. Many MUDs are in perpetual beta , meaning they are never considered \"finished\", but just repeat the cycle of Planning, Coding, Testing and Building over and over as new features get implemented or Players come with suggestions. As the game designer it is now up to you to gradually perfect your vision.","title":"Beta Release/Perpetual Beta"},{"location":"Game-Planning.html#congratulate-yourself","text":"You are worthy of a celebration since at this point you have joined the small, exclusive crowd who have made their dream game a reality!","title":"Congratulate yourself!"},{"location":"Gametime-Tutorial.html","text":"A lot of games use a separate time system we refer to as game time . This runs in parallel to what we usually think of as real time . The game time might run at a different speed, use different names for its time units or might even use a completely custom calendar. You don't need to rely on a game time system at all. But if you do, Evennia offers basic tools to handle these various situations. This tutorial will walk you through these features. A game time with a standard calendar \u00b6 Many games let their in-game time run faster or slower than real time, but still use our normal real-world calendar. This is common both for games set in present day as well as for games in historical or futuristic settings. Using a standard calendar has some advantages: Handling repetitive actions is much easier, since converting from the real time experience to the in-game perceived one is easy. The intricacies of the real world calendar, with leap years and months of different length etc are automatically handled by the system. Evennia's game time features assume a standard calendar (see the relevant section below for a custom calendar). Setting up game time for a standard calendar \u00b6 All is done through the settings. Here are the settings you should use if you want a game time with a standard calendar: # The time factor dictates if the game world runs faster (timefactor>1) # or slower (timefactor<1) than the real world. TIME_FACTOR = 2.0 # The starting point of your game time (the epoch), in seconds. # In Python a value of 0 means Jan 1 1970 (use negatives for earlier # start date). This will affect the returns from the utils.gametime # module. TIME_GAME_EPOCH = None By default, the game time runs twice as fast as the real time. You can set the time factor to be 1 (the game time would run exactly at the same speed than the real time) or lower (the game time will be slower than the real time). Most games choose to have the game time spinning faster (you will find some games that have a time factor of 60, meaning the game time runs sixty times as fast as the real time, a minute in real time would be an hour in game time). The epoch is a slightly more complex setting. It should contain a number of seconds that would indicate the time your game started. As indicated, an epoch of 0 would mean January 1st, 1970. If you want to set your time in the future, you just need to find the starting point in seconds. There are several ways to do this in Python, this method will show you how to do it in local time: # We're looking for the number of seconds representing # January 1st, 2020 from datetime import datetime import time start = datetime(2020, 1, 1) time.mktime(start.timetuple()) This should return a huge number - the number of seconds since Jan 1 1970. Copy that directly into your settings (editing server/conf/settings.py ): TIME_GAME_EPOCH = 1577865600 Reload the game with @reload , and then use the @time command. You should see something like this: +----------------------------+-------------------------------------+ | Server time | | +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ | Current uptime | 20 seconds | | Total runtime | 1 day, 1 hour, 55 minutes | | First start | 2017-02-12 15:47:50.565000 | | Current time | 2017-02-13 17:43:10.760000 | +----------------------------+-------------------------------------+ | In-Game time | Real time x 2 | +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ | Epoch (from settings) | 2020-01-01 00:00:00 | | Total time passed: | 1 day, 17 hours, 34 minutes | | Current time | 2020-01-02 17:34:55.430000 | +----------------------------+-------------------------------------+ The line that is most relevant here is the game time epoch. You see it shown at 2020-01-01. From this point forward, the game time keeps increasing. If you keep typing @time , you'll see the game time updated correctly... and going (by default) twice as fast as the real time. Time-related events \u00b6 The gametime utility also has a way to schedule game-related events, taking into account your game time, and assuming a standard calendar (see below for the same feature with a custom calendar). For instance, it can be used to have a specific message every (in-game) day at 6:00 AM showing how the sun rises. The function schedule() should be used here. It will create a script with some additional features to make sure the script is always executed when the game time matches the given parameters. The schedule function takes the following arguments: The callback , a function to be called when time is up. The keyword repeat ( False by default) to indicate whether this function should be called repeatedly. Additional keyword arguments sec , min , hour , day , month and year to describe the time to schedule. If the parameter isn't given, it assumes the current time value of this specific unit. Here is a short example for making the sun rise every day: # in a file ingame_time.py in mygame/world/ from evennia.utils import gametime from typeclasses.rooms import Room def at_sunrise(): \"\"\"When the sun rises, display a message in every room.\"\"\" # Browse all rooms for room in Room.objects.all(): room.msg_contents(\"The sun rises from the eastern horizon.\") def start_sunrise_event(): \"\"\"Schedule an sunrise event to happen every day at 6 AM.\"\"\" script = gametime.schedule(at_sunrise, repeat=True, hour=6, min=0, sec=0) script.key = \"at sunrise\" If you want to test this function, you can easily do something like: @py from world import ingame_time; ingame_time.start_sunrise_event() The script will be created silently. The at_sunrise function will now be called every in-game day at 6 AM. You can use the @scripts command to see it. You could stop it using @scripts/stop . If we hadn't set repeat the sun would only have risen once and then never again. We used the @py command here: nothing prevents you from adding the system into your game code. Remember to be careful not to add each event at startup, however, otherwise there will be a lot of overlapping events scheduled when the sun rises. The schedule function when using repeat set to True works with the higher, non-specified unit. In our example, we have specified hour, minute and second. The higher unit we haven't specified is day: schedule assumes we mean \"run the callback every day at the specified time\". Therefore, you can have an event that runs every hour at HH:30, or every month on the 3rd day. A word of caution for repeated scripts on a monthly or yearly basis: due to the variations in the real-life calendar you need to be careful when scheduling events for the end of the month or year. For example, if you set a script to run every month on the 31st it will run in January but find no such day in February, April etc. Similarly, leap years may change the number of days in the year. A game time with a custom calendar \u00b6 Using a custom calendar to handle game time is sometimes needed if you want to place your game in a fictional universe. For instance you may want to create the Shire calendar which Tolkien described having 12 months, each which 30 days. That would give only 360 days per year (presumably hobbits weren't really fond of the hassle of following the astronomical calendar). Another example would be creating a planet in a different solar system with, say, days 29 hours long and months of only 18 days. Evennia handles custom calendars through an optional contrib module, called custom_gametime . Contrary to the normal gametime module described above it is not active by default. Setting up the custom calendar \u00b6 In our first example of the Shire calendar, used by hobbits in books by Tolkien, we don't really need the notion of weeks... but we need the notion of months having 30 days, not 28. The custom calendar is defined by adding the TIME_UNITS setting to your settings file. It's a dictionary containing as keys the name of the units, and as value the number of seconds (the smallest unit for us) in this unit. Its keys must be picked among the following: \"sec\", \"min\", \"hour\", \"day\", \"week\", \"month\" and \"year\" but you don't have to include them all. Here is the configuration for the Shire calendar: TIME_UNITS = {\"sec\": 1, \"min\": 60, \"hour\": 60 * 60, \"day\": 60 * 60 * 24, \"month\": 60 * 60 * 24 * 30, \"year\": 60 * 60 * 24 * 30 * 12 } We give each unit we want as keys. Values represent the number of seconds in that unit. Hour is set to 60 * 60 (that is, 3600 seconds per hour). Notice that we don't specify the week unit in this configuration: instead, we skip from days to months directly. In order for this setting to work properly, remember all units have to be multiples of the previous units. If you create \"day\", it needs to be multiple of hours, for instance. So for our example, our settings may look like this: # Time factor TIME_FACTOR = 4 # Game time epoch TIME_GAME_EPOCH = 0 # Units TIME_UNITS = { \"sec\": 1, \"min\": 60, \"hour\": 60 * 60, \"day\": 60 * 60 * 24, \"month\": 60 * 60 * 24 * 30, \"year\": 60 * 60 * 24 * 30 * 12, } Notice we have set a time epoch of 0. Using a custom calendar, we will come up with a nice display of time on our own. In our case the game time starts at year 0, month 0, day 0, and at midnight. Note that while we use \"month\", \"week\" etc in the settings, your game may not use those terms in-game, instead referring to them as \"cycles\", \"moons\", \"sand falls\" etc. This is just a matter of you displaying them differently. See next section. A command to display the current game time \u00b6 As pointed out earlier, the @time command is meant to be used with a standard calendar, not a custom one. We can easily create a new command though. We'll call it time , as is often the case on other MU*. Here's an example of how we could write it (for the example, you can create a file showtime.py in your commands directory and paste this code in it): # in a file mygame/commands/gametime.py from evennia.contrib import custom_gametime from commands.command import Command class CmdTime(Command): \"\"\" Display the time. Syntax: time \"\"\" key = \"time\" locks = \"cmd:all()\" def func(self): \"\"\"Execute the time command.\"\"\" # Get the absolute game time year, month, day, hour, min, sec = custom_gametime.custom_gametime(absolute=True) string = \"We are in year {year}, day {day}, month {month}.\" string += \"\\nIt's {hour:02}:{min:02}:{sec:02}.\" self.msg(string.format(year=year, month=month, day=day, hour=hour, min=min, sec=sec)) Don't forget to add it in your CharacterCmdSet to see this command: from commands.gametime import CmdTime class CharacterCmdSet(default_cmds.CharacterCmdSet): \"\"\" The `CharacterCmdSet` contains general in-game commands like `look`, `get`, etc available on in-game Character objects. It is merged with the `AccountCmdSet` when an Account puppets a Character. \"\"\" key = \"DefaultCharacter\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() self.add(CmdTime()) Reload your game with the @reload command. You should now see the time command. If you enter it, you might see something like: We are in year 0, day 0, month 0. It's 00:52:17. You could display it a bit more prettily with names for months and perhaps even days, if you want. And if \"months\" are called \"moons\" in your game, this is where you'd add that. Time-related events \u00b6 The custom_gametime module also has a way to schedule game-related events, taking into account your game time (and your custom calendar). It can be used to have a specific message every day at 6:00 AM, to show the sun rises, for instance. The custom_gametime.schedule function works in the same way as described for the default one above.","title":"Gametime Tutorial"},{"location":"Gametime-Tutorial.html#a-game-time-with-a-standard-calendar","text":"Many games let their in-game time run faster or slower than real time, but still use our normal real-world calendar. This is common both for games set in present day as well as for games in historical or futuristic settings. Using a standard calendar has some advantages: Handling repetitive actions is much easier, since converting from the real time experience to the in-game perceived one is easy. The intricacies of the real world calendar, with leap years and months of different length etc are automatically handled by the system. Evennia's game time features assume a standard calendar (see the relevant section below for a custom calendar).","title":"A game time with a standard calendar"},{"location":"Gametime-Tutorial.html#setting-up-game-time-for-a-standard-calendar","text":"All is done through the settings. Here are the settings you should use if you want a game time with a standard calendar: # The time factor dictates if the game world runs faster (timefactor>1) # or slower (timefactor<1) than the real world. TIME_FACTOR = 2.0 # The starting point of your game time (the epoch), in seconds. # In Python a value of 0 means Jan 1 1970 (use negatives for earlier # start date). This will affect the returns from the utils.gametime # module. TIME_GAME_EPOCH = None By default, the game time runs twice as fast as the real time. You can set the time factor to be 1 (the game time would run exactly at the same speed than the real time) or lower (the game time will be slower than the real time). Most games choose to have the game time spinning faster (you will find some games that have a time factor of 60, meaning the game time runs sixty times as fast as the real time, a minute in real time would be an hour in game time). The epoch is a slightly more complex setting. It should contain a number of seconds that would indicate the time your game started. As indicated, an epoch of 0 would mean January 1st, 1970. If you want to set your time in the future, you just need to find the starting point in seconds. There are several ways to do this in Python, this method will show you how to do it in local time: # We're looking for the number of seconds representing # January 1st, 2020 from datetime import datetime import time start = datetime(2020, 1, 1) time.mktime(start.timetuple()) This should return a huge number - the number of seconds since Jan 1 1970. Copy that directly into your settings (editing server/conf/settings.py ): TIME_GAME_EPOCH = 1577865600 Reload the game with @reload , and then use the @time command. You should see something like this: +----------------------------+-------------------------------------+ | Server time | | +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ | Current uptime | 20 seconds | | Total runtime | 1 day, 1 hour, 55 minutes | | First start | 2017-02-12 15:47:50.565000 | | Current time | 2017-02-13 17:43:10.760000 | +----------------------------+-------------------------------------+ | In-Game time | Real time x 2 | +~~~~~~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ | Epoch (from settings) | 2020-01-01 00:00:00 | | Total time passed: | 1 day, 17 hours, 34 minutes | | Current time | 2020-01-02 17:34:55.430000 | +----------------------------+-------------------------------------+ The line that is most relevant here is the game time epoch. You see it shown at 2020-01-01. From this point forward, the game time keeps increasing. If you keep typing @time , you'll see the game time updated correctly... and going (by default) twice as fast as the real time.","title":"Setting up game time for a standard calendar"},{"location":"Gametime-Tutorial.html#time-related-events","text":"The gametime utility also has a way to schedule game-related events, taking into account your game time, and assuming a standard calendar (see below for the same feature with a custom calendar). For instance, it can be used to have a specific message every (in-game) day at 6:00 AM showing how the sun rises. The function schedule() should be used here. It will create a script with some additional features to make sure the script is always executed when the game time matches the given parameters. The schedule function takes the following arguments: The callback , a function to be called when time is up. The keyword repeat ( False by default) to indicate whether this function should be called repeatedly. Additional keyword arguments sec , min , hour , day , month and year to describe the time to schedule. If the parameter isn't given, it assumes the current time value of this specific unit. Here is a short example for making the sun rise every day: # in a file ingame_time.py in mygame/world/ from evennia.utils import gametime from typeclasses.rooms import Room def at_sunrise(): \"\"\"When the sun rises, display a message in every room.\"\"\" # Browse all rooms for room in Room.objects.all(): room.msg_contents(\"The sun rises from the eastern horizon.\") def start_sunrise_event(): \"\"\"Schedule an sunrise event to happen every day at 6 AM.\"\"\" script = gametime.schedule(at_sunrise, repeat=True, hour=6, min=0, sec=0) script.key = \"at sunrise\" If you want to test this function, you can easily do something like: @py from world import ingame_time; ingame_time.start_sunrise_event() The script will be created silently. The at_sunrise function will now be called every in-game day at 6 AM. You can use the @scripts command to see it. You could stop it using @scripts/stop . If we hadn't set repeat the sun would only have risen once and then never again. We used the @py command here: nothing prevents you from adding the system into your game code. Remember to be careful not to add each event at startup, however, otherwise there will be a lot of overlapping events scheduled when the sun rises. The schedule function when using repeat set to True works with the higher, non-specified unit. In our example, we have specified hour, minute and second. The higher unit we haven't specified is day: schedule assumes we mean \"run the callback every day at the specified time\". Therefore, you can have an event that runs every hour at HH:30, or every month on the 3rd day. A word of caution for repeated scripts on a monthly or yearly basis: due to the variations in the real-life calendar you need to be careful when scheduling events for the end of the month or year. For example, if you set a script to run every month on the 31st it will run in January but find no such day in February, April etc. Similarly, leap years may change the number of days in the year.","title":"Time-related events"},{"location":"Gametime-Tutorial.html#a-game-time-with-a-custom-calendar","text":"Using a custom calendar to handle game time is sometimes needed if you want to place your game in a fictional universe. For instance you may want to create the Shire calendar which Tolkien described having 12 months, each which 30 days. That would give only 360 days per year (presumably hobbits weren't really fond of the hassle of following the astronomical calendar). Another example would be creating a planet in a different solar system with, say, days 29 hours long and months of only 18 days. Evennia handles custom calendars through an optional contrib module, called custom_gametime . Contrary to the normal gametime module described above it is not active by default.","title":"A game time with a custom calendar"},{"location":"Gametime-Tutorial.html#setting-up-the-custom-calendar","text":"In our first example of the Shire calendar, used by hobbits in books by Tolkien, we don't really need the notion of weeks... but we need the notion of months having 30 days, not 28. The custom calendar is defined by adding the TIME_UNITS setting to your settings file. It's a dictionary containing as keys the name of the units, and as value the number of seconds (the smallest unit for us) in this unit. Its keys must be picked among the following: \"sec\", \"min\", \"hour\", \"day\", \"week\", \"month\" and \"year\" but you don't have to include them all. Here is the configuration for the Shire calendar: TIME_UNITS = {\"sec\": 1, \"min\": 60, \"hour\": 60 * 60, \"day\": 60 * 60 * 24, \"month\": 60 * 60 * 24 * 30, \"year\": 60 * 60 * 24 * 30 * 12 } We give each unit we want as keys. Values represent the number of seconds in that unit. Hour is set to 60 * 60 (that is, 3600 seconds per hour). Notice that we don't specify the week unit in this configuration: instead, we skip from days to months directly. In order for this setting to work properly, remember all units have to be multiples of the previous units. If you create \"day\", it needs to be multiple of hours, for instance. So for our example, our settings may look like this: # Time factor TIME_FACTOR = 4 # Game time epoch TIME_GAME_EPOCH = 0 # Units TIME_UNITS = { \"sec\": 1, \"min\": 60, \"hour\": 60 * 60, \"day\": 60 * 60 * 24, \"month\": 60 * 60 * 24 * 30, \"year\": 60 * 60 * 24 * 30 * 12, } Notice we have set a time epoch of 0. Using a custom calendar, we will come up with a nice display of time on our own. In our case the game time starts at year 0, month 0, day 0, and at midnight. Note that while we use \"month\", \"week\" etc in the settings, your game may not use those terms in-game, instead referring to them as \"cycles\", \"moons\", \"sand falls\" etc. This is just a matter of you displaying them differently. See next section.","title":"Setting up the custom calendar"},{"location":"Gametime-Tutorial.html#a-command-to-display-the-current-game-time","text":"As pointed out earlier, the @time command is meant to be used with a standard calendar, not a custom one. We can easily create a new command though. We'll call it time , as is often the case on other MU*. Here's an example of how we could write it (for the example, you can create a file showtime.py in your commands directory and paste this code in it): # in a file mygame/commands/gametime.py from evennia.contrib import custom_gametime from commands.command import Command class CmdTime(Command): \"\"\" Display the time. Syntax: time \"\"\" key = \"time\" locks = \"cmd:all()\" def func(self): \"\"\"Execute the time command.\"\"\" # Get the absolute game time year, month, day, hour, min, sec = custom_gametime.custom_gametime(absolute=True) string = \"We are in year {year}, day {day}, month {month}.\" string += \"\\nIt's {hour:02}:{min:02}:{sec:02}.\" self.msg(string.format(year=year, month=month, day=day, hour=hour, min=min, sec=sec)) Don't forget to add it in your CharacterCmdSet to see this command: from commands.gametime import CmdTime class CharacterCmdSet(default_cmds.CharacterCmdSet): \"\"\" The `CharacterCmdSet` contains general in-game commands like `look`, `get`, etc available on in-game Character objects. It is merged with the `AccountCmdSet` when an Account puppets a Character. \"\"\" key = \"DefaultCharacter\" def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() self.add(CmdTime()) Reload your game with the @reload command. You should now see the time command. If you enter it, you might see something like: We are in year 0, day 0, month 0. It's 00:52:17. You could display it a bit more prettily with names for months and perhaps even days, if you want. And if \"months\" are called \"moons\" in your game, this is where you'd add that.","title":"A command to display the current game time"},{"location":"Gametime-Tutorial.html#time-related-events_1","text":"The custom_gametime module also has a way to schedule game-related events, taking into account your game time (and your custom calendar). It can be used to have a specific message every day at 6:00 AM, to show the sun rises, for instance. The custom_gametime.schedule function works in the same way as described for the default one above.","title":"Time-related events"},{"location":"Getting-Started.html","text":"This will help you download, install and start Evennia for the first time. Note: You don't need to make anything visible to the 'net in order to run and test out Evennia. Apart from downloading and updating you don't even need an internet connection until you feel ready to share your game with the world. Quick Start Requirements Linux Install Mac Install Windows Install Running in Docker Where to Go Next Troubleshooting Glossary of terms Quick Start \u00b6 For the impatient. If you have trouble with a step, you should jump on to the more detailed instructions for your platform. Install Python, GIT and python-virtualenv. Start a Console/Terminal. cd to some place you want to do your development (like a folder /home/anna/muddev/ on Linux or a folder in your personal user directory on Windows). git clone https://github.com/evennia/evennia.git virtualenv evenv source evenv/bin/activate (Linux, Mac), evenv\\Scripts\\activate (Windows) pip install -e evennia evennia --init mygame cd mygame evennia migrate evennia start (make sure to make a superuser when asked) Evennia should now be running and you can connect to it by pointing a web browser to http://localhost:4001 or a MUD telnet client to localhost:4000 (use 127.0.0.1 if your OS does not recognize localhost ). We also release Docker images based on master and develop branches. Requirements \u00b6 Any system that supports latest Python3.7+ should work. We'll describe how to install everything in the following sections. - Linux/Unix - Windows (Vista, Win7, Win8, Win10) - Mac OSX (>=10.5 recommended) Python (v3.7+) virtualenv for making isolated Python environments. Installed with pip install virtualenv . GIT - version control software for getting and updating Evennia itself - Mac users can use the git-osx-installer or the MacPorts version . Twisted (v19.0+) ZopeInterface (v3.0+) - usually included in Twisted packages Linux/Mac users may need the gcc and python-dev packages or equivalent. Windows users need MS Visual C++ and maybe pypiwin32 . Django (v2.2), be warned that latest dev version is usually untested with Evennia) Linux Install \u00b6 If you run into any issues during the installation and first start, please check out Linux Troubleshooting . Also, one of our devs made a Linux install video , check it out! For Debian-derived systems (like Ubuntu, Mint etc), start a terminal and install the dependencies : sudo apt-get update sudo apt-get install python3 python3-pip python3-dev python3-setuptools python3-git python3-virtualenv gcc # If you are using an Ubuntu version that defaults to Python3, like 18.04+, use this instead: sudo apt-get update sudo apt-get install python3.7 python3-pip python3.7-dev python3-setuptools virtualenv gcc You should make sure to not be root after this step, running as root is a security risk. Now create a folder where you want to do all your Evennia development: mkdir muddev cd muddev Next we fetch Evennia itself: git clone https://github.com/evennia/evennia.git A new folder evennia will appear containing the Evennia library. This only contains the source code though, it is not installed yet. To isolate the Evennia install and its dependencies from the rest of the system, it is good Python practice to install into a virtualenv . If you are unsure about what a virtualenv is and why it's useful, see the Glossary entry on virtualenv . Run python -V to see which version of Python your system defaults to. # If your Linux defaults to Python3: virtualenv evenv # If your Linux defaults to Python2 or an older version of Python3, you must instead point to Python3.7+ explicitly: virtualenv -p /usr/bin/python3.7 evenv A new folder evenv will appear (we could have called it anything). This folder will hold a self-contained setup of Python packages without interfering with default Python packages on your system (or the Linux distro lagging behind on Python package versions). It will also always use the right version of Python. Activate the virtualenv: source evenv/bin/activate The text (evenv) should appear next to your prompt to show that the virtual environment is active. Remember that you need to activate the virtualenv like this every time you start a new terminal to get access to the Python packages (notably the important evennia program) we are about to install. Next, install Evennia into your active virtualenv. Make sure you are standing at the top of your mud directory tree (so you see the evennia/ and evenv/ folders) and run pip install -e evennia For more info about pip , see the Glossary entry on pip . If install failed with any issues, see Linux Troubleshooting . Next we'll start our new game, here called \"mygame\". This will create yet another new folder where you will be creating your new game: evennia --init mygame Your final folder structure should look like this: ./muddev evenv/ evennia/ mygame/ You can configure Evennia extensively, for example to use a different database . For now we'll just stick to the defaults though. cd mygame evennia migrate # (this creates the database) evennia start # (create a superuser when asked. Email is optional.) Server logs are found in mygame/server/logs/ . To easily view server logs live in the terminal, use evennia -l (exit the log-view with Ctrl-C). Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created. Check out where to go next . Mac Install \u00b6 The Evennia server is a terminal program. Open the terminal e.g. from Applications->Utilities->Terminal . Here is an introduction to the Mac terminal if you are unsure how it works. If you run into any issues during the installation, please check out Mac Troubleshooting . Python should already be installed but you must make sure it's a high enough version. ( This discusses how you may upgrade it). Remember that you need Python3.7, not Python2.7! GIT can be obtained with git-osx-installer or via MacPorts as described here . If you run into issues with installing Twisted later you may need to install gcc and the Python headers. After this point you should not need sudo or any higher privileges to install anything. Now create a folder where you want to do all your Evennia development: mkdir muddev cd muddev Next we fetch Evennia itself: git clone https://github.com/evennia/evennia.git A new folder evennia will appear containing the Evennia library. This only contains the source code though, it is not installed yet. To isolate the Evennia install and its dependencies from the rest of the system, it is good Python practice to install into a virtualenv . If you are unsure about what a virtualenv is and why it's useful, see the Glossary entry on virtualenv . Run python -V to check which Python your system defaults to. # If your Mac defaults to Python3: virtualenv evenv # If your Mac defaults to Python2 you need to specify the Python3.7 binary explicitly: virtualenv -p /path/to/your/python3.7 evenv A new folder evenv will appear (we could have called it anything). This folder will hold a self-contained setup of Python packages without interfering with default Python packages on your system. Activate the virtualenv: source evenv/bin/activate The text (evenv) should appear next to your prompt to show the virtual environment is active. Remember that you need to activate the virtualenv like this every time you start a new terminal to get access to the Python packages (notably the important evennia program) we are about to install. Next, install Evennia into your active virtualenv. Make sure you are standing at the top of your mud directory tree (so you see the evennia/ and evenv/ folders) and run pip install --upgrade pip # Old pip versions may be an issue on Mac. pip install --upgrade setuptools # Ditto concerning Mac issues. pip install -e evennia For more info about pip , see the Glossary entry on pip . If install failed with any issues, see Mac Troubleshooting . Next we'll start our new game. We'll call it \"mygame\" here. This creates a new folder where you will be creating your new game: evennia --init mygame Your final folder structure should look like this: ./muddev evenv/ evennia/ mygame/ You can configure Evennia extensively, for example to use a different database . We'll go with the defaults here. cd mygame evennia migrate # (this creates the database) evennia start # (create a superuser when asked. Email is optional.) Server logs are found in mygame/server/logs/ . To easily view server logs live in the terminal, use evennia -l (exit the log-view with Ctrl-C). Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created. Check out where to go next . Windows Install \u00b6 If you run into any issues during the installation, please check out Windows Troubleshooting . If you are running Windows10, consider using the Windows Subsystem for Linux ( WSL ) instead. You should then follow the Linux install instructions above. The Evennia server itself is a command line program. In the Windows launch menu, start All Programs -> Accessories -> command prompt and you will get the Windows command line interface. Here is one of many tutorials on using the Windows command line if you are unfamiliar with it. Install Python from the Python homepage . You will need to be a Windows Administrator to install packages. You want Python version 3.7.0 (latest verified version), usually the 64-bit version (although it doesn't matter too much). When installing, make sure to check-mark all install options, especially the one about making Python available on the path (you may have to scroll to see it) . This allows you to just write python in any console without first finding where the python program actually sits on your hard drive. You need to also get GIT and install it. You can use the default install options but when you get asked to \"Adjust your PATH environment\", you should select the second option \"Use Git from the Windows Command Prompt\", which gives you more freedom as to where you can use the program. Finally you must install the Microsoft Visual C++ compiler for Python . Download and run the linked installer and install the C++ tools. Keep all the defaults. Allow the install of the \"Win10 SDK\", even if you are on Win7 (not tested on older Windows versions). If you later have issues with installing Evennia due to a failure to build the \"Twisted wheels\", this is where you are missing things. You may need the pypiwin32 Python headers. Install these only if you have issues. You can install Evennia wherever you want. cd to that location and create a new folder for all your Evennia development (let's call it muddev ). mkdir muddev cd muddev Hint: If cd isn't working you can use pushd instead to force the directory change. Next we fetch Evennia itself: git clone https://github.com/evennia/evennia.git A new folder evennia will appear containing the Evennia library. This only contains the source code though, it is not installed yet. To isolate the Evennia install and its dependencies from the rest of the system, it is good Python practice to install into a virtualenv . If you are unsure about what a virtualenv is and why it's useful, see the Glossary entry on virtualenv . In your console, try python -V to see which version of Python your system defaults to. pip install virtualenv # If your setup defaults to Python3.7: virtualenv evenv # If your setup defaults to Python2, specify path to python3.exe explicitly: virtualenv -p C:\\Python37\\python.exe evenv # If you get an infinite spooling response, press CTRL + C to interrupt and try using: python -m venv evenv A new folder evenv will appear (we could have called it anything). This folder will hold a self-contained setup of Python packages without interfering with default Python packages on your system. Activate the virtualenv: # If you are using a standard command prompt, you can use the following: evenv\\scripts\\activate.bat # If you are using a PS Shell, Git Bash, or other, you can use the following: .\\evenv\\scripts\\activate The text (evenv) should appear next to your prompt to show the virtual environment is active. Remember that you need to activate the virtualenv like this every time you start a new console window if you want to get access to the Python packages (notably the important evennia program) we are about to install. Next, install Evennia into your active virtualenv. Make sure you are standing at the top of your mud directory tree (so you see the evennia and evenv folders when you use the dir command) and run pip install -e evennia For more info about pip , see the Glossary entry on pip . If the install failed with any issues, see Windows Troubleshooting . Next we'll start our new game, we'll call it \"mygame\" here. This creates a new folder where you will be creating your new game: evennia --init mygame Your final folder structure should look like this: path\\to\\muddev evenv\\ evennia\\ mygame\\ You can configure Evennia extensively, for example to use a different database . We'll go with the defaults here. cd mygame evennia migrate # (this creates the database) evennia start # (create a superuser when asked. Email is optional.) Server logs are found in mygame/server/logs/ . To easily view server logs live in the terminal, use evennia -l (exit the log-view with Ctrl-C). Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created. Check out where to go next . Where to Go Next \u00b6 Welcome to Evennia! Your new game is fully functioning, but empty. If you just logged in, stand in the Limbo room and run @batchcommand tutorial_world.build to build Evennia's tutorial world - it's a small solo quest to explore. Only run the instructed @batchcommand once. You'll get a lot of text scrolling by as the tutorial is built. Once done, the tutorial exit will have appeared out of Limbo - just write tutorial to enter it. Once you get back to Limbo from the tutorial (if you get stuck in the tutorial quest you can do @tel #2 to jump to Limbo), a good idea is to learn how to start, stop and reload the Evennia server. You may also want to familiarize yourself with some commonly used terms in our Glossary . After that, why not experiment with creating some new items and build some new rooms out from Limbo. From here on, you could move on to do one of our introductory tutorials or simply dive headlong into Evennia's comprehensive manual . While Evennia has no major game systems out of the box, we do supply a range of optional contribs that you can use or borrow from. They range from dice rolling and alternative color schemes to barter and combat systems. You can find the growing list of contribs here . If you have any questions, you can always ask in the developer chat #evennia on irc.freenode.net or by posting to the Evennia forums . You can also join the Discord Server . Finally, if you are itching to help out or support Evennia (awesome!) have an issue to report or a feature to request, see here . Enjoy your stay! Troubleshooting \u00b6 If you have issues with installing or starting Evennia for the first time, check the section for your operating system below. If you have an issue not covered here, please report it so it can be fixed or a workaround found! Remember, the server logs are in mygame/server/logs/ . To easily view server logs in the terminal, you can run evennia -l , or (in the future) start the server with evennia start -l . Linux Troubleshooting \u00b6 If you get an error when installing Evennia (especially with lines mentioning failing to include Python.h ) then try sudo apt-get install python3-setuptools python3-dev . Once installed, run pip install -e evennia again. Under some not-updated Linux distributions you may run into errors with a too-old setuptools or missing functools . If so, update your environment with pip install --upgrade pip wheel setuptools . Then try pip install -e evennia again. One user reported a rare issue on Ubuntu 16 is an install error on installing Twisted; Command \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-vnIFTg/twisted/ with errors like distutils.errors.DistutilsError: Could not find suitable distribution for Requirement.parse('incremental>=16.10.1') . This appears possible to solve by simply updating Ubuntu with sudo apt-get update && sudo apt-get dist-upgrade . Users of Fedora (notably Fedora 24) has reported a gcc error saying the directory /usr/lib/rpm/redhat/redhat-hardened-cc1 is missing, despite gcc itself being installed. The confirmed work-around seems to be to install the redhat-rpm-config package with e.g. sudo dnf install redhat-rpm-config . Some users trying to set up a virtualenv on an NTFS filesystem find that it fails due to issues with symlinks not being supported. Answer is to not use NTFS (seriously, why would you do that to yourself?) Mac Troubleshooting \u00b6 Mac users have reported a critical MemoryError when trying to start Evennia on Mac with a Python version below 2.7.12 . If you get this error, update to the latest XCode and Python2 version. Some Mac users have reported not being able to connect to localhost (i.e. your own computer). If so, try to connect to 127.0.0.1 instead, which is the same thing. Use port 4000 from mud clients and port 4001 from the web browser as usual. Windows Troubleshooting \u00b6 If you installed Python but the python command is not available (even in a new console), then you might have missed installing Python on the path. In the Windows Python installer you get a list of options for what to install. Most or all options are pre-checked except this one, and you may even have to scroll down to see it. Reinstall Python and make sure it's checked. If your MUD client cannot connect to localhost:4000 , try the equivalent 127.0.0.1:4000 instead. Some MUD clients on Windows does not appear to understand the alias localhost . If you run virtualenv evenv and get a 'virtualenv' is not recognized as an internal or external command, operable program or batch file. error, you can mkdir evenv , cd evenv and then python -m virtualenv . as a workaround. Some Windows users get an error installing the Twisted 'wheel'. A wheel is a pre-compiled binary package for Python. A common reason for this error is that you are using a 32-bit version of Python, but Twisted has not yet uploaded the latest 32-bit wheel. Easiest way to fix this is to install a slightly older Twisted version. So if, say, version 18.1 failed, install 18.0 manually with pip install twisted==18.0 . Alternatively you could try to get a 64-bit version of Python (uninstall the 32bit one). If so, you must then deactivate the virtualenv, delete the evenv folder and recreate it anew (it will then use the new Python executable). If your server won't start, with no error messages (and no log files at all when starting from scratch), try to start with evennia ipstart instead. If you then see an error about system cannot find the path specified , it may be that the file evennia/evennia/server/twistd.bat has the wrong path to the twistd executable. This file is auto-generated, so try to delete it and then run evennia start to rebuild it and see if it works. If it still doesn't work you need to open it in a text editor like Notepad. It's just one line containing the path to the twistd.exe executable as determined by Evennia. If you installed Twisted in a non-standard location this might be wrong and you should update the line to the real location.","title":"Getting Started"},{"location":"Getting-Started.html#quick-start","text":"For the impatient. If you have trouble with a step, you should jump on to the more detailed instructions for your platform. Install Python, GIT and python-virtualenv. Start a Console/Terminal. cd to some place you want to do your development (like a folder /home/anna/muddev/ on Linux or a folder in your personal user directory on Windows). git clone https://github.com/evennia/evennia.git virtualenv evenv source evenv/bin/activate (Linux, Mac), evenv\\Scripts\\activate (Windows) pip install -e evennia evennia --init mygame cd mygame evennia migrate evennia start (make sure to make a superuser when asked) Evennia should now be running and you can connect to it by pointing a web browser to http://localhost:4001 or a MUD telnet client to localhost:4000 (use 127.0.0.1 if your OS does not recognize localhost ). We also release Docker images based on master and develop branches.","title":"Quick Start"},{"location":"Getting-Started.html#requirements","text":"Any system that supports latest Python3.7+ should work. We'll describe how to install everything in the following sections. - Linux/Unix - Windows (Vista, Win7, Win8, Win10) - Mac OSX (>=10.5 recommended) Python (v3.7+) virtualenv for making isolated Python environments. Installed with pip install virtualenv . GIT - version control software for getting and updating Evennia itself - Mac users can use the git-osx-installer or the MacPorts version . Twisted (v19.0+) ZopeInterface (v3.0+) - usually included in Twisted packages Linux/Mac users may need the gcc and python-dev packages or equivalent. Windows users need MS Visual C++ and maybe pypiwin32 . Django (v2.2), be warned that latest dev version is usually untested with Evennia)","title":"Requirements"},{"location":"Getting-Started.html#linux-install","text":"If you run into any issues during the installation and first start, please check out Linux Troubleshooting . Also, one of our devs made a Linux install video , check it out! For Debian-derived systems (like Ubuntu, Mint etc), start a terminal and install the dependencies : sudo apt-get update sudo apt-get install python3 python3-pip python3-dev python3-setuptools python3-git python3-virtualenv gcc # If you are using an Ubuntu version that defaults to Python3, like 18.04+, use this instead: sudo apt-get update sudo apt-get install python3.7 python3-pip python3.7-dev python3-setuptools virtualenv gcc You should make sure to not be root after this step, running as root is a security risk. Now create a folder where you want to do all your Evennia development: mkdir muddev cd muddev Next we fetch Evennia itself: git clone https://github.com/evennia/evennia.git A new folder evennia will appear containing the Evennia library. This only contains the source code though, it is not installed yet. To isolate the Evennia install and its dependencies from the rest of the system, it is good Python practice to install into a virtualenv . If you are unsure about what a virtualenv is and why it's useful, see the Glossary entry on virtualenv . Run python -V to see which version of Python your system defaults to. # If your Linux defaults to Python3: virtualenv evenv # If your Linux defaults to Python2 or an older version of Python3, you must instead point to Python3.7+ explicitly: virtualenv -p /usr/bin/python3.7 evenv A new folder evenv will appear (we could have called it anything). This folder will hold a self-contained setup of Python packages without interfering with default Python packages on your system (or the Linux distro lagging behind on Python package versions). It will also always use the right version of Python. Activate the virtualenv: source evenv/bin/activate The text (evenv) should appear next to your prompt to show that the virtual environment is active. Remember that you need to activate the virtualenv like this every time you start a new terminal to get access to the Python packages (notably the important evennia program) we are about to install. Next, install Evennia into your active virtualenv. Make sure you are standing at the top of your mud directory tree (so you see the evennia/ and evenv/ folders) and run pip install -e evennia For more info about pip , see the Glossary entry on pip . If install failed with any issues, see Linux Troubleshooting . Next we'll start our new game, here called \"mygame\". This will create yet another new folder where you will be creating your new game: evennia --init mygame Your final folder structure should look like this: ./muddev evenv/ evennia/ mygame/ You can configure Evennia extensively, for example to use a different database . For now we'll just stick to the defaults though. cd mygame evennia migrate # (this creates the database) evennia start # (create a superuser when asked. Email is optional.) Server logs are found in mygame/server/logs/ . To easily view server logs live in the terminal, use evennia -l (exit the log-view with Ctrl-C). Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created. Check out where to go next .","title":"Linux Install"},{"location":"Getting-Started.html#mac-install","text":"The Evennia server is a terminal program. Open the terminal e.g. from Applications->Utilities->Terminal . Here is an introduction to the Mac terminal if you are unsure how it works. If you run into any issues during the installation, please check out Mac Troubleshooting . Python should already be installed but you must make sure it's a high enough version. ( This discusses how you may upgrade it). Remember that you need Python3.7, not Python2.7! GIT can be obtained with git-osx-installer or via MacPorts as described here . If you run into issues with installing Twisted later you may need to install gcc and the Python headers. After this point you should not need sudo or any higher privileges to install anything. Now create a folder where you want to do all your Evennia development: mkdir muddev cd muddev Next we fetch Evennia itself: git clone https://github.com/evennia/evennia.git A new folder evennia will appear containing the Evennia library. This only contains the source code though, it is not installed yet. To isolate the Evennia install and its dependencies from the rest of the system, it is good Python practice to install into a virtualenv . If you are unsure about what a virtualenv is and why it's useful, see the Glossary entry on virtualenv . Run python -V to check which Python your system defaults to. # If your Mac defaults to Python3: virtualenv evenv # If your Mac defaults to Python2 you need to specify the Python3.7 binary explicitly: virtualenv -p /path/to/your/python3.7 evenv A new folder evenv will appear (we could have called it anything). This folder will hold a self-contained setup of Python packages without interfering with default Python packages on your system. Activate the virtualenv: source evenv/bin/activate The text (evenv) should appear next to your prompt to show the virtual environment is active. Remember that you need to activate the virtualenv like this every time you start a new terminal to get access to the Python packages (notably the important evennia program) we are about to install. Next, install Evennia into your active virtualenv. Make sure you are standing at the top of your mud directory tree (so you see the evennia/ and evenv/ folders) and run pip install --upgrade pip # Old pip versions may be an issue on Mac. pip install --upgrade setuptools # Ditto concerning Mac issues. pip install -e evennia For more info about pip , see the Glossary entry on pip . If install failed with any issues, see Mac Troubleshooting . Next we'll start our new game. We'll call it \"mygame\" here. This creates a new folder where you will be creating your new game: evennia --init mygame Your final folder structure should look like this: ./muddev evenv/ evennia/ mygame/ You can configure Evennia extensively, for example to use a different database . We'll go with the defaults here. cd mygame evennia migrate # (this creates the database) evennia start # (create a superuser when asked. Email is optional.) Server logs are found in mygame/server/logs/ . To easily view server logs live in the terminal, use evennia -l (exit the log-view with Ctrl-C). Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created. Check out where to go next .","title":"Mac Install"},{"location":"Getting-Started.html#windows-install","text":"If you run into any issues during the installation, please check out Windows Troubleshooting . If you are running Windows10, consider using the Windows Subsystem for Linux ( WSL ) instead. You should then follow the Linux install instructions above. The Evennia server itself is a command line program. In the Windows launch menu, start All Programs -> Accessories -> command prompt and you will get the Windows command line interface. Here is one of many tutorials on using the Windows command line if you are unfamiliar with it. Install Python from the Python homepage . You will need to be a Windows Administrator to install packages. You want Python version 3.7.0 (latest verified version), usually the 64-bit version (although it doesn't matter too much). When installing, make sure to check-mark all install options, especially the one about making Python available on the path (you may have to scroll to see it) . This allows you to just write python in any console without first finding where the python program actually sits on your hard drive. You need to also get GIT and install it. You can use the default install options but when you get asked to \"Adjust your PATH environment\", you should select the second option \"Use Git from the Windows Command Prompt\", which gives you more freedom as to where you can use the program. Finally you must install the Microsoft Visual C++ compiler for Python . Download and run the linked installer and install the C++ tools. Keep all the defaults. Allow the install of the \"Win10 SDK\", even if you are on Win7 (not tested on older Windows versions). If you later have issues with installing Evennia due to a failure to build the \"Twisted wheels\", this is where you are missing things. You may need the pypiwin32 Python headers. Install these only if you have issues. You can install Evennia wherever you want. cd to that location and create a new folder for all your Evennia development (let's call it muddev ). mkdir muddev cd muddev Hint: If cd isn't working you can use pushd instead to force the directory change. Next we fetch Evennia itself: git clone https://github.com/evennia/evennia.git A new folder evennia will appear containing the Evennia library. This only contains the source code though, it is not installed yet. To isolate the Evennia install and its dependencies from the rest of the system, it is good Python practice to install into a virtualenv . If you are unsure about what a virtualenv is and why it's useful, see the Glossary entry on virtualenv . In your console, try python -V to see which version of Python your system defaults to. pip install virtualenv # If your setup defaults to Python3.7: virtualenv evenv # If your setup defaults to Python2, specify path to python3.exe explicitly: virtualenv -p C:\\Python37\\python.exe evenv # If you get an infinite spooling response, press CTRL + C to interrupt and try using: python -m venv evenv A new folder evenv will appear (we could have called it anything). This folder will hold a self-contained setup of Python packages without interfering with default Python packages on your system. Activate the virtualenv: # If you are using a standard command prompt, you can use the following: evenv\\scripts\\activate.bat # If you are using a PS Shell, Git Bash, or other, you can use the following: .\\evenv\\scripts\\activate The text (evenv) should appear next to your prompt to show the virtual environment is active. Remember that you need to activate the virtualenv like this every time you start a new console window if you want to get access to the Python packages (notably the important evennia program) we are about to install. Next, install Evennia into your active virtualenv. Make sure you are standing at the top of your mud directory tree (so you see the evennia and evenv folders when you use the dir command) and run pip install -e evennia For more info about pip , see the Glossary entry on pip . If the install failed with any issues, see Windows Troubleshooting . Next we'll start our new game, we'll call it \"mygame\" here. This creates a new folder where you will be creating your new game: evennia --init mygame Your final folder structure should look like this: path\\to\\muddev evenv\\ evennia\\ mygame\\ You can configure Evennia extensively, for example to use a different database . We'll go with the defaults here. cd mygame evennia migrate # (this creates the database) evennia start # (create a superuser when asked. Email is optional.) Server logs are found in mygame/server/logs/ . To easily view server logs live in the terminal, use evennia -l (exit the log-view with Ctrl-C). Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created. Check out where to go next .","title":"Windows Install"},{"location":"Getting-Started.html#where-to-go-next","text":"Welcome to Evennia! Your new game is fully functioning, but empty. If you just logged in, stand in the Limbo room and run @batchcommand tutorial_world.build to build Evennia's tutorial world - it's a small solo quest to explore. Only run the instructed @batchcommand once. You'll get a lot of text scrolling by as the tutorial is built. Once done, the tutorial exit will have appeared out of Limbo - just write tutorial to enter it. Once you get back to Limbo from the tutorial (if you get stuck in the tutorial quest you can do @tel #2 to jump to Limbo), a good idea is to learn how to start, stop and reload the Evennia server. You may also want to familiarize yourself with some commonly used terms in our Glossary . After that, why not experiment with creating some new items and build some new rooms out from Limbo. From here on, you could move on to do one of our introductory tutorials or simply dive headlong into Evennia's comprehensive manual . While Evennia has no major game systems out of the box, we do supply a range of optional contribs that you can use or borrow from. They range from dice rolling and alternative color schemes to barter and combat systems. You can find the growing list of contribs here . If you have any questions, you can always ask in the developer chat #evennia on irc.freenode.net or by posting to the Evennia forums . You can also join the Discord Server . Finally, if you are itching to help out or support Evennia (awesome!) have an issue to report or a feature to request, see here . Enjoy your stay!","title":"Where to Go Next"},{"location":"Getting-Started.html#troubleshooting","text":"If you have issues with installing or starting Evennia for the first time, check the section for your operating system below. If you have an issue not covered here, please report it so it can be fixed or a workaround found! Remember, the server logs are in mygame/server/logs/ . To easily view server logs in the terminal, you can run evennia -l , or (in the future) start the server with evennia start -l .","title":"Troubleshooting"},{"location":"Getting-Started.html#linux-troubleshooting","text":"If you get an error when installing Evennia (especially with lines mentioning failing to include Python.h ) then try sudo apt-get install python3-setuptools python3-dev . Once installed, run pip install -e evennia again. Under some not-updated Linux distributions you may run into errors with a too-old setuptools or missing functools . If so, update your environment with pip install --upgrade pip wheel setuptools . Then try pip install -e evennia again. One user reported a rare issue on Ubuntu 16 is an install error on installing Twisted; Command \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-vnIFTg/twisted/ with errors like distutils.errors.DistutilsError: Could not find suitable distribution for Requirement.parse('incremental>=16.10.1') . This appears possible to solve by simply updating Ubuntu with sudo apt-get update && sudo apt-get dist-upgrade . Users of Fedora (notably Fedora 24) has reported a gcc error saying the directory /usr/lib/rpm/redhat/redhat-hardened-cc1 is missing, despite gcc itself being installed. The confirmed work-around seems to be to install the redhat-rpm-config package with e.g. sudo dnf install redhat-rpm-config . Some users trying to set up a virtualenv on an NTFS filesystem find that it fails due to issues with symlinks not being supported. Answer is to not use NTFS (seriously, why would you do that to yourself?)","title":"Linux Troubleshooting"},{"location":"Getting-Started.html#mac-troubleshooting","text":"Mac users have reported a critical MemoryError when trying to start Evennia on Mac with a Python version below 2.7.12 . If you get this error, update to the latest XCode and Python2 version. Some Mac users have reported not being able to connect to localhost (i.e. your own computer). If so, try to connect to 127.0.0.1 instead, which is the same thing. Use port 4000 from mud clients and port 4001 from the web browser as usual.","title":"Mac Troubleshooting"},{"location":"Getting-Started.html#windows-troubleshooting","text":"If you installed Python but the python command is not available (even in a new console), then you might have missed installing Python on the path. In the Windows Python installer you get a list of options for what to install. Most or all options are pre-checked except this one, and you may even have to scroll down to see it. Reinstall Python and make sure it's checked. If your MUD client cannot connect to localhost:4000 , try the equivalent 127.0.0.1:4000 instead. Some MUD clients on Windows does not appear to understand the alias localhost . If you run virtualenv evenv and get a 'virtualenv' is not recognized as an internal or external command, operable program or batch file. error, you can mkdir evenv , cd evenv and then python -m virtualenv . as a workaround. Some Windows users get an error installing the Twisted 'wheel'. A wheel is a pre-compiled binary package for Python. A common reason for this error is that you are using a 32-bit version of Python, but Twisted has not yet uploaded the latest 32-bit wheel. Easiest way to fix this is to install a slightly older Twisted version. So if, say, version 18.1 failed, install 18.0 manually with pip install twisted==18.0 . Alternatively you could try to get a 64-bit version of Python (uninstall the 32bit one). If so, you must then deactivate the virtualenv, delete the evenv folder and recreate it anew (it will then use the new Python executable). If your server won't start, with no error messages (and no log files at all when starting from scratch), try to start with evennia ipstart instead. If you then see an error about system cannot find the path specified , it may be that the file evennia/evennia/server/twistd.bat has the wrong path to the twistd executable. This file is auto-generated, so try to delete it and then run evennia start to rebuild it and see if it works. If it still doesn't work you need to open it in a text editor like Notepad. It's just one line containing the path to the twistd.exe executable as determined by Evennia. If you installed Twisted in a non-standard location this might be wrong and you should update the line to the real location.","title":"Windows Troubleshooting"},{"location":"Glossary.html","text":"This explains common recurring terms used in the Evennia docs. It will be expanded as needed. account - the player's account on the game admin-site - the Django web page for manipulating the database attribute - persistent, custom data stored on typeclasses channel - game communication channels character - the player's avatar in the game, controlled from account core - a term used for the code distributed with Evennia proper django - web framework Evennia uses for database access and web integration field - a typeclass property representing a database column git - the version-control system we use github - the online hosting of our source code migrate - updating the database schema multisession mode` - a setting defining how users connect to Evennia object - Python instance, general term or in-game typeclass pip - the Python installer player - the human connecting to the game with their client puppet - when an account controls an in-game object property - a python property evenv - see virtualenv repository - a store of source code + source history script - a building block for custom storage, systems and time-keepint session - represents one client connection ticker - Allows to run events on a steady 'tick' twisted - networking engine responsible for Evennia's event loop and communications typeclass - Evennia's database-connected Python class upstream - see github virtualenv - a Python program and way to make an isolated Python install account \u00b6 The term 'account' refers to the player's unique account on the game. It is represented by the Account typeclass and holds things like email, password, configuration etc. When a player connects to the game, they connect to their account. The account has no representation in the game world. Through their Account they can instead choose to puppet one (or more, depending on game mode) Characters in the game. In the default multisession mode of Evennia, you immediately start puppeting a Character with the same name as your Account when you log in - mimicking how older servers used to work. admin-site \u00b6 This usually refers to Django's Admin site or database-administration web page ( link to Django docs ). The admin site is an automatically generated web interface to the database (it can be customized extensively). It's reachable from the admin link on the default Evennia website you get with your server. attribute \u00b6 The term Attribute should not be confused with ( properties or fields . The Attribute represents arbitrary pieces of data that can be attached to any typeclassed entity in Evennia. Attributes allows storing new persistent data on typeclasses without changing their underlying database schemas. Read more about Attributes here . channel \u00b6 A Channel refers to an in-game communication channel. It's an entity that people subscribe to and which re-distributes messages between all subscribers. Such subscribers default to being Accounts , for out-of-game communication but could also be Objects (usually Characters) if one wanted to adopt Channels for things like in-game walkie-talkies or phone systems. It is represented by the Channel typeclass. You can read more about the comm system here . character \u00b6 The Character is the term we use for the default avatar being puppeted by the account in the game world. It is represented by the Character typeclass (which is a child of Object ). Many developers use children of this class to represent monsters and other NPCs. You can read more about it here . django \u00b6 Django is a professional and very popular Python web framework, similar to Rails for the Ruby language. It is one of Evennia's central library dependencies (the other one is Twisted ). Evennia uses Django for two main things - to map all database operations to Python and for structuring our web site. Through Django, we can work with any supported database (SQlite3, Postgres, MySQL ...) using generic Python instead of database-specific SQL: A database table is represented in Django as a Python class (called a model ). An Python instance of such a class represents a row in that table. There is usually no need to know the details of Django's database handling in order to use Evennia - it will handle most of the complexity for you under the hood using what we call typeclasses . But should you need the power of Django you can always get it. Most commonly people want to use \"raw\" Django when doing more advanced/custom database queries than offered by Evennia's default search functions . One will then need to read about Django's querysets . Querysets are Python method calls on a special form that lets you build complex queries. They get converted into optimized SQL queries under the hood, suitable for your current database. Here is our tutorial/explanation of Django queries . By the way, Django (and Evennia) does allow you to fall through and send raw SQL if you really want to. It's highly unlikely to be needed though; the Django database abstraction is very, very powerful. The other aspect where Evennia uses Django is for web integration. On one end Django gives an infrastructure for wiring Python functions (called views ) to URLs: the view/function is called when a user goes that URL in their browser, enters data into a form etc. The return is the web page to show. Django also offers templating with features such as being able to add special markers in HTML where it will insert the values of Python variables on the fly (like showing the current player count on the web page). Here is one of our tutorials on wiring up such a web page . Django also comes with the admin site , which automatically maps the database into a form accessible from a web browser. core \u00b6 This term is sometimes used to represent the main Evennia library code suite, excluding its contrib directory. It can sometimes come up in code reviews, such as Evennia is game-agnostic but this feature is for a particular game genre. So it does not belong in core. Better make it a contrib. field \u00b6 A field or database field in Evennia refers to a property on a typeclass directly linked to an underlying database column. Only a few fixed properties per typeclass are database fields but they are often tied to the core functionality of that base typeclass (for example Objects store its location as a field). In all other cases, attributes are used to add new persistent data to the typeclass. Read more about typeclass properties here . git \u00b6 Git is a version control tool. It allows us to track the development of the Evennia code by dividing it into units called commits . A 'commit' is sort of a save-spot - you save the current state of your code and can then come back to it later if later changes caused problems. By tracking commits we know what 'version' of the code we are currently using. Evennia's source code + its source history is jointly called a repository . This is centrally stored at our online home on GitHub . Everyone using or developing Evennia makes a 'clone' of this repository to their own computer - everyone automatically gets everything that is online, including all the code history. Don't confuse Git and GitHub . The former is the version control system. The latter is a website (run by a company) that allows you to upload source code controlled by Git for others to see (among other things). Git allows multiple users from around the world to efficiently collaborate on Evennia's code: People can make local commits on their cloned code. The commits they do can then be uploaded to GitHub and reviewed by the Evennia lead devs - and if the changes look ok they can be safely merged into the central Evennia code - and everyone can pull those changes to update their local copies. Developers using Evennia often uses Git on their own games in the same way - to track their changes and to help collaboration with team mates. This is done completely independently of Evennia's Git usage. Common usage (for non-Evennia developers): - git clone <github-url> - clone an online repository to your computer. This is what you do when you 'download' Evennia. You only need to do this once. - git pull (inside local copy of repository) - sync your local repository with what is online. Full usage of Git is way beyond the scope of this glossary. See Tutorial - version control for more info and links to the Git documentation. migrate \u00b6 This term is used for upgrading the database structure (it's schema )to a new version. Most often this is due to Evennia's upstream schema changing. When that happens you need to migrate that schema to the new version as well. Once you have used git to pull the latest changes, just cd into your game dir and run evennia migrate That should be it (see virtualenv if you get a warning that the evennia command is not available). See also Updating your game for more details. Technically, migrations are shipped as little Python snippets of code that explains which database actions must be taken to upgrade from one version of the schema to the next. When you run the command above, those snippets are run in sequence. multisession mode \u00b6 This term refers to the MULTISESSION_MODE setting, which has a value of 0 to 3. The mode alters how players can connect to the game, such as how many Sessions a player can start with one account and how many Characters they can control at the same time. It is described in detail here . github \u00b6 Github is where Evennia's source code and documentation is hosted. This online repository of code we also sometimes refer to as upstream . GitHub is a business, offering free hosting to Open-source projects like Evennia. Despite the similarity in name, don't confuse GitHub the website with Git , the versioning system. Github hosts Git repositories online and helps with collaboration and infrastructure. Git itself is a separate project. object \u00b6 In general Python (and other object-oriented languages ), an object is what we call the instance of a class . But one of Evennia's core typeclasses is also called \"Object\". To separate these in the docs we try to use object to refer to the general term and capitalized Object when we refer to the typeclass. The Object is a typeclass that represents all in-game entities, including Characters , rooms, trees, weapons etc. Read more about Objects here . pip \u00b6 pip comes with Python and is the main tool for installing third-party Python packages from the web. Once a python package is installed you can do import <packagename> in your Python code. Common usage: - pip install <package-name> - install the given package along with all its dependencies. - pip search <name> - search Python's central package repository PyPi for a package of that name. - pip install --upgrade <package_name> - upgrade a package you already have to the latest version. - pip install <packagename>==1.5 - install exactly a specific package version. - pip install <folder> - install a Python package you have downloaded earlier (or cloned using git). - pip install -e <folder> - install a local package by just making a soft link to the folder. This means that if the code in <folder> changes, the installed Python package is immediately updated. If not using -e , one would need to run pip install --upgrade <folder> every time to make the changes available when you import this package into your code. Evennia is installed this way. For development, pip is usually used together with a virtualenv to install all packages and dependencies needed for a project in one, isolated location on the hard drive. puppet \u00b6 An account can take control and \"play as\" any Object . When doing so, we call this puppeting , (like puppeteering ). Normally the entity being puppeted is of the Character subclass but it does not have to be. property \u00b6 A property is a general term used for properties on any Python object. The term also sometimes refers to the property built-in function of Python ( read more here ). Note the distinction between properties, fields and Attributes . repository \u00b6 A repository is a version control/ git term. It represents a folder containing source code plus its versioning history. In Git's case, that history is stored in a hidden folder .git . If you ever feel the need to look into this folder you probably already know enough Git to know why. The evennia folder you download from us with git clone is a repository. The code on GitHub is often referred to as the 'online repository' (or the upstream repository). If you put your game dir under version control, that of course becomes a repository as well. script \u00b6 When we refer to Scripts , we generally refer to the Script typeclass . Scripts are the mavericks of Evennia - they are like Objects but without any in-game existence. They are useful as custom places to store data but also as building blocks in persistent game systems. Since the can be initialized with timing capabilities they can also be used for long-time persistent time keeping (for fast updates other types of timers may be better though). Read more about Scripts here session \u00b6 A Session is a Python object representing a single client connection to the server. A given human player could connect to the game from different clients and each would get a Session (even if you did not allow them to actually log in and get access to an account ). Sessions are not typeclassed and has no database persistence. But since they always exist (also when not logged in), they share some common functionality with typeclasses that can be useful for certain game states. ticker \u00b6 The Ticker handler runs Evennia's optional 'ticker' system. In other engines, such as DIKU , all game events are processed only at specific intervals called 'ticks'. Evennia has no such technical limitation (events are processed whenever needed) but using a fixed tick can still be useful for certain types of game systems, like combat. Ticker Handler allows you to emulate any number of tick rates (not just one) and subscribe actions to be called when those ticks come around. typeclass \u00b6 The typeclass is an Evennia-specific term. A typeclass allows developers to work with database-persistent objects as if they were normal Python objects. It makes use of specific Django features to link a Python class to a database table. Sometimes we refer to such code entities as being typeclassed . Evennia's main typeclasses are Account , Object , Script and Channel . Children of the base class (such as Character ) will use the same database table as the parent, but can have vastly different Python capabilities (and persistent features through Attributes and Tags . A typeclass can be coded and treated pretty much like any other Python class except it must inherit (at any distance) from one of the base typeclasses. Also, creating a new instance of a typeclass will add a new row to the database table to which it is linked. The core typeclasses in the Evennia library are all named DefaultAccount , DefaultObject etc. When you initialize your [game dir] you automatically get empty children of these, called Account , Object etc that you can start working with. twisted \u00b6 Twisted is a heavy-duty asynchronous networking engine. It is one of Evennia's two major library dependencies (the other one is Django ). Twisted is what \"runs\" Evennia - it handles Evennia's event loop. Twisted also has the building blocks we need to construct network protocols and communicate with the outside world; such as our MUD-custom version of Telnet, Telnet+SSL, SSH, webclient-websockets etc. Twisted also runs our integrated web server, serving the Django-based website for your game. virtualenv \u00b6 The standard virtualenv program comes with Python. It is used to isolate all Python packages needed by a given Python project into one folder (we call that folder evenv but it could be called anything). A package environment created this way is usually referred to as \"a virtualenv\". If you ever try to run the evennia program and get an error saying something like \"the command 'evennia' is not available\" - it's probably because your virtualenv is not 'active' yet (see below). Usage: - virtualenv <name> - initialize a new virtualenv <name> in a new folder <name> in the current location. Called evenv in these docs. - virtualenv -p path/to/alternate/python_executable <name> - create a virtualenv using another Python version than default. - source <folder_name>/bin/activate (linux/mac) - activate the virtualenv in <folder_name> . - <folder_name>\\Scripts\\activate (windows) - deactivate - turn off the currently activated virtualenv. A virtualenv is 'activated' only for the console/terminal it was started in, but it's safe to activate the same virtualenv many times in different windows if you want. Once activated, all Python packages now installed with pip will install to evenv rather than to a global location like /usr/local/bin or C:\\Program Files . Note that if you have root/admin access you could install Evennia globally just fine, without using a virtualenv. It's strongly discouraged and considered bad practice though. Experienced Python developers tend to rather create one new virtualenv per project they are working on, to keep the varying installs cleanly separated from one another. When you execute Python code within this activated virtualenv, only those packages installed within will be possible to import into your code. So if you installed a Python package globally on your computer, you'll need to install it again in your virtualenv. Virtualenvs only deal with Python programs/packages. Other programs on your computer couldn't care less if your virtualenv is active or not. So you could use git without the virtualenv being active, for example. When your virtualenv is active you should see your console/terminal prompt change to (evenv) ... ... or whatever name you gave the virtualenv when you initialized it. We sometimes say that we are \"in\" the virtualenv when it's active. But just to be clear - you never have to actually cd into the evenv folder. You can activate it from anywhere and will still be considered \"in\" the virtualenv wherever you go until you deactivate or close the console/terminal. So, when do I need to activate my virtualenv? If the virtualenv is not active, none of the Python packages/programs you installed in it will be available to you. So at a minimum, it needs to be activated whenever you want to use the evennia command for any reason.","title":"Glossary"},{"location":"Glossary.html#account","text":"The term 'account' refers to the player's unique account on the game. It is represented by the Account typeclass and holds things like email, password, configuration etc. When a player connects to the game, they connect to their account. The account has no representation in the game world. Through their Account they can instead choose to puppet one (or more, depending on game mode) Characters in the game. In the default multisession mode of Evennia, you immediately start puppeting a Character with the same name as your Account when you log in - mimicking how older servers used to work.","title":"account"},{"location":"Glossary.html#admin-site","text":"This usually refers to Django's Admin site or database-administration web page ( link to Django docs ). The admin site is an automatically generated web interface to the database (it can be customized extensively). It's reachable from the admin link on the default Evennia website you get with your server.","title":"admin-site"},{"location":"Glossary.html#attribute","text":"The term Attribute should not be confused with ( properties or fields . The Attribute represents arbitrary pieces of data that can be attached to any typeclassed entity in Evennia. Attributes allows storing new persistent data on typeclasses without changing their underlying database schemas. Read more about Attributes here .","title":"attribute"},{"location":"Glossary.html#channel","text":"A Channel refers to an in-game communication channel. It's an entity that people subscribe to and which re-distributes messages between all subscribers. Such subscribers default to being Accounts , for out-of-game communication but could also be Objects (usually Characters) if one wanted to adopt Channels for things like in-game walkie-talkies or phone systems. It is represented by the Channel typeclass. You can read more about the comm system here .","title":"channel"},{"location":"Glossary.html#character","text":"The Character is the term we use for the default avatar being puppeted by the account in the game world. It is represented by the Character typeclass (which is a child of Object ). Many developers use children of this class to represent monsters and other NPCs. You can read more about it here .","title":"character"},{"location":"Glossary.html#django","text":"Django is a professional and very popular Python web framework, similar to Rails for the Ruby language. It is one of Evennia's central library dependencies (the other one is Twisted ). Evennia uses Django for two main things - to map all database operations to Python and for structuring our web site. Through Django, we can work with any supported database (SQlite3, Postgres, MySQL ...) using generic Python instead of database-specific SQL: A database table is represented in Django as a Python class (called a model ). An Python instance of such a class represents a row in that table. There is usually no need to know the details of Django's database handling in order to use Evennia - it will handle most of the complexity for you under the hood using what we call typeclasses . But should you need the power of Django you can always get it. Most commonly people want to use \"raw\" Django when doing more advanced/custom database queries than offered by Evennia's default search functions . One will then need to read about Django's querysets . Querysets are Python method calls on a special form that lets you build complex queries. They get converted into optimized SQL queries under the hood, suitable for your current database. Here is our tutorial/explanation of Django queries . By the way, Django (and Evennia) does allow you to fall through and send raw SQL if you really want to. It's highly unlikely to be needed though; the Django database abstraction is very, very powerful. The other aspect where Evennia uses Django is for web integration. On one end Django gives an infrastructure for wiring Python functions (called views ) to URLs: the view/function is called when a user goes that URL in their browser, enters data into a form etc. The return is the web page to show. Django also offers templating with features such as being able to add special markers in HTML where it will insert the values of Python variables on the fly (like showing the current player count on the web page). Here is one of our tutorials on wiring up such a web page . Django also comes with the admin site , which automatically maps the database into a form accessible from a web browser.","title":"django"},{"location":"Glossary.html#core","text":"This term is sometimes used to represent the main Evennia library code suite, excluding its contrib directory. It can sometimes come up in code reviews, such as Evennia is game-agnostic but this feature is for a particular game genre. So it does not belong in core. Better make it a contrib.","title":"core"},{"location":"Glossary.html#field","text":"A field or database field in Evennia refers to a property on a typeclass directly linked to an underlying database column. Only a few fixed properties per typeclass are database fields but they are often tied to the core functionality of that base typeclass (for example Objects store its location as a field). In all other cases, attributes are used to add new persistent data to the typeclass. Read more about typeclass properties here .","title":"field"},{"location":"Glossary.html#git","text":"Git is a version control tool. It allows us to track the development of the Evennia code by dividing it into units called commits . A 'commit' is sort of a save-spot - you save the current state of your code and can then come back to it later if later changes caused problems. By tracking commits we know what 'version' of the code we are currently using. Evennia's source code + its source history is jointly called a repository . This is centrally stored at our online home on GitHub . Everyone using or developing Evennia makes a 'clone' of this repository to their own computer - everyone automatically gets everything that is online, including all the code history. Don't confuse Git and GitHub . The former is the version control system. The latter is a website (run by a company) that allows you to upload source code controlled by Git for others to see (among other things). Git allows multiple users from around the world to efficiently collaborate on Evennia's code: People can make local commits on their cloned code. The commits they do can then be uploaded to GitHub and reviewed by the Evennia lead devs - and if the changes look ok they can be safely merged into the central Evennia code - and everyone can pull those changes to update their local copies. Developers using Evennia often uses Git on their own games in the same way - to track their changes and to help collaboration with team mates. This is done completely independently of Evennia's Git usage. Common usage (for non-Evennia developers): - git clone <github-url> - clone an online repository to your computer. This is what you do when you 'download' Evennia. You only need to do this once. - git pull (inside local copy of repository) - sync your local repository with what is online. Full usage of Git is way beyond the scope of this glossary. See Tutorial - version control for more info and links to the Git documentation.","title":"git"},{"location":"Glossary.html#migrate","text":"This term is used for upgrading the database structure (it's schema )to a new version. Most often this is due to Evennia's upstream schema changing. When that happens you need to migrate that schema to the new version as well. Once you have used git to pull the latest changes, just cd into your game dir and run evennia migrate That should be it (see virtualenv if you get a warning that the evennia command is not available). See also Updating your game for more details. Technically, migrations are shipped as little Python snippets of code that explains which database actions must be taken to upgrade from one version of the schema to the next. When you run the command above, those snippets are run in sequence.","title":"migrate"},{"location":"Glossary.html#multisession-mode","text":"This term refers to the MULTISESSION_MODE setting, which has a value of 0 to 3. The mode alters how players can connect to the game, such as how many Sessions a player can start with one account and how many Characters they can control at the same time. It is described in detail here .","title":"multisession mode"},{"location":"Glossary.html#github","text":"Github is where Evennia's source code and documentation is hosted. This online repository of code we also sometimes refer to as upstream . GitHub is a business, offering free hosting to Open-source projects like Evennia. Despite the similarity in name, don't confuse GitHub the website with Git , the versioning system. Github hosts Git repositories online and helps with collaboration and infrastructure. Git itself is a separate project.","title":"github"},{"location":"Glossary.html#object","text":"In general Python (and other object-oriented languages ), an object is what we call the instance of a class . But one of Evennia's core typeclasses is also called \"Object\". To separate these in the docs we try to use object to refer to the general term and capitalized Object when we refer to the typeclass. The Object is a typeclass that represents all in-game entities, including Characters , rooms, trees, weapons etc. Read more about Objects here .","title":"object"},{"location":"Glossary.html#pip","text":"pip comes with Python and is the main tool for installing third-party Python packages from the web. Once a python package is installed you can do import <packagename> in your Python code. Common usage: - pip install <package-name> - install the given package along with all its dependencies. - pip search <name> - search Python's central package repository PyPi for a package of that name. - pip install --upgrade <package_name> - upgrade a package you already have to the latest version. - pip install <packagename>==1.5 - install exactly a specific package version. - pip install <folder> - install a Python package you have downloaded earlier (or cloned using git). - pip install -e <folder> - install a local package by just making a soft link to the folder. This means that if the code in <folder> changes, the installed Python package is immediately updated. If not using -e , one would need to run pip install --upgrade <folder> every time to make the changes available when you import this package into your code. Evennia is installed this way. For development, pip is usually used together with a virtualenv to install all packages and dependencies needed for a project in one, isolated location on the hard drive.","title":"pip"},{"location":"Glossary.html#puppet","text":"An account can take control and \"play as\" any Object . When doing so, we call this puppeting , (like puppeteering ). Normally the entity being puppeted is of the Character subclass but it does not have to be.","title":"puppet"},{"location":"Glossary.html#property","text":"A property is a general term used for properties on any Python object. The term also sometimes refers to the property built-in function of Python ( read more here ). Note the distinction between properties, fields and Attributes .","title":"property"},{"location":"Glossary.html#repository","text":"A repository is a version control/ git term. It represents a folder containing source code plus its versioning history. In Git's case, that history is stored in a hidden folder .git . If you ever feel the need to look into this folder you probably already know enough Git to know why. The evennia folder you download from us with git clone is a repository. The code on GitHub is often referred to as the 'online repository' (or the upstream repository). If you put your game dir under version control, that of course becomes a repository as well.","title":"repository"},{"location":"Glossary.html#script","text":"When we refer to Scripts , we generally refer to the Script typeclass . Scripts are the mavericks of Evennia - they are like Objects but without any in-game existence. They are useful as custom places to store data but also as building blocks in persistent game systems. Since the can be initialized with timing capabilities they can also be used for long-time persistent time keeping (for fast updates other types of timers may be better though). Read more about Scripts here","title":"script"},{"location":"Glossary.html#session","text":"A Session is a Python object representing a single client connection to the server. A given human player could connect to the game from different clients and each would get a Session (even if you did not allow them to actually log in and get access to an account ). Sessions are not typeclassed and has no database persistence. But since they always exist (also when not logged in), they share some common functionality with typeclasses that can be useful for certain game states.","title":"session"},{"location":"Glossary.html#ticker","text":"The Ticker handler runs Evennia's optional 'ticker' system. In other engines, such as DIKU , all game events are processed only at specific intervals called 'ticks'. Evennia has no such technical limitation (events are processed whenever needed) but using a fixed tick can still be useful for certain types of game systems, like combat. Ticker Handler allows you to emulate any number of tick rates (not just one) and subscribe actions to be called when those ticks come around.","title":"ticker"},{"location":"Glossary.html#typeclass","text":"The typeclass is an Evennia-specific term. A typeclass allows developers to work with database-persistent objects as if they were normal Python objects. It makes use of specific Django features to link a Python class to a database table. Sometimes we refer to such code entities as being typeclassed . Evennia's main typeclasses are Account , Object , Script and Channel . Children of the base class (such as Character ) will use the same database table as the parent, but can have vastly different Python capabilities (and persistent features through Attributes and Tags . A typeclass can be coded and treated pretty much like any other Python class except it must inherit (at any distance) from one of the base typeclasses. Also, creating a new instance of a typeclass will add a new row to the database table to which it is linked. The core typeclasses in the Evennia library are all named DefaultAccount , DefaultObject etc. When you initialize your [game dir] you automatically get empty children of these, called Account , Object etc that you can start working with.","title":"typeclass"},{"location":"Glossary.html#twisted","text":"Twisted is a heavy-duty asynchronous networking engine. It is one of Evennia's two major library dependencies (the other one is Django ). Twisted is what \"runs\" Evennia - it handles Evennia's event loop. Twisted also has the building blocks we need to construct network protocols and communicate with the outside world; such as our MUD-custom version of Telnet, Telnet+SSL, SSH, webclient-websockets etc. Twisted also runs our integrated web server, serving the Django-based website for your game.","title":"twisted"},{"location":"Glossary.html#virtualenv","text":"The standard virtualenv program comes with Python. It is used to isolate all Python packages needed by a given Python project into one folder (we call that folder evenv but it could be called anything). A package environment created this way is usually referred to as \"a virtualenv\". If you ever try to run the evennia program and get an error saying something like \"the command 'evennia' is not available\" - it's probably because your virtualenv is not 'active' yet (see below). Usage: - virtualenv <name> - initialize a new virtualenv <name> in a new folder <name> in the current location. Called evenv in these docs. - virtualenv -p path/to/alternate/python_executable <name> - create a virtualenv using another Python version than default. - source <folder_name>/bin/activate (linux/mac) - activate the virtualenv in <folder_name> . - <folder_name>\\Scripts\\activate (windows) - deactivate - turn off the currently activated virtualenv. A virtualenv is 'activated' only for the console/terminal it was started in, but it's safe to activate the same virtualenv many times in different windows if you want. Once activated, all Python packages now installed with pip will install to evenv rather than to a global location like /usr/local/bin or C:\\Program Files . Note that if you have root/admin access you could install Evennia globally just fine, without using a virtualenv. It's strongly discouraged and considered bad practice though. Experienced Python developers tend to rather create one new virtualenv per project they are working on, to keep the varying installs cleanly separated from one another. When you execute Python code within this activated virtualenv, only those packages installed within will be possible to import into your code. So if you installed a Python package globally on your computer, you'll need to install it again in your virtualenv. Virtualenvs only deal with Python programs/packages. Other programs on your computer couldn't care less if your virtualenv is active or not. So you could use git without the virtualenv being active, for example. When your virtualenv is active you should see your console/terminal prompt change to (evenv) ... ... or whatever name you gave the virtualenv when you initialized it. We sometimes say that we are \"in\" the virtualenv when it's active. But just to be clear - you never have to actually cd into the evenv folder. You can activate it from anywhere and will still be considered \"in\" the virtualenv wherever you go until you deactivate or close the console/terminal. So, when do I need to activate my virtualenv? If the virtualenv is not active, none of the Python packages/programs you installed in it will be available to you. So at a minimum, it needs to be activated whenever you want to use the evennia command for any reason.","title":"virtualenv"},{"location":"Grapevine.html","text":"Grapevine is a new chat network for MU* *** games. By connecting an in-game channel to the grapevine network, players on your game can chat with players in other games, also non-Evennia ones. Configuring Grapevine \u00b6 To use Grapevine, you first need the pyopenssl module. Install it into your Evennia python environment with pip install pyopenssl To configure Grapevine, you'll need to activate it in your settings file. GRAPEVINE_ENABLED = True Next, register an account at https://grapevine.haus. When you have logged in, go to your Settings/Profile and to the Games sub menu. Here you register your new game by filling in its information. At the end of registration you are going to get a Client ID and a Client Secret . These should not be shared. Open/create the file mygame/server/conf/secret_settings.py and add the following: GRAPEVINE_CLIENT_ID = \"<client ID>\" GRAPEVINE_CLIENT_SECRET = \"<client_secret>\" You can also customize the Grapevine channels you are allowed to connect to. This is added to the GRAPEVINE_CHANNELS setting. You can see which channels are available by going to the Grapevine online chat here: https://grapevine.haus/chat. Start/reload Evennia and log in as a privileged user. You should now have a new command available: @grapevine2chan . This command is called like this: @grapevine2chan[/switches] <evennia_channel> = <grapevine_channel> Here, the evennia_channel must be the name of an existing Evennia channel and grapevine_channel one of the supported channels in GRAPEVINE_CHANNELS . At the time of writing, the Grapevine network only has two channels: testing and gossip . Evennia defaults to allowing connecting to both. Use testing for trying your connection. Setting up Grapevine, step by step \u00b6 You can connect Grapevine to any Evennia channel (so you could connect it to the default public channel if you like), but for testing, let's set up a new channel gw . @ccreate gw = This is connected to an gw channel! You will automatically join the new channel. Next we will create a connection to the Grapevine network. @grapevine2chan gw = gossip Evennia will now create a new connection and connect it to Grapevine. Connect to https://grapevine.haus/chat to check. Write something in the Evennia channel gw and check so a message appears in the Grapevine chat. Write a reply in the chat and the grapevine bot should echo it to your channel in-game. Your Evennia gamers can now chat with users on external Grapevine channels!","title":"Grapevine"},{"location":"Grapevine.html#configuring-grapevine","text":"To use Grapevine, you first need the pyopenssl module. Install it into your Evennia python environment with pip install pyopenssl To configure Grapevine, you'll need to activate it in your settings file. GRAPEVINE_ENABLED = True Next, register an account at https://grapevine.haus. When you have logged in, go to your Settings/Profile and to the Games sub menu. Here you register your new game by filling in its information. At the end of registration you are going to get a Client ID and a Client Secret . These should not be shared. Open/create the file mygame/server/conf/secret_settings.py and add the following: GRAPEVINE_CLIENT_ID = \"<client ID>\" GRAPEVINE_CLIENT_SECRET = \"<client_secret>\" You can also customize the Grapevine channels you are allowed to connect to. This is added to the GRAPEVINE_CHANNELS setting. You can see which channels are available by going to the Grapevine online chat here: https://grapevine.haus/chat. Start/reload Evennia and log in as a privileged user. You should now have a new command available: @grapevine2chan . This command is called like this: @grapevine2chan[/switches] <evennia_channel> = <grapevine_channel> Here, the evennia_channel must be the name of an existing Evennia channel and grapevine_channel one of the supported channels in GRAPEVINE_CHANNELS . At the time of writing, the Grapevine network only has two channels: testing and gossip . Evennia defaults to allowing connecting to both. Use testing for trying your connection.","title":"Configuring Grapevine"},{"location":"Grapevine.html#setting-up-grapevine-step-by-step","text":"You can connect Grapevine to any Evennia channel (so you could connect it to the default public channel if you like), but for testing, let's set up a new channel gw . @ccreate gw = This is connected to an gw channel! You will automatically join the new channel. Next we will create a connection to the Grapevine network. @grapevine2chan gw = gossip Evennia will now create a new connection and connect it to Grapevine. Connect to https://grapevine.haus/chat to check. Write something in the Evennia channel gw and check so a message appears in the Grapevine chat. Write a reply in the chat and the grapevine bot should echo it to your channel in-game. Your Evennia gamers can now chat with users on external Grapevine channels!","title":"Setting up Grapevine, step by step"},{"location":"Guest-Logins.html","text":"Evennia supports guest logins out of the box. A guest login is an anonymous, low-access account and can be useful if you want users to have a chance to try out your game without committing to creating a real account. Guest accounts are turned off by default. To activate, add this to your game/settings.py file: GUEST_ENABLED = True Henceforth users can use connect guest (in the default command set) to login with a guest account. You may need to change your Connection Screen to inform them of this possibility. Guest accounts work differently from normal accounts - they are automatically deleted whenever the user logs off or the server resets (but not during a reload). They are literally re-usable throw-away accounts. You can add a few more variables to your settings.py file to customize your guests: BASE_GUEST_TYPECLASS - the python-path to the default typeclass for guests. Defaults to \"typeclasses.accounts.Guest\" . PERMISSION_GUEST_DEFAULT - permission level for guest accounts. Defaults to \"Guests\" , which is the lowest permission level in the hierarchy. GUEST_START_LOCATION - the #dbref to the starting location newly logged-in guests should appear at. Defaults to \"#2 (Limbo). GUEST_HOME - guest home locations. Defaults to Limbo as well. GUEST_LIST - this is a list holding the possible guest names to use when entering the game. The length of this list also sets how many guests may log in at the same time. By default this is a list of nine names from \"Guest1\" to \"Guest9\" .","title":"Guest Logins"},{"location":"HAProxy-Config-(Optional).html","text":"Evennia, HTTPS and Secure Websockets can play nicely together, quickly. \u00b6 May I suggest giving HAProxy 1.5+ a chance... Installing HAProxy is usually as simple as: # Redhat derivatives yum install haproxy # dnf instead of yum for very recent Fedora distros. or # Debian derivatives apt install haproxy Configuration of HAProxy requires a single file given as an argument on the command line: haproxy -f /path/to/config.file In it (example using haproxy 1.5.18 on Centos7): # stuff provided by the default haproxy installs global log /dev/log local0 chroot /var/lib/haproxy maxconn 4000 user haproxy defaults mode http option forwardfor # Evennia Specifics listen evennia-https-website bind <public-ip-address>:<public-SSL-port--probably-443> ssl no-sslv3 no-tlsv10 crt /path/to/your-cert.pem server localhost 127.0.0.1:<evennia-web-port-probably-4001> listen evennia-secure-websocket bind <public-ip-address>:<WEBSOCKET_CLIENT_URL 4002> ssl no-sslv3 no-tlsv10 crt /path/to/your-cert.pem server localhost 127.0.0.1:<WEBSOCKET_CLIENT_URL 4002> timeout client 10m timeout server 10m Then edit mygame/server/conf/settings.py and add: WEBSERVER_INTERFACES = ['127.0.0.1'] WEBSOCKET_CLIENT_INTERFACE = '127.0.0.1' or LOCKDOWN_MODE=True and WEBSOCKET_CLIENT_URL=\"wss://yourhost.com:4002/\"","title":"HAProxy Config (Optional)"},{"location":"HAProxy-Config-(Optional).html#evennia-https-and-secure-websockets-can-play-nicely-together-quickly","text":"May I suggest giving HAProxy 1.5+ a chance... Installing HAProxy is usually as simple as: # Redhat derivatives yum install haproxy # dnf instead of yum for very recent Fedora distros. or # Debian derivatives apt install haproxy Configuration of HAProxy requires a single file given as an argument on the command line: haproxy -f /path/to/config.file In it (example using haproxy 1.5.18 on Centos7): # stuff provided by the default haproxy installs global log /dev/log local0 chroot /var/lib/haproxy maxconn 4000 user haproxy defaults mode http option forwardfor # Evennia Specifics listen evennia-https-website bind <public-ip-address>:<public-SSL-port--probably-443> ssl no-sslv3 no-tlsv10 crt /path/to/your-cert.pem server localhost 127.0.0.1:<evennia-web-port-probably-4001> listen evennia-secure-websocket bind <public-ip-address>:<WEBSOCKET_CLIENT_URL 4002> ssl no-sslv3 no-tlsv10 crt /path/to/your-cert.pem server localhost 127.0.0.1:<WEBSOCKET_CLIENT_URL 4002> timeout client 10m timeout server 10m Then edit mygame/server/conf/settings.py and add: WEBSERVER_INTERFACES = ['127.0.0.1'] WEBSOCKET_CLIENT_INTERFACE = '127.0.0.1' or LOCKDOWN_MODE=True and WEBSOCKET_CLIENT_URL=\"wss://yourhost.com:4002/\"","title":"Evennia, HTTPS and Secure Websockets can play nicely together, quickly."},{"location":"Help-System-Tutorial.html","text":"Before doing this tutorial you will probably want to read the intro in Basic Web tutorial . Reading the three first parts of the Django tutorial might help as well. This tutorial will show you how to access the help system through your website. Both help commands and regular help entries will be visible, depending on the logged-in user or an anonymous character. This tutorial will show you how to: Create a new page to add to your website. Take advantage of a basic view and basic templates. Access the help system on your website. Identify whether the viewer of this page is logged-in and, if so, to what account. Creating our app \u00b6 The first step is to create our new Django app . An app in Django can contain pages and mechanisms: your website may contain different apps. Actually, the website provided out-of-the-box by Evennia has already three apps: a \"webclient\" app, to handle the entire webclient, a \"website\" app to contain your basic pages, and a third app provided by Django to create a simple admin interface. So we'll create another app in parallel, giving it a clear name to represent our help system. From your game directory, use the following command: evennia startapp help_system Note: calling the app \"help\" would have been more explicit, but this name is already used by Django. This will create a directory named help_system at the root of your game directory. It's a good idea to keep things organized and move this directory in the \"web\" directory of your game. Your game directory should look like: mygame/ ... web/ help_system/ ... The \"web/help_system\" directory contains files created by Django. We'll use some of them, but if you want to learn more about them all, you should read the Django tutorial . There is a last thing to be done: your folder has been added, but Django doesn't know about it, it doesn't know it's a new app. We need to tell it, and we do so by editing a simple setting. Open your \"server/conf/settings.py\" file and add, or edit, these lines: # Web configuration INSTALLED_APPS += ( \"web.help_system\", ) You can start Evennia if you want, and go to your website, probably at http://localhost:4001 . You won't see anything different though: we added the app but it's fairly empty. Our new page \u00b6 At this point, our new app contains mostly empty files that you can explore. In order to create a page for our help system, we need to add: A view , dealing with the logic of our page. A template to display our new page. A new URL pointing to our page. We could get away by creating just a view and a new URL, but that's not a recommended way to work with your website. Building on templates is so much more convenient. Create a view \u00b6 A view in Django is a simple Python function placed in the \"views.py\" file in your app. It will handle the behavior that is triggered when a user asks for this information by entering a URL (the connection between views and URLs will be discussed later). So let's create our view. You can open the \"web/help_system/view.py\" file and paste the following lines: from django.shortcuts import render def index(request): \"\"\"The 'index' view.\"\"\" return render(request, \"help_system/index.html\") Our view handles all code logic. This time, there's not much: when this function is called, it will render the template we will now create. But that's where we will do most of our work afterward. Create a template \u00b6 The render function called into our view asks the template help_system/index.html . The templates of our apps are stored in the app directory, \"templates\" sub-directory. Django may have created the \"templates\" folder already. If not, create it yourself. In it, create another folder \"help_system\", and inside of this folder, create a file named \"index.html\". Wow, that's some hierarchy. Your directory structure (starting from web ) should look like this: web/ help_system/ ... templates/ help_system/ index.html Open the \"index.html\" file and paste in the following lines: {% extends \"base.html\" %} {% block titleblock %}Help index{% endblock %} {% block content %} <h2>Help index</h2> {% endblock %} Here's a little explanation line by line of what this template does: It loads the \"base.html\" template . This describes the basic structure of all your pages, with a menu at the top and a footer, and perhaps other information like images and things to be present on each page. You can create templates that do not inherit from \"base.html\", but you should have a good reason for doing so. The \"base.html\" template defines all the structure of the page. What is left is to override some sections of our pages. These sections are called blocks . On line 2, we override the block named \"blocktitle\", which contains the title of our page. Same thing here, we override the block named \"content\", which contains the main content of our web page. This block is bigger, so we define it on several lines. This is perfectly normal HTML code to display a level-2 heading. And finally we close the block named \"content\". Create a new URL \u00b6 Last step to add our page: we need to add a URL leading to it... otherwise users won't be able to access it. The URLs of our apps are stored in the app's directory \"urls.py\" file. Open the \"web/help_system/urls.py\" file (you might have to create it) and write in it: # URL patterns for the help_system app from django.conf.urls import url from web.help_system.views import index urlpatterns = [ url(r'^$', index, name=\"index\") ] We also need to add our app as a namespace holder for URLS. Edit the file \"web/urls.py\". In it you will find the custom_patterns variable. Replace it with: custom_patterns = [ url(r'^help/', include('web.help_system.urls', namespace='help_system', app_name='help_system')), ] When a user will ask for a specific URL on your site, Django will: Read the list of custom patterns defined in \"web/urls.py\". There's one pattern here, which describes to Django that all URLs beginning by 'help/' should be sent to the 'help_system' app. The 'help/' part is removed. Then Django will check the \"web.help_system/urls.py\" file. It contains only one URL, which is empty ( ^$ ). In other words, if the URL is '/help/', then Django will execute our defined view. Let's see it work \u00b6 You can now reload or start Evennia. Open a tab in your browser and go to http://localhost:4001/help/ . If everything goes well, you should see your new page... which isn't empty since Evennia uses our \"base.html\" template . In the content of our page, there's only a heading that reads \"help index\". Notice that the title of our page is \"mygame - Help index\" (\"mygame\" is replaced by the name of your game). From now on, it will be easier to move forward and add features. A brief reminder \u00b6 We'll be trying the following things: Have the help of commands and help entries accessed online. Have various commands and help entries depending on whether the user is logged in or not. In terms of pages, we'll have: One to display the list of help topics. One to display the content of a help topic. The first one would link to the second. Should we create two URLs? The answer is... maybe. It depends on what you want to do. We have our help index accessible through the \"/help/\" URL. We could have the detail of a help entry accessible through \"/help/desc\" (to see the detail of the \"desc\" command). The problem is that our commands or help topics may contain special characters that aren't to be present in URLs. There are different ways around this problem. I have decided to use a GET variable here, which would create URLs like this: /help?name=desc If you use this system, you don't have to add a new URL: GET and POST variables are accessible through our requests and we'll see how soon enough. Handling logged-in users \u00b6 One of our requirements is to have a help system tailored to our accounts. If an account with admin access logs in, the page should display a lot of commands that aren't accessible to common users. And perhaps even some additional help topics. Fortunately, it's fairly easy to get the logged in account in our view (remember that we'll do most of our coding there). The request object, passed to our function, contains a user attribute. This attribute will always be there: we cannot test whether it's None or not, for instance. But when the request comes from a user that isn't logged in, the user attribute will contain an anonymous Django user. We then can use the is_anonymous method to see whether the user is logged-in or not. Last gift by Evennia, if the user is logged in, request.user contains a reference to an account object, which will help us a lot in coupling the game and online system. So we might end up with something like: def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.character: character = user.character Note: this code works when your MULTISESSION_MODE is set to 0 or 1. When it's above, you would have something like: def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.db._playable_characters: character = user.db._playable_characters[0] In this second case, it will select the first character of the account. But what if the user's not logged in? Again, we have different solutions. One of the most simple is to create a character that will behave as our default character for the help system. You can create it through your game: connect to it and enter: @charcreate anonymous The system should answer: Created new character anonymous. Use @ic anonymous to enter the game as this character. So in our view, we could have something like this: from typeclasses.characters import Character def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.character: character = user.character else: character = Character.objects.get(db_key=\"anonymous\") This time, we have a valid character no matter what: remember to adapt this code if you're running in multisession mode above 1. The full system \u00b6 What we're going to do is to browse through all commands and help entries, and list all the commands that can be seen by this character (either our 'anonymous' character, or our logged-in character). The code is longer, but it presents the entire concept in our view. Edit the \"web/help_system/views.py\" file and paste into it: from django.http import Http404 from django.shortcuts import render from evennia.help.models import HelpEntry from typeclasses.characters import Character def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.character: character = user.character else: character = Character.objects.get(db_key=\"anonymous\") # Get the categories and topics accessible to this character categories, topics = _get_topics(character) # If we have the 'name' in our GET variable topic = request.GET.get(\"name\") if topic: if topic not in topics: raise Http404(\"This help topic doesn't exist.\") topic = topics[topic] context = { \"character\": character, \"topic\": topic, } return render(request, \"help_system/detail.html\", context) else: context = { \"character\": character, \"categories\": categories, } return render(request, \"help_system/index.html\", context) def _get_topics(character): \"\"\"Return the categories and topics for this character.\"\"\" cmdset = character.cmdset.all()[0] commands = cmdset.commands entries = [entry for entry in HelpEntry.objects.all()] categories = {} topics = {} # Browse commands for command in commands: if not command.auto_help or not command.access(character): continue # Create the template for a command template = { \"name\": command.key, \"category\": command.help_category, \"content\": command.get_help(character, cmdset), } category = command.help_category if category not in categories: categories[category] = [] categories[category].append(template) topics[command.key] = template # Browse through the help entries for entry in entries: if not entry.access(character, 'view', default=True): continue # Create the template for an entry template = { \"name\": entry.key, \"category\": entry.help_category, \"content\": entry.entrytext, } category = entry.help_category if category not in categories: categories[category] = [] categories[category].append(template) topics[entry.key] = template # Sort categories for entries in categories.values(): entries.sort(key=lambda c: c[\"name\"]) categories = list(sorted(categories.items())) return categories, topics That's a bit more complicated here, but all in all, it can be divided in small chunks: The index function is our view: It begins by getting the character as we saw in the previous section. It gets the help topics (commands and help entries) accessible to this character. It's another function that handles that part. If there's a GET variable \"name\" in our URL (like \"/help?name=drop\"), it will retrieve it. If it's not a valid topic's name, it returns a 404 . Otherwise, it renders the template called \"detail.html\", to display the detail of our topic. If there's no GET variable \"name\", render \"index.html\", to display the list of topics. The _get_topics is a private function. Its sole mission is to retrieve the commands a character can execute, and the help entries this same character can see. This code is more Evennia-specific than Django-specific, it will not be detailed in this tutorial. Just notice that all help topics are stored in a dictionary. This is to simplify our job when displaying them in our templates. Notice that, in both cases when we asked to render a template , we passed to render a third argument which is the dictionary of variables used in our templates. We can pass variables this way, and we will use them in our templates. The index template \u00b6 Let's look at our full \"index\" template . You can open the \"web/help_system/templates/help_sstem/index.html\" file and paste the following into it: {% extends \"base.html\" %} {% block titleblock %}Help index{% endblock %} {% block content %} <h2>Help index</h2> {% if categories %} {% for category, topics in categories %} <h2>{{ category|capfirst }}</h2> <table> <tr> {% for topic in topics %} {% if forloop.counter|divisibleby:\"5\" %} </tr> <tr> {% endif %} <td><a href=\"{% url 'help_system:index' %}?name={{ topic.name|urlencode }}\"> {{ topic.name }}</td> {% endfor %} </tr> </table> {% endfor %} {% endif %} {% endblock %} This template is definitely more detailed. What it does is: Browse through all categories. For all categories, display a level-2 heading with the name of the category. All topics in a category (remember, they can be either commands or help entries) are displayed in a table. The trickier part may be that, when the loop is above 5, it will create a new line. The table will have 5 columns at the most per row. For every cell in the table, we create a link redirecting to the detail page (see below). The URL would look something like \"help?name=say\". We use urlencode to ensure special characters are properly escaped. The detail template \u00b6 It's now time to show the detail of a topic (command or help entry). You can create the file \"web/help_system/templates/help_system/detail.html\". You can paste into it the following code: {% extends \"base.html\" %} {% block titleblock %}Help for {{ topic.name }}{% endblock %} {% block content %} <h2>{{ topic.name|capfirst }} help topic</h2> <p>Category: {{ topic.category|capfirst }}</p> {{ topic.content|linebreaks }} {% endblock %} This template is much easier to read. Some filters might be unknown to you, but they are just used to format here. Put it all together \u00b6 Remember to reload or start Evennia, and then go to http://localhost:4001/help . You should see the list of commands and topics accessible by all characters. Try to login (click the \"login\" link in the menu of your website) and go to the same page again. You should now see a more detailed list of commands and help entries. Click on one to see its detail. To improve this feature \u00b6 As always, a tutorial is here to help you feel comfortable adding new features and code by yourself. Here are some ideas of things to improve this little feature: Links at the bottom of the detail template to go back to the index might be useful. A link in the main menu to link to this page would be great... for the time being you have to enter the URL, users won't guess it's there. Colors aren't handled at this point, which isn't exactly surprising. You could add it though. Linking help entries between one another won't be simple, but it would be great. For instance, if you see a help entry about how to use several commands, it would be great if these commands were themselves links to display their details.","title":"Help System Tutorial"},{"location":"Help-System-Tutorial.html#creating-our-app","text":"The first step is to create our new Django app . An app in Django can contain pages and mechanisms: your website may contain different apps. Actually, the website provided out-of-the-box by Evennia has already three apps: a \"webclient\" app, to handle the entire webclient, a \"website\" app to contain your basic pages, and a third app provided by Django to create a simple admin interface. So we'll create another app in parallel, giving it a clear name to represent our help system. From your game directory, use the following command: evennia startapp help_system Note: calling the app \"help\" would have been more explicit, but this name is already used by Django. This will create a directory named help_system at the root of your game directory. It's a good idea to keep things organized and move this directory in the \"web\" directory of your game. Your game directory should look like: mygame/ ... web/ help_system/ ... The \"web/help_system\" directory contains files created by Django. We'll use some of them, but if you want to learn more about them all, you should read the Django tutorial . There is a last thing to be done: your folder has been added, but Django doesn't know about it, it doesn't know it's a new app. We need to tell it, and we do so by editing a simple setting. Open your \"server/conf/settings.py\" file and add, or edit, these lines: # Web configuration INSTALLED_APPS += ( \"web.help_system\", ) You can start Evennia if you want, and go to your website, probably at http://localhost:4001 . You won't see anything different though: we added the app but it's fairly empty.","title":"Creating our app"},{"location":"Help-System-Tutorial.html#our-new-page","text":"At this point, our new app contains mostly empty files that you can explore. In order to create a page for our help system, we need to add: A view , dealing with the logic of our page. A template to display our new page. A new URL pointing to our page. We could get away by creating just a view and a new URL, but that's not a recommended way to work with your website. Building on templates is so much more convenient.","title":"Our new page"},{"location":"Help-System-Tutorial.html#create-a-view","text":"A view in Django is a simple Python function placed in the \"views.py\" file in your app. It will handle the behavior that is triggered when a user asks for this information by entering a URL (the connection between views and URLs will be discussed later). So let's create our view. You can open the \"web/help_system/view.py\" file and paste the following lines: from django.shortcuts import render def index(request): \"\"\"The 'index' view.\"\"\" return render(request, \"help_system/index.html\") Our view handles all code logic. This time, there's not much: when this function is called, it will render the template we will now create. But that's where we will do most of our work afterward.","title":"Create a view"},{"location":"Help-System-Tutorial.html#create-a-template","text":"The render function called into our view asks the template help_system/index.html . The templates of our apps are stored in the app directory, \"templates\" sub-directory. Django may have created the \"templates\" folder already. If not, create it yourself. In it, create another folder \"help_system\", and inside of this folder, create a file named \"index.html\". Wow, that's some hierarchy. Your directory structure (starting from web ) should look like this: web/ help_system/ ... templates/ help_system/ index.html Open the \"index.html\" file and paste in the following lines: {% extends \"base.html\" %} {% block titleblock %}Help index{% endblock %} {% block content %} <h2>Help index</h2> {% endblock %} Here's a little explanation line by line of what this template does: It loads the \"base.html\" template . This describes the basic structure of all your pages, with a menu at the top and a footer, and perhaps other information like images and things to be present on each page. You can create templates that do not inherit from \"base.html\", but you should have a good reason for doing so. The \"base.html\" template defines all the structure of the page. What is left is to override some sections of our pages. These sections are called blocks . On line 2, we override the block named \"blocktitle\", which contains the title of our page. Same thing here, we override the block named \"content\", which contains the main content of our web page. This block is bigger, so we define it on several lines. This is perfectly normal HTML code to display a level-2 heading. And finally we close the block named \"content\".","title":"Create a template"},{"location":"Help-System-Tutorial.html#create-a-new-url","text":"Last step to add our page: we need to add a URL leading to it... otherwise users won't be able to access it. The URLs of our apps are stored in the app's directory \"urls.py\" file. Open the \"web/help_system/urls.py\" file (you might have to create it) and write in it: # URL patterns for the help_system app from django.conf.urls import url from web.help_system.views import index urlpatterns = [ url(r'^$', index, name=\"index\") ] We also need to add our app as a namespace holder for URLS. Edit the file \"web/urls.py\". In it you will find the custom_patterns variable. Replace it with: custom_patterns = [ url(r'^help/', include('web.help_system.urls', namespace='help_system', app_name='help_system')), ] When a user will ask for a specific URL on your site, Django will: Read the list of custom patterns defined in \"web/urls.py\". There's one pattern here, which describes to Django that all URLs beginning by 'help/' should be sent to the 'help_system' app. The 'help/' part is removed. Then Django will check the \"web.help_system/urls.py\" file. It contains only one URL, which is empty ( ^$ ). In other words, if the URL is '/help/', then Django will execute our defined view.","title":"Create a new URL"},{"location":"Help-System-Tutorial.html#lets-see-it-work","text":"You can now reload or start Evennia. Open a tab in your browser and go to http://localhost:4001/help/ . If everything goes well, you should see your new page... which isn't empty since Evennia uses our \"base.html\" template . In the content of our page, there's only a heading that reads \"help index\". Notice that the title of our page is \"mygame - Help index\" (\"mygame\" is replaced by the name of your game). From now on, it will be easier to move forward and add features.","title":"Let's see it work"},{"location":"Help-System-Tutorial.html#a-brief-reminder","text":"We'll be trying the following things: Have the help of commands and help entries accessed online. Have various commands and help entries depending on whether the user is logged in or not. In terms of pages, we'll have: One to display the list of help topics. One to display the content of a help topic. The first one would link to the second. Should we create two URLs? The answer is... maybe. It depends on what you want to do. We have our help index accessible through the \"/help/\" URL. We could have the detail of a help entry accessible through \"/help/desc\" (to see the detail of the \"desc\" command). The problem is that our commands or help topics may contain special characters that aren't to be present in URLs. There are different ways around this problem. I have decided to use a GET variable here, which would create URLs like this: /help?name=desc If you use this system, you don't have to add a new URL: GET and POST variables are accessible through our requests and we'll see how soon enough.","title":"A brief reminder"},{"location":"Help-System-Tutorial.html#handling-logged-in-users","text":"One of our requirements is to have a help system tailored to our accounts. If an account with admin access logs in, the page should display a lot of commands that aren't accessible to common users. And perhaps even some additional help topics. Fortunately, it's fairly easy to get the logged in account in our view (remember that we'll do most of our coding there). The request object, passed to our function, contains a user attribute. This attribute will always be there: we cannot test whether it's None or not, for instance. But when the request comes from a user that isn't logged in, the user attribute will contain an anonymous Django user. We then can use the is_anonymous method to see whether the user is logged-in or not. Last gift by Evennia, if the user is logged in, request.user contains a reference to an account object, which will help us a lot in coupling the game and online system. So we might end up with something like: def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.character: character = user.character Note: this code works when your MULTISESSION_MODE is set to 0 or 1. When it's above, you would have something like: def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.db._playable_characters: character = user.db._playable_characters[0] In this second case, it will select the first character of the account. But what if the user's not logged in? Again, we have different solutions. One of the most simple is to create a character that will behave as our default character for the help system. You can create it through your game: connect to it and enter: @charcreate anonymous The system should answer: Created new character anonymous. Use @ic anonymous to enter the game as this character. So in our view, we could have something like this: from typeclasses.characters import Character def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.character: character = user.character else: character = Character.objects.get(db_key=\"anonymous\") This time, we have a valid character no matter what: remember to adapt this code if you're running in multisession mode above 1.","title":"Handling logged-in users"},{"location":"Help-System-Tutorial.html#the-full-system","text":"What we're going to do is to browse through all commands and help entries, and list all the commands that can be seen by this character (either our 'anonymous' character, or our logged-in character). The code is longer, but it presents the entire concept in our view. Edit the \"web/help_system/views.py\" file and paste into it: from django.http import Http404 from django.shortcuts import render from evennia.help.models import HelpEntry from typeclasses.characters import Character def index(request): \"\"\"The 'index' view.\"\"\" user = request.user if not user.is_anonymous() and user.character: character = user.character else: character = Character.objects.get(db_key=\"anonymous\") # Get the categories and topics accessible to this character categories, topics = _get_topics(character) # If we have the 'name' in our GET variable topic = request.GET.get(\"name\") if topic: if topic not in topics: raise Http404(\"This help topic doesn't exist.\") topic = topics[topic] context = { \"character\": character, \"topic\": topic, } return render(request, \"help_system/detail.html\", context) else: context = { \"character\": character, \"categories\": categories, } return render(request, \"help_system/index.html\", context) def _get_topics(character): \"\"\"Return the categories and topics for this character.\"\"\" cmdset = character.cmdset.all()[0] commands = cmdset.commands entries = [entry for entry in HelpEntry.objects.all()] categories = {} topics = {} # Browse commands for command in commands: if not command.auto_help or not command.access(character): continue # Create the template for a command template = { \"name\": command.key, \"category\": command.help_category, \"content\": command.get_help(character, cmdset), } category = command.help_category if category not in categories: categories[category] = [] categories[category].append(template) topics[command.key] = template # Browse through the help entries for entry in entries: if not entry.access(character, 'view', default=True): continue # Create the template for an entry template = { \"name\": entry.key, \"category\": entry.help_category, \"content\": entry.entrytext, } category = entry.help_category if category not in categories: categories[category] = [] categories[category].append(template) topics[entry.key] = template # Sort categories for entries in categories.values(): entries.sort(key=lambda c: c[\"name\"]) categories = list(sorted(categories.items())) return categories, topics That's a bit more complicated here, but all in all, it can be divided in small chunks: The index function is our view: It begins by getting the character as we saw in the previous section. It gets the help topics (commands and help entries) accessible to this character. It's another function that handles that part. If there's a GET variable \"name\" in our URL (like \"/help?name=drop\"), it will retrieve it. If it's not a valid topic's name, it returns a 404 . Otherwise, it renders the template called \"detail.html\", to display the detail of our topic. If there's no GET variable \"name\", render \"index.html\", to display the list of topics. The _get_topics is a private function. Its sole mission is to retrieve the commands a character can execute, and the help entries this same character can see. This code is more Evennia-specific than Django-specific, it will not be detailed in this tutorial. Just notice that all help topics are stored in a dictionary. This is to simplify our job when displaying them in our templates. Notice that, in both cases when we asked to render a template , we passed to render a third argument which is the dictionary of variables used in our templates. We can pass variables this way, and we will use them in our templates.","title":"The full system"},{"location":"Help-System-Tutorial.html#the-index-template","text":"Let's look at our full \"index\" template . You can open the \"web/help_system/templates/help_sstem/index.html\" file and paste the following into it: {% extends \"base.html\" %} {% block titleblock %}Help index{% endblock %} {% block content %} <h2>Help index</h2> {% if categories %} {% for category, topics in categories %} <h2>{{ category|capfirst }}</h2> <table> <tr> {% for topic in topics %} {% if forloop.counter|divisibleby:\"5\" %} </tr> <tr> {% endif %} <td><a href=\"{% url 'help_system:index' %}?name={{ topic.name|urlencode }}\"> {{ topic.name }}</td> {% endfor %} </tr> </table> {% endfor %} {% endif %} {% endblock %} This template is definitely more detailed. What it does is: Browse through all categories. For all categories, display a level-2 heading with the name of the category. All topics in a category (remember, they can be either commands or help entries) are displayed in a table. The trickier part may be that, when the loop is above 5, it will create a new line. The table will have 5 columns at the most per row. For every cell in the table, we create a link redirecting to the detail page (see below). The URL would look something like \"help?name=say\". We use urlencode to ensure special characters are properly escaped.","title":"The index template"},{"location":"Help-System-Tutorial.html#the-detail-template","text":"It's now time to show the detail of a topic (command or help entry). You can create the file \"web/help_system/templates/help_system/detail.html\". You can paste into it the following code: {% extends \"base.html\" %} {% block titleblock %}Help for {{ topic.name }}{% endblock %} {% block content %} <h2>{{ topic.name|capfirst }} help topic</h2> <p>Category: {{ topic.category|capfirst }}</p> {{ topic.content|linebreaks }} {% endblock %} This template is much easier to read. Some filters might be unknown to you, but they are just used to format here.","title":"The detail template"},{"location":"Help-System-Tutorial.html#put-it-all-together","text":"Remember to reload or start Evennia, and then go to http://localhost:4001/help . You should see the list of commands and topics accessible by all characters. Try to login (click the \"login\" link in the menu of your website) and go to the same page again. You should now see a more detailed list of commands and help entries. Click on one to see its detail.","title":"Put it all together"},{"location":"Help-System-Tutorial.html#to-improve-this-feature","text":"As always, a tutorial is here to help you feel comfortable adding new features and code by yourself. Here are some ideas of things to improve this little feature: Links at the bottom of the detail template to go back to the index might be useful. A link in the main menu to link to this page would be great... for the time being you have to enter the URL, users won't guess it's there. Colors aren't handled at this point, which isn't exactly surprising. You could add it though. Linking help entries between one another won't be simple, but it would be great. For instance, if you see a help entry about how to use several commands, it would be great if these commands were themselves links to display their details.","title":"To improve this feature"},{"location":"Help-System.html","text":"An important part of Evennia is the online help system. This allows the players and staff alike to learn how to use the game's commands as well as other information pertinent to the game. The help system has many different aspects, from the normal editing of help entries from inside the game, to auto-generated help entries during code development using the auto-help system . Viewing the help database \u00b6 The main command is help : help [searchstring] This will show a list of help entries, ordered after categories. You will find two sections, Command help entries and Other help entries (initially you will only have the first one). You can use help to get more info about an entry; you can also give partial matches to get suggestions. If you give category names you will only be shown the topics in that category. Command Auto-help system \u00b6 A common item that requires help entries are in-game commands. Keeping these entries up-to-date with the actual source code functionality can be a chore. Evennia's commands are therefore auto-documenting straight from the sources through its auto-help system . Only commands that you and your character can actually currently use are picked up by the auto-help system. That means an admin will see a considerably larger amount of help topics than a normal player when using the default help command. The auto-help system uses the __doc__ strings of your command classes and formats this to a nice-looking help entry. This makes for a very easy way to keep the help updated - just document your commands well and updating the help file is just a @reload away. There is no need to manually create and maintain help database entries for commands; as long as you keep the docstrings updated your help will be dynamically updated for you as well. Example (from a module with command definitions): class CmdMyCmd(Command): \"\"\" mycmd - my very own command Usage: mycmd[/switches] <args> Switches: test - test the command run - do something else This is my own command that does this and that. \"\"\" # [...] help_category = \"General\" # default auto_help = True # default # [...] The text at the very top of the command class definition is the class' __doc__ -string and will be shown to users looking for help. Try to use a consistent format - all default commands are using the structure shown above. You should also supply the help_category class property if you can; this helps to group help entries together for people to more easily find them. See the help command in-game to see the default categories. If you don't specify the category, \"General\" is assumed. If you don't want your command to be picked up by the auto-help system at all (like if you want to write its docs manually using the info in the next section or you use a cmdset that has its own help functionality) you can explicitly set auto_help class property to False in your command definition. Alternatively, you can keep the advantages of auto-help in commands, but control the display of command helps. You can do so by overriding the command's get_help() method. By default, this method will return the class docstring. You could modify it to add custom behavior: the text returned by this method will be displayed to the character asking for help in this command. Database help entries \u00b6 These are all help entries not involving commands (this is handled automatically by the Command Auto-help system ). Non-automatic help entries describe how your particular game is played - its rules, world descriptions and so on. A help entry consists of four parts: The topic . This is the name of the help entry. This is what players search for when they are looking for help. The topic can contain spaces and also partial matches will be found. The help category . Examples are Administration , Building , Comms or General . This is an overall grouping of similar help topics, used by the engine to give a better overview. The text - the help text itself, of any length. locks - a lock definition . This can be used to limit access to this help entry, maybe because it's staff-only or otherwise meant to be restricted. Help commands check for access_type s view and edit . An example of a lock string would be view:perm(Builders) . You can create new help entries in code by using evennia.create_help_entry() . from evennia import create_help_entry entry = create_help_entry(\"emote\", \"Emoting is important because ...\", category=\"Roleplaying\", locks=\"view:all()\") From inside the game those with the right permissions can use the @sethelp command to add and modify help entries. > @sethelp/add emote = The emote command is ... Using @sethelp you can add, delete and append text to existing entries. By default new entries will go in the General help category. You can change this using a different form of the @sethelp command: > @sethelp/add emote, Roleplaying = Emoting is important because ... If the category Roleplaying did not already exist, it is created and will appear in the help index. You can, finally, define a lock for the help entry by following the category with a lock definition : > @sethelp/add emote, Roleplaying, view:all() = Emoting is ...","title":"Help System"},{"location":"Help-System.html#viewing-the-help-database","text":"The main command is help : help [searchstring] This will show a list of help entries, ordered after categories. You will find two sections, Command help entries and Other help entries (initially you will only have the first one). You can use help to get more info about an entry; you can also give partial matches to get suggestions. If you give category names you will only be shown the topics in that category.","title":"Viewing the help database"},{"location":"Help-System.html#command-auto-help-system","text":"A common item that requires help entries are in-game commands. Keeping these entries up-to-date with the actual source code functionality can be a chore. Evennia's commands are therefore auto-documenting straight from the sources through its auto-help system . Only commands that you and your character can actually currently use are picked up by the auto-help system. That means an admin will see a considerably larger amount of help topics than a normal player when using the default help command. The auto-help system uses the __doc__ strings of your command classes and formats this to a nice-looking help entry. This makes for a very easy way to keep the help updated - just document your commands well and updating the help file is just a @reload away. There is no need to manually create and maintain help database entries for commands; as long as you keep the docstrings updated your help will be dynamically updated for you as well. Example (from a module with command definitions): class CmdMyCmd(Command): \"\"\" mycmd - my very own command Usage: mycmd[/switches] <args> Switches: test - test the command run - do something else This is my own command that does this and that. \"\"\" # [...] help_category = \"General\" # default auto_help = True # default # [...] The text at the very top of the command class definition is the class' __doc__ -string and will be shown to users looking for help. Try to use a consistent format - all default commands are using the structure shown above. You should also supply the help_category class property if you can; this helps to group help entries together for people to more easily find them. See the help command in-game to see the default categories. If you don't specify the category, \"General\" is assumed. If you don't want your command to be picked up by the auto-help system at all (like if you want to write its docs manually using the info in the next section or you use a cmdset that has its own help functionality) you can explicitly set auto_help class property to False in your command definition. Alternatively, you can keep the advantages of auto-help in commands, but control the display of command helps. You can do so by overriding the command's get_help() method. By default, this method will return the class docstring. You could modify it to add custom behavior: the text returned by this method will be displayed to the character asking for help in this command.","title":"Command Auto-help system"},{"location":"Help-System.html#database-help-entries","text":"These are all help entries not involving commands (this is handled automatically by the Command Auto-help system ). Non-automatic help entries describe how your particular game is played - its rules, world descriptions and so on. A help entry consists of four parts: The topic . This is the name of the help entry. This is what players search for when they are looking for help. The topic can contain spaces and also partial matches will be found. The help category . Examples are Administration , Building , Comms or General . This is an overall grouping of similar help topics, used by the engine to give a better overview. The text - the help text itself, of any length. locks - a lock definition . This can be used to limit access to this help entry, maybe because it's staff-only or otherwise meant to be restricted. Help commands check for access_type s view and edit . An example of a lock string would be view:perm(Builders) . You can create new help entries in code by using evennia.create_help_entry() . from evennia import create_help_entry entry = create_help_entry(\"emote\", \"Emoting is important because ...\", category=\"Roleplaying\", locks=\"view:all()\") From inside the game those with the right permissions can use the @sethelp command to add and modify help entries. > @sethelp/add emote = The emote command is ... Using @sethelp you can add, delete and append text to existing entries. By default new entries will go in the General help category. You can change this using a different form of the @sethelp command: > @sethelp/add emote, Roleplaying = Emoting is important because ... If the category Roleplaying did not already exist, it is created and will appear in the help index. You can, finally, define a lock for the help entry by following the category with a lock definition : > @sethelp/add emote, Roleplaying, view:all() = Emoting is ...","title":"Database help entries"},{"location":"Home.html","text":"Evennia Documentation \u00b6 This is the manual of Evennia , the open source Python MU* creation system. You can Search the documentation as well as browse all pages alphabetically in the Index . If you have trouble with unclear documentation, please let us know on our mailing list , over IRC or by dropping a note in our quick no-registration online suggestion box ! There is a lengthier introduction to read. You might also want to read about how to get and give help . Getting Started Admin Docs Builder Docs Developer Central Tutorials & Examples API The Getting Started page helps installing and starting Evennia for the first time. The Admin Docs covers running and maintaining an Evennia server. The Builder Docs helps for starting to build a game world using Evennia. The Developer Central describes how Evennia works and is used by coders. The Tutorials & Examples contains help pages on a step-by-step or tutorial format. The API documentation is created from the latest source code.","title":"Home"},{"location":"Home.html#evennia-documentation","text":"This is the manual of Evennia , the open source Python MU* creation system. You can Search the documentation as well as browse all pages alphabetically in the Index . If you have trouble with unclear documentation, please let us know on our mailing list , over IRC or by dropping a note in our quick no-registration online suggestion box ! There is a lengthier introduction to read. You might also want to read about how to get and give help . Getting Started Admin Docs Builder Docs Developer Central Tutorials & Examples API The Getting Started page helps installing and starting Evennia for the first time. The Admin Docs covers running and maintaining an Evennia server. The Builder Docs helps for starting to build a game world using Evennia. The Developer Central describes how Evennia works and is used by coders. The Tutorials & Examples contains help pages on a step-by-step or tutorial format. The API documentation is created from the latest source code.","title":"Evennia Documentation"},{"location":"How-To-Get-And-Give-Help.html","text":"How to get Help \u00b6 If you cannot find what you are looking for in the online documentation , here's what to do: If you think the documentation is not clear enough and are short on time, fill in our quick little online form and let us know - no login required. Maybe the docs need to be improved or a new tutorial added! Note that while this form is useful as a suggestion box we cannot answer questions or reply to you. Use the discussion group or chat (linked below) if you want feedback. If you have trouble with a missing feature or a problem you think is a bug, go to the issue tracker and search to see if has been reported/suggested already. If you can't find an existing entry create a new one. If you need help, want to start a discussion or get some input on something you are working on, make a post to the discussions group This is technically a 'mailing list', but you don't need to use e-mail; you can post and read all messages just as easily from your browser via the online interface. If you want more direct discussions with developers and other users, consider dropping into our IRC chat channel #evennia on the Freenode network. Please note however that you have to be patient if you don't get any response immediately; we are all in very different time zones and many have busy personal lives. So you might have to hang around for a while - you'll get noticed eventually! How to give Help \u00b6 Evennia is a completely non-funded project. It relies on the time donated by its users and developers in order to progress. The first and easiest way you as a user can help us out is by taking part in community discussions and by giving feedback on what is good or bad. Report bugs you find and features you lack to our issue tracker . Just the simple act of letting developers know you are out there using their program is worth a lot. Generally mentioning and reviewing Evennia elsewhere is also a nice way to spread the word. If you'd like to help develop Evennia more hands-on, here are some ways to get going: Look through our online documentation wiki and see if you can help improve or expand the documentation (even small things like fixing typos!). You don't need any particular permissions to edit the wiki. Send a message to our discussion group and/or our IRC chat asking about what needs doing, along with what your interests and skills are. Take a look at our issue tracker and see if there's something you feel like taking on. here are bugs that need fixes. At any given time there may also be some bounties open - these are issues members of the community has put up money to see fixed (if you want to put up a bounty yourself you can do so via our page on bountysource ). Check out the Contributing page on how to practically contribute with code using github. ... And finally, if you want to help motivate and support development you can also drop some coins in the developer's cup. You can make a donation via PayPal or, even better, become an Evennia patron on Patreon ! This is a great way to tip your hat and show that you appreciate the work done with the server! Finally, if you want to encourage the community to resolve a particular","title":"How To Get And Give Help"},{"location":"How-To-Get-And-Give-Help.html#how-to-get-help","text":"If you cannot find what you are looking for in the online documentation , here's what to do: If you think the documentation is not clear enough and are short on time, fill in our quick little online form and let us know - no login required. Maybe the docs need to be improved or a new tutorial added! Note that while this form is useful as a suggestion box we cannot answer questions or reply to you. Use the discussion group or chat (linked below) if you want feedback. If you have trouble with a missing feature or a problem you think is a bug, go to the issue tracker and search to see if has been reported/suggested already. If you can't find an existing entry create a new one. If you need help, want to start a discussion or get some input on something you are working on, make a post to the discussions group This is technically a 'mailing list', but you don't need to use e-mail; you can post and read all messages just as easily from your browser via the online interface. If you want more direct discussions with developers and other users, consider dropping into our IRC chat channel #evennia on the Freenode network. Please note however that you have to be patient if you don't get any response immediately; we are all in very different time zones and many have busy personal lives. So you might have to hang around for a while - you'll get noticed eventually!","title":"How to get Help"},{"location":"How-To-Get-And-Give-Help.html#how-to-give-help","text":"Evennia is a completely non-funded project. It relies on the time donated by its users and developers in order to progress. The first and easiest way you as a user can help us out is by taking part in community discussions and by giving feedback on what is good or bad. Report bugs you find and features you lack to our issue tracker . Just the simple act of letting developers know you are out there using their program is worth a lot. Generally mentioning and reviewing Evennia elsewhere is also a nice way to spread the word. If you'd like to help develop Evennia more hands-on, here are some ways to get going: Look through our online documentation wiki and see if you can help improve or expand the documentation (even small things like fixing typos!). You don't need any particular permissions to edit the wiki. Send a message to our discussion group and/or our IRC chat asking about what needs doing, along with what your interests and skills are. Take a look at our issue tracker and see if there's something you feel like taking on. here are bugs that need fixes. At any given time there may also be some bounties open - these are issues members of the community has put up money to see fixed (if you want to put up a bounty yourself you can do so via our page on bountysource ). Check out the Contributing page on how to practically contribute with code using github. ... And finally, if you want to help motivate and support development you can also drop some coins in the developer's cup. You can make a donation via PayPal or, even better, become an Evennia patron on Patreon ! This is a great way to tip your hat and show that you appreciate the work done with the server! Finally, if you want to encourage the community to resolve a particular","title":"How to give Help"},{"location":"How-to-connect-Evennia-to-Twitter.html","text":"Twitter is an online social networking service that enables users to send and read short 280-character messages called \"tweets\". Following is a short tutorial explaining how to enable users to send tweets from inside Evennia. Configuring Twitter \u00b6 You must first have a Twitter account. Log in and register an App at the Twitter Dev Site . Make sure you enable access to \"write\" tweets! To tweet from Evennia you will need both the \"API Token\" and the \"API secret\" strings as well as the \"Access Token\" and \"Access Secret\" strings. Twitter changed their requirements to require a Mobile number on the Twitter account to register new apps with write access. If you're unable to do this, please see this Dev post which describes how to get around it. Install the twitter python module \u00b6 To use Twitter you must install the Twitter Python module: pip install python-twitter A basic tweet command \u00b6 Evennia doesn't have a tweet command out of the box so you need to write your own little Command in order to tweet. If you are unsure about how commands work and how to add them, it can be an idea to go through the Adding a Command Tutorial before continuing. You can create the command in a separate command module (something like mygame/commands/tweet.py ) or together with your other custom commands, as you prefer. This is how it can look: import twitter from evennia import Command # here you insert your unique App tokens # from the Twitter dev site TWITTER_API = twitter.Api(consumer_key='api_key', consumer_secret='api_secret', access_token_key='access_token_key', access_token_secret='access_token_secret') class CmdTweet(Command): \"\"\" Tweet a message Usage: tweet <message> This will send a Twitter tweet to a pre-configured Twitter account. A tweet has a maximum length of 280 characters. \"\"\" key = \"tweet\" locks = \"cmd:pperm(tweet) or pperm(Developers)\" help_category = \"Comms\" def func(self): \"This performs the tweet\" caller = self.caller tweet = self.args if not tweet: caller.msg(\"Usage: tweet <message>\") return tlen = len(tweet) if tlen > 280: caller.msg(\"Your tweet was %i chars long (max 280).\" % tlen) return # post the tweet TWITTER_API.PostUpdate(tweet) caller.msg(\"You tweeted:\\n%s\" % tweet) Be sure to substitute your own actual API/Access keys and secrets in the appropriate places. We default to limiting tweet access to players with Developers -level access or to those players that have the permission \"tweet\" (allow individual characters to tweet with @perm/player playername = tweet ). You may change the lock as you feel is appropriate. Change the overall permission to Players if you want everyone to be able to tweet. Now add this command to your default command set (e.g in mygame/commands/defalt_cmdsets.py \") and reload the server. From now on those with access can simply use tweet <message> to see the tweet posted from the game's Twitter account. Next Steps \u00b6 This shows only a basic tweet setup, other things to do could be: Auto-Adding the character name to the tweet More error-checking of postings Changing locks to make tweeting open to more people Echo your tweets to an in-game channel Rather than using an explicit command you can set up a Script to send automatic tweets, for example to post updated game stats. See the Tweeting Game Stats tutorial for help.","title":"How to connect Evennia to Twitter"},{"location":"How-to-connect-Evennia-to-Twitter.html#configuring-twitter","text":"You must first have a Twitter account. Log in and register an App at the Twitter Dev Site . Make sure you enable access to \"write\" tweets! To tweet from Evennia you will need both the \"API Token\" and the \"API secret\" strings as well as the \"Access Token\" and \"Access Secret\" strings. Twitter changed their requirements to require a Mobile number on the Twitter account to register new apps with write access. If you're unable to do this, please see this Dev post which describes how to get around it.","title":"Configuring Twitter"},{"location":"How-to-connect-Evennia-to-Twitter.html#install-the-twitter-python-module","text":"To use Twitter you must install the Twitter Python module: pip install python-twitter","title":"Install the twitter python module"},{"location":"How-to-connect-Evennia-to-Twitter.html#a-basic-tweet-command","text":"Evennia doesn't have a tweet command out of the box so you need to write your own little Command in order to tweet. If you are unsure about how commands work and how to add them, it can be an idea to go through the Adding a Command Tutorial before continuing. You can create the command in a separate command module (something like mygame/commands/tweet.py ) or together with your other custom commands, as you prefer. This is how it can look: import twitter from evennia import Command # here you insert your unique App tokens # from the Twitter dev site TWITTER_API = twitter.Api(consumer_key='api_key', consumer_secret='api_secret', access_token_key='access_token_key', access_token_secret='access_token_secret') class CmdTweet(Command): \"\"\" Tweet a message Usage: tweet <message> This will send a Twitter tweet to a pre-configured Twitter account. A tweet has a maximum length of 280 characters. \"\"\" key = \"tweet\" locks = \"cmd:pperm(tweet) or pperm(Developers)\" help_category = \"Comms\" def func(self): \"This performs the tweet\" caller = self.caller tweet = self.args if not tweet: caller.msg(\"Usage: tweet <message>\") return tlen = len(tweet) if tlen > 280: caller.msg(\"Your tweet was %i chars long (max 280).\" % tlen) return # post the tweet TWITTER_API.PostUpdate(tweet) caller.msg(\"You tweeted:\\n%s\" % tweet) Be sure to substitute your own actual API/Access keys and secrets in the appropriate places. We default to limiting tweet access to players with Developers -level access or to those players that have the permission \"tweet\" (allow individual characters to tweet with @perm/player playername = tweet ). You may change the lock as you feel is appropriate. Change the overall permission to Players if you want everyone to be able to tweet. Now add this command to your default command set (e.g in mygame/commands/defalt_cmdsets.py \") and reload the server. From now on those with access can simply use tweet <message> to see the tweet posted from the game's Twitter account.","title":"A basic tweet command"},{"location":"How-to-connect-Evennia-to-Twitter.html#next-steps","text":"This shows only a basic tweet setup, other things to do could be: Auto-Adding the character name to the tweet More error-checking of postings Changing locks to make tweeting open to more people Echo your tweets to an in-game channel Rather than using an explicit command you can set up a Script to send automatic tweets, for example to post updated game stats. See the Tweeting Game Stats tutorial for help.","title":"Next Steps"},{"location":"IRC.html","text":"IRC (Internet Relay Chat) is a long standing chat protocol used by many open-source projects for communicating in real time. By connecting one of Evennia's Channels to an IRC channel you can communicate also with people not on an mud themselves. You can also use IRC if you are only running your Evennia MUD locally on your computer (your game doesn't need to be open to the public)! All you need is an internet connection. For IRC operation you also need twisted.words . This is available simply as a package python-twisted-words in many Linux distros, or directly downloadable from the link. Configuring IRC \u00b6 To configure IRC, you'll need to activate it in your settings file. IRC_ENABLED = True Start Evennia and log in as a privileged user. You should now have a new command available: @irc2chan . This command is called like this: @irc2chan[/switches] <evennia_channel> = <ircnetwork> <port> <#irchannel> <botname> If you already know how IRC works, this should be pretty self-evident to use. Read the help entry for more features. Setting up IRC, step by step \u00b6 You can connect IRC to any Evennia channel (so you could connect it to the default public channel if you like), but for testing, let's set up a new channel irc . @ccreate irc = This is connected to an irc channel! You will automatically join the new channel. Next we will create a connection to an external IRC network and channel. There are many, many IRC nets. Here is a list of some of the biggest ones, the one you choose is not really very important unless you want to connect to a particular channel (also make sure that the network allows for \"bots\" to connect). For testing, we choose the Freenode network, irc.freenode.net . We will connect to a test channel, let's call it #myevennia-test (an IRC channel always begins with # ). It's best if you pick an obscure channel name that didn't exist previously - if it didn't exist it will be created for you. Don't connect to #evennia for testing and debugging, that is Evennia's official chat channel! You are welcome to connect your game to #evennia once you have everything working though - it can be a good way to get help and ideas. But if you do, please do so with an in-game channel open only to your game admins and developers). The port needed depends on the network. For Freenode this is 6667 . What will happen is that your Evennia server will connect to this IRC channel as a normal user. This \"user\" (or \"bot\") needs a name, which you must also supply. Let's call it \"mud-bot\". To test that the bot connects correctly you also want to log onto this channel with a separate, third-party IRC client. There are hundreds of such clients available. If you use Firefox, the Chatzilla plugin is good and easy. Freenode also offers its own web-based chat page. Once you have connected to a network, the command to join is usually /join #channelname (don't forget the #). Next we connect Evennia with the IRC channel. @irc2chan irc = irc.freenode.net 6667 #myevennia-test mud-bot Evennia will now create a new IRC bot mud-bot and connect it to the IRC network and the channel #myevennia. If you are connected to the IRC channel you will soon see the user mud-bot connect. Write something in the Evennia channel irc . irc Hello, World! [irc] Anna: Hello, World! If you are viewing your IRC channel with a separate IRC client you should see your text appearing there, spoken by the bot: mud-bot> [irc] Anna: Hello, World! Write Hello! in your IRC client window and it will appear in your normal channel, marked with the name of the IRC channel you used (#evennia here). [irc] Anna@#myevennia-test: Hello! Your Evennia gamers can now chat with users on external IRC channels!","title":"IRC"},{"location":"IRC.html#configuring-irc","text":"To configure IRC, you'll need to activate it in your settings file. IRC_ENABLED = True Start Evennia and log in as a privileged user. You should now have a new command available: @irc2chan . This command is called like this: @irc2chan[/switches] <evennia_channel> = <ircnetwork> <port> <#irchannel> <botname> If you already know how IRC works, this should be pretty self-evident to use. Read the help entry for more features.","title":"Configuring IRC"},{"location":"IRC.html#setting-up-irc-step-by-step","text":"You can connect IRC to any Evennia channel (so you could connect it to the default public channel if you like), but for testing, let's set up a new channel irc . @ccreate irc = This is connected to an irc channel! You will automatically join the new channel. Next we will create a connection to an external IRC network and channel. There are many, many IRC nets. Here is a list of some of the biggest ones, the one you choose is not really very important unless you want to connect to a particular channel (also make sure that the network allows for \"bots\" to connect). For testing, we choose the Freenode network, irc.freenode.net . We will connect to a test channel, let's call it #myevennia-test (an IRC channel always begins with # ). It's best if you pick an obscure channel name that didn't exist previously - if it didn't exist it will be created for you. Don't connect to #evennia for testing and debugging, that is Evennia's official chat channel! You are welcome to connect your game to #evennia once you have everything working though - it can be a good way to get help and ideas. But if you do, please do so with an in-game channel open only to your game admins and developers). The port needed depends on the network. For Freenode this is 6667 . What will happen is that your Evennia server will connect to this IRC channel as a normal user. This \"user\" (or \"bot\") needs a name, which you must also supply. Let's call it \"mud-bot\". To test that the bot connects correctly you also want to log onto this channel with a separate, third-party IRC client. There are hundreds of such clients available. If you use Firefox, the Chatzilla plugin is good and easy. Freenode also offers its own web-based chat page. Once you have connected to a network, the command to join is usually /join #channelname (don't forget the #). Next we connect Evennia with the IRC channel. @irc2chan irc = irc.freenode.net 6667 #myevennia-test mud-bot Evennia will now create a new IRC bot mud-bot and connect it to the IRC network and the channel #myevennia. If you are connected to the IRC channel you will soon see the user mud-bot connect. Write something in the Evennia channel irc . irc Hello, World! [irc] Anna: Hello, World! If you are viewing your IRC channel with a separate IRC client you should see your text appearing there, spoken by the bot: mud-bot> [irc] Anna: Hello, World! Write Hello! in your IRC client window and it will appear in your normal channel, marked with the name of the IRC channel you used (#evennia here). [irc] Anna@#myevennia-test: Hello! Your Evennia gamers can now chat with users on external IRC channels!","title":"Setting up IRC, step by step"},{"location":"Implementing-a-game-rule-system.html","text":"The simplest way to create an online roleplaying game (at least from a code perspective) is to simply grab a paperback RPG rule book, get a staff of game masters together and start to run scenes with whomever logs in. Game masters can roll their dice in front of their computers and tell the players the results. This is only one step away from a traditional tabletop game and puts heavy demands on the staff - it is unlikely staff will be able to keep up around the clock even if they are very dedicated. Many games, even the most roleplay-dedicated, thus tend to allow for players to mediate themselves to some extent. A common way to do this is to introduce coded systems - that is, to let the computer do some of the heavy lifting. A basic thing is to add an online dice-roller so everyone can make rolls and make sure noone is cheating. Somewhere at this level you find the most bare-bones roleplaying MUSHes. The advantage of a coded system is that as long as the rules are fair the computer is too - it makes no judgement calls and holds no personal grudges (and cannot be accused of holding any). Also, the computer doesn't need to sleep and can always be online regardless of when a player logs on. The drawback is that a coded system is not flexible and won't adapt to the unprogrammed actions human players may come up with in role play. For this reason many roleplay-heavy MUDs do a hybrid variation - they use coded systems for things like combat and skill progression but leave role play to be mostly freeform, overseen by staff game masters. Finally, on the other end of the scale are less- or no-roleplay games, where game mechanics (and thus player fairness) is the most important aspect. In such games the only events with in-game value are those resulting from code. Such games are very common and include everything from hack-and-slash MUDs to various tactical simulations. So your first decision needs to be just what type of system you are aiming for. This page will try to give some ideas for how to organize the \"coded\" part of your system, however big that may be. Overall system infrastructure \u00b6 We strongly recommend that you code your rule system as stand-alone as possible. That is, don't spread your skill check code, race bonus calculation, die modifiers or what have you all over your game. Put everything you would need to look up in a rule book into a module in mygame/world . Hide away as much as you can. Think of it as a black box (or maybe the code representation of an all-knowing game master). The rest of your game will ask this black box questions and get answers back. Exactly how it arrives at those results should not need to be known outside the box. Doing it this way makes it easier to change and update things in one place later. Store only the minimum stuff you need with each game object. That is, if your Characters need values for Health, a list of skills etc, store those things on the Character - don't store how to roll or change them. Next is to determine just how you want to store things on your Objects and Characters. You can choose to either store things as individual Attributes , like character.db.STR=34 and character.db.Hunting_skill=20 . But you could also use some custom storage method, like a dictionary character.db.skills = {\"Hunting\":34, \"Fishing\":20, ...} . A much more fancy solution is to look at the Ainneve Trait handler . Finally you could even go with a custom django model . Which is the better depends on your game and the complexity of your system. Make a clear API into your rules. That is, make methods/functions that you feed with, say, your Character and which skill you want to check. That is, you want something similar to this: python from world import rules result = rules.roll_skill(character, \"hunting\") result = rules.roll_challenge(character1, character2, \"swords\") You might need to make these functions more or less complex depending on your game. For example the properties of the room might matter to the outcome of a roll (if the room is dark, burning etc). Establishing just what you need to send into your game mechanic module is a great way to also get a feel for what you need to add to your engine. Coded systems \u00b6 Inspired by tabletop role playing games, most game systems mimic some sort of die mechanic. To this end Evennia offers a full dice roller in its contrib folder. For custom implementations, Python offers many ways to randomize a result using its in-built random module. No matter how it's implemented, we will in this text refer to the action of determining an outcome as a \"roll\". In a freeform system, the result of the roll is just compared with values and people (or the game master) just agree on what it means. In a coded system the result now needs to be processed somehow. There are many things that may happen as a result of rule enforcement: Health may be added or deducted. This can effect the character in various ways. Experience may need to be added, and if a level-based system is used, the player might need to be informed they have increased a level. Room-wide effects need to be reported to the room, possibly affecting everyone in the room. There are also a slew of other things that fall under \"Coded systems\", including things like weather, NPC artificial intelligence and game economy. Basically everything about the world that a Game master would control in a tabletop role playing game can be mimicked to some level by coded systems. Example of Rule module \u00b6 Here is a simple example of a rule module. This is what we assume about our simple example game: - Characters have only four numerical values: - Their level , which starts at 1. - A skill combat , which determines how good they are at hitting things. Starts between 5 and 10. - Their Strength, STR , which determine how much damage they do. Starts between 1 and 10. - Their Health points, HP , which starts at 100. - When a Character reaches HP = 0 , they are presumed \"defeated\". Their HP is reset and they get a failure message (as a stand-in for death code). - Abilities are stored as simple Attributes on the Character. - \"Rolls\" are done by rolling a 100-sided die. If the result is below the combat value, it's a success and damage is rolled. Damage is rolled as a six-sided die + the value of STR (for this example we ignore weapons and assume STR is all that matters). - Every successful attack roll gives 1-3 experience points ( XP ). Every time the number of XP reaches (level + 1) ** 2 , the Character levels up. When leveling up, the Character's combat value goes up by 2 points and STR by one (this is a stand-in for a real progression system). Character \u00b6 The Character typeclass is simple. It goes in mygame/typeclasses/characters.py . There is already an empty Character class there that Evennia will look to and use. from random import randint from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" Custom rule-restricted character. We randomize the initial skill and ability values bettween 1-10. \"\"\" def at_object_creation(self): \"Called only when first created\" self.db.level = 1 self.db.HP = 100 self.db.XP = 0 self.db.STR = randint(1, 10) self.db.combat = randint(5, 10) @reload the server to load up the new code. Doing examine self will however not show the new Attributes on yourself. This is because the at_object_creation hook is only called on new Characters. Your Character was already created and will thus not have them. To force a reload, use the following command: @typeclass/force/reset self The examine self command will now show the new Attributes. Rule module \u00b6 This is a module mygame/world/rules.py . from random import randint def roll_hit(): \"Roll 1d100\" return randint(1, 100) def roll_dmg(): \"Roll 1d6\" return randint(1, 6) def check_defeat(character): \"Checks if a character is 'defeated'.\" if character.db.HP <= 0: character.msg(\"You fall down, defeated!\") character.db.HP = 100 # reset def add_XP(character, amount): \"Add XP to character, tracking level increases.\" character.db.XP += amount if character.db.XP >= (character.db.level + 1) ** 2: character.db.level += 1 character.db.STR += 1 character.db.combat += 2 character.msg(\"You are now level %i!\" % character.db.level) def skill_combat(*args): \"\"\" This determines outcome of combat. The one who rolls under their combat skill AND higher than their opponent's roll hits. \"\"\" char1, char2 = args roll1, roll2 = roll_hit(), roll_hit() failtext = \"You are hit by %s for %i damage!\" wintext = \"You hit %s for %i damage!\" xp_gain = randint(1, 3) if char1.db.combat >= roll1 > roll2: # char 1 hits dmg = roll_dmg() + char1.db.STR char1.msg(wintext % (char2, dmg)) add_XP(char1, xp_gain) char2.msg(failtext % (char1, dmg)) char2.db.HP -= dmg check_defeat(char2) elif char2.db.combat >= roll2 > roll1: # char 2 hits dmg = roll_dmg() + char2.db.STR char1.msg(failtext % (char2, dmg)) char1.db.HP -= dmg check_defeat(char1) char2.msg(wintext % (char1, dmg)) add_XP(char2, xp_gain) else: # a draw drawtext = \"Neither of you can find an opening.\" char1.msg(drawtext) char2.msg(drawtext) SKILLS = {\"combat\": skill_combat} def roll_challenge(character1, character2, skillname): \"\"\" Determine the outcome of a skill challenge between two characters based on the skillname given. \"\"\" if skillname in SKILLS: SKILLS[skillname](character1, character2) else: raise RunTimeError(\"Skillname %s not found.\" % skillname) These few functions implement the entirety of our simple rule system. We have a function to check the \"defeat\" condition and reset the HP back to 100 again. We define a generic \"skill\" function. Multiple skills could all be added with the same signature; our SKILLS dictionary makes it easy to look up the skills regardless of what their actual functions are called. Finally, the access function roll_challenge just picks the skill and gets the result. In this example, the skill function actually does a lot - it not only rolls results, it also informs everyone of their results via character.msg() calls. Here is an example of usage in a game command: from evennia import Command from world import rules class CmdAttack(Command): \"\"\" attack an opponent Usage: attack <target> This will attack a target in the same room, dealing damage with your bare hands. \"\"\" def func(self): \"Implementing combat\" caller = self.caller if not self.args: caller.msg(\"You need to pick a target to attack.\") return target = caller.search(self.args) if target: rules.roll_challenge(caller, target, \"combat\") Note how simple the command becomes and how generic you can make it. It becomes simple to offer any number of Combat commands by just extending this functionality - you can easily roll challenges and pick different skills to check. And if you ever decided to, say, change how to determine hit chance, you don't have to change every command, but need only change the single roll_hit function inside your rules module.","title":"Implementing a game rule system"},{"location":"Implementing-a-game-rule-system.html#overall-system-infrastructure","text":"We strongly recommend that you code your rule system as stand-alone as possible. That is, don't spread your skill check code, race bonus calculation, die modifiers or what have you all over your game. Put everything you would need to look up in a rule book into a module in mygame/world . Hide away as much as you can. Think of it as a black box (or maybe the code representation of an all-knowing game master). The rest of your game will ask this black box questions and get answers back. Exactly how it arrives at those results should not need to be known outside the box. Doing it this way makes it easier to change and update things in one place later. Store only the minimum stuff you need with each game object. That is, if your Characters need values for Health, a list of skills etc, store those things on the Character - don't store how to roll or change them. Next is to determine just how you want to store things on your Objects and Characters. You can choose to either store things as individual Attributes , like character.db.STR=34 and character.db.Hunting_skill=20 . But you could also use some custom storage method, like a dictionary character.db.skills = {\"Hunting\":34, \"Fishing\":20, ...} . A much more fancy solution is to look at the Ainneve Trait handler . Finally you could even go with a custom django model . Which is the better depends on your game and the complexity of your system. Make a clear API into your rules. That is, make methods/functions that you feed with, say, your Character and which skill you want to check. That is, you want something similar to this: python from world import rules result = rules.roll_skill(character, \"hunting\") result = rules.roll_challenge(character1, character2, \"swords\") You might need to make these functions more or less complex depending on your game. For example the properties of the room might matter to the outcome of a roll (if the room is dark, burning etc). Establishing just what you need to send into your game mechanic module is a great way to also get a feel for what you need to add to your engine.","title":"Overall system infrastructure"},{"location":"Implementing-a-game-rule-system.html#coded-systems","text":"Inspired by tabletop role playing games, most game systems mimic some sort of die mechanic. To this end Evennia offers a full dice roller in its contrib folder. For custom implementations, Python offers many ways to randomize a result using its in-built random module. No matter how it's implemented, we will in this text refer to the action of determining an outcome as a \"roll\". In a freeform system, the result of the roll is just compared with values and people (or the game master) just agree on what it means. In a coded system the result now needs to be processed somehow. There are many things that may happen as a result of rule enforcement: Health may be added or deducted. This can effect the character in various ways. Experience may need to be added, and if a level-based system is used, the player might need to be informed they have increased a level. Room-wide effects need to be reported to the room, possibly affecting everyone in the room. There are also a slew of other things that fall under \"Coded systems\", including things like weather, NPC artificial intelligence and game economy. Basically everything about the world that a Game master would control in a tabletop role playing game can be mimicked to some level by coded systems.","title":"Coded systems"},{"location":"Implementing-a-game-rule-system.html#example-of-rule-module","text":"Here is a simple example of a rule module. This is what we assume about our simple example game: - Characters have only four numerical values: - Their level , which starts at 1. - A skill combat , which determines how good they are at hitting things. Starts between 5 and 10. - Their Strength, STR , which determine how much damage they do. Starts between 1 and 10. - Their Health points, HP , which starts at 100. - When a Character reaches HP = 0 , they are presumed \"defeated\". Their HP is reset and they get a failure message (as a stand-in for death code). - Abilities are stored as simple Attributes on the Character. - \"Rolls\" are done by rolling a 100-sided die. If the result is below the combat value, it's a success and damage is rolled. Damage is rolled as a six-sided die + the value of STR (for this example we ignore weapons and assume STR is all that matters). - Every successful attack roll gives 1-3 experience points ( XP ). Every time the number of XP reaches (level + 1) ** 2 , the Character levels up. When leveling up, the Character's combat value goes up by 2 points and STR by one (this is a stand-in for a real progression system).","title":"Example of Rule module"},{"location":"Implementing-a-game-rule-system.html#character","text":"The Character typeclass is simple. It goes in mygame/typeclasses/characters.py . There is already an empty Character class there that Evennia will look to and use. from random import randint from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" Custom rule-restricted character. We randomize the initial skill and ability values bettween 1-10. \"\"\" def at_object_creation(self): \"Called only when first created\" self.db.level = 1 self.db.HP = 100 self.db.XP = 0 self.db.STR = randint(1, 10) self.db.combat = randint(5, 10) @reload the server to load up the new code. Doing examine self will however not show the new Attributes on yourself. This is because the at_object_creation hook is only called on new Characters. Your Character was already created and will thus not have them. To force a reload, use the following command: @typeclass/force/reset self The examine self command will now show the new Attributes.","title":"Character"},{"location":"Implementing-a-game-rule-system.html#rule-module","text":"This is a module mygame/world/rules.py . from random import randint def roll_hit(): \"Roll 1d100\" return randint(1, 100) def roll_dmg(): \"Roll 1d6\" return randint(1, 6) def check_defeat(character): \"Checks if a character is 'defeated'.\" if character.db.HP <= 0: character.msg(\"You fall down, defeated!\") character.db.HP = 100 # reset def add_XP(character, amount): \"Add XP to character, tracking level increases.\" character.db.XP += amount if character.db.XP >= (character.db.level + 1) ** 2: character.db.level += 1 character.db.STR += 1 character.db.combat += 2 character.msg(\"You are now level %i!\" % character.db.level) def skill_combat(*args): \"\"\" This determines outcome of combat. The one who rolls under their combat skill AND higher than their opponent's roll hits. \"\"\" char1, char2 = args roll1, roll2 = roll_hit(), roll_hit() failtext = \"You are hit by %s for %i damage!\" wintext = \"You hit %s for %i damage!\" xp_gain = randint(1, 3) if char1.db.combat >= roll1 > roll2: # char 1 hits dmg = roll_dmg() + char1.db.STR char1.msg(wintext % (char2, dmg)) add_XP(char1, xp_gain) char2.msg(failtext % (char1, dmg)) char2.db.HP -= dmg check_defeat(char2) elif char2.db.combat >= roll2 > roll1: # char 2 hits dmg = roll_dmg() + char2.db.STR char1.msg(failtext % (char2, dmg)) char1.db.HP -= dmg check_defeat(char1) char2.msg(wintext % (char1, dmg)) add_XP(char2, xp_gain) else: # a draw drawtext = \"Neither of you can find an opening.\" char1.msg(drawtext) char2.msg(drawtext) SKILLS = {\"combat\": skill_combat} def roll_challenge(character1, character2, skillname): \"\"\" Determine the outcome of a skill challenge between two characters based on the skillname given. \"\"\" if skillname in SKILLS: SKILLS[skillname](character1, character2) else: raise RunTimeError(\"Skillname %s not found.\" % skillname) These few functions implement the entirety of our simple rule system. We have a function to check the \"defeat\" condition and reset the HP back to 100 again. We define a generic \"skill\" function. Multiple skills could all be added with the same signature; our SKILLS dictionary makes it easy to look up the skills regardless of what their actual functions are called. Finally, the access function roll_challenge just picks the skill and gets the result. In this example, the skill function actually does a lot - it not only rolls results, it also informs everyone of their results via character.msg() calls. Here is an example of usage in a game command: from evennia import Command from world import rules class CmdAttack(Command): \"\"\" attack an opponent Usage: attack <target> This will attack a target in the same room, dealing damage with your bare hands. \"\"\" def func(self): \"Implementing combat\" caller = self.caller if not self.args: caller.msg(\"You need to pick a target to attack.\") return target = caller.search(self.args) if target: rules.roll_challenge(caller, target, \"combat\") Note how simple the command becomes and how generic you can make it. It becomes simple to offer any number of Combat commands by just extending this functionality - you can easily roll challenges and pick different skills to check. And if you ever decided to, say, change how to determine hit chance, you don't have to change every command, but need only change the single roll_hit function inside your rules module.","title":"Rule module"},{"location":"Inputfuncs.html","text":"An inputfunc is an Evennia function that handles a particular input (an inputcommand ) from the client. The inputfunc is the last destination for the inputcommand along the ingoing message path . The inputcommand always has the form (commandname, (args), {kwargs}) and Evennia will use this to try to find and call an inputfunc on the form def commandname(session, *args, **kwargs): # ... Or, if no match was found, it will call an inputfunc named \"default\" on this form def default(session, cmdname, *args, **kwargs): # cmdname is the name of the mismatched inputcommand Adding your own inputfuncs \u00b6 This is simple. Add a function on the above form to mygame/server/conf/inputfuncs.py . Your function must be in the global, outermost scope of that module and not start with an underscore ( _ ) to be recognized as an inputfunc. Reload the server. That's it. To overload a default inputfunc (see below), just add a function with the same name. The modules Evennia looks into for inputfuncs are defined in the list settings.INPUT_FUNC_MODULES . This list will be imported from left to right and later imported functions will replace earlier ones. Default inputfuncs \u00b6 Evennia defines a few default inputfuncs to handle the common cases. These are defined in evennia/server/inputfuncs.py . text \u00b6 Input: (\"text\", (textstring,), {}) Output: Depends on Command triggered This is the most common of inputcommands, and the only one supported by every traditional mud. The argument is usually what the user sent from their command line. Since all text input from the user like this is considered a Command , this inputfunc will do things like nick-replacement and then pass on the input to the central Commandhandler. echo \u00b6 Input: (\"echo\", (args), {}) Output: (\"text\", (\"Echo returns: %s\" % args), {}) This is a test input, which just echoes the argument back to the session as text. Can be used for testing custom client input. default \u00b6 The default function, as mentioned above, absorbs all non-recognized inputcommands. The default one will just log an error. client_options \u00b6 Input: (\"client_options, (), {key:value, ...}) Output: normal: None get: (\"client_options\", (), {key:value, ...}) This is a direct command for setting protocol options. These are settable with the @option command, but this offers a client-side way to set them. Not all connection protocols makes use of all flags, but here are the possible keywords: get (bool): If this is true, ignore all other kwargs and immediately return the current settings as an outputcommand (\"client_options\", (), {key=value, ...}) - client (str): A client identifier, like \"mushclient\". version (str): A client version ansi (bool): Supports ansi colors xterm256 (bool): Supports xterm256 colors or not mxp (bool): Supports MXP or not utf-8 (bool): Supports UTF-8 or not screenreader (bool): Screen-reader mode on/off mccp (bool): MCCP compression on/off screenheight (int): Screen height in lines screenwidth (int): Screen width in characters inputdebug (bool): Debug input functions nomarkup (bool): Strip all text tags raw (bool): Leave text tags unparsed Note that there are two GMCP aliases to this inputfunc - hello and supports_set , which means it will be accessed via the GMCP Hello and Supports.Set instructions assumed by some clients. get_client_options \u00b6 Input: (\"get_client_options, (), {key:value, ...}) Output: (\"client_options, (), {key:value, ...}) This is a convenience wrapper that retrieves the current options by sending \"get\" to client_options above. get_inputfuncs \u00b6 Input: (\"get_inputfuncs\", (), {}) Output: (\"get_inputfuncs\", (), {funcname:docstring, ...}) Returns an outputcommand on the form (\"get_inputfuncs\", (), {funcname:docstring, ...}) - a list of all the available inputfunctions along with their docstrings. login \u00b6 Note: this is currently experimental and not very well tested. Input: (\"login\", (username, password), {}) Output: Depends on login hooks This performs the inputfunc version of a login operation on the current Session. get_value \u00b6 Input: (\"get_value\", (name, ), {}) Output: (\"get_value\", (value, ), {}) Retrieves a value from the Character or Account currently controlled by this Session. Takes one argument, This will only accept particular white-listed names, you'll need to overload the function to expand. By default the following values can be retrieved: \"name\" or \"key\": The key of the Account or puppeted Character. \"location\": Name of the current location, or \"None\". \"servername\": Name of the Evennia server connected to. repeat \u00b6 Input: (\"repeat\", (), {\"callback\":funcname, \"interval\": secs, \"stop\": False}) Output: Depends on the repeated function. Will return (\"text\", (repeatlist),{} with a list of accepted names if given an unfamiliar callback name. This will tell evennia to repeatedly call a named function at a given interval. Behind the scenes this will set up a Ticker . Only previously acceptable functions are possible to repeat-call in this way, you'll need to overload this inputfunc to add the ones you want to offer. By default only two example functions are allowed, \"test1\" and \"test2\", which will just echo a text back at the given interval. Stop the repeat by sending \"stop\": True (note that you must include both the callback name and interval for Evennia to know what to stop). unrepeat \u00b6 Input: (\"unrepeat\", (), (\"callback\":funcname, \"interval\": secs) Output: None This is a convenience wrapper for sending \"stop\" to the repeat inputfunc. monitor \u00b6 Input: (\"monitor\", (), (\"name\":field_or_argname, stop=False) Output (on change): (\"monitor\", (), {\"name\":name, \"value\":value}) This sets up on-object monitoring of Attributes or database fields. Whenever the field or Attribute changes in any way, the outputcommand will be sent. This is using the MonitorHandler behind the scenes. Pass the \"stop\" key to stop monitoring. Note that you must supply the name also when stopping to let the system know which monitor should be cancelled. Only fields/attributes in a whitelist are allowed to be used, you have to overload this function to add more. By default the following fields/attributes can be monitored: \"name\": The current character name \"location\": The current location \"desc\": The description Argument unmonitor \u00b6 Input: (\"unmonitor\", (), {\"name\":name}) Output: None A convenience wrapper that sends \"stop\" to the monitor function.","title":"Inputfuncs"},{"location":"Inputfuncs.html#adding-your-own-inputfuncs","text":"This is simple. Add a function on the above form to mygame/server/conf/inputfuncs.py . Your function must be in the global, outermost scope of that module and not start with an underscore ( _ ) to be recognized as an inputfunc. Reload the server. That's it. To overload a default inputfunc (see below), just add a function with the same name. The modules Evennia looks into for inputfuncs are defined in the list settings.INPUT_FUNC_MODULES . This list will be imported from left to right and later imported functions will replace earlier ones.","title":"Adding your own inputfuncs"},{"location":"Inputfuncs.html#default-inputfuncs","text":"Evennia defines a few default inputfuncs to handle the common cases. These are defined in evennia/server/inputfuncs.py .","title":"Default inputfuncs"},{"location":"Inputfuncs.html#text","text":"Input: (\"text\", (textstring,), {}) Output: Depends on Command triggered This is the most common of inputcommands, and the only one supported by every traditional mud. The argument is usually what the user sent from their command line. Since all text input from the user like this is considered a Command , this inputfunc will do things like nick-replacement and then pass on the input to the central Commandhandler.","title":"text"},{"location":"Inputfuncs.html#echo","text":"Input: (\"echo\", (args), {}) Output: (\"text\", (\"Echo returns: %s\" % args), {}) This is a test input, which just echoes the argument back to the session as text. Can be used for testing custom client input.","title":"echo"},{"location":"Inputfuncs.html#default","text":"The default function, as mentioned above, absorbs all non-recognized inputcommands. The default one will just log an error.","title":"default"},{"location":"Inputfuncs.html#client_options","text":"Input: (\"client_options, (), {key:value, ...}) Output: normal: None get: (\"client_options\", (), {key:value, ...}) This is a direct command for setting protocol options. These are settable with the @option command, but this offers a client-side way to set them. Not all connection protocols makes use of all flags, but here are the possible keywords: get (bool): If this is true, ignore all other kwargs and immediately return the current settings as an outputcommand (\"client_options\", (), {key=value, ...}) - client (str): A client identifier, like \"mushclient\". version (str): A client version ansi (bool): Supports ansi colors xterm256 (bool): Supports xterm256 colors or not mxp (bool): Supports MXP or not utf-8 (bool): Supports UTF-8 or not screenreader (bool): Screen-reader mode on/off mccp (bool): MCCP compression on/off screenheight (int): Screen height in lines screenwidth (int): Screen width in characters inputdebug (bool): Debug input functions nomarkup (bool): Strip all text tags raw (bool): Leave text tags unparsed Note that there are two GMCP aliases to this inputfunc - hello and supports_set , which means it will be accessed via the GMCP Hello and Supports.Set instructions assumed by some clients.","title":"client_options"},{"location":"Inputfuncs.html#get_client_options","text":"Input: (\"get_client_options, (), {key:value, ...}) Output: (\"client_options, (), {key:value, ...}) This is a convenience wrapper that retrieves the current options by sending \"get\" to client_options above.","title":"get_client_options"},{"location":"Inputfuncs.html#get_inputfuncs","text":"Input: (\"get_inputfuncs\", (), {}) Output: (\"get_inputfuncs\", (), {funcname:docstring, ...}) Returns an outputcommand on the form (\"get_inputfuncs\", (), {funcname:docstring, ...}) - a list of all the available inputfunctions along with their docstrings.","title":"get_inputfuncs"},{"location":"Inputfuncs.html#login","text":"Note: this is currently experimental and not very well tested. Input: (\"login\", (username, password), {}) Output: Depends on login hooks This performs the inputfunc version of a login operation on the current Session.","title":"login"},{"location":"Inputfuncs.html#get_value","text":"Input: (\"get_value\", (name, ), {}) Output: (\"get_value\", (value, ), {}) Retrieves a value from the Character or Account currently controlled by this Session. Takes one argument, This will only accept particular white-listed names, you'll need to overload the function to expand. By default the following values can be retrieved: \"name\" or \"key\": The key of the Account or puppeted Character. \"location\": Name of the current location, or \"None\". \"servername\": Name of the Evennia server connected to.","title":"get_value"},{"location":"Inputfuncs.html#repeat","text":"Input: (\"repeat\", (), {\"callback\":funcname, \"interval\": secs, \"stop\": False}) Output: Depends on the repeated function. Will return (\"text\", (repeatlist),{} with a list of accepted names if given an unfamiliar callback name. This will tell evennia to repeatedly call a named function at a given interval. Behind the scenes this will set up a Ticker . Only previously acceptable functions are possible to repeat-call in this way, you'll need to overload this inputfunc to add the ones you want to offer. By default only two example functions are allowed, \"test1\" and \"test2\", which will just echo a text back at the given interval. Stop the repeat by sending \"stop\": True (note that you must include both the callback name and interval for Evennia to know what to stop).","title":"repeat"},{"location":"Inputfuncs.html#unrepeat","text":"Input: (\"unrepeat\", (), (\"callback\":funcname, \"interval\": secs) Output: None This is a convenience wrapper for sending \"stop\" to the repeat inputfunc.","title":"unrepeat"},{"location":"Inputfuncs.html#monitor","text":"Input: (\"monitor\", (), (\"name\":field_or_argname, stop=False) Output (on change): (\"monitor\", (), {\"name\":name, \"value\":value}) This sets up on-object monitoring of Attributes or database fields. Whenever the field or Attribute changes in any way, the outputcommand will be sent. This is using the MonitorHandler behind the scenes. Pass the \"stop\" key to stop monitoring. Note that you must supply the name also when stopping to let the system know which monitor should be cancelled. Only fields/attributes in a whitelist are allowed to be used, you have to overload this function to add more. By default the following fields/attributes can be monitored: \"name\": The current character name \"location\": The current location \"desc\": The description Argument","title":"monitor"},{"location":"Inputfuncs.html#unmonitor","text":"Input: (\"unmonitor\", (), {\"name\":name}) Output: None A convenience wrapper that sends \"stop\" to the monitor function.","title":"unmonitor"},{"location":"Installing-on-Android.html","text":"This page describes how to install and run the Evennia server on an Android phone. This will involve installing a slew of third-party programs from the Google Play store, so make sure you are okay with this before starting. Install Termux \u00b6 The first thing to do is install a terminal emulator that allows a \"full\" version of linux to be run. Note that Android is essentially running on top of linux so if you have a rooted phone, you may be able to skip this step. You don't require a rooted phone to install Evennia though. Assuming we do not have root, we will install Termux . Termux provides a base installation of Linux essentials, including apt and Python, and makes them available under a writeable directory. It also gives us a terminal where we can enter commands. By default, Android doesn't give you permissions to the root folder, so Termux pretends that its own installation directory is the root directory. Termux will set up a base system for us on first launch, but we will need to install some prerequisites for Evennia. Commands you should run in Termux will look like this: $ cat file.txt The $ symbol is your prompt - do not include it when running commands. Prerequisites \u00b6 To install some of the libraries Evennia requires, namely Pillow and Twisted, we have to first install some packages they depend on. In Termux, run the following $ pkg install -y clang git zlib ndk-sysroot libjpeg-turbo libcrypt python Termux ships with Python 3, perfect. Python 3 has venv (virtualenv) and pip (Python's module installer) built-in. So, let's set up our virtualenv. This keeps the Python packages we install separate from the system versions. $ cd $ python3 -m venv evenv This will create a new folder, called evenv , containing the new python executable. Next, let's activate our new virtualenv. Every time you want to work on Evennia, you need to run the following command: $ source evenv/bin/activate Your prompt will change to look like this: (evenv) $ Update the updaters and installers in the venv: pip, setuptools and wheel. python3 -m pip install --upgrade pip setuptools wheel Installing Evennia \u00b6 Now that we have everything in place, we're ready to download and install Evennia itself. Mysterious incantations export LDFLAGS=\"-L/data/data/com.termux/files/usr/lib/\" export CFLAGS=\"-I/data/data/com.termux/files/usr/include/\" (these tell clang, the C compiler, where to find the bits for zlib when building Pillow) Install the latest Evennia in a way that lets you edit the source (evenv) $ pip install --upgrade -e 'git+https://github.com/evennia/evennia#egg=evennia' This step will possibly take quite a while - we are downloading Evennia and are then installing it, building all of the requirements for Evennia to run. If you run into trouble on this step, please see Troubleshooting . You can go to the dir where Evennia is installed with cd $VIRTUAL_ENV/src/evennia . git grep (something) can be handy, as can git diff Final steps \u00b6 At this point, Evennia is installed on your phone! You can now continue with the original Getting Started instruction, we repeat them here for clarity. To start a new game: (evenv) $ evennia --init mygame (evenv) $ ls mygame evenv To start the game for the first time: (evenv) $ cd mygame (evenv) $ evennia migrate (evenv) $ evennia start Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created. Running Evennia \u00b6 When you wish to run Evennia, get into your Termux console and make sure you have activated your virtualenv as well as are in your game's directory. You can then run evennia start as normal. $ cd ~ && source evenv/bin/activate (evenv) $ cd mygame (evenv) $ evennia start You may wish to look at the Linux Instructions for more. Caveats \u00b6 Android's os module doesn't support certain functions - in particular getloadavg. Thusly, running the command @server in-game will throw an exception. So far, there is no fix for this problem. As you might expect, performance is not amazing. Android is fairly aggressive about memory handling, and you may find that your server process is killed if your phone is heavily taxed. Termux seems to keep a notification up to discourage this. Troubleshooting \u00b6 As time goes by and errors are reported, this section will be added to. Some steps to try anyway: * Make sure your packages are up-to-date, try running pkg update && pkg upgrade -y * Make sure you've installed the clang package. If not, try pkg install clang -y * Make sure you're in the right directory. cd ~/mygame * Make sure you've sourced your virtualenv. type cd && source evenv/bin/activate * See if a shell will start: cd ~/mygame ; evennia shell` * Look at the log files in ~/mygame/server/logs/","title":"Installing on Android"},{"location":"Installing-on-Android.html#install-termux","text":"The first thing to do is install a terminal emulator that allows a \"full\" version of linux to be run. Note that Android is essentially running on top of linux so if you have a rooted phone, you may be able to skip this step. You don't require a rooted phone to install Evennia though. Assuming we do not have root, we will install Termux . Termux provides a base installation of Linux essentials, including apt and Python, and makes them available under a writeable directory. It also gives us a terminal where we can enter commands. By default, Android doesn't give you permissions to the root folder, so Termux pretends that its own installation directory is the root directory. Termux will set up a base system for us on first launch, but we will need to install some prerequisites for Evennia. Commands you should run in Termux will look like this: $ cat file.txt The $ symbol is your prompt - do not include it when running commands.","title":"Install Termux"},{"location":"Installing-on-Android.html#prerequisites","text":"To install some of the libraries Evennia requires, namely Pillow and Twisted, we have to first install some packages they depend on. In Termux, run the following $ pkg install -y clang git zlib ndk-sysroot libjpeg-turbo libcrypt python Termux ships with Python 3, perfect. Python 3 has venv (virtualenv) and pip (Python's module installer) built-in. So, let's set up our virtualenv. This keeps the Python packages we install separate from the system versions. $ cd $ python3 -m venv evenv This will create a new folder, called evenv , containing the new python executable. Next, let's activate our new virtualenv. Every time you want to work on Evennia, you need to run the following command: $ source evenv/bin/activate Your prompt will change to look like this: (evenv) $ Update the updaters and installers in the venv: pip, setuptools and wheel. python3 -m pip install --upgrade pip setuptools wheel","title":"Prerequisites"},{"location":"Installing-on-Android.html#installing-evennia","text":"Now that we have everything in place, we're ready to download and install Evennia itself. Mysterious incantations export LDFLAGS=\"-L/data/data/com.termux/files/usr/lib/\" export CFLAGS=\"-I/data/data/com.termux/files/usr/include/\" (these tell clang, the C compiler, where to find the bits for zlib when building Pillow) Install the latest Evennia in a way that lets you edit the source (evenv) $ pip install --upgrade -e 'git+https://github.com/evennia/evennia#egg=evennia' This step will possibly take quite a while - we are downloading Evennia and are then installing it, building all of the requirements for Evennia to run. If you run into trouble on this step, please see Troubleshooting . You can go to the dir where Evennia is installed with cd $VIRTUAL_ENV/src/evennia . git grep (something) can be handy, as can git diff","title":"Installing Evennia"},{"location":"Installing-on-Android.html#final-steps","text":"At this point, Evennia is installed on your phone! You can now continue with the original Getting Started instruction, we repeat them here for clarity. To start a new game: (evenv) $ evennia --init mygame (evenv) $ ls mygame evenv To start the game for the first time: (evenv) $ cd mygame (evenv) $ evennia migrate (evenv) $ evennia start Your game should now be running! Open a web browser at http://localhost:4001 or point a telnet client to localhost:4000 and log in with the user you created.","title":"Final steps"},{"location":"Installing-on-Android.html#running-evennia","text":"When you wish to run Evennia, get into your Termux console and make sure you have activated your virtualenv as well as are in your game's directory. You can then run evennia start as normal. $ cd ~ && source evenv/bin/activate (evenv) $ cd mygame (evenv) $ evennia start You may wish to look at the Linux Instructions for more.","title":"Running Evennia"},{"location":"Installing-on-Android.html#caveats","text":"Android's os module doesn't support certain functions - in particular getloadavg. Thusly, running the command @server in-game will throw an exception. So far, there is no fix for this problem. As you might expect, performance is not amazing. Android is fairly aggressive about memory handling, and you may find that your server process is killed if your phone is heavily taxed. Termux seems to keep a notification up to discourage this.","title":"Caveats"},{"location":"Installing-on-Android.html#troubleshooting","text":"As time goes by and errors are reported, this section will be added to. Some steps to try anyway: * Make sure your packages are up-to-date, try running pkg update && pkg upgrade -y * Make sure you've installed the clang package. If not, try pkg install clang -y * Make sure you're in the right directory. cd ~/mygame * Make sure you've sourced your virtualenv. type cd && source evenv/bin/activate * See if a shell will start: cd ~/mygame ; evennia shell` * Look at the log files in ~/mygame/server/logs/","title":"Troubleshooting"},{"location":"Internationalization.html","text":"Internationalization (often abbreviated i18n since there are 18 characters between the first \"i\" and the last \"n\" in that word) allows Evennia's core server to return texts in other languages than English - without anyone having to edit the source code. Take a look at the locale directory of the Evennia installation, there you will find which languages are currently supported. Changing server language \u00b6 Change language by adding the following to your mygame/server/conf/settings.py file: USE_I18N = True LANGUAGE_CODE = 'en' Here 'en' should be changed to the abbreviation for one of the supported languages found in locale/ . Restart the server to activate i18n. The two-character international language codes are found here . Windows Note: If you get errors concerning gettext or xgettext on Windows, see the Django documentation . A self-installing and up-to-date version of gettext for Windows (32/64-bit) is available on Github . Translating Evennia \u00b6 Important Note: Evennia offers translations of hard-coded strings in the server, things like \"Connection closed\" or \"Server restarted\", strings that end users will see and which game devs are not supposed to change on their own. Text you see in the log file or on the command line (like error messages) are generally not translated (this is a part of Python). In addition, text in default Commands and in default Typeclasses will not be translated by switching i18n language. To translate Commands and Typeclass hooks you must overload them in your game directory and translate their returns to the language you want. This is because from Evennia's perspective, adding i18n code to commands tend to add complexity to code that is meant to be changed anyway. One of the goals of Evennia is to keep the user-changeable code as clean and easy-to-read as possible. If you cannot find your language in evennia/locale/ it's because noone has translated it yet. Alternatively you might have the language but find the translation bad ... You are welcome to help improve the situation! To start a new translation you need to first have cloned the Evennia repositry with GIT and activated a python virtualenv as described on the Getting Started page. You now need to cd to the evennia/ directory. This is not your created game folder but the main Evennia library folder. If you see a folder locale/ then you are in the right place. From here you run: evennia makemessages <language-code> where <language-code> is the two-letter locale code for the language you want, like 'sv' for Swedish or 'es' for Spanish. After a moment it will tell you the language has been processed. For instance: evennia makemessages sv If you started a new language a new folder for that language will have emerged in the locale/ folder. Otherwise the system will just have updated the existing translation with eventual new strings found in the server. Running this command will not overwrite any existing strings so you can run it as much as you want. Note: in Django, the makemessages command prefixes the locale name by the -l option ( ... makemessages -l sv for instance). This syntax is not allowed in Evennia, due to the fact that -l is the option to tail log files. Hence, makemessages doesn't use the -l flag. Next head to locale/<language-code>/LC_MESSAGES and edit the **.po file you find there. You can edit this with a normal text editor but it is easiest if you use a special po-file editor from the web (search the web for \"po editor\" for many free alternatives). The concept of translating is simple, it's just a matter of taking the english strings you find in the **.po file and add your language's translation best you can. The **.po format (and many supporting editors) allow you to mark translations as \"fuzzy\". This tells the system (and future translators) that you are unsure about the translation, or that you couldn't find a translation that exactly matched the intention of the original text. Other translators will see this and might be able to improve it later. Finally, you need to compile your translation into a more efficient form. Do so from the evennia folder again: evennia compilemessages This will go through all languages and create/update compiled files ( **.mo ) for them. This needs to be done whenever a **.po file is updated. When you are done, send the **.po and *.mo file to the Evennia developer list (or push it into your own repository clone) so we can integrate your translation into Evennia!","title":"Internationalization"},{"location":"Internationalization.html#changing-server-language","text":"Change language by adding the following to your mygame/server/conf/settings.py file: USE_I18N = True LANGUAGE_CODE = 'en' Here 'en' should be changed to the abbreviation for one of the supported languages found in locale/ . Restart the server to activate i18n. The two-character international language codes are found here . Windows Note: If you get errors concerning gettext or xgettext on Windows, see the Django documentation . A self-installing and up-to-date version of gettext for Windows (32/64-bit) is available on Github .","title":"Changing server language"},{"location":"Internationalization.html#translating-evennia","text":"Important Note: Evennia offers translations of hard-coded strings in the server, things like \"Connection closed\" or \"Server restarted\", strings that end users will see and which game devs are not supposed to change on their own. Text you see in the log file or on the command line (like error messages) are generally not translated (this is a part of Python). In addition, text in default Commands and in default Typeclasses will not be translated by switching i18n language. To translate Commands and Typeclass hooks you must overload them in your game directory and translate their returns to the language you want. This is because from Evennia's perspective, adding i18n code to commands tend to add complexity to code that is meant to be changed anyway. One of the goals of Evennia is to keep the user-changeable code as clean and easy-to-read as possible. If you cannot find your language in evennia/locale/ it's because noone has translated it yet. Alternatively you might have the language but find the translation bad ... You are welcome to help improve the situation! To start a new translation you need to first have cloned the Evennia repositry with GIT and activated a python virtualenv as described on the Getting Started page. You now need to cd to the evennia/ directory. This is not your created game folder but the main Evennia library folder. If you see a folder locale/ then you are in the right place. From here you run: evennia makemessages <language-code> where <language-code> is the two-letter locale code for the language you want, like 'sv' for Swedish or 'es' for Spanish. After a moment it will tell you the language has been processed. For instance: evennia makemessages sv If you started a new language a new folder for that language will have emerged in the locale/ folder. Otherwise the system will just have updated the existing translation with eventual new strings found in the server. Running this command will not overwrite any existing strings so you can run it as much as you want. Note: in Django, the makemessages command prefixes the locale name by the -l option ( ... makemessages -l sv for instance). This syntax is not allowed in Evennia, due to the fact that -l is the option to tail log files. Hence, makemessages doesn't use the -l flag. Next head to locale/<language-code>/LC_MESSAGES and edit the **.po file you find there. You can edit this with a normal text editor but it is easiest if you use a special po-file editor from the web (search the web for \"po editor\" for many free alternatives). The concept of translating is simple, it's just a matter of taking the english strings you find in the **.po file and add your language's translation best you can. The **.po format (and many supporting editors) allow you to mark translations as \"fuzzy\". This tells the system (and future translators) that you are unsure about the translation, or that you couldn't find a translation that exactly matched the intention of the original text. Other translators will see this and might be able to improve it later. Finally, you need to compile your translation into a more efficient form. Do so from the evennia folder again: evennia compilemessages This will go through all languages and create/update compiled files ( **.mo ) for them. This needs to be done whenever a **.po file is updated. When you are done, send the **.po and *.mo file to the Evennia developer list (or push it into your own repository clone) so we can integrate your translation into Evennia!","title":"Translating Evennia"},{"location":"Learn-Python-for-Evennia-The-Hard-Way.html","text":"WORK IN PROGRESS - DO NOT USE \u00b6 Evennia provides a great foundation to build your very own MU* whether you have programming experience or none at all. Whilst Evennia has a number of in-game building commands and tutorials available to get you started, when approaching game systems of any complexity it is advisable to have the basics of Python under your belt before jumping into the code. There are many Python tutorials freely available online however this page focuses on Learn Python the Hard Way (LPTHW) by Zed Shaw. This tutorial takes you through the basics of Python and progresses you to creating your very own online text based game. Whilst completing the course feel free to install Evennia and try out some of our beginner tutorials. On completion you can return to this page, which will act as an overview to the concepts separating your online text based game and the inner-workings of Evennia. -The latter portion of the tutorial focuses working your engine into a webpage and is not strictly required for development in Evennia. Exercise 23 \u00b6 You may have returned here when you were invited to read some code. If you haven\u2019t already, you should now have the knowledge necessary to install Evennia. Head over to the Getting Started page for install instructions. You can also try some of our tutorials to get you started on working with Evennia. Bridging the gap. \u00b6 If you have successfully completed the Learn Python the Hard Way tutorial you should now have a simple browser based Interactive Fiction engine which looks similar to this. This engine is built using a single interactive object type, the Room class. The Room class holds a description of itself that is presented to the user and a list of hardcoded commands which if selected correctly will present you with the next rooms\u2019 description and commands. Whilst your game only has one interactive object, MU* have many more: Swords and shields, potions and scrolls or even laser guns and robots. Even the player has an in-game representation in the form of your character. Each of these examples are represented by their own object with their own description that can be presented to the user. A basic object in Evennia has a number of default functions but perhaps most important is the idea of location. In your text engine you receive a description of a room but you are not really in the room because you have no in-game representation. However, in Evennia when you enter a Dungeon you ARE in the dungeon. That is to say your character.location = Dungeon whilst the Dungeon.contents now has a spunky young adventurer added to it. In turn, your character.contents may have amongst it a number of swords and potions to help you on your adventure and their location would be you. In reality each of these \u201cobjects\u201d are just an entry in your Evennia projects database which keeps track of all these attributes, such as location and contents. Making changes to those attributes and the rules in which they are changed is the most fundamental perspective of how your game works. We define those rules in the objects Typeclass. The Typeclass is a Python class with a special connection to the games database which changes values for us through various class methods. Let\u2019s look at your characters Typeclass rules for changing location. 1. `self.at_before_move(destination)` (if this returns False, move is aborted) 2. `self.announce_move_from(destination)` 3. (move happens here) 4. `self.announce_move_to(source_location)` 5. `self.at_after_move(source_location)` First we check if it\u2019s okay to leave our current location, then we tell everyone there that we\u2019re leaving. We move locations and tell everyone at our new location that we\u2019ve arrived before checking we\u2019re okay to be there. By default stages 1 and 5 are empty ready for us to add some rules. We\u2019ll leave an explanation as to how to make those changes for the tutorial section, but imagine if you were an astronaut. A smart astronaut might stop at step 1 to remember to put his helmet on whilst a slower astronaut might realise he\u2019s forgotten in step 5 before shortly after ceasing to be an astronaut. With all these objects and all this moving around it raises another problem. In your text engine the commands available to the player were hard-coded to the room. That means if we have commands we always want available to the player we\u2019ll need to have those commands hard-coded on every single room. What about an armoury? When all the swords are gone the command to take a sword would still remain causing confusion. Evennia solves this problem by giving each object the ability to hold commands. Rooms can have commands attached to them specific to that location, like climbing a tree; Players can have commands which are always available to them, like \u2018look\u2019, \u2018get\u2019 and \u2018say\u2019; and objects can have commands attached to them which unlock when taking possession of it, like attack commands when obtaining a weapon.","title":"WORK IN PROGRESS - DO NOT USE"},{"location":"Learn-Python-for-Evennia-The-Hard-Way.html#work-in-progress-do-not-use","text":"Evennia provides a great foundation to build your very own MU* whether you have programming experience or none at all. Whilst Evennia has a number of in-game building commands and tutorials available to get you started, when approaching game systems of any complexity it is advisable to have the basics of Python under your belt before jumping into the code. There are many Python tutorials freely available online however this page focuses on Learn Python the Hard Way (LPTHW) by Zed Shaw. This tutorial takes you through the basics of Python and progresses you to creating your very own online text based game. Whilst completing the course feel free to install Evennia and try out some of our beginner tutorials. On completion you can return to this page, which will act as an overview to the concepts separating your online text based game and the inner-workings of Evennia. -The latter portion of the tutorial focuses working your engine into a webpage and is not strictly required for development in Evennia.","title":"WORK IN PROGRESS - DO NOT USE"},{"location":"Learn-Python-for-Evennia-The-Hard-Way.html#exercise-23","text":"You may have returned here when you were invited to read some code. If you haven\u2019t already, you should now have the knowledge necessary to install Evennia. Head over to the Getting Started page for install instructions. You can also try some of our tutorials to get you started on working with Evennia.","title":"Exercise 23"},{"location":"Learn-Python-for-Evennia-The-Hard-Way.html#bridging-the-gap","text":"If you have successfully completed the Learn Python the Hard Way tutorial you should now have a simple browser based Interactive Fiction engine which looks similar to this. This engine is built using a single interactive object type, the Room class. The Room class holds a description of itself that is presented to the user and a list of hardcoded commands which if selected correctly will present you with the next rooms\u2019 description and commands. Whilst your game only has one interactive object, MU* have many more: Swords and shields, potions and scrolls or even laser guns and robots. Even the player has an in-game representation in the form of your character. Each of these examples are represented by their own object with their own description that can be presented to the user. A basic object in Evennia has a number of default functions but perhaps most important is the idea of location. In your text engine you receive a description of a room but you are not really in the room because you have no in-game representation. However, in Evennia when you enter a Dungeon you ARE in the dungeon. That is to say your character.location = Dungeon whilst the Dungeon.contents now has a spunky young adventurer added to it. In turn, your character.contents may have amongst it a number of swords and potions to help you on your adventure and their location would be you. In reality each of these \u201cobjects\u201d are just an entry in your Evennia projects database which keeps track of all these attributes, such as location and contents. Making changes to those attributes and the rules in which they are changed is the most fundamental perspective of how your game works. We define those rules in the objects Typeclass. The Typeclass is a Python class with a special connection to the games database which changes values for us through various class methods. Let\u2019s look at your characters Typeclass rules for changing location. 1. `self.at_before_move(destination)` (if this returns False, move is aborted) 2. `self.announce_move_from(destination)` 3. (move happens here) 4. `self.announce_move_to(source_location)` 5. `self.at_after_move(source_location)` First we check if it\u2019s okay to leave our current location, then we tell everyone there that we\u2019re leaving. We move locations and tell everyone at our new location that we\u2019ve arrived before checking we\u2019re okay to be there. By default stages 1 and 5 are empty ready for us to add some rules. We\u2019ll leave an explanation as to how to make those changes for the tutorial section, but imagine if you were an astronaut. A smart astronaut might stop at step 1 to remember to put his helmet on whilst a slower astronaut might realise he\u2019s forgotten in step 5 before shortly after ceasing to be an astronaut. With all these objects and all this moving around it raises another problem. In your text engine the commands available to the player were hard-coded to the room. That means if we have commands we always want available to the player we\u2019ll need to have those commands hard-coded on every single room. What about an armoury? When all the swords are gone the command to take a sword would still remain causing confusion. Evennia solves this problem by giving each object the ability to hold commands. Rooms can have commands attached to them specific to that location, like climbing a tree; Players can have commands which are always available to them, like \u2018look\u2019, \u2018get\u2019 and \u2018say\u2019; and objects can have commands attached to them which unlock when taking possession of it, like attack commands when obtaining a weapon.","title":"Bridging the gap."},{"location":"Licensing.html","text":"Evennia is licensed under the very friendly BSD (3-clause) license. You can find the license as LICENSE.txt in the Evennia repository's root. Q: When creating a game using Evennia, what does the license permit me to do with it? A: It's your own game world to do with as you please! Keep it to yourself or re-distribute it under another license of your choice - or sell it and become filthy rich for all we care. Q: I have modified the Evennia library itself, what does the license say about that? A: Our license allows you to do whatever you want with your modified Evennia, including re-distributing or selling it, as long as you include our license and copyright info found in LICENSE.txt along with your distribution. ... Of course, if you fix bugs or add some new snazzy feature we softly nudge you to make those changes available so they can be added to the core Evennia package for everyone's benefit. The license doesn't require you to do it, but that doesn't mean we won't still greatly appreciate it if you do! Q: Can I re-distribute the Evennia server package along with my custom game implementation? A: Sure. As long as the text in LICENSE.txt is included. Q: What about Contributions? The contributions in evennia/evennia/contrib are considered to be released under the same license as Evennia itself, unless the individual contributor has specifically defined otherwise.","title":"Licensing"},{"location":"Links.html","text":"A list of resources that may be useful for Evennia users and developers. Official Evennia links \u00b6 evennia.com - Main Evennia portal page. Links to all corners of Evennia. Evennia github page - Download code and read documentation. Evennia official chat channel - Our official IRC chat #evennia at irc.freenode.net:6667. Evennia forums/mailing list - Web interface to our google group. Evennia development blog - Musings from the lead developer. Evennia's manual on ReadTheDocs - Read and download offline in html, PDF or epub formats. Evennia Game Index - An automated listing of Evennia games. Evennia on Open Hub Evennia on OpenHatch Evennia on PyPi Evennia subreddit (not much there yet though) Third-party Evennia utilities and resources \u00b6 For publicly available games running on Evennia, add and find those in the Evennia game index instead! Discord Evennia channel - This is a fan-driven Discord channel with a bridge to the official Evennia IRC channel. Discord live blog of the Blackbirds Evennia game project. Unreal Engine Evennia plugin - an in-progress Unreal plugin for integrating Evennia with Epic Games' Unreal Engine. The dark net/March Hare MUD from the 2019 DEF CON 27 hacker conference in Paris. This is an Evennia game dir with batchcode to build the custom Hackers style cyberspace zone with puzzles and challenges used during the conference . Arx sources - Open-source code release of the very popular Arx Evennia game. Here are instructions for installing Evennia-wiki - An Evennia-specific Wiki for your website. Evcolor - Optional coloration for Evennia unit-test output. Paxboards - Evennia bulletin board system (both for telnet/web). Encarnia sources - An open-sourced game dir for Evennia with things like races, combat etc. Summary here . The world of Cool battles sources - Open source turn-based battle system for Evennia. It also has a live demo . nextRPI - A github project for making a toolbox for people to make RPI -style Evennia games. Muddery - A mud framework under development, based on an older fork of Evennia. It has some specific design goals for building and extending the game based on input files. vim-evennia - A mode for editing batch-build files ( .ev ) files in the vim text editor (Emacs users can use evennia-mode.el ). Other Evennia-related repos on github EvCast video series - Tutorial videos explaining installing Evennia, basic Python etc. Evennia-docker - Evennia in a Docker container for quick install and deployment in just a few commands. Evennia's docs in Chinese - A translated mirror of a slightly older Evennia version. Announcement here . Evennia for MUSHers - An article describing Evennia for those used to the MUSH way of doing things. Language Understanding for Text games using Deep reinforcement learning ( PDF ) - MIT research paper using Evennia to train AIs. Other useful mud development resources \u00b6 ROM area reader - Parser for converting ROM area files to Python objects. Gossip MUD chat network General MUD forums and discussions \u00b6 MUD Coder's Guild - A blog and associated Slack channel with discussions on MUD development. MuSoapbox - Very active Mu* game community mainly focused on MUSH-type gaming. Imaginary Realities - An e-magazine on game and MUD design that has several articles about Evennia. There is also an archive of older issues from 1998-2001 that are still very relevant. Optional Realities - Mud development discussion forums that has regular articles on MUD development focused on roleplay-intensive games. After a HD crash it's not as content-rich as it once was. MudLab - Mud design discussion forum MudConnector - Mud listing and forums MudBytes - Mud listing and forums Top Mud Sites - Mud listing and forums Planet Mud-Dev - A blog aggregator following blogs of current MUD development (including Evennia) around the 'net. Worth to put among your RSS subscriptions. Mud Dev mailing list archive ( mirror ) - Influential mailing list active 1996-2004. Advanced game design discussions. Mud-dev wiki - A (very) slowly growing resource on MUD creation. Mud Client/Server Interaction - A page on classic MUD telnet protocols. Mud Tech's fun/cool but ... - Greg Taylor gives good advice on mud design. Lost Library of MOO - Archive of scientific articles on mudding (in particular moo). Nick Gammon's hints thread - Contains a very useful list of things to think about when starting your new MUD. Lost Garden - A game development blog with long and interesting articles (not MUD-specific) What Games Are - A blog about general game design (not MUD-specific) The Alexandrian - A blog about tabletop roleplaying and board games, but with lots of general discussion about rule systems and game balance that could be applicable also for MUDs. Raph Koster's laws of game design - thought-provoking guidelines and things to think about when designing a virtual multiplayer world (Raph is known for Ultima Online among other things). Literature \u00b6 Richard Bartle Designing Virtual Worlds ( amazon page ) - Essential reading for the design of any persistent game world, written by the co-creator of the original game MUD . Published in 2003 but it's still as relevant now as when it came out. Covers everything you need to know and then some. Zed A. Shaw Learn Python the Hard way ( homepage ) - Despite the imposing name this book is for the absolute Python/programming beginner. One learns the language by gradually creating a small text game! It has been used by multiple users before moving on to Evennia. Update: This used to be free to read online, this is no longer the case. David M. Beazley Python Essential Reference (4th ed) ( amazon page ) - Our recommended book on Python; it not only efficiently summarizes the language but is also an excellent reference to the standard library for more experienced Python coders. Luciano Ramalho, Fluent Python ( o'reilly page ) - This is an excellent book for experienced Python coders willing to take their code to the next level. A great read with a lot of useful info also for veteran Pythonistas. Richard Cantillon An Essay on Economic Theory ( free pdf ) - A very good English translation of Essai sur la Nature du Commerce en G\u00e9n\u00e9ral , one of the foundations of modern economic theory. Written in 1730 but the translation is annotated and the essay is actually very easy to follow also for a modern reader. Required reading if you think of implementing a sane game economic system. Frameworks \u00b6 Django's homepage Documentation Code Twisted homepage Documentation Code Tools \u00b6 GIT Documentation Learn GIT in 15 minutes (interactive tutorial) Python Info \u00b6 Python Website Documentation Tutorial Library Reference Language Reference Python tips and tricks Credits \u00b6 Wiki Home Icons made by Freepik from flaticon.com , licensed under Creative Commons BY 3.0 .","title":"Links"},{"location":"Links.html#official-evennia-links","text":"evennia.com - Main Evennia portal page. Links to all corners of Evennia. Evennia github page - Download code and read documentation. Evennia official chat channel - Our official IRC chat #evennia at irc.freenode.net:6667. Evennia forums/mailing list - Web interface to our google group. Evennia development blog - Musings from the lead developer. Evennia's manual on ReadTheDocs - Read and download offline in html, PDF or epub formats. Evennia Game Index - An automated listing of Evennia games. Evennia on Open Hub Evennia on OpenHatch Evennia on PyPi Evennia subreddit (not much there yet though)","title":"Official Evennia links"},{"location":"Links.html#third-party-evennia-utilities-and-resources","text":"For publicly available games running on Evennia, add and find those in the Evennia game index instead! Discord Evennia channel - This is a fan-driven Discord channel with a bridge to the official Evennia IRC channel. Discord live blog of the Blackbirds Evennia game project. Unreal Engine Evennia plugin - an in-progress Unreal plugin for integrating Evennia with Epic Games' Unreal Engine. The dark net/March Hare MUD from the 2019 DEF CON 27 hacker conference in Paris. This is an Evennia game dir with batchcode to build the custom Hackers style cyberspace zone with puzzles and challenges used during the conference . Arx sources - Open-source code release of the very popular Arx Evennia game. Here are instructions for installing Evennia-wiki - An Evennia-specific Wiki for your website. Evcolor - Optional coloration for Evennia unit-test output. Paxboards - Evennia bulletin board system (both for telnet/web). Encarnia sources - An open-sourced game dir for Evennia with things like races, combat etc. Summary here . The world of Cool battles sources - Open source turn-based battle system for Evennia. It also has a live demo . nextRPI - A github project for making a toolbox for people to make RPI -style Evennia games. Muddery - A mud framework under development, based on an older fork of Evennia. It has some specific design goals for building and extending the game based on input files. vim-evennia - A mode for editing batch-build files ( .ev ) files in the vim text editor (Emacs users can use evennia-mode.el ). Other Evennia-related repos on github EvCast video series - Tutorial videos explaining installing Evennia, basic Python etc. Evennia-docker - Evennia in a Docker container for quick install and deployment in just a few commands. Evennia's docs in Chinese - A translated mirror of a slightly older Evennia version. Announcement here . Evennia for MUSHers - An article describing Evennia for those used to the MUSH way of doing things. Language Understanding for Text games using Deep reinforcement learning ( PDF ) - MIT research paper using Evennia to train AIs.","title":"Third-party Evennia utilities and resources"},{"location":"Links.html#other-useful-mud-development-resources","text":"ROM area reader - Parser for converting ROM area files to Python objects. Gossip MUD chat network","title":"Other useful mud development resources"},{"location":"Links.html#general-mud-forums-and-discussions","text":"MUD Coder's Guild - A blog and associated Slack channel with discussions on MUD development. MuSoapbox - Very active Mu* game community mainly focused on MUSH-type gaming. Imaginary Realities - An e-magazine on game and MUD design that has several articles about Evennia. There is also an archive of older issues from 1998-2001 that are still very relevant. Optional Realities - Mud development discussion forums that has regular articles on MUD development focused on roleplay-intensive games. After a HD crash it's not as content-rich as it once was. MudLab - Mud design discussion forum MudConnector - Mud listing and forums MudBytes - Mud listing and forums Top Mud Sites - Mud listing and forums Planet Mud-Dev - A blog aggregator following blogs of current MUD development (including Evennia) around the 'net. Worth to put among your RSS subscriptions. Mud Dev mailing list archive ( mirror ) - Influential mailing list active 1996-2004. Advanced game design discussions. Mud-dev wiki - A (very) slowly growing resource on MUD creation. Mud Client/Server Interaction - A page on classic MUD telnet protocols. Mud Tech's fun/cool but ... - Greg Taylor gives good advice on mud design. Lost Library of MOO - Archive of scientific articles on mudding (in particular moo). Nick Gammon's hints thread - Contains a very useful list of things to think about when starting your new MUD. Lost Garden - A game development blog with long and interesting articles (not MUD-specific) What Games Are - A blog about general game design (not MUD-specific) The Alexandrian - A blog about tabletop roleplaying and board games, but with lots of general discussion about rule systems and game balance that could be applicable also for MUDs. Raph Koster's laws of game design - thought-provoking guidelines and things to think about when designing a virtual multiplayer world (Raph is known for Ultima Online among other things).","title":"General MUD forums and discussions"},{"location":"Links.html#literature","text":"Richard Bartle Designing Virtual Worlds ( amazon page ) - Essential reading for the design of any persistent game world, written by the co-creator of the original game MUD . Published in 2003 but it's still as relevant now as when it came out. Covers everything you need to know and then some. Zed A. Shaw Learn Python the Hard way ( homepage ) - Despite the imposing name this book is for the absolute Python/programming beginner. One learns the language by gradually creating a small text game! It has been used by multiple users before moving on to Evennia. Update: This used to be free to read online, this is no longer the case. David M. Beazley Python Essential Reference (4th ed) ( amazon page ) - Our recommended book on Python; it not only efficiently summarizes the language but is also an excellent reference to the standard library for more experienced Python coders. Luciano Ramalho, Fluent Python ( o'reilly page ) - This is an excellent book for experienced Python coders willing to take their code to the next level. A great read with a lot of useful info also for veteran Pythonistas. Richard Cantillon An Essay on Economic Theory ( free pdf ) - A very good English translation of Essai sur la Nature du Commerce en G\u00e9n\u00e9ral , one of the foundations of modern economic theory. Written in 1730 but the translation is annotated and the essay is actually very easy to follow also for a modern reader. Required reading if you think of implementing a sane game economic system.","title":"Literature"},{"location":"Links.html#frameworks","text":"Django's homepage Documentation Code Twisted homepage Documentation Code","title":"Frameworks"},{"location":"Links.html#tools","text":"GIT Documentation Learn GIT in 15 minutes (interactive tutorial)","title":"Tools"},{"location":"Links.html#python-info","text":"Python Website Documentation Tutorial Library Reference Language Reference Python tips and tricks","title":"Python Info"},{"location":"Links.html#credits","text":"Wiki Home Icons made by Freepik from flaticon.com , licensed under Creative Commons BY 3.0 .","title":"Credits"},{"location":"Locks.html","text":"For most games it is a good idea to restrict what people can do. In Evennia such restrictions are applied and checked by something called locks . All Evennia entities ( Commands , Objects , Scripts , Accounts , Help System , messages and channels ) are accessed through locks. A lock can be thought of as an \"access rule\" restricting a particular use of an Evennia entity. Whenever another entity wants that kind of access the lock will analyze that entity in different ways to determine if access should be granted or not. Evennia implements a \"lockdown\" philosophy - all entities are inaccessible unless you explicitly define a lock that allows some or full access. Let's take an example: An object has a lock on itself that restricts how people may \"delete\" that object. Apart from knowing that it restricts deletion, the lock also knows that only players with the specific ID of, say, 34 are allowed to delete it. So whenever a player tries to run delete on the object, the delete command makes sure to check if this player is really allowed to do so. It calls the lock, which in turn checks if the player's id is 34 . Only then will it allow delete to go on with its job. Setting and checking a lock \u00b6 The in-game command for setting locks on objects is lock : > lock obj = <lockstring> The <lockstring> is a string of a certain form that defines the behaviour of the lock. We will go into more detail on how <lockstring> should look in the next section. Code-wise, Evennia handles locks through what is usually called locks on all relevant entities. This is a handler that allows you to add, delete and check locks. myobj.locks.add(<lockstring>) One can call locks.check() to perform a lock check, but to hide the underlying implementation all objects also have a convenience function called access . This should preferably be used. In the example below, accessing_obj is the object requesting the 'delete' access whereas obj is the object that might get deleted. This is how it would look (and does look) from inside the delete command: if not obj.access(accessing_obj, 'delete'): accessing_obj.msg(\"Sorry, you may not delete that.\") return Defining locks \u00b6 Defining a lock (i.e. an access restriction) in Evennia is done by adding simple strings of lock definitions to the object's locks property using obj.locks.add() . Here are some examples of lock strings (not including the quotes): delete:id(34) # only allow obj #34 to delete edit:all() # let everyone edit # only those who are not \"very_weak\" or are Admins may pick this up get: not attr(very_weak) or perm(Admin) Formally, a lockstring has the following syntax: access_type: [NOT] lockfunc1([arg1,..]) [AND|OR] [NOT] lockfunc2([arg1,...]) [...] where [] marks optional parts. AND , OR and NOT are not case sensitive and excess spaces are ignored. lockfunc1, lockfunc2 etc are special lock functions available to the lock system. So, a lockstring consists of the type of restriction (the access_type ), a colon ( : ) and then an expression involving function calls that determine what is needed to pass the lock. Each function returns either True or False . AND , OR and NOT work as they do normally in Python. If the total result is True , the lock is passed. You can create several lock types one after the other by separating them with a semicolon ( ; ) in the lockstring. The string below yields the same result as the previous example: delete:id(34);edit:all();get: not attr(very_weak) or perm(Admin) Valid access_types \u00b6 An access_type , the first part of a lockstring, defines what kind of capability a lock controls, such as \"delete\" or \"edit\". You may in principle name your access_type anything as long as it is unique for the particular object. The name of the access types is not case-sensitive. If you want to make sure the lock is used however, you should pick access_type names that you (or the default command set) actually checks for, as in the example of delete above that uses the 'delete' access_type . Below are the access_types checked by the default commandset. Commands cmd - this defines who may call this command at all. Objects : control - who is the \"owner\" of the object. Can set locks, delete it etc. Defaults to the creator of the object. call - who may call Object-commands stored on this Object except for the Object itself. By default, Objects share their Commands with anyone in the same location (e.g. so you can 'press' a Button object in the room). For Characters and Mobs (who likely only use those Commands for themselves and don't want to share them) this should usually be turned off completely, using something like call:false() . examine - who may examine this object's properties. delete - who may delete the object. edit - who may edit properties and attributes of the object. view - if the look command will display/list this object get - who may pick up the object and carry it around. puppet - who may \"become\" this object and control it as their \"character\". attrcreate - who may create new attributes on the object (default True) Characters : Same as for Objects Exits : Same as for Objects traverse - who may pass the exit. Accounts : examine - who may examine the account's properties. delete - who may delete the account. edit - who may edit the account's attributes and properties. msg - who may send messages to the account. boot - who may boot the account. Attributes : (only checked by obj.secure_attr ) attrread - see/access attribute attredit - change/delete attribute Channels : control - who is administrating the channel. This means the ability to delete the channel, boot listeners etc. send - who may send to the channel. listen - who may subscribe and listen to the channel. HelpEntry : examine - who may view this help entry (usually everyone) edit - who may edit this help entry. So to take an example, whenever an exit is to be traversed, a lock of the type traverse will be checked. Defining a suitable lock type for an exit object would thus involve a lockstring traverse: <lock functions> . Custom access_types \u00b6 As stated above, the access_type part of the lock is simply the 'name' or 'type' of the lock. The text is an arbitrary string that must be unique for an object. If adding a lock with the same access_type as one that already exists on the object, the new one override the old one. For example, if you wanted to create a bulletin board system and wanted to restrict who can either read a board or post to a board. You could then define locks such as: obj.locks.add(\"read:perm(Player);post:perm(Admin)\") This will create a 'read' access type for Characters having the Player permission or above and a 'post' access type for those with Admin permissions or above (see below how the perm() lock function works). When it comes time to test these permissions, simply check like this (in this example, the obj may be a board on the bulletin board system and accessing_obj is the player trying to read the board): if not obj.access(accessing_obj, 'read'): accessing_obj.msg(\"Sorry, you may not read that.\") return Lock functions \u00b6 A lock function is a normal Python function put in a place Evennia looks for such functions. The modules Evennia looks at is the list settings.LOCK_FUNC_MODULES . All functions in any of those modules will automatically be considered a valid lock function. The default ones are found in evennia/locks/lockfuncs.py and you can start adding your own in mygame/server/conf/lockfuncs.py . You can append the setting to add more module paths. To replace a default lock function, just add your own with the same name. A lock function must always accept at least two arguments - the accessing object (this is the object wanting to get access) and the accessed object (this is the object with the lock). Those two are fed automatically as the first two arguments to the function when the lock is checked. Any arguments explicitly given in the lock definition will appear as extra arguments. # A simple example lock function. Called with e.g. `id(34)`. This is # defined in, say mygame/server/conf/lockfuncs.py def id(accessing_obj, accessed_obj, *args, **kwargs): if args: wanted_id = args[0] return accessing_obj.id == wanted_id return False The above could for example be used in a lock function like this: # we have `obj` and `owner_object` from before obj.locks.add(\"edit: id(%i)\" % owner_object.id) We could check if the \"edit\" lock is passed with something like this: # as part of a Command's func() method, for example if not obj.access(caller, \"edit\"): caller.msg(\"You don't have access to edit this!\") return In this example, everyone except the caller with the right id will get the error. (Using the * and ** syntax causes Python to magically put all extra arguments into a list args and all keyword arguments into a dictionary kwargs respectively. If you are unfamiliar with how *args and **kwargs work, see the Python manuals). Some useful default lockfuncs (see src/locks/lockfuncs.py for more): true()/all() - give access to everyone false()/none()/superuser() - give access to none. Superusers bypass the check entirely and are thus the only ones who will pass this check. perm(perm) - this tries to match a given permission property, on an Account firsthand, on a Character second. See below . perm_above(perm) - like perm but requires a \"higher\" permission level than the one given. id(num)/dbref(num) - checks so the access_object has a certain dbref/id. attr(attrname) - checks if a certain Attribute exists on accessing_object. attr(attrname, value) - checks so an attribute exists on accessing_object and has the given value. attr_gt(attrname, value) - checks so accessing_object has a value larger ( > ) than the given value. attr_ge, attr_lt, attr_le, attr_ne - corresponding for >= , < , <= and != . holds(objid) - checks so the accessing objects contains an object of given name or dbref. inside() - checks so the accessing object is inside the accessed object (the inverse of holds() ). pperm(perm) , pid(num)/pdbref(num) - same as perm , id/dbref but always looks for permissions and dbrefs of Accounts , not on Characters. serversetting(settingname, value) - Only returns True if Evennia has a given setting or a setting set to a given value. Checking simple strings \u00b6 Sometimes you don't really need to look up a certain lock, you just want to check a lockstring. A common use is inside Commands, in order to check if a user has a certain permission. The lockhandler has a method check_lockstring(accessing_obj, lockstring, bypass_superuser=False) that allows this. # inside command definition if not self.caller.locks.check_lockstring(self.caller, \"dummy:perm(Admin)\"): self.caller.msg(\"You must be an Admin or higher to do this!\") return Note here that the access_type can be left to a dummy value since this method does not actually do a Lock lookup. Default locks \u00b6 Evennia sets up a few basic locks on all new objects and accounts (if we didn't, noone would have any access to anything from the start). This is all defined in the root Typeclasses of the respective entity, in the hook method basetype_setup() (which you usually don't want to edit unless you want to change how basic stuff like rooms and exits store their internal variables). This is called once, before at_object_creation , so just put them in the latter method on your child object to change the default. Also creation commands like create changes the locks of objects you create - for example it sets the control lock_type so as to allow you, its creator, to control and delete the object. Permissions \u00b6 This section covers the underlying code use of permissions. If you just want to learn how to practically assign permissions in-game, refer to the Building Permissions page, which details how you use the perm command. A permission is simply a list of text strings stored in the handler permissions on Objects and Accounts . Permissions can be used as a convenient way to structure access levels and hierarchies. It is set by the perm command. Permissions are especially handled by the perm() and pperm() lock functions listed above. Let's say we have a red_key object. We also have red chests that we want to unlock with this key. perm red_key = unlocks_red_chests This gives the red_key object the permission \"unlocks_red_chests\". Next we lock our red chests: lock red chest = unlock:perm(unlocks_red_chests) What this lock will expect is to the fed the actual key object. The perm() lock function will check the permissions set on the key and only return true if the permission is the one given. Finally we need to actually check this lock somehow. Let's say the chest has an command open <key> sitting on itself. Somewhere in its code the command needs to figure out which key you are using and test if this key has the correct permission: # self.obj is the chest # and used_key is the key we used as argument to # the command. The self.caller is the one trying # to unlock the chest if not self.obj.access(used_key, \"unlock\"): self.caller.msg(\"The key does not fit!\") return All new accounts are given a default set of permissions defined by settings.PERMISSION_ACCOUNT_DEFAULT . Selected permission strings can be organized in a permission hierarchy by editing the tuple settings.PERMISSION_HIERARCHY . Evennia's default permission hierarchy is as follows: Developer # like superuser but affected by locks Admin # can administrate accounts Builder # can edit the world Helper # can edit help files Player # can chat and send tells (default level) (Also the plural form works, so you could use Developers etc too). There is also a Guest level below Player that is only active if settings.GUEST_ENABLED is set. This is never part of settings.PERMISSION_HIERARCHY . The main use of this is that if you use the lock function perm() mentioned above, a lock check for a particular permission in the hierarchy will also grant access to those with higher hierarchy access. So if you have the permission \"Admin\" you will also pass a lock defined as perm(Builder) or any of those levels below \"Admin\". When doing an access check from an Object or Character, the perm() lock function will always first use the permissions of any Account connected to that Object before checking for permissions on the Object. In the case of hierarchical permissions (Admins, Builders etc), the Account permission will always be used (this stops an Account from escalating their permission by puppeting a high-level Character). If the permission looked for is not in the hierarchy, an exact match is required, first on the Account and if not found there (or if no Account is connected), then on the Object itself. Here is how you use perm to give an account more permissions: perm/account Tommy = Builders perm/account/del Tommy = Builders # remove it again Note the use of the /account switch. It means you assign the permission to the Accounts Tommy instead of any Character that also happens to be named \"Tommy\". Putting permissions on the Account guarantees that they are kept, regardless of which Character they are currently puppeting. This is especially important to remember when assigning permissions from the hierarchy tree - as mentioned above, an Account's permissions will overrule that of its character. So to be sure to avoid confusion you should generally put hierarchy permissions on the Account, not on their Characters (but see also quelling ). Below is an example of an object without any connected account obj1.permissions = [\"Builders\", \"cool_guy\"] obj2.locks.add(\"enter:perm_above(Accounts) and perm(cool_guy)\") obj2.access(obj1, \"enter\") # this returns True! And one example of a puppet with a connected account: account.permissions.add(\"Accounts\") puppet.permissions.add(\"Builders\", \"cool_guy\") obj2.locks.add(\"enter:perm_above(Accounts) and perm(cool_guy)\") obj2.access(puppet, \"enter\") # this returns False! Superusers \u00b6 There is normally only one superuser account and that is the one first created when starting Evennia (User #1). This is sometimes known as the \"Owner\" or \"God\" user. A superuser has more than full access - it completely bypasses all locks so no checks are even run. This allows for the superuser to always have access to everything in an emergency. But it also hides any eventual errors you might have made in your lock definitions. So when trying out game systems you should either use quelling (see below) or make a second Developer-level character so your locks get tested correctly. Quelling \u00b6 The quell command can be used to enforce the perm() lockfunc to ignore permissions on the Account and instead use the permissions on the Character only. This can be used e.g. by staff to test out things with a lower permission level. Return to the normal operation with unquell . Note that quelling will use the smallest of any hierarchical permission on the Account or Character, so one cannot escalate one's Account permission by quelling to a high-permission Character. Also the superuser can quell their powers this way, making them affectable by locks. More Lock definition examples \u00b6 examine: attr(eyesight, excellent) or perm(Builders) You are only allowed to do examine on this object if you have 'excellent' eyesight (that is, has an Attribute eyesight with the value excellent defined on yourself) or if you have the \"Builders\" permission string assigned to you. open: holds('the green key') or perm(Builder) This could be called by the open command on a \"door\" object. The check is passed if you are a Builder or has the right key in your inventory. cmd: perm(Builders) Evennia's command handler looks for a lock of type cmd to determine if a user is allowed to even call upon a particular command or not. When you define a command, this is the kind of lock you must set. See the default command set for lots of examples. If a character/account don't pass the cmd lock type the command will not even appear in their help list. cmd: not perm(no_tell) \"Permissions\" can also be used to block users or implement highly specific bans. The above example would be be added as a lock string to the tell command. This will allow everyone not having the \"permission\" no_tell to use the tell command. You could easily give an account the \"permission\" no_tell to disable their use of this particular command henceforth. dbref = caller.id lockstring = \"control:id(%s);examine:perm(Builders);delete:id(%s) or perm(Admin);get:all()\" % (dbref, dbref) new_obj.locks.add(lockstring) This is how the create command sets up new objects. In sequence, this permission string sets the owner of this object be the creator (the one running create ). Builders may examine the object whereas only Admins and the creator may delete it. Everyone can pick it up. A complete example of setting locks on an object \u00b6 Assume we have two objects - one is ourselves (not superuser) and the other is an Object called box . > create/drop box > desc box = \"This is a very big and heavy box.\" We want to limit which objects can pick up this heavy box. Let's say that to do that we require the would-be lifter to to have an attribute strength on themselves, with a value greater than 50. We assign it to ourselves to begin with. > set self/strength = 45 Ok, so for testing we made ourselves strong, but not strong enough. Now we need to look at what happens when someone tries to pick up the the box - they use the get command (in the default set). This is defined in evennia/commands/default/general.py . In its code we find this snippet: if not obj.access(caller, 'get'): if obj.db.get_err_msg: caller.msg(obj.db.get_err_msg) else: caller.msg(\"You can't get that.\") return So the get command looks for a lock with the type get (not so surprising). It also looks for an Attribute on the checked object called get_err_msg in order to return a customized error message. Sounds good! Let's start by setting that on the box: > set box/get_err_msg = You are not strong enough to lift this box. Next we need to craft a Lock of type get on our box. We want it to only be passed if the accessing object has the attribute strength of the right value. For this we would need to create a lock function that checks if attributes have a value greater than a given value. Luckily there is already such a one included in evennia (see evennia/locks/lockfuncs.py ), called attr_gt . So the lock string will look like this: get:attr_gt(strength, 50) . We put this on the box now: lock box = get:attr_gt(strength, 50) Try to get the object and you should get the message that we are not strong enough. Increase your strength above 50 however and you'll pick it up no problem. Done! A very heavy box! If you wanted to set this up in python code, it would look something like this: from evennia import create_object # create, then set the lock box = create_object(None, key=\"box\") box.locks.add(\"get:attr_gt(strength, 50)\") # or we can assign locks in one go right away box = create_object(None, key=\"box\", locks=\"get:attr_gt(strength, 50)\") # set the attributes box.db.desc = \"This is a very big and heavy box.\" box.db.get_err_msg = \"You are not strong enough to lift this box.\" # one heavy box, ready to withstand all but the strongest... On Django's permission system \u00b6 Django also implements a comprehensive permission/security system of its own. The reason we don't use that is because it is app-centric (app in the Django sense). Its permission strings are of the form appname.permstring and it automatically adds three of them for each database model in the app - for the app evennia/object this would be for example 'object.create', 'object.admin' and 'object.edit'. This makes a lot of sense for a web application, not so much for a MUD, especially when we try to hide away as much of the underlying architecture as possible. The django permissions are not completely gone however. We use it for validating passwords during login. It is also used exclusively for managing Evennia's web-based admin site, which is a graphical front-end for the database of Evennia. You edit and assign such permissions directly from the web interface. It's stand-alone from the permissions described above.","title":"Locks"},{"location":"Locks.html#setting-and-checking-a-lock","text":"The in-game command for setting locks on objects is lock : > lock obj = <lockstring> The <lockstring> is a string of a certain form that defines the behaviour of the lock. We will go into more detail on how <lockstring> should look in the next section. Code-wise, Evennia handles locks through what is usually called locks on all relevant entities. This is a handler that allows you to add, delete and check locks. myobj.locks.add(<lockstring>) One can call locks.check() to perform a lock check, but to hide the underlying implementation all objects also have a convenience function called access . This should preferably be used. In the example below, accessing_obj is the object requesting the 'delete' access whereas obj is the object that might get deleted. This is how it would look (and does look) from inside the delete command: if not obj.access(accessing_obj, 'delete'): accessing_obj.msg(\"Sorry, you may not delete that.\") return","title":"Setting and checking a lock"},{"location":"Locks.html#defining-locks","text":"Defining a lock (i.e. an access restriction) in Evennia is done by adding simple strings of lock definitions to the object's locks property using obj.locks.add() . Here are some examples of lock strings (not including the quotes): delete:id(34) # only allow obj #34 to delete edit:all() # let everyone edit # only those who are not \"very_weak\" or are Admins may pick this up get: not attr(very_weak) or perm(Admin) Formally, a lockstring has the following syntax: access_type: [NOT] lockfunc1([arg1,..]) [AND|OR] [NOT] lockfunc2([arg1,...]) [...] where [] marks optional parts. AND , OR and NOT are not case sensitive and excess spaces are ignored. lockfunc1, lockfunc2 etc are special lock functions available to the lock system. So, a lockstring consists of the type of restriction (the access_type ), a colon ( : ) and then an expression involving function calls that determine what is needed to pass the lock. Each function returns either True or False . AND , OR and NOT work as they do normally in Python. If the total result is True , the lock is passed. You can create several lock types one after the other by separating them with a semicolon ( ; ) in the lockstring. The string below yields the same result as the previous example: delete:id(34);edit:all();get: not attr(very_weak) or perm(Admin)","title":"Defining locks"},{"location":"Locks.html#valid-access_types","text":"An access_type , the first part of a lockstring, defines what kind of capability a lock controls, such as \"delete\" or \"edit\". You may in principle name your access_type anything as long as it is unique for the particular object. The name of the access types is not case-sensitive. If you want to make sure the lock is used however, you should pick access_type names that you (or the default command set) actually checks for, as in the example of delete above that uses the 'delete' access_type . Below are the access_types checked by the default commandset. Commands cmd - this defines who may call this command at all. Objects : control - who is the \"owner\" of the object. Can set locks, delete it etc. Defaults to the creator of the object. call - who may call Object-commands stored on this Object except for the Object itself. By default, Objects share their Commands with anyone in the same location (e.g. so you can 'press' a Button object in the room). For Characters and Mobs (who likely only use those Commands for themselves and don't want to share them) this should usually be turned off completely, using something like call:false() . examine - who may examine this object's properties. delete - who may delete the object. edit - who may edit properties and attributes of the object. view - if the look command will display/list this object get - who may pick up the object and carry it around. puppet - who may \"become\" this object and control it as their \"character\". attrcreate - who may create new attributes on the object (default True) Characters : Same as for Objects Exits : Same as for Objects traverse - who may pass the exit. Accounts : examine - who may examine the account's properties. delete - who may delete the account. edit - who may edit the account's attributes and properties. msg - who may send messages to the account. boot - who may boot the account. Attributes : (only checked by obj.secure_attr ) attrread - see/access attribute attredit - change/delete attribute Channels : control - who is administrating the channel. This means the ability to delete the channel, boot listeners etc. send - who may send to the channel. listen - who may subscribe and listen to the channel. HelpEntry : examine - who may view this help entry (usually everyone) edit - who may edit this help entry. So to take an example, whenever an exit is to be traversed, a lock of the type traverse will be checked. Defining a suitable lock type for an exit object would thus involve a lockstring traverse: <lock functions> .","title":"Valid access_types"},{"location":"Locks.html#custom-access_types","text":"As stated above, the access_type part of the lock is simply the 'name' or 'type' of the lock. The text is an arbitrary string that must be unique for an object. If adding a lock with the same access_type as one that already exists on the object, the new one override the old one. For example, if you wanted to create a bulletin board system and wanted to restrict who can either read a board or post to a board. You could then define locks such as: obj.locks.add(\"read:perm(Player);post:perm(Admin)\") This will create a 'read' access type for Characters having the Player permission or above and a 'post' access type for those with Admin permissions or above (see below how the perm() lock function works). When it comes time to test these permissions, simply check like this (in this example, the obj may be a board on the bulletin board system and accessing_obj is the player trying to read the board): if not obj.access(accessing_obj, 'read'): accessing_obj.msg(\"Sorry, you may not read that.\") return","title":"Custom access_types"},{"location":"Locks.html#lock-functions","text":"A lock function is a normal Python function put in a place Evennia looks for such functions. The modules Evennia looks at is the list settings.LOCK_FUNC_MODULES . All functions in any of those modules will automatically be considered a valid lock function. The default ones are found in evennia/locks/lockfuncs.py and you can start adding your own in mygame/server/conf/lockfuncs.py . You can append the setting to add more module paths. To replace a default lock function, just add your own with the same name. A lock function must always accept at least two arguments - the accessing object (this is the object wanting to get access) and the accessed object (this is the object with the lock). Those two are fed automatically as the first two arguments to the function when the lock is checked. Any arguments explicitly given in the lock definition will appear as extra arguments. # A simple example lock function. Called with e.g. `id(34)`. This is # defined in, say mygame/server/conf/lockfuncs.py def id(accessing_obj, accessed_obj, *args, **kwargs): if args: wanted_id = args[0] return accessing_obj.id == wanted_id return False The above could for example be used in a lock function like this: # we have `obj` and `owner_object` from before obj.locks.add(\"edit: id(%i)\" % owner_object.id) We could check if the \"edit\" lock is passed with something like this: # as part of a Command's func() method, for example if not obj.access(caller, \"edit\"): caller.msg(\"You don't have access to edit this!\") return In this example, everyone except the caller with the right id will get the error. (Using the * and ** syntax causes Python to magically put all extra arguments into a list args and all keyword arguments into a dictionary kwargs respectively. If you are unfamiliar with how *args and **kwargs work, see the Python manuals). Some useful default lockfuncs (see src/locks/lockfuncs.py for more): true()/all() - give access to everyone false()/none()/superuser() - give access to none. Superusers bypass the check entirely and are thus the only ones who will pass this check. perm(perm) - this tries to match a given permission property, on an Account firsthand, on a Character second. See below . perm_above(perm) - like perm but requires a \"higher\" permission level than the one given. id(num)/dbref(num) - checks so the access_object has a certain dbref/id. attr(attrname) - checks if a certain Attribute exists on accessing_object. attr(attrname, value) - checks so an attribute exists on accessing_object and has the given value. attr_gt(attrname, value) - checks so accessing_object has a value larger ( > ) than the given value. attr_ge, attr_lt, attr_le, attr_ne - corresponding for >= , < , <= and != . holds(objid) - checks so the accessing objects contains an object of given name or dbref. inside() - checks so the accessing object is inside the accessed object (the inverse of holds() ). pperm(perm) , pid(num)/pdbref(num) - same as perm , id/dbref but always looks for permissions and dbrefs of Accounts , not on Characters. serversetting(settingname, value) - Only returns True if Evennia has a given setting or a setting set to a given value.","title":"Lock functions"},{"location":"Locks.html#checking-simple-strings","text":"Sometimes you don't really need to look up a certain lock, you just want to check a lockstring. A common use is inside Commands, in order to check if a user has a certain permission. The lockhandler has a method check_lockstring(accessing_obj, lockstring, bypass_superuser=False) that allows this. # inside command definition if not self.caller.locks.check_lockstring(self.caller, \"dummy:perm(Admin)\"): self.caller.msg(\"You must be an Admin or higher to do this!\") return Note here that the access_type can be left to a dummy value since this method does not actually do a Lock lookup.","title":"Checking simple strings"},{"location":"Locks.html#default-locks","text":"Evennia sets up a few basic locks on all new objects and accounts (if we didn't, noone would have any access to anything from the start). This is all defined in the root Typeclasses of the respective entity, in the hook method basetype_setup() (which you usually don't want to edit unless you want to change how basic stuff like rooms and exits store their internal variables). This is called once, before at_object_creation , so just put them in the latter method on your child object to change the default. Also creation commands like create changes the locks of objects you create - for example it sets the control lock_type so as to allow you, its creator, to control and delete the object.","title":"Default locks"},{"location":"Locks.html#permissions","text":"This section covers the underlying code use of permissions. If you just want to learn how to practically assign permissions in-game, refer to the Building Permissions page, which details how you use the perm command. A permission is simply a list of text strings stored in the handler permissions on Objects and Accounts . Permissions can be used as a convenient way to structure access levels and hierarchies. It is set by the perm command. Permissions are especially handled by the perm() and pperm() lock functions listed above. Let's say we have a red_key object. We also have red chests that we want to unlock with this key. perm red_key = unlocks_red_chests This gives the red_key object the permission \"unlocks_red_chests\". Next we lock our red chests: lock red chest = unlock:perm(unlocks_red_chests) What this lock will expect is to the fed the actual key object. The perm() lock function will check the permissions set on the key and only return true if the permission is the one given. Finally we need to actually check this lock somehow. Let's say the chest has an command open <key> sitting on itself. Somewhere in its code the command needs to figure out which key you are using and test if this key has the correct permission: # self.obj is the chest # and used_key is the key we used as argument to # the command. The self.caller is the one trying # to unlock the chest if not self.obj.access(used_key, \"unlock\"): self.caller.msg(\"The key does not fit!\") return All new accounts are given a default set of permissions defined by settings.PERMISSION_ACCOUNT_DEFAULT . Selected permission strings can be organized in a permission hierarchy by editing the tuple settings.PERMISSION_HIERARCHY . Evennia's default permission hierarchy is as follows: Developer # like superuser but affected by locks Admin # can administrate accounts Builder # can edit the world Helper # can edit help files Player # can chat and send tells (default level) (Also the plural form works, so you could use Developers etc too). There is also a Guest level below Player that is only active if settings.GUEST_ENABLED is set. This is never part of settings.PERMISSION_HIERARCHY . The main use of this is that if you use the lock function perm() mentioned above, a lock check for a particular permission in the hierarchy will also grant access to those with higher hierarchy access. So if you have the permission \"Admin\" you will also pass a lock defined as perm(Builder) or any of those levels below \"Admin\". When doing an access check from an Object or Character, the perm() lock function will always first use the permissions of any Account connected to that Object before checking for permissions on the Object. In the case of hierarchical permissions (Admins, Builders etc), the Account permission will always be used (this stops an Account from escalating their permission by puppeting a high-level Character). If the permission looked for is not in the hierarchy, an exact match is required, first on the Account and if not found there (or if no Account is connected), then on the Object itself. Here is how you use perm to give an account more permissions: perm/account Tommy = Builders perm/account/del Tommy = Builders # remove it again Note the use of the /account switch. It means you assign the permission to the Accounts Tommy instead of any Character that also happens to be named \"Tommy\". Putting permissions on the Account guarantees that they are kept, regardless of which Character they are currently puppeting. This is especially important to remember when assigning permissions from the hierarchy tree - as mentioned above, an Account's permissions will overrule that of its character. So to be sure to avoid confusion you should generally put hierarchy permissions on the Account, not on their Characters (but see also quelling ). Below is an example of an object without any connected account obj1.permissions = [\"Builders\", \"cool_guy\"] obj2.locks.add(\"enter:perm_above(Accounts) and perm(cool_guy)\") obj2.access(obj1, \"enter\") # this returns True! And one example of a puppet with a connected account: account.permissions.add(\"Accounts\") puppet.permissions.add(\"Builders\", \"cool_guy\") obj2.locks.add(\"enter:perm_above(Accounts) and perm(cool_guy)\") obj2.access(puppet, \"enter\") # this returns False!","title":"Permissions"},{"location":"Locks.html#superusers","text":"There is normally only one superuser account and that is the one first created when starting Evennia (User #1). This is sometimes known as the \"Owner\" or \"God\" user. A superuser has more than full access - it completely bypasses all locks so no checks are even run. This allows for the superuser to always have access to everything in an emergency. But it also hides any eventual errors you might have made in your lock definitions. So when trying out game systems you should either use quelling (see below) or make a second Developer-level character so your locks get tested correctly.","title":"Superusers"},{"location":"Locks.html#quelling","text":"The quell command can be used to enforce the perm() lockfunc to ignore permissions on the Account and instead use the permissions on the Character only. This can be used e.g. by staff to test out things with a lower permission level. Return to the normal operation with unquell . Note that quelling will use the smallest of any hierarchical permission on the Account or Character, so one cannot escalate one's Account permission by quelling to a high-permission Character. Also the superuser can quell their powers this way, making them affectable by locks.","title":"Quelling"},{"location":"Locks.html#more-lock-definition-examples","text":"examine: attr(eyesight, excellent) or perm(Builders) You are only allowed to do examine on this object if you have 'excellent' eyesight (that is, has an Attribute eyesight with the value excellent defined on yourself) or if you have the \"Builders\" permission string assigned to you. open: holds('the green key') or perm(Builder) This could be called by the open command on a \"door\" object. The check is passed if you are a Builder or has the right key in your inventory. cmd: perm(Builders) Evennia's command handler looks for a lock of type cmd to determine if a user is allowed to even call upon a particular command or not. When you define a command, this is the kind of lock you must set. See the default command set for lots of examples. If a character/account don't pass the cmd lock type the command will not even appear in their help list. cmd: not perm(no_tell) \"Permissions\" can also be used to block users or implement highly specific bans. The above example would be be added as a lock string to the tell command. This will allow everyone not having the \"permission\" no_tell to use the tell command. You could easily give an account the \"permission\" no_tell to disable their use of this particular command henceforth. dbref = caller.id lockstring = \"control:id(%s);examine:perm(Builders);delete:id(%s) or perm(Admin);get:all()\" % (dbref, dbref) new_obj.locks.add(lockstring) This is how the create command sets up new objects. In sequence, this permission string sets the owner of this object be the creator (the one running create ). Builders may examine the object whereas only Admins and the creator may delete it. Everyone can pick it up.","title":"More Lock definition examples"},{"location":"Locks.html#a-complete-example-of-setting-locks-on-an-object","text":"Assume we have two objects - one is ourselves (not superuser) and the other is an Object called box . > create/drop box > desc box = \"This is a very big and heavy box.\" We want to limit which objects can pick up this heavy box. Let's say that to do that we require the would-be lifter to to have an attribute strength on themselves, with a value greater than 50. We assign it to ourselves to begin with. > set self/strength = 45 Ok, so for testing we made ourselves strong, but not strong enough. Now we need to look at what happens when someone tries to pick up the the box - they use the get command (in the default set). This is defined in evennia/commands/default/general.py . In its code we find this snippet: if not obj.access(caller, 'get'): if obj.db.get_err_msg: caller.msg(obj.db.get_err_msg) else: caller.msg(\"You can't get that.\") return So the get command looks for a lock with the type get (not so surprising). It also looks for an Attribute on the checked object called get_err_msg in order to return a customized error message. Sounds good! Let's start by setting that on the box: > set box/get_err_msg = You are not strong enough to lift this box. Next we need to craft a Lock of type get on our box. We want it to only be passed if the accessing object has the attribute strength of the right value. For this we would need to create a lock function that checks if attributes have a value greater than a given value. Luckily there is already such a one included in evennia (see evennia/locks/lockfuncs.py ), called attr_gt . So the lock string will look like this: get:attr_gt(strength, 50) . We put this on the box now: lock box = get:attr_gt(strength, 50) Try to get the object and you should get the message that we are not strong enough. Increase your strength above 50 however and you'll pick it up no problem. Done! A very heavy box! If you wanted to set this up in python code, it would look something like this: from evennia import create_object # create, then set the lock box = create_object(None, key=\"box\") box.locks.add(\"get:attr_gt(strength, 50)\") # or we can assign locks in one go right away box = create_object(None, key=\"box\", locks=\"get:attr_gt(strength, 50)\") # set the attributes box.db.desc = \"This is a very big and heavy box.\" box.db.get_err_msg = \"You are not strong enough to lift this box.\" # one heavy box, ready to withstand all but the strongest...","title":"A complete example of setting locks on an object"},{"location":"Locks.html#on-djangos-permission-system","text":"Django also implements a comprehensive permission/security system of its own. The reason we don't use that is because it is app-centric (app in the Django sense). Its permission strings are of the form appname.permstring and it automatically adds three of them for each database model in the app - for the app evennia/object this would be for example 'object.create', 'object.admin' and 'object.edit'. This makes a lot of sense for a web application, not so much for a MUD, especially when we try to hide away as much of the underlying architecture as possible. The django permissions are not completely gone however. We use it for validating passwords during login. It is also used exclusively for managing Evennia's web-based admin site, which is a graphical front-end for the database of Evennia. You edit and assign such permissions directly from the web interface. It's stand-alone from the permissions described above.","title":"On Django's permission system"},{"location":"Manually-Configuring-Color.html","text":"This is a small tutorial for customizing your character objects, using the example of letting users turn on and off ANSI color parsing as an example. @options NOCOLOR=True will now do what this tutorial shows, but the tutorial subject can be applied to other toggles you may want, as well. In the Building guide's Colors page you can learn how to add color to your game by using special markup. Colors enhance the gaming experience, but not all users want color. Examples would be users working from clients that don't support color, or people with various seeing disabilities that rely on screen readers to play your game. Also, whereas Evennia normally automatically detects if a client supports color, it may get it wrong. Being able to turn it on manually if you know it should work could be a nice feature. So here's how to allow those users to remove color. It basically means you implementing a simple configuration system for your characters. This is the basic sequence: Define your own default character typeclass, inheriting from Evennia's default. Set an attribute on the character to control markup on/off. Set your custom character class to be the default for new accounts. Overload the msg() method on the typeclass and change how it uses markup. Create a custom command to allow users to change their setting. Setting up a custom Typeclass \u00b6 Create a new module in mygame/typeclasses named, for example, mycharacter.py . Alternatively you can simply add a new class to 'mygamegame/typeclasses/characters.py'. In your new module(or characters.py), create a new Typeclass inheriting from evennia.DefaultCharacter . We will also import evennia.utils.ansi , which we will use later. from evennia import Character from evennia.utils import ansi class ColorableCharacter(Character): at_object_creation(self): # set a color config value self.db.config_color = True Above we set a simple config value as an Attribute . Let's make sure that new characters are created of this type. Edit your mygame/server/conf/settings.py file and add/change BASE_CHARACTER_TYPECLASS to point to your new character class. Observe that this will only affect new characters, not those already created. You have to convert already created characters to the new typeclass by using the @typeclass command (try on a secondary character first though, to test that everything works - you don't want to render your root user unusable!). @typeclass/reset/force Bob = mycharacter.ColorableCharacter @typeclass changes Bob's typeclass and runs all its creation hooks all over again. The /reset switch clears all attributes and properties back to the default for the new typeclass - this is useful in this case to avoid ending up with an object having a \"mixture\" of properties from the old typeclass and the new one. /force might be needed if you edit the typeclass and want to update the object despite the actual typeclass name not having changed. Overload the msg() method \u00b6 Next we need to overload the msg() method. What we want is to check the configuration value before calling the main function. The original msg method call is seen in evennia/objects/objects.py and is called like this: msg(self, text=None, from_obj=None, session=None, options=None, **kwargs): As long as we define a method on our custom object with the same name and keep the same number of arguments/keywords we will overload the original. Here's how it could look: class ColorableCharacter(Character): # [...] msg(self, text=None, from_obj=None, session=None, options=None, **kwargs): \"our custom msg()\" if self.db.config_color is not None: # this would mean it was not set if not self.db.config_color: # remove the ANSI from the text text = ansi.strip_ansi(text) super().msg(text=text, from_obj=from_obj, session=session, **kwargs) Above we create a custom version of the msg() method. If the configuration Attribute is set, it strips the ANSI from the text it is about to send, and then calls the parent msg() as usual. You need to @reload before your changes become visible. There we go! Just flip the attribute config_color to False and your users will not see any color. As superuser (assuming you use the Typeclass ColorableCharacter ) you can test this with the @py command: @py self.db.config_color = False Custom color config command \u00b6 For completeness, let's add a custom command so users can turn off their color display themselves if they want. In mygame/commands , create a new file, call it for example configcmds.py (it's likely that you'll want to add other commands for configuration down the line). You can also copy/rename the command template. from evennia import Command class CmdConfigColor(Command): \"\"\" Configures your color Usage: @togglecolor on|off This turns ANSI-colors on/off. Default is on. \"\"\" key = \"@togglecolor\" aliases = [\"@setcolor\"] def func(self): \"implements the command\" # first we must remove whitespace from the argument self.args = self.args.strip() if not self.args or not self.args in (\"on\", \"off\"): self.caller.msg(\"Usage: @setcolor on|off\") return if self.args == \"on\": self.caller.db.config_color = True # send a message with a tiny bit of formatting, just for fun self.caller.msg(\"Color was turned |won|W.\") else: self.caller.db.config_color = False self.caller.msg(\"Color was turned off.\") Lastly, we make this command available to the user by adding it to the default CharacterCmdSet in mygame/commands/default_cmdsets.py and reloading the server. Make sure you also import the command: from mygame.commands import configcmds class CharacterCmdSet(default_cmds.CharacterCmdSet): # [...] def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # # any commands you add below will overload the default ones. # # here is the only line that we edit self.add(configcmds.CmdConfigColor()) More colors \u00b6 Apart from ANSI colors, Evennia also supports Xterm256 colors (See Colors ). The msg() method supports the xterm256 keyword for manually activating/deactiving xterm256. It should be easy to expand the above example to allow players to customize xterm256 regardless of if Evennia thinks their client supports it or not. To get a better understanding of how msg() works with keywords, you can try this as superuser: @py self.msg(\"|123Dark blue with xterm256, bright blue with ANSI\", xterm256=True) @py self.msg(\"|gThis should be uncolored\", nomarkup=True)","title":"Manually Configuring Color"},{"location":"Manually-Configuring-Color.html#setting-up-a-custom-typeclass","text":"Create a new module in mygame/typeclasses named, for example, mycharacter.py . Alternatively you can simply add a new class to 'mygamegame/typeclasses/characters.py'. In your new module(or characters.py), create a new Typeclass inheriting from evennia.DefaultCharacter . We will also import evennia.utils.ansi , which we will use later. from evennia import Character from evennia.utils import ansi class ColorableCharacter(Character): at_object_creation(self): # set a color config value self.db.config_color = True Above we set a simple config value as an Attribute . Let's make sure that new characters are created of this type. Edit your mygame/server/conf/settings.py file and add/change BASE_CHARACTER_TYPECLASS to point to your new character class. Observe that this will only affect new characters, not those already created. You have to convert already created characters to the new typeclass by using the @typeclass command (try on a secondary character first though, to test that everything works - you don't want to render your root user unusable!). @typeclass/reset/force Bob = mycharacter.ColorableCharacter @typeclass changes Bob's typeclass and runs all its creation hooks all over again. The /reset switch clears all attributes and properties back to the default for the new typeclass - this is useful in this case to avoid ending up with an object having a \"mixture\" of properties from the old typeclass and the new one. /force might be needed if you edit the typeclass and want to update the object despite the actual typeclass name not having changed.","title":"Setting up a custom Typeclass"},{"location":"Manually-Configuring-Color.html#overload-the-msg-method","text":"Next we need to overload the msg() method. What we want is to check the configuration value before calling the main function. The original msg method call is seen in evennia/objects/objects.py and is called like this: msg(self, text=None, from_obj=None, session=None, options=None, **kwargs): As long as we define a method on our custom object with the same name and keep the same number of arguments/keywords we will overload the original. Here's how it could look: class ColorableCharacter(Character): # [...] msg(self, text=None, from_obj=None, session=None, options=None, **kwargs): \"our custom msg()\" if self.db.config_color is not None: # this would mean it was not set if not self.db.config_color: # remove the ANSI from the text text = ansi.strip_ansi(text) super().msg(text=text, from_obj=from_obj, session=session, **kwargs) Above we create a custom version of the msg() method. If the configuration Attribute is set, it strips the ANSI from the text it is about to send, and then calls the parent msg() as usual. You need to @reload before your changes become visible. There we go! Just flip the attribute config_color to False and your users will not see any color. As superuser (assuming you use the Typeclass ColorableCharacter ) you can test this with the @py command: @py self.db.config_color = False","title":"Overload the msg() method"},{"location":"Manually-Configuring-Color.html#custom-color-config-command","text":"For completeness, let's add a custom command so users can turn off their color display themselves if they want. In mygame/commands , create a new file, call it for example configcmds.py (it's likely that you'll want to add other commands for configuration down the line). You can also copy/rename the command template. from evennia import Command class CmdConfigColor(Command): \"\"\" Configures your color Usage: @togglecolor on|off This turns ANSI-colors on/off. Default is on. \"\"\" key = \"@togglecolor\" aliases = [\"@setcolor\"] def func(self): \"implements the command\" # first we must remove whitespace from the argument self.args = self.args.strip() if not self.args or not self.args in (\"on\", \"off\"): self.caller.msg(\"Usage: @setcolor on|off\") return if self.args == \"on\": self.caller.db.config_color = True # send a message with a tiny bit of formatting, just for fun self.caller.msg(\"Color was turned |won|W.\") else: self.caller.db.config_color = False self.caller.msg(\"Color was turned off.\") Lastly, we make this command available to the user by adding it to the default CharacterCmdSet in mygame/commands/default_cmdsets.py and reloading the server. Make sure you also import the command: from mygame.commands import configcmds class CharacterCmdSet(default_cmds.CharacterCmdSet): # [...] def at_cmdset_creation(self): \"\"\" Populates the cmdset \"\"\" super().at_cmdset_creation() # # any commands you add below will overload the default ones. # # here is the only line that we edit self.add(configcmds.CmdConfigColor())","title":"Custom color config command"},{"location":"Manually-Configuring-Color.html#more-colors","text":"Apart from ANSI colors, Evennia also supports Xterm256 colors (See Colors ). The msg() method supports the xterm256 keyword for manually activating/deactiving xterm256. It should be easy to expand the above example to allow players to customize xterm256 regardless of if Evennia thinks their client supports it or not. To get a better understanding of how msg() works with keywords, you can try this as superuser: @py self.msg(\"|123Dark blue with xterm256, bright blue with ANSI\", xterm256=True) @py self.msg(\"|gThis should be uncolored\", nomarkup=True)","title":"More colors"},{"location":"Mass-and-weight-for-objects.html","text":"An easy addition to add dynamic variety to your world objects is to give them some mass. Why mass and not weight? Weight varies in setting; for example things on the Moon weigh 1/6 as much. On Earth's surface and in most environments, no relative weight factor is needed. In most settings, mass can be used as weight to spring a pressure plate trap or a floor giving way, determine a character's burden weight for travel speed... The total mass of an object can contribute to the force of a weapon swing, or a speeding meteor to give it a potential striking force. Objects \u00b6 Now that we have reasons for keeping track of object mass, let's look at the default object class inside your mygame/typeclasses/objects.py and see how easy it is to total up mass from an object and its contents. # inside your mygame/typeclasses/objects.py class Object(DefaultObject): # [...] def get_mass(self): mass = self.attributes.get('mass', 1) # Default objects have 1 unit mass. return mass + sum(obj.get_mass() for obj in self.contents) Adding the get_mass definition to the objects you want to sum up the masses for is done with Python's \"sum\" function which operates on all the contents, in this case by summing them to return a total mass value. If you only wanted specific object types to have mass or have the new object type in a different module, see Adding-Object-Typeclass-Tutorial with its Heavy class object. You could set the default for Heavy types to something much larger than 1 gram or whatever unit you want to use. Any non-default mass would be stored on the mass Attributes of the objects. Characters and rooms \u00b6 You can add a get_mass definition to characters and rooms, also. If you were in a one metric-ton elevator with four other friends also wearing armor and carrying gold bricks, you might wonder if this elevator's going to move, and how fast. Assuming the unit is grams and the elevator itself weights 1,000 kilograms, it would already be @set elevator/mass=1000000 , we're @set me/mass=85000 and our armor is @set armor/mass=50000 . We're each carrying 20 gold bars each @set gold bar/mass=12400 then step into the elevator and see the following message in the elevator's appearance: Elevator weight and contents should not exceed 3 metric tons. Are we safe? Maybe not if you consider dynamic loading. But at rest: # Elevator object knows when it checks itself: if self.get_mass() < 3000000: pass # Elevator functions as normal. else: pass # Danger! Alarm sounds, cable snaps, elevator stops... Inventory \u00b6 Example of listing mass of items in your inventory: class CmdInventory(MuxCommand): \"\"\" view inventory Usage: inventory inv Switches: /weight to display all available channels. Shows your inventory: carrying, wielding, wearing, obscuring. \"\"\" key = \"inventory\" aliases = [\"inv\", \"i\"] locks = \"cmd:all()\" def func(self): \"check inventory\" items = self.caller.contents if not items: string = \"You are not carrying anything.\" else: table = prettytable.PrettyTable([\"name\", \"desc\"]) table.header = False table.border = False for item in items: second = item.get_mass() \\ if 'weight' in self.switches else item.db.desc table.add_row([\"%s\" % item.get_display_name(self.caller.sessions), second and second or \"\"]) string = \"|wYou are carrying:\\n%s\" % table self.caller.msg(string)","title":"Mass and weight for objects"},{"location":"Mass-and-weight-for-objects.html#objects","text":"Now that we have reasons for keeping track of object mass, let's look at the default object class inside your mygame/typeclasses/objects.py and see how easy it is to total up mass from an object and its contents. # inside your mygame/typeclasses/objects.py class Object(DefaultObject): # [...] def get_mass(self): mass = self.attributes.get('mass', 1) # Default objects have 1 unit mass. return mass + sum(obj.get_mass() for obj in self.contents) Adding the get_mass definition to the objects you want to sum up the masses for is done with Python's \"sum\" function which operates on all the contents, in this case by summing them to return a total mass value. If you only wanted specific object types to have mass or have the new object type in a different module, see Adding-Object-Typeclass-Tutorial with its Heavy class object. You could set the default for Heavy types to something much larger than 1 gram or whatever unit you want to use. Any non-default mass would be stored on the mass Attributes of the objects.","title":"Objects"},{"location":"Mass-and-weight-for-objects.html#characters-and-rooms","text":"You can add a get_mass definition to characters and rooms, also. If you were in a one metric-ton elevator with four other friends also wearing armor and carrying gold bricks, you might wonder if this elevator's going to move, and how fast. Assuming the unit is grams and the elevator itself weights 1,000 kilograms, it would already be @set elevator/mass=1000000 , we're @set me/mass=85000 and our armor is @set armor/mass=50000 . We're each carrying 20 gold bars each @set gold bar/mass=12400 then step into the elevator and see the following message in the elevator's appearance: Elevator weight and contents should not exceed 3 metric tons. Are we safe? Maybe not if you consider dynamic loading. But at rest: # Elevator object knows when it checks itself: if self.get_mass() < 3000000: pass # Elevator functions as normal. else: pass # Danger! Alarm sounds, cable snaps, elevator stops...","title":"Characters and rooms"},{"location":"Mass-and-weight-for-objects.html#inventory","text":"Example of listing mass of items in your inventory: class CmdInventory(MuxCommand): \"\"\" view inventory Usage: inventory inv Switches: /weight to display all available channels. Shows your inventory: carrying, wielding, wearing, obscuring. \"\"\" key = \"inventory\" aliases = [\"inv\", \"i\"] locks = \"cmd:all()\" def func(self): \"check inventory\" items = self.caller.contents if not items: string = \"You are not carrying anything.\" else: table = prettytable.PrettyTable([\"name\", \"desc\"]) table.header = False table.border = False for item in items: second = item.get_mass() \\ if 'weight' in self.switches else item.db.desc table.add_row([\"%s\" % item.get_display_name(self.caller.sessions), second and second or \"\"]) string = \"|wYou are carrying:\\n%s\" % table self.caller.msg(string)","title":"Inventory"},{"location":"Messagepath.html","text":"The main functionality of Evennia is to communicate with clients connected to it; a player enters commands or their client queries for a gui update (ingoing data). The server responds or sends data on its own as the game changes (outgoing data). It's important to understand how this flow of information works in Evennia. The ingoing message path \u00b6 We'll start by tracing data from the client to the server. Here it is in short: Client -> PortalSession -> PortalSessionhandler -> (AMP) -> ServerSessionHandler -> ServerSession -> Inputfunc Client \u00b6 The client sends data to Evennia in two ways. When first connecting, the client can send data to the server about its capabilities. This is things like \"I support xterm256 but not unicode\" and is mainly used when a Telnet client connects. This is called a \"handshake\" and will generally set some flags on the Portal Session that are later synced to the Server Session. Since this is not something the player controls, we'll not explore this further here. The client can send an inputcommand to the server. Traditionally this only happens when the player enters text on the command line. But with a custom client GUI, a command could also come from the pressing of a button. Finally the client may send commands based on a timer or some trigger. Exactly how the inputcommand looks when it travels from the client to Evennia depends on the Protocol used: - Telnet: A string. If GMCP or MSDP OOB protocols are used, this string will be formatted in a special way, but it's still a raw string. If Telnet SSL is active, the string will be encrypted. - SSH: An encrypted string - Webclient: A JSON-serialized string. Portal Session \u00b6 Each client is connected to the game via a Portal Session , one per connection. This Session is different depending on the type of connection (telnet, webclient etc) and thus know how to handle that particular data type. So regardless of how the data arrives, the Session will identify the type of the instruction and any arguments it should have. For example, the telnet protocol will figure that anything arriving normally over the wire should be passed on as a \"text\" type. PortalSessionHandler \u00b6 The PortalSessionhandler manages all connected Sessions in the Portal. Its data_in method (called by each Portal Session) will parse the command names and arguments from the protocols and convert them to a standardized form we call the inputcommand : (commandname, (args), {kwargs}) All inputcommands must have a name, but they may or may not have arguments and keyword arguments - in fact no default inputcommands use kwargs at all. The most common inputcommand is \"text\", which has the argument the player input on the command line: (\"text\", (\"look\",), {}) This inputcommand-structure is pickled together with the unique session-id of the Session to which it belongs. This is then sent over the AMP connection. ServerSessionHandler \u00b6 On the Server side, the AMP unpickles the data and associates the session id with the server-side Session . Data and Session are passed to the server-side SessionHandler.data_in . This in turn calls ServerSession.data_in() ServerSession \u00b6 The method ServerSession.data_in is meant to offer a single place to override if they want to examine all data passing into the server from the client. It is meant to call the ssessionhandler.call_inputfuncs with the (potentially processed) data (so this is technically a sort of detour back to the sessionhandler). In call_inputfuncs , the inputcommand's name is compared against the names of all the inputfuncs registered with the server. The inputfuncs are named the same as the inputcommand they are supposed to handle, so the (default) inputfunc for handling our \"look\" command is called \"text\". These are just normal functions and one can plugin new ones by simply putting them in a module where Evennia looks for such functions. If a matching inputfunc is found, it will be called with the Session and the inputcommand's arguments: text(session, *(\"look\",), **{}) If no matching inputfunc is found, an inputfunc named \"default\" will be tried and if that is also not found, an error will be raised. Inputfunc \u00b6 The Inputfunc must be on the form func(session, *args, **kwargs) . An exception is the default inputfunc which has form default(session, cmdname, *args, **kwargs) , where cmdname is the un-matched inputcommand string. This is where the message's path diverges, since just what happens next depends on the type of inputfunc was triggered. In the example of sending \"look\", the inputfunc is named \"text\". It will pass the argument to the cmdhandler which will eventually lead to the look command being executed. The outgoing message path \u00b6 Next let's trace the passage from server to client. msg -> ServerSession -> ServerSessionHandler -> (AMP) -> PortalSessionHandler -> PortalSession -> Client msg \u00b6 All outgoing messages start in the msg method. This is accessible from three places: Object.msg Account.msg Session.msg The call sign of the msg method looks like this: msg(text=None, from_obj=None, session=None, options=None, **kwargs) For our purposes, what is important to know is that with the exception of from_obj , session and options , all keywords given to the msg method is the name of an outputcommand and its arguments. So text is actually such a command, taking a string as its argument. The reason text sits as the first keyword argument is that it's so commonly used ( caller.msg(\"Text\") for example). Here are some examples msg(\"Hello!\") # using the 'text' outputfunc msg(prompt=\"HP:%i, SP: %i, MP: %i\" % (HP, SP, MP)) msg(mycommand=((1,2,3,4), {\"foo\": \"bar\"}) Note the form of the mycommand outputfunction. This explicitly defines the arguments and keyword arguments for the function. In the case of the text and prompt calls we just specify a string - this works too: The system will convert this into a single argument for us later in the message path. Note: The msg method sits on your Object- and Account typeclasses. It means you can easily override msg and make custom- or per-object modifications to the flow of data as it passes through. Session \u00b6 Nothing is processed on the Session, it just serves as a gathering points for all different msg . It immediately passes the data on to ... ServerSessionHandler \u00b6 In the ServerSessionhandler , the keywords from the msg method are collated into one or more outputcommands on a standardized form (identical to inputcommands): (commandname, (args), {kwargs}) This will intelligently convert different input to the same form. So msg(\"Hello\") will end up as an outputcommand (\"text\", (\"Hello\",), {}) . This is also the point where Inlinefuncs are parsed, depending on the session to receive the data. Said data is pickled together with the Session id then sent over the AMP bridge. PortalSessionHandler \u00b6 After the AMP connection has unpickled the data and paired the session id to the matching PortalSession, the handler next determines if this Session has a suitable method for handling the outputcommand. The situation is analogous to how inputfuncs work, except that protocols are fixed things that don't need a plugin infrastructure like the inputfuncs are handled. So instead of an \"outputfunc\", the handler looks for methods on the PortalSession with names of the form send_<commandname> . For example, the common sending of text expects a PortalSession method send_text . This will be called as send_text(*(\"Hello\",), **{}) . If the \"prompt\" outputfunction was used, send_prompt is called. In all other cases the send_default(cmdname, *args, **kwargs) will be called - this is the case for all client-custom outputcommands, like when wanting to tell the client to update a graphic or play a sound. PortalSession \u00b6 At this point it is up to the session to convert the command into a form understood by this particular protocol. For telnet, send_text will just send the argument as a string (since that is what telnet clients expect when \"text\" is coming). If send_default was called (basically everything that is not traditional text or a prompt), it will pack the data as an GMCP or MSDP command packet if the telnet client supports either (otherwise it won't send at all). If sending to the webclient, the data will get packed into a JSON structure at all times. Client \u00b6 Once arrived at the client, the outputcommand is handled in the way supported by the client (or it may be quietly ignored if not). \"text\" commands will be displayed in the main window while others may trigger changes in the GUI or play a sound etc.","title":"Messagepath"},{"location":"Messagepath.html#the-ingoing-message-path","text":"We'll start by tracing data from the client to the server. Here it is in short: Client -> PortalSession -> PortalSessionhandler -> (AMP) -> ServerSessionHandler -> ServerSession -> Inputfunc","title":"The ingoing message path"},{"location":"Messagepath.html#client","text":"The client sends data to Evennia in two ways. When first connecting, the client can send data to the server about its capabilities. This is things like \"I support xterm256 but not unicode\" and is mainly used when a Telnet client connects. This is called a \"handshake\" and will generally set some flags on the Portal Session that are later synced to the Server Session. Since this is not something the player controls, we'll not explore this further here. The client can send an inputcommand to the server. Traditionally this only happens when the player enters text on the command line. But with a custom client GUI, a command could also come from the pressing of a button. Finally the client may send commands based on a timer or some trigger. Exactly how the inputcommand looks when it travels from the client to Evennia depends on the Protocol used: - Telnet: A string. If GMCP or MSDP OOB protocols are used, this string will be formatted in a special way, but it's still a raw string. If Telnet SSL is active, the string will be encrypted. - SSH: An encrypted string - Webclient: A JSON-serialized string.","title":"Client"},{"location":"Messagepath.html#portal-session","text":"Each client is connected to the game via a Portal Session , one per connection. This Session is different depending on the type of connection (telnet, webclient etc) and thus know how to handle that particular data type. So regardless of how the data arrives, the Session will identify the type of the instruction and any arguments it should have. For example, the telnet protocol will figure that anything arriving normally over the wire should be passed on as a \"text\" type.","title":"Portal Session"},{"location":"Messagepath.html#portalsessionhandler","text":"The PortalSessionhandler manages all connected Sessions in the Portal. Its data_in method (called by each Portal Session) will parse the command names and arguments from the protocols and convert them to a standardized form we call the inputcommand : (commandname, (args), {kwargs}) All inputcommands must have a name, but they may or may not have arguments and keyword arguments - in fact no default inputcommands use kwargs at all. The most common inputcommand is \"text\", which has the argument the player input on the command line: (\"text\", (\"look\",), {}) This inputcommand-structure is pickled together with the unique session-id of the Session to which it belongs. This is then sent over the AMP connection.","title":"PortalSessionHandler"},{"location":"Messagepath.html#serversessionhandler","text":"On the Server side, the AMP unpickles the data and associates the session id with the server-side Session . Data and Session are passed to the server-side SessionHandler.data_in . This in turn calls ServerSession.data_in()","title":"ServerSessionHandler"},{"location":"Messagepath.html#serversession","text":"The method ServerSession.data_in is meant to offer a single place to override if they want to examine all data passing into the server from the client. It is meant to call the ssessionhandler.call_inputfuncs with the (potentially processed) data (so this is technically a sort of detour back to the sessionhandler). In call_inputfuncs , the inputcommand's name is compared against the names of all the inputfuncs registered with the server. The inputfuncs are named the same as the inputcommand they are supposed to handle, so the (default) inputfunc for handling our \"look\" command is called \"text\". These are just normal functions and one can plugin new ones by simply putting them in a module where Evennia looks for such functions. If a matching inputfunc is found, it will be called with the Session and the inputcommand's arguments: text(session, *(\"look\",), **{}) If no matching inputfunc is found, an inputfunc named \"default\" will be tried and if that is also not found, an error will be raised.","title":"ServerSession"},{"location":"Messagepath.html#inputfunc","text":"The Inputfunc must be on the form func(session, *args, **kwargs) . An exception is the default inputfunc which has form default(session, cmdname, *args, **kwargs) , where cmdname is the un-matched inputcommand string. This is where the message's path diverges, since just what happens next depends on the type of inputfunc was triggered. In the example of sending \"look\", the inputfunc is named \"text\". It will pass the argument to the cmdhandler which will eventually lead to the look command being executed.","title":"Inputfunc"},{"location":"Messagepath.html#the-outgoing-message-path","text":"Next let's trace the passage from server to client. msg -> ServerSession -> ServerSessionHandler -> (AMP) -> PortalSessionHandler -> PortalSession -> Client","title":"The outgoing message path"},{"location":"Messagepath.html#msg","text":"All outgoing messages start in the msg method. This is accessible from three places: Object.msg Account.msg Session.msg The call sign of the msg method looks like this: msg(text=None, from_obj=None, session=None, options=None, **kwargs) For our purposes, what is important to know is that with the exception of from_obj , session and options , all keywords given to the msg method is the name of an outputcommand and its arguments. So text is actually such a command, taking a string as its argument. The reason text sits as the first keyword argument is that it's so commonly used ( caller.msg(\"Text\") for example). Here are some examples msg(\"Hello!\") # using the 'text' outputfunc msg(prompt=\"HP:%i, SP: %i, MP: %i\" % (HP, SP, MP)) msg(mycommand=((1,2,3,4), {\"foo\": \"bar\"}) Note the form of the mycommand outputfunction. This explicitly defines the arguments and keyword arguments for the function. In the case of the text and prompt calls we just specify a string - this works too: The system will convert this into a single argument for us later in the message path. Note: The msg method sits on your Object- and Account typeclasses. It means you can easily override msg and make custom- or per-object modifications to the flow of data as it passes through.","title":"msg"},{"location":"Messagepath.html#session","text":"Nothing is processed on the Session, it just serves as a gathering points for all different msg . It immediately passes the data on to ...","title":"Session"},{"location":"Messagepath.html#serversessionhandler_1","text":"In the ServerSessionhandler , the keywords from the msg method are collated into one or more outputcommands on a standardized form (identical to inputcommands): (commandname, (args), {kwargs}) This will intelligently convert different input to the same form. So msg(\"Hello\") will end up as an outputcommand (\"text\", (\"Hello\",), {}) . This is also the point where Inlinefuncs are parsed, depending on the session to receive the data. Said data is pickled together with the Session id then sent over the AMP bridge.","title":"ServerSessionHandler"},{"location":"Messagepath.html#portalsessionhandler_1","text":"After the AMP connection has unpickled the data and paired the session id to the matching PortalSession, the handler next determines if this Session has a suitable method for handling the outputcommand. The situation is analogous to how inputfuncs work, except that protocols are fixed things that don't need a plugin infrastructure like the inputfuncs are handled. So instead of an \"outputfunc\", the handler looks for methods on the PortalSession with names of the form send_<commandname> . For example, the common sending of text expects a PortalSession method send_text . This will be called as send_text(*(\"Hello\",), **{}) . If the \"prompt\" outputfunction was used, send_prompt is called. In all other cases the send_default(cmdname, *args, **kwargs) will be called - this is the case for all client-custom outputcommands, like when wanting to tell the client to update a graphic or play a sound.","title":"PortalSessionHandler"},{"location":"Messagepath.html#portalsession","text":"At this point it is up to the session to convert the command into a form understood by this particular protocol. For telnet, send_text will just send the argument as a string (since that is what telnet clients expect when \"text\" is coming). If send_default was called (basically everything that is not traditional text or a prompt), it will pack the data as an GMCP or MSDP command packet if the telnet client supports either (otherwise it won't send at all). If sending to the webclient, the data will get packed into a JSON structure at all times.","title":"PortalSession"},{"location":"Messagepath.html#client_1","text":"Once arrived at the client, the outputcommand is handled in the way supported by the client (or it may be quietly ignored if not). \"text\" commands will be displayed in the main window while others may trigger changes in the GUI or play a sound etc.","title":"Client"},{"location":"MonitorHandler.html","text":"The MonitorHandler is a system for watching changes in properties or Attributes on objects. A monitor can be thought of as a sort of trigger that responds to change. The main use for the MonitorHandler is to report changes to the client; for example the client Session may ask Evennia to monitor the value of the Characer's health attribute and report whenever it changes. This way the client could for example update its health bar graphic as needed. Using the MonitorHandler \u00b6 The MontorHandler is accessed from the singleton evennia.MONITOR_HANDLER . The code for the handler is in evennia.scripts.monitorhandler . Here's how to add a new monitor: from evennia import MONITOR_HANDLER MONITOR_HANDLER.add(obj, fieldname, callback, idstring=\"\", persistent=False, **kwargs) obj ( Typeclassed entity) - the object to monitor. Since this must be typeclassed, it means you can't monitor changes on Sessions with the monitorhandler, for example. fieldname (str) - the name of a field or Attribute on obj . If you want to monitor a database field you must specify its full name, including the starting db_ (like db_key , db_location etc). Any names not starting with db_ are instead assumed to be the names of Attributes. This difference matters, since the MonitorHandler will automatically know to watch the db_value field of the Attribute. callback (callable) - This will be called as callback(fieldname=fieldname, obj=obj, **kwargs) when the field updates. idstring (str) - this is used to separate multiple monitors on the same object and fieldname. This is required in order to properly identify and remove the monitor later. It's also used for saving it. persistent (bool) - if True, the monitor will survive a server reboot. Example: from evennia import MONITOR_HANDLER as monitorhandler def _monitor_callback(fieldname=\"\", obj=None, **kwargs): # reporting callback that works both # for db-fields and Attributes if fieldname.startswith(\"db_\"): new_value = getattr(obj, fieldname) else: # an attribute new_value = obj.attributes.get(fieldname) obj.msg(\"%s.%s changed to '%s'.\" % \\ (obj.key, fieldname, new_value)) # (we could add _some_other_monitor_callback here too) # monitor Attribute (assume we have obj from before) monitorhandler.add(obj, \"desc\", _monitor_callback) # monitor same db-field with two different callbacks (must separate by id_string) monitorhandler.add(obj, \"db_key\", _monitor_callback, id_string=\"foo\") monitorhandler.add(obj, \"db_key\", _some_other_monitor_callback, id_string=\"bar\") A monitor is uniquely identified by the combination of the object instance it is monitoring, the name of the field/attribute to monitor on that object and its idstring ( obj + fieldname + idstring ). The idstring will be the empty string unless given explicitly. So to \"un-monitor\" the above you need to supply enough information for the system to uniquely find the monitor to remove: monitorhandler.remove(obj, \"desc\") monitorhandler.remove(obj, \"db_key\", idstring=\"foo\") monitorhandler.remove(obj, \"db_key\", idstring=\"bar\")","title":"MonitorHandler"},{"location":"MonitorHandler.html#using-the-monitorhandler","text":"The MontorHandler is accessed from the singleton evennia.MONITOR_HANDLER . The code for the handler is in evennia.scripts.monitorhandler . Here's how to add a new monitor: from evennia import MONITOR_HANDLER MONITOR_HANDLER.add(obj, fieldname, callback, idstring=\"\", persistent=False, **kwargs) obj ( Typeclassed entity) - the object to monitor. Since this must be typeclassed, it means you can't monitor changes on Sessions with the monitorhandler, for example. fieldname (str) - the name of a field or Attribute on obj . If you want to monitor a database field you must specify its full name, including the starting db_ (like db_key , db_location etc). Any names not starting with db_ are instead assumed to be the names of Attributes. This difference matters, since the MonitorHandler will automatically know to watch the db_value field of the Attribute. callback (callable) - This will be called as callback(fieldname=fieldname, obj=obj, **kwargs) when the field updates. idstring (str) - this is used to separate multiple monitors on the same object and fieldname. This is required in order to properly identify and remove the monitor later. It's also used for saving it. persistent (bool) - if True, the monitor will survive a server reboot. Example: from evennia import MONITOR_HANDLER as monitorhandler def _monitor_callback(fieldname=\"\", obj=None, **kwargs): # reporting callback that works both # for db-fields and Attributes if fieldname.startswith(\"db_\"): new_value = getattr(obj, fieldname) else: # an attribute new_value = obj.attributes.get(fieldname) obj.msg(\"%s.%s changed to '%s'.\" % \\ (obj.key, fieldname, new_value)) # (we could add _some_other_monitor_callback here too) # monitor Attribute (assume we have obj from before) monitorhandler.add(obj, \"desc\", _monitor_callback) # monitor same db-field with two different callbacks (must separate by id_string) monitorhandler.add(obj, \"db_key\", _monitor_callback, id_string=\"foo\") monitorhandler.add(obj, \"db_key\", _some_other_monitor_callback, id_string=\"bar\") A monitor is uniquely identified by the combination of the object instance it is monitoring, the name of the field/attribute to monitor on that object and its idstring ( obj + fieldname + idstring ). The idstring will be the empty string unless given explicitly. So to \"un-monitor\" the above you need to supply enough information for the system to uniquely find the monitor to remove: monitorhandler.remove(obj, \"desc\") monitorhandler.remove(obj, \"db_key\", idstring=\"foo\") monitorhandler.remove(obj, \"db_key\", idstring=\"bar\")","title":"Using the MonitorHandler"},{"location":"NPC-shop-Tutorial.html","text":"This tutorial will describe how to make an NPC-run shop. We will make use of the EvMenu system to present shoppers with a menu where they can buy things from the store's stock. Our shop extends over two rooms - a \"front\" room open to the shop's customers and a locked \"store room\" holding the wares the shop should be able to sell. We aim for the following features: The front room should have an Attribute storeroom that points to the store room. Inside the front room, the customer should have a command buy or browse . This will open a menu listing all items available to buy from the store room. A customer should be able to look at individual items before buying. We use \"gold\" as an example currency. To determine cost, the system will look for an Attribute gold_value on the items in the store room. If not found, a fixed base value of 1 will be assumed. The wealth of the customer should be set as an Attribute gold on the Character. If not set, they have no gold and can't buy anything. When the customer makes a purchase, the system will check the gold_value of the goods and compare it to the gold Attribute of the customer. If enough gold is available, this will be deducted and the goods transferred from the store room to the inventory of the customer. We will lock the store room so that only people with the right key can get in there. The shop menu \u00b6 We want to show a menu to the customer where they can list, examine and buy items in the store. This menu should change depending on what is currently for sale. Evennia's EvMenu utility will manage the menu for us. It's a good idea to read up on EvMenu if you are not familiar with it. Designing the menu \u00b6 The shopping menu's design is straightforward. First we want the main screen. You get this when you enter a shop and use the browse or buy command: *** Welcome to ye Old Sword shop! *** Things for sale (choose 1-3 to inspect, quit to exit): _________________________________________________________ 1. A rusty sword (5 gold) 2. A sword with a leather handle (10 gold) 3. Excalibur (100 gold) There are only three items to buy in this example but the menu should expand to however many items are needed. When you make a selection you will get a new screen showing the options for that particular item: You inspect A rusty sword: This is an old weapon maybe once used by soldiers in some long forgotten army. It is rusty and in bad condition. __________________________________________________________ 1. Buy A rusty sword (5 gold) 2. Look for something else. Finally, when you buy something, a brief message should pop up: You pay 5 gold and purchase A rusty sword! or You cannot afford 5 gold for A rusty sword! After this you should be back to the top level of the shopping menu again and can continue browsing. Coding the menu \u00b6 EvMenu defines the nodes (each menu screen with options) as normal Python functions. Each node must be able to change on the fly depending on what items are currently for sale. EvMenu will automatically make the quit command available to us so we won't add that manually. For compactness we will put everything needed for our shop in one module, mygame/typeclasses/npcshop.py . # mygame/typeclasses/npcshop.py from evennia.utils import evmenu def menunode_shopfront(caller): \"This is the top-menu screen.\" shopname = caller.location.key wares = caller.location.db.storeroom.contents # Wares includes all items inside the storeroom, including the # door! Let's remove that from our for sale list. wares = [ware for ware in wares if ware.key.lower() != \"door\"] text = \"*** Welcome to %s! ***\\n\" % shopname if wares: text += \" Things for sale (choose 1-%i to inspect);\" \\ \" quit to exit:\" % len(wares) else: text += \" There is nothing for sale; quit to exit.\" options = [] for ware in wares: # add an option for every ware in store options.append({\"desc\": \"%s (%s gold)\" % (ware.key, ware.db.gold_value or 1), \"goto\": \"menunode_inspect_and_buy\"}) return text, options In this code we assume the caller to be inside the shop when accessing the menu. This means we can access the shop room via caller.location and get its key to display as the shop's name. We also assume the shop has an Attribute storeroom we can use to get to our stock. We loop over our goods to build up the menu's options. Note that all options point to the same menu node called menunode_inspect_and_buy ! We can't know which goods will be available to sale so we rely on this node to modify itself depending on the circumstances. Let's create it now. # further down in mygame/typeclasses/npcshop.py def menunode_inspect_and_buy(caller, raw_string): \"Sets up the buy menu screen.\" wares = caller.location.db.storeroom.contents # Don't forget, we will need to remove that pesky door again! wares = [ware for ware in wares if ware.key.lower() != \"door\"] iware = int(raw_string) - 1 ware = wares[iware] value = ware.db.gold_value or 1 wealth = caller.db.gold or 0 text = \"You inspect %s:\\n\\n%s\" % (ware.key, ware.db.desc) def buy_ware_result(caller): \"This will be executed first when choosing to buy.\" if wealth >= value: rtext = \"You pay %i gold and purchase %s!\" % \\ (value, ware.key) caller.db.gold -= value ware.move_to(caller, quiet=True) else: rtext = \"You cannot afford %i gold for %s!\" % \\ (value, ware.key) caller.msg(rtext) options = ({\"desc\": \"Buy %s for %s gold\" % \\ (ware.key, ware.db.gold_value or 1), \"goto\": \"menunode_shopfront\", \"exec\": buy_ware_result}, {\"desc\": \"Look for something else\", \"goto\": \"menunode_shopfront\"}) return text, options In this menu node we make use of the raw_string argument to the node. This is the text the menu user entered on the previous node to get here. Since we only allow numbered options in our menu, raw_input must be an number for the player to get to this point. So we convert it to an integer index (menu lists start from 1, whereas Python indices always starts at 0, so we need to subtract 1). We then use the index to get the corresponding item from storage. We just show the customer the desc of the item. In a more elaborate setup you might want to show things like weapon damage and special stats here as well. When the user choose the \"buy\" option, EvMenu will execute the exec instruction before we go back to the top node (the goto instruction). For this we make a little inline function buy_ware_result . EvMenu will call the function given to exec like any menu node but it does not need to return anything. In buy_ware_result we determine if the customer can afford the cost and give proper return messages. This is also where we actually move the bought item into the inventory of the customer. The command to start the menu \u00b6 We could in principle launch the shopping menu the moment a customer steps into our shop room, but this would probably be considered pretty annoying. It's better to create a Command for customers to explicitly wanting to shop around. # mygame/typeclasses/npcshop.py from evennia import Command class CmdBuy(Command): \"\"\" Start to do some shopping Usage: buy shop browse This will allow you to browse the wares of the current shop and buy items you want. \"\"\" key = \"buy\" aliases = (\"shop\", \"browse\") def func(self): \"Starts the shop EvMenu instance\" evmenu.EvMenu(self.caller, \"typeclasses.npcshop\", startnode=\"menunode_shopfront\") This will launch the menu. The EvMenu instance is initialized with the path to this very module - since the only global functions available in this module are our menu nodes, this will work fine (you could also have put those in a separate module). We now just need to put this command in a CmdSet so we can add it correctly to the game: from evennia import CmdSet class ShopCmdSet(CmdSet): def at_cmdset_creation(self): self.add(CmdBuy()) Building the shop \u00b6 There are really only two things that separate our shop from any other Room: The shop has the storeroom Attribute set on it, pointing to a second (completely normal) room. It has the ShopCmdSet stored on itself. This makes the buy command available to users entering the shop. For testing we could easily add these features manually to a room using @py or other admin commands. Just to show how it can be done we'll instead make a custom Typeclass for the shop room and make a small command that builders can use to build both the shop and the storeroom at once. # bottom of mygame/typeclasses/npcshop.py from evennia import DefaultRoom, DefaultExit, DefaultObject from evennia.utils.create import create_object # class for our front shop room class NPCShop(DefaultRoom): def at_object_creation(self): # we could also use add(ShopCmdSet, permanent=True) self.cmdset.add_default(ShopCmdSet) self.db.storeroom = None # command to build a complete shop (the Command base class # should already have been imported earlier in this file) class CmdBuildShop(Command): \"\"\" Build a new shop Usage: @buildshop shopname This will create a new NPCshop room as well as a linked store room (named simply <storename>-storage) for the wares on sale. The store room will be accessed through a locked door in the shop. \"\"\" key = \"@buildshop\" locks = \"cmd:perm(Builders)\" help_category = \"Builders\" def func(self): \"Create the shop rooms\" if not self.args: self.msg(\"Usage: @buildshop <storename>\") return # create the shop and storeroom shopname = self.args.strip() shop = create_object(NPCShop, key=shopname, location=None) storeroom = create_object(DefaultRoom, key=\"%s-storage\" % shopname, location=None) shop.db.storeroom = storeroom # create a door between the two shop_exit = create_object(DefaultExit, key=\"back door\", aliases=[\"storage\", \"store room\"], location=shop, destination=storeroom) storeroom_exit = create_object(DefaultExit, key=\"door\", location=storeroom, destination=shop) # make a key for accessing the store room storeroom_key_name = \"%s-storekey\" % shopname storeroom_key = create_object(DefaultObject, key=storeroom_key_name, location=shop) # only allow chars with this key to enter the store room shop_exit.locks.add(\"traverse:holds(%s)\" % storeroom_key_name) # inform the builder about progress self.caller.msg(\"The shop %s was created!\" % shop) Our typeclass is simple and so is our buildshop command. The command (which is for Builders only) just takes the name of the shop and builds the front room and a store room to go with it (always named \"<shopname>-storage\" . It connects the rooms with a two-way exit. You need to add CmdBuildShop to the default cmdset before you can use it. Once having created the shop you can now @teleport to it or @open a new exit to it. You could also easily expand the above command to automatically create exits to and from the new shop from your current location. To avoid customers walking in and stealing everything, we create a Lock on the storage door. It's a simple lock that requires the one entering to carry an object named <shopname>-storekey . We even create such a key object and drop it in the shop for the new shop keeper to pick up. If players are given the right to name their own objects, this simple lock is not very secure and you need to come up with a more robust lock-key solution. We don't add any descriptions to all these objects so looking \"at\" them will not be too thrilling. You could add better default descriptions as part of the @buildshop command or leave descriptions this up to the Builder. The shop is open for business! \u00b6 We now have a functioning shop and an easy way for Builders to create it. All you need now is to @open a new exit from the rest of the game into the shop and put some sell-able items in the store room. Our shop does have some shortcomings: For Characters to be able to buy stuff they need to also have the gold Attribute set on themselves. We manually remove the \"door\" exit from our items for sale. But what if there are other unsellable items in the store room? What if the shop owner walks in there for example - anyone in the store could then buy them for 1 gold. What if someone else were to buy the item we're looking at just before we decide to buy it? It would then be gone and the counter be wrong - the shop would pass us the next item in the list. Fixing these issues are left as an exercise. If you want to keep the shop fully NPC-run you could add a Script to restock the shop's store room regularly. This shop example could also easily be owned by a human Player (run for them by a hired NPC) - the shop owner would get the key to the store room and be responsible for keeping it well stocked.","title":"NPC shop Tutorial"},{"location":"NPC-shop-Tutorial.html#the-shop-menu","text":"We want to show a menu to the customer where they can list, examine and buy items in the store. This menu should change depending on what is currently for sale. Evennia's EvMenu utility will manage the menu for us. It's a good idea to read up on EvMenu if you are not familiar with it.","title":"The shop menu"},{"location":"NPC-shop-Tutorial.html#designing-the-menu","text":"The shopping menu's design is straightforward. First we want the main screen. You get this when you enter a shop and use the browse or buy command: *** Welcome to ye Old Sword shop! *** Things for sale (choose 1-3 to inspect, quit to exit): _________________________________________________________ 1. A rusty sword (5 gold) 2. A sword with a leather handle (10 gold) 3. Excalibur (100 gold) There are only three items to buy in this example but the menu should expand to however many items are needed. When you make a selection you will get a new screen showing the options for that particular item: You inspect A rusty sword: This is an old weapon maybe once used by soldiers in some long forgotten army. It is rusty and in bad condition. __________________________________________________________ 1. Buy A rusty sword (5 gold) 2. Look for something else. Finally, when you buy something, a brief message should pop up: You pay 5 gold and purchase A rusty sword! or You cannot afford 5 gold for A rusty sword! After this you should be back to the top level of the shopping menu again and can continue browsing.","title":"Designing the menu"},{"location":"NPC-shop-Tutorial.html#coding-the-menu","text":"EvMenu defines the nodes (each menu screen with options) as normal Python functions. Each node must be able to change on the fly depending on what items are currently for sale. EvMenu will automatically make the quit command available to us so we won't add that manually. For compactness we will put everything needed for our shop in one module, mygame/typeclasses/npcshop.py . # mygame/typeclasses/npcshop.py from evennia.utils import evmenu def menunode_shopfront(caller): \"This is the top-menu screen.\" shopname = caller.location.key wares = caller.location.db.storeroom.contents # Wares includes all items inside the storeroom, including the # door! Let's remove that from our for sale list. wares = [ware for ware in wares if ware.key.lower() != \"door\"] text = \"*** Welcome to %s! ***\\n\" % shopname if wares: text += \" Things for sale (choose 1-%i to inspect);\" \\ \" quit to exit:\" % len(wares) else: text += \" There is nothing for sale; quit to exit.\" options = [] for ware in wares: # add an option for every ware in store options.append({\"desc\": \"%s (%s gold)\" % (ware.key, ware.db.gold_value or 1), \"goto\": \"menunode_inspect_and_buy\"}) return text, options In this code we assume the caller to be inside the shop when accessing the menu. This means we can access the shop room via caller.location and get its key to display as the shop's name. We also assume the shop has an Attribute storeroom we can use to get to our stock. We loop over our goods to build up the menu's options. Note that all options point to the same menu node called menunode_inspect_and_buy ! We can't know which goods will be available to sale so we rely on this node to modify itself depending on the circumstances. Let's create it now. # further down in mygame/typeclasses/npcshop.py def menunode_inspect_and_buy(caller, raw_string): \"Sets up the buy menu screen.\" wares = caller.location.db.storeroom.contents # Don't forget, we will need to remove that pesky door again! wares = [ware for ware in wares if ware.key.lower() != \"door\"] iware = int(raw_string) - 1 ware = wares[iware] value = ware.db.gold_value or 1 wealth = caller.db.gold or 0 text = \"You inspect %s:\\n\\n%s\" % (ware.key, ware.db.desc) def buy_ware_result(caller): \"This will be executed first when choosing to buy.\" if wealth >= value: rtext = \"You pay %i gold and purchase %s!\" % \\ (value, ware.key) caller.db.gold -= value ware.move_to(caller, quiet=True) else: rtext = \"You cannot afford %i gold for %s!\" % \\ (value, ware.key) caller.msg(rtext) options = ({\"desc\": \"Buy %s for %s gold\" % \\ (ware.key, ware.db.gold_value or 1), \"goto\": \"menunode_shopfront\", \"exec\": buy_ware_result}, {\"desc\": \"Look for something else\", \"goto\": \"menunode_shopfront\"}) return text, options In this menu node we make use of the raw_string argument to the node. This is the text the menu user entered on the previous node to get here. Since we only allow numbered options in our menu, raw_input must be an number for the player to get to this point. So we convert it to an integer index (menu lists start from 1, whereas Python indices always starts at 0, so we need to subtract 1). We then use the index to get the corresponding item from storage. We just show the customer the desc of the item. In a more elaborate setup you might want to show things like weapon damage and special stats here as well. When the user choose the \"buy\" option, EvMenu will execute the exec instruction before we go back to the top node (the goto instruction). For this we make a little inline function buy_ware_result . EvMenu will call the function given to exec like any menu node but it does not need to return anything. In buy_ware_result we determine if the customer can afford the cost and give proper return messages. This is also where we actually move the bought item into the inventory of the customer.","title":"Coding the menu"},{"location":"NPC-shop-Tutorial.html#the-command-to-start-the-menu","text":"We could in principle launch the shopping menu the moment a customer steps into our shop room, but this would probably be considered pretty annoying. It's better to create a Command for customers to explicitly wanting to shop around. # mygame/typeclasses/npcshop.py from evennia import Command class CmdBuy(Command): \"\"\" Start to do some shopping Usage: buy shop browse This will allow you to browse the wares of the current shop and buy items you want. \"\"\" key = \"buy\" aliases = (\"shop\", \"browse\") def func(self): \"Starts the shop EvMenu instance\" evmenu.EvMenu(self.caller, \"typeclasses.npcshop\", startnode=\"menunode_shopfront\") This will launch the menu. The EvMenu instance is initialized with the path to this very module - since the only global functions available in this module are our menu nodes, this will work fine (you could also have put those in a separate module). We now just need to put this command in a CmdSet so we can add it correctly to the game: from evennia import CmdSet class ShopCmdSet(CmdSet): def at_cmdset_creation(self): self.add(CmdBuy())","title":"The command to start the menu"},{"location":"NPC-shop-Tutorial.html#building-the-shop","text":"There are really only two things that separate our shop from any other Room: The shop has the storeroom Attribute set on it, pointing to a second (completely normal) room. It has the ShopCmdSet stored on itself. This makes the buy command available to users entering the shop. For testing we could easily add these features manually to a room using @py or other admin commands. Just to show how it can be done we'll instead make a custom Typeclass for the shop room and make a small command that builders can use to build both the shop and the storeroom at once. # bottom of mygame/typeclasses/npcshop.py from evennia import DefaultRoom, DefaultExit, DefaultObject from evennia.utils.create import create_object # class for our front shop room class NPCShop(DefaultRoom): def at_object_creation(self): # we could also use add(ShopCmdSet, permanent=True) self.cmdset.add_default(ShopCmdSet) self.db.storeroom = None # command to build a complete shop (the Command base class # should already have been imported earlier in this file) class CmdBuildShop(Command): \"\"\" Build a new shop Usage: @buildshop shopname This will create a new NPCshop room as well as a linked store room (named simply <storename>-storage) for the wares on sale. The store room will be accessed through a locked door in the shop. \"\"\" key = \"@buildshop\" locks = \"cmd:perm(Builders)\" help_category = \"Builders\" def func(self): \"Create the shop rooms\" if not self.args: self.msg(\"Usage: @buildshop <storename>\") return # create the shop and storeroom shopname = self.args.strip() shop = create_object(NPCShop, key=shopname, location=None) storeroom = create_object(DefaultRoom, key=\"%s-storage\" % shopname, location=None) shop.db.storeroom = storeroom # create a door between the two shop_exit = create_object(DefaultExit, key=\"back door\", aliases=[\"storage\", \"store room\"], location=shop, destination=storeroom) storeroom_exit = create_object(DefaultExit, key=\"door\", location=storeroom, destination=shop) # make a key for accessing the store room storeroom_key_name = \"%s-storekey\" % shopname storeroom_key = create_object(DefaultObject, key=storeroom_key_name, location=shop) # only allow chars with this key to enter the store room shop_exit.locks.add(\"traverse:holds(%s)\" % storeroom_key_name) # inform the builder about progress self.caller.msg(\"The shop %s was created!\" % shop) Our typeclass is simple and so is our buildshop command. The command (which is for Builders only) just takes the name of the shop and builds the front room and a store room to go with it (always named \"<shopname>-storage\" . It connects the rooms with a two-way exit. You need to add CmdBuildShop to the default cmdset before you can use it. Once having created the shop you can now @teleport to it or @open a new exit to it. You could also easily expand the above command to automatically create exits to and from the new shop from your current location. To avoid customers walking in and stealing everything, we create a Lock on the storage door. It's a simple lock that requires the one entering to carry an object named <shopname>-storekey . We even create such a key object and drop it in the shop for the new shop keeper to pick up. If players are given the right to name their own objects, this simple lock is not very secure and you need to come up with a more robust lock-key solution. We don't add any descriptions to all these objects so looking \"at\" them will not be too thrilling. You could add better default descriptions as part of the @buildshop command or leave descriptions this up to the Builder.","title":"Building the shop"},{"location":"NPC-shop-Tutorial.html#the-shop-is-open-for-business","text":"We now have a functioning shop and an easy way for Builders to create it. All you need now is to @open a new exit from the rest of the game into the shop and put some sell-able items in the store room. Our shop does have some shortcomings: For Characters to be able to buy stuff they need to also have the gold Attribute set on themselves. We manually remove the \"door\" exit from our items for sale. But what if there are other unsellable items in the store room? What if the shop owner walks in there for example - anyone in the store could then buy them for 1 gold. What if someone else were to buy the item we're looking at just before we decide to buy it? It would then be gone and the counter be wrong - the shop would pass us the next item in the list. Fixing these issues are left as an exercise. If you want to keep the shop fully NPC-run you could add a Script to restock the shop's store room regularly. This shop example could also easily be owned by a human Player (run for them by a hired NPC) - the shop owner would get the key to the store room and be responsible for keeping it well stocked.","title":"The shop is open for business!"},{"location":"New-Models.html","text":"Note: This is considered an advanced topic. Evennia offers many convenient ways to store object data, such as via Attributes or Scripts. This is sufficient for most use cases. But if you aim to build a large stand-alone system, trying to squeeze your storage requirements into those may be more complex than you bargain for. Examples may be to store guild data for guild members to be able to change, tracking the flow of money across a game-wide economic system or implement other custom game systems that requires the storage of custom data in a quickly accessible way. Whereas Tags or Scripts can handle many situations, sometimes things may be easier to handle by adding your own database model. Overview of database tables \u00b6 SQL-type databases (which is what Evennia supports) are basically highly optimized systems for retrieving text stored in tables. A table may look like this id | db_key | db_typeclass_path | db_permissions ... ------------------------------------------------------------------ 1 | Griatch | evennia.DefaultCharacter | Developers ... 2 | Rock | evennia.DefaultObject | None ... Each line is considerably longer in your database. Each column is referred to as a \"field\" and every row is a separate object. You can check this out for yourself. If you use the default sqlite3 database, go to your game folder and run evennia dbshell You will drop into the database shell. While there, try: sqlite> .help # view help sqlite> .tables # view all tables # show the table field names for objects_objectdb sqlite> .schema objects_objectdb # show the first row from the objects_objectdb table sqlite> select * from objects_objectdb limit 1; sqlite> .exit Evennia uses Django , which abstracts away the database SQL manipulation and allows you to search and manipulate your database entirely in Python. Each database table is in Django represented by a class commonly called a model since it describes the look of the table. In Evennia, Objects, Scripts, Channels etc are examples of Django models that we then extend and build on. Adding a new database table \u00b6 Here is how you add your own database table/models: In Django lingo, we will create a new \"application\" - a subsystem under the main Evennia program. For this example we'll call it \"myapp\". Run the following (you need to have a working Evennia running before you do this, so make sure you have run the steps in Getting Started first): cd mygame/world evennia startapp myapp A new folder myapp is created. \"myapp\" will also be the name (the \"app label\") from now on. We chose to put it in the world/ subfolder here, but you could put it in the root of your mygame if that makes more sense. The myapp folder contains a few empty default files. What we are interested in for now is models.py . In models.py you define your model(s). Each model will be a table in the database. See the next section and don't continue until you have added the models you want. You now need to tell Evennia that the models of your app should be a part of your database scheme. Add this line to your mygame/server/conf/settings.py file (make sure to use the path where you put myapp and don't forget the comma at the end of the tuple): INSTALLED_APPS = INSTALLED_APPS + (\"world.myapp\", ) From mygame/ , run evennia makemigrations myapp evennia migrate This will add your new database table to the database. If you have put your game under version control (if not, you should ), don't forget to git add myapp/* to add all items to version control. Defining your models \u00b6 A Django model is the Python representation of a database table. It can be handled like any other Python class. It defines fields on itself, objects of a special type. These become the \"columns\" of the database table. Finally, you create new instances of the model to add new rows to the database. We won't describe all aspects of Django models here, for that we refer to the vast Django documentation on the subject. Here is a (very) brief example: from django.db import models class MyDataStore(models.Model): \"A simple model for storing some data\" db_key = models.CharField(max_length=80, db_index=True) db_category = models.CharField(max_length=80, null=True, blank=True) db_text = models.TextField(null=True, blank=True) # we need this one if we want to be # able to store this in an Evennia Attribute! db_date_created = models.DateTimeField('date created', editable=False, auto_now_add=True, db_index=True) We create four fields: two character fields of limited length and one text field which has no maximum length. Finally we create a field containing the current time of us creating this object. The db_date_created field, with exactly this name, is required if you want to be able to store instances of your custom model in an Evennia Attribute . It will automatically be set upon creation and can after that not be changed. Having this field will allow you to do e.g. obj.db.myinstance = mydatastore . If you know you'll never store your model instances in Attributes the db_date_created field is optional. You don't have to start field names with db_ , this is an Evennia convention. It's nevertheless recommended that you do use db_ , partly for clarity and consistency with Evennia (if you ever want to share your code) and partly for the case of you later deciding to use Evennia's SharedMemoryModel parent down the line. The field keyword db_index creates a database index for this field, which allows quicker lookups, so it's recommended to put it on fields you know you'll often use in queries. The null=True and blank=True keywords means that these fields may be left empty or set to the empty string without the database complaining. There are many other field types and keywords to define them, see django docs for more info. Similar to using django-admin you are able to do evennia inspectdb to get an automated listing of model information for an existing database. As is the case with any model generating tool you should only use this as a starting point for your models. Creating a new model instance \u00b6 To create a new row in your table, you instantiate the model and then call its save() method: from evennia.myapp import MyDataStore new_datastore = MyDataStore(db_key=\"LargeSword\", db_category=\"weapons\", db_text=\"This is a huge weapon!\") # this is required to actually create the row in the database! new_datastore.save() Note that the db_date_created field of the model is not specified. Its flag at_now_add=True makes sure to set it to the current date when the object is created (it can also not be changed further after creation). When you update an existing object with some new field value, remember that you have to save the object afterwards, otherwise the database will not update: my_datastore.db_key = \"Larger Sword\" my_datastore.save() Evennia's normal models don't need to explicitly save, since they are based on SharedMemoryModel rather than the raw django model. This is covered in the next section. Using the SharedMemoryModel parent \u00b6 Evennia doesn't base most of its models on the raw django.db.models but on the Evennia base model evennia.utils.idmapper.models.SharedMemoryModel . There are two main reasons for this: Ease of updating fields without having to explicitly call save() On-object memory persistence and database caching The first (and least important) point means that as long as you named your fields db_* , Evennia will automatically create field wrappers for them. This happens in the model's Metaclass so there is no speed penalty for this. The name of the wrapper will be the same name as the field, minus the db_ prefix. So the db_key field will have a wrapper property named key . You can then do: my_datastore.key = \"Larger Sword\" and don't have to explicitly call save() afterwards. The saving also happens in a more efficient way under the hood, updating only the field rather than the entire model using django optimizations. Note that if you were to manually add the property or method key to your model, this will be used instead of the automatic wrapper and allows you to fully customize access as needed. To explain the second and more important point, consider the following example using the default Django model parent: shield = MyDataStore.objects.get(db_key=\"SmallShield\") shield.cracked = True # where cracked is not a database field And then later: shield = MyDataStore.objects.get(db_key=\"SmallShield\") print(shield.cracked) # error! The outcome of that last print statement is undefined ! It could maybe randomly work but most likely you will get an AttributeError for not finding the cracked property. The reason is that cracked doesn't represent an actual field in the database. It was just added at run-time and thus Django don't care about it. When you retrieve your shield-match later there is no guarantee you will get back the same Python instance of the model where you defined cracked , even if you search for the same database object. Evennia relies heavily on on-model handlers and other dynamically created properties. So rather than using the vanilla Django models, Evennia uses SharedMemoryModel , which levies something called idmapper . The idmapper caches model instances so that we will always get the same instance back after the first lookup of a given object. Using idmapper, the above example would work fine and you could retrieve your cracked property at any time - until you rebooted when all non-persistent data goes. Using the idmapper is both more intuitive and more efficient per object ; it leads to a lot less reading from disk. The drawback is that this system tends to be more memory hungry overall . So if you know that you'll never need to add new properties to running instances or know that you will create new objects all the time yet rarely access them again (like for a log system), you are probably better off making \"plain\" Django models rather than using SharedMemoryModel and its idmapper. To use the idmapper and the field-wrapper functionality you just have to have your model classes inherit from evennia.utils.idmapper.models.SharedMemoryModel instead of from the default django.db.models.Model : from evennia.utils.idmapper.models import SharedMemoryModel class MyDataStore(SharedMemoryModel): # the rest is the same as before, but db_* is important; these will # later be settable as .key, .category, .text ... db_key = models.CharField(max_length=80, db_index=True) db_category = models.CharField(max_length=80, null=True, blank=True) db_text = models.TextField(null=True, blank=True) db_date_created = models.DateTimeField('date created', editable=False, auto_now_add=True, db_index=True) Searching for your models \u00b6 To search your new custom database table you need to use its database manager to build a query . Note that even if you use SharedMemoryModel as described in the previous section, you have to use the actual field names in the query, not the wrapper name (so db_key and not just key ). from world.myapp import MyDataStore # get all datastore objects exactly matching a given key matches = MyDataStore.objects.filter(db_key=\"Larger Sword\") # get all datastore objects with a key containing \"sword\" # and having the category \"weapons\" (both ignoring upper/lower case) matches2 = MyDataStore.objects.filter(db_key__icontains=\"sword\", db_category__iequals=\"weapons\") # show the matching data (e.g. inside a command) for match in matches2: self.caller.msg(match.db_text) See the Django query documentation for a lot more information about querying the database.","title":"New Models"},{"location":"New-Models.html#overview-of-database-tables","text":"SQL-type databases (which is what Evennia supports) are basically highly optimized systems for retrieving text stored in tables. A table may look like this id | db_key | db_typeclass_path | db_permissions ... ------------------------------------------------------------------ 1 | Griatch | evennia.DefaultCharacter | Developers ... 2 | Rock | evennia.DefaultObject | None ... Each line is considerably longer in your database. Each column is referred to as a \"field\" and every row is a separate object. You can check this out for yourself. If you use the default sqlite3 database, go to your game folder and run evennia dbshell You will drop into the database shell. While there, try: sqlite> .help # view help sqlite> .tables # view all tables # show the table field names for objects_objectdb sqlite> .schema objects_objectdb # show the first row from the objects_objectdb table sqlite> select * from objects_objectdb limit 1; sqlite> .exit Evennia uses Django , which abstracts away the database SQL manipulation and allows you to search and manipulate your database entirely in Python. Each database table is in Django represented by a class commonly called a model since it describes the look of the table. In Evennia, Objects, Scripts, Channels etc are examples of Django models that we then extend and build on.","title":"Overview of database tables"},{"location":"New-Models.html#adding-a-new-database-table","text":"Here is how you add your own database table/models: In Django lingo, we will create a new \"application\" - a subsystem under the main Evennia program. For this example we'll call it \"myapp\". Run the following (you need to have a working Evennia running before you do this, so make sure you have run the steps in Getting Started first): cd mygame/world evennia startapp myapp A new folder myapp is created. \"myapp\" will also be the name (the \"app label\") from now on. We chose to put it in the world/ subfolder here, but you could put it in the root of your mygame if that makes more sense. The myapp folder contains a few empty default files. What we are interested in for now is models.py . In models.py you define your model(s). Each model will be a table in the database. See the next section and don't continue until you have added the models you want. You now need to tell Evennia that the models of your app should be a part of your database scheme. Add this line to your mygame/server/conf/settings.py file (make sure to use the path where you put myapp and don't forget the comma at the end of the tuple): INSTALLED_APPS = INSTALLED_APPS + (\"world.myapp\", ) From mygame/ , run evennia makemigrations myapp evennia migrate This will add your new database table to the database. If you have put your game under version control (if not, you should ), don't forget to git add myapp/* to add all items to version control.","title":"Adding a new database table"},{"location":"New-Models.html#defining-your-models","text":"A Django model is the Python representation of a database table. It can be handled like any other Python class. It defines fields on itself, objects of a special type. These become the \"columns\" of the database table. Finally, you create new instances of the model to add new rows to the database. We won't describe all aspects of Django models here, for that we refer to the vast Django documentation on the subject. Here is a (very) brief example: from django.db import models class MyDataStore(models.Model): \"A simple model for storing some data\" db_key = models.CharField(max_length=80, db_index=True) db_category = models.CharField(max_length=80, null=True, blank=True) db_text = models.TextField(null=True, blank=True) # we need this one if we want to be # able to store this in an Evennia Attribute! db_date_created = models.DateTimeField('date created', editable=False, auto_now_add=True, db_index=True) We create four fields: two character fields of limited length and one text field which has no maximum length. Finally we create a field containing the current time of us creating this object. The db_date_created field, with exactly this name, is required if you want to be able to store instances of your custom model in an Evennia Attribute . It will automatically be set upon creation and can after that not be changed. Having this field will allow you to do e.g. obj.db.myinstance = mydatastore . If you know you'll never store your model instances in Attributes the db_date_created field is optional. You don't have to start field names with db_ , this is an Evennia convention. It's nevertheless recommended that you do use db_ , partly for clarity and consistency with Evennia (if you ever want to share your code) and partly for the case of you later deciding to use Evennia's SharedMemoryModel parent down the line. The field keyword db_index creates a database index for this field, which allows quicker lookups, so it's recommended to put it on fields you know you'll often use in queries. The null=True and blank=True keywords means that these fields may be left empty or set to the empty string without the database complaining. There are many other field types and keywords to define them, see django docs for more info. Similar to using django-admin you are able to do evennia inspectdb to get an automated listing of model information for an existing database. As is the case with any model generating tool you should only use this as a starting point for your models.","title":"Defining your models"},{"location":"New-Models.html#creating-a-new-model-instance","text":"To create a new row in your table, you instantiate the model and then call its save() method: from evennia.myapp import MyDataStore new_datastore = MyDataStore(db_key=\"LargeSword\", db_category=\"weapons\", db_text=\"This is a huge weapon!\") # this is required to actually create the row in the database! new_datastore.save() Note that the db_date_created field of the model is not specified. Its flag at_now_add=True makes sure to set it to the current date when the object is created (it can also not be changed further after creation). When you update an existing object with some new field value, remember that you have to save the object afterwards, otherwise the database will not update: my_datastore.db_key = \"Larger Sword\" my_datastore.save() Evennia's normal models don't need to explicitly save, since they are based on SharedMemoryModel rather than the raw django model. This is covered in the next section.","title":"Creating a new model instance"},{"location":"New-Models.html#using-the-sharedmemorymodel-parent","text":"Evennia doesn't base most of its models on the raw django.db.models but on the Evennia base model evennia.utils.idmapper.models.SharedMemoryModel . There are two main reasons for this: Ease of updating fields without having to explicitly call save() On-object memory persistence and database caching The first (and least important) point means that as long as you named your fields db_* , Evennia will automatically create field wrappers for them. This happens in the model's Metaclass so there is no speed penalty for this. The name of the wrapper will be the same name as the field, minus the db_ prefix. So the db_key field will have a wrapper property named key . You can then do: my_datastore.key = \"Larger Sword\" and don't have to explicitly call save() afterwards. The saving also happens in a more efficient way under the hood, updating only the field rather than the entire model using django optimizations. Note that if you were to manually add the property or method key to your model, this will be used instead of the automatic wrapper and allows you to fully customize access as needed. To explain the second and more important point, consider the following example using the default Django model parent: shield = MyDataStore.objects.get(db_key=\"SmallShield\") shield.cracked = True # where cracked is not a database field And then later: shield = MyDataStore.objects.get(db_key=\"SmallShield\") print(shield.cracked) # error! The outcome of that last print statement is undefined ! It could maybe randomly work but most likely you will get an AttributeError for not finding the cracked property. The reason is that cracked doesn't represent an actual field in the database. It was just added at run-time and thus Django don't care about it. When you retrieve your shield-match later there is no guarantee you will get back the same Python instance of the model where you defined cracked , even if you search for the same database object. Evennia relies heavily on on-model handlers and other dynamically created properties. So rather than using the vanilla Django models, Evennia uses SharedMemoryModel , which levies something called idmapper . The idmapper caches model instances so that we will always get the same instance back after the first lookup of a given object. Using idmapper, the above example would work fine and you could retrieve your cracked property at any time - until you rebooted when all non-persistent data goes. Using the idmapper is both more intuitive and more efficient per object ; it leads to a lot less reading from disk. The drawback is that this system tends to be more memory hungry overall . So if you know that you'll never need to add new properties to running instances or know that you will create new objects all the time yet rarely access them again (like for a log system), you are probably better off making \"plain\" Django models rather than using SharedMemoryModel and its idmapper. To use the idmapper and the field-wrapper functionality you just have to have your model classes inherit from evennia.utils.idmapper.models.SharedMemoryModel instead of from the default django.db.models.Model : from evennia.utils.idmapper.models import SharedMemoryModel class MyDataStore(SharedMemoryModel): # the rest is the same as before, but db_* is important; these will # later be settable as .key, .category, .text ... db_key = models.CharField(max_length=80, db_index=True) db_category = models.CharField(max_length=80, null=True, blank=True) db_text = models.TextField(null=True, blank=True) db_date_created = models.DateTimeField('date created', editable=False, auto_now_add=True, db_index=True)","title":"Using the SharedMemoryModel parent"},{"location":"New-Models.html#searching-for-your-models","text":"To search your new custom database table you need to use its database manager to build a query . Note that even if you use SharedMemoryModel as described in the previous section, you have to use the actual field names in the query, not the wrapper name (so db_key and not just key ). from world.myapp import MyDataStore # get all datastore objects exactly matching a given key matches = MyDataStore.objects.filter(db_key=\"Larger Sword\") # get all datastore objects with a key containing \"sword\" # and having the category \"weapons\" (both ignoring upper/lower case) matches2 = MyDataStore.objects.filter(db_key__icontains=\"sword\", db_category__iequals=\"weapons\") # show the matching data (e.g. inside a command) for match in matches2: self.caller.msg(match.db_text) See the Django query documentation for a lot more information about querying the database.","title":"Searching for your models"},{"location":"Nicks.html","text":"Nicks , short for Nicknames is a system allowing an object (usually a Account ) to assign custom replacement names for other game entities. Nicks are not to be confused with Aliases . Setting an Alias on a game entity actually changes an inherent attribute on that entity, and everyone in the game will be able to use that alias to address the entity thereafter. A Nick on the other hand, is used to map a different way you alone can refer to that entity. Nicks are also commonly used to replace your input text which means you can create your own aliases to default commands. Default Evennia use Nicks in three flavours that determine when Evennia actually tries to do the substitution. inputline - replacement is attempted whenever you write anything on the command line. This is the default. objects - replacement is only attempted when referring to an object accounts - replacement is only attempted when referring an account Here's how to use it in the default command set (using the nick command): nick ls = look This is a good one for unix/linux users who are accustomed to using the ls command in their daily life. It is equivalent to nick/inputline ls = look . nick/object mycar2 = The red sports car With this example, substitutions will only be done specifically for commands expecting an object reference, such as look mycar2 becomes equivalent to \" look The red sports car \". nick/accounts tom = Thomas Johnsson This is useful for commands searching for accounts explicitly: @find *tom One can use nicks to speed up input. Below we add ourselves a quicker way to build red buttons. In the future just writing rb will be enough to execute that whole long string. nick rb = @create button:examples.red_button.RedButton Nicks could also be used as the start for building a \"recog\" system suitable for an RP mud. nick/account Arnold = The mysterious hooded man The nick replacer also supports unix-style templating : nick build $1 $2 = @create/drop $1;$2 This will catch space separated arguments and store them in the the tags $1 and $2 , to be inserted in the replacement string. This example allows you to do build box crate and have Evennia see @create/drop box;crate . You may use any $ numbers between 1 and 99, but the markers must match between the nick pattern and the replacement. If you want to catch \"the rest\" of a command argument, make sure to put a $ tag with no spaces to the right of it - it will then receive everything up until the end of the line. You can also use shell-type wildcards : * - matches everything. ? - matches a single character. [seq] - matches everything in the sequence, e.g. [xyz] will match both x, y and z [!seq] - matches everything not in the sequence. e.g. [!xyz] will match all but x,y z. Coding with nicks \u00b6 Nicks are stored as the Nick database model and are referred from the normal Evennia object through the nicks property - this is known as the NickHandler . The NickHandler offers effective error checking, searches and conversion. # A command/channel nick: obj.nicks.add(\"greetjack\", \"tell Jack = Hello pal!\") # An object nick: obj.nicks.add(\"rose\", \"The red flower\", nick_type=\"object\") # An account nick: obj.nicks.add(\"tom\", \"Tommy Hill\", nick_type=\"account\") # My own custom nick type (handled by my own game code somehow): obj.nicks.add(\"hood\", \"The hooded man\", nick_type=\"my_identsystem\") # get back the translated nick: full_name = obj.nicks.get(\"rose\", nick_type=\"object\") # delete a previous set nick object.nicks.remove(\"rose\", nick_type=\"object\") In a command definition you can reach the nick handler through self.caller.nicks . See the nick command in evennia/commands/default/general.py for more examples. As a last note, The Evennia channel alias systems are using nicks with the nick_type=\"channel\" in order to allow users to create their own custom aliases to channels. Advanced note \u00b6 Internally, nicks are Attributes saved with the db_attrype set to \"nick\" (normal Attributes has this set to None ). The nick stores the replacement data in the Attribute.db_value field as a tuple with four fields (regex_nick, template_string, raw_nick, raw_template) . Here regex_nick is the converted regex representation of the raw_nick and the template-string is a version of the raw_template prepared for efficient replacement of any $ - type markers. The raw_nick and raw_template are basically the unchanged strings you enter to the nick command (with unparsed $ etc). If you need to access the tuple for some reason, here's how: tuple = obj.nicks.get(\"nickname\", return_tuple=True) # or, alternatively tuple = obj.nicks.get(\"nickname\", return_obj=True).value","title":"Nicks"},{"location":"Nicks.html#coding-with-nicks","text":"Nicks are stored as the Nick database model and are referred from the normal Evennia object through the nicks property - this is known as the NickHandler . The NickHandler offers effective error checking, searches and conversion. # A command/channel nick: obj.nicks.add(\"greetjack\", \"tell Jack = Hello pal!\") # An object nick: obj.nicks.add(\"rose\", \"The red flower\", nick_type=\"object\") # An account nick: obj.nicks.add(\"tom\", \"Tommy Hill\", nick_type=\"account\") # My own custom nick type (handled by my own game code somehow): obj.nicks.add(\"hood\", \"The hooded man\", nick_type=\"my_identsystem\") # get back the translated nick: full_name = obj.nicks.get(\"rose\", nick_type=\"object\") # delete a previous set nick object.nicks.remove(\"rose\", nick_type=\"object\") In a command definition you can reach the nick handler through self.caller.nicks . See the nick command in evennia/commands/default/general.py for more examples. As a last note, The Evennia channel alias systems are using nicks with the nick_type=\"channel\" in order to allow users to create their own custom aliases to channels.","title":"Coding with nicks"},{"location":"Nicks.html#advanced-note","text":"Internally, nicks are Attributes saved with the db_attrype set to \"nick\" (normal Attributes has this set to None ). The nick stores the replacement data in the Attribute.db_value field as a tuple with four fields (regex_nick, template_string, raw_nick, raw_template) . Here regex_nick is the converted regex representation of the raw_nick and the template-string is a version of the raw_template prepared for efficient replacement of any $ - type markers. The raw_nick and raw_template are basically the unchanged strings you enter to the nick command (with unparsed $ etc). If you need to access the tuple for some reason, here's how: tuple = obj.nicks.get(\"nickname\", return_tuple=True) # or, alternatively tuple = obj.nicks.get(\"nickname\", return_obj=True).value","title":"Advanced note"},{"location":"OOB.html","text":"OOB, or Out-Of-Band, means sending data between Evennia and the user's client without the user prompting it or necessarily being aware that it's being passed. Common uses would be to update client health-bars, handle client button-presses or to display certain tagged text in a different window pane. Briefly on input/outputcommands \u00b6 Inside Evennia, all server-client communication happens in the same way (so plain text is also an 'OOB message' as far as Evennia is concerned). The message follows the Message Path . You should read up on that if you are unfamiliar with it. As the message travels along the path it has a standardized internal form: a tuple with a string, a tuple and a dict: (\"cmdname\", (args), {kwargs}) This is often referred to as an inputcommand or outputcommand , depending on the direction it's traveling. The end point for an inputcommand, (the 'Evennia-end' of the message path) is a matching Inputfunc . This function is called as cmdname(session, *args, **kwargs) where session is the Session-source of the command. Inputfuncs can easily be added by the developer to support/map client commands to actions inside Evennia (see the inputfunc page for more details). When a message is outgoing (at the 'Client-end' of the message path) the outputcommand is handled by a matching Outputfunc . This is responsible for converting the internal Evennia representation to a form suitable to send over the wire to the Client. Outputfuncs are hard-coded. Which is chosen and how it processes the outgoing data depends on the nature of the client it's connected to. The only time one would want to add new outputfuncs is as part of developing support for a new Evennia Protocol . Sending and receiving an OOB message \u00b6 Sending is simple. You just use the normal msg method of the object whose session you want to send to. For example in a Command: caller.msg(cmdname=((args, ...), {key:value, ...})) A special case is the text input/outputfunc. It's so common that it's the default of the msg method. So these are equivalent: caller.msg(\"Hello\") caller.msg(text=\"Hello\") You don't have to specify the full output/input definition. So for example, if your particular command only needs kwargs, you can skip the (args) part. Like in the text case you can skip writing the tuple if there is only one arg ... and so on - the input is pretty flexible. If there are no args at all you need to give the empty tuple msg(cmdname=(,) (giving None would mean a single argument None ). Which commands you can send depends on the client. If the client does not support an explicit OOB protocol (like many old/legacy MUD clients) Evennia can only send text to them and will quietly drop any other types of outputfuncs. Remember that a given message may go to multiple clients with different capabilities. So unless you turn off telnet completely and only rely on the webclient, you should never rely on non- text OOB messages always reaching all targets. Inputfuncs lists the default inputfuncs available to handle incoming OOB messages. To accept more you need to add more inputfuncs (see that page for more info). Supported OOB protocols \u00b6 Evennia supports clients using one of the following protocols: Telnet \u00b6 By default telnet (and telnet+SSL) supports only the plain text outputcommand. Evennia however detects if the Client supports one of two MUD-specific OOB extensions to the standard telnet protocol - GMCP or MSDP. Evennia supports both simultaneously and will switch to the protocol the client uses. If the client supports both, GMCP will be used. Note that for Telnet, text has a special status as the \"in-band\" operation. So the text outputcommand sends the text argument directly over the wire, without going through the OOB translations described below. Telnet + GMCP \u00b6 GMCP , the Generic Mud Communication Protocol sends data on the form cmdname + JSONdata . Here the cmdname is expected to be on the form \"Package.Subpackage\". There could also be additional Sub-sub packages etc. The names of these 'packages' and 'subpackages' are not that well standardized beyond what individual MUDs or companies have chosen to go with over the years. You can decide on your own package names, but here are what others are using: Aardwolf GMCP Discworld GMCP Avatar GMCP IRE games GMCP Evennia will translate underscores to . and capitalize to fit the specification. So the outputcommand foo_bar will become a GMCP command-name Foo.Bar . A GMCP command \"Foo.Bar\" will be come foo_bar . To send a GMCP command that turns into an Evennia inputcommand without an underscore, use the Core package. So Core.Cmdname becomes just cmdname in Evennia and vice versa. On the wire, a GMCP instruction for (\"cmdname\", (\"arg\",), {}) will look like this: IAC SB GMCP \"cmdname\" \"arg\" IAC SE where all the capitalized words are telnet character constants specified in evennia/server/portal/telnet_oob.py . These are parsed/added by the protocol and we don't include these in the listings below. Input/Outputfunc GMCP-Command [cmd_name, [], {}] Cmd.Name [cmd_name, [arg], {}] Cmd.Name arg [cmd_na_me, [args],{}] Cmd.Na.Me [args] [cmd_name, [], {kwargs}] Cmd.Name {kwargs} [cmdname, [args, {kwargs}] Core.Cmdname [[args],{kwargs}] Since Evennia already supplies default inputfuncs that don't match the names expected by the most common GMCP implementations we have a few hard-coded mappings for those: GMCP command name Input/Outputfunc name \"Core.Hello\" \"client_options\" \"Core.Supports.Get\" \"client_options\" \"Core.Commands.Get\" \"get_inputfuncs\" \"Char.Value.Get\" \"get_value\" \"Char.Repeat.Update\" \"repeat\" \"Char.Monitor.Update\" \"monitor\" Telnet + MSDP \u00b6 MSDP , the Mud Server Data Protocol , is a competing standard to GMCP. The MSDP protocol page specifies a range of \"recommended\" available MSDP command names. Evennia does not support those - since MSDP doesn't specify a special format for its command names (like GMCP does) the client can and should just call the internal Evennia inputfunc by its actual name. MSDP uses Telnet character constants to package various structured data over the wire. MSDP supports strings, arrays (lists) and tables (dicts). These are used to define the cmdname, args and kwargs needed. When sending MSDP for (\"cmdname\", (\"arg\",), {}) the resulting MSDP instruction will look like this: IAC SB MSDP VAR cmdname VAL arg IAC SE The various available MSDP constants like VAR (variable), VAL (value), ARRAYOPEN / ARRAYCLOSE and TABLEOPEN / TABLECLOSE are specified in evennia/server/portal/telnet_oob . Outputfunc/Inputfunc MSDP instruction [cmdname, [], {}] VAR cmdname VAL [cmdname, [arg], {}] VAR cmdname VAL arg [cmdname, [args],{}] VAR cmdname VAL ARRAYOPEN VAL arg VAL arg ... ARRAYCLOSE [cmdname, [], {kwargs}] VAR cmdname VAL TABLEOPEN VAR key VAL val ... TABLECLOSE [cmdname, [args], {kwargs}] VAR cmdname VAL ARRAYOPEN VAL arg VAL arg ... ARRAYCLOSE VAR cmdname VAL TABLEOPEN VAR key VAL val ... TABLECLOSE Observe that VAR ... VAL always identifies cmdnames, so if there are multiple arrays/dicts tagged with the same cmdname they will be appended to the args, kwargs of that inputfunc. Vice-versa, a different VAR ... VAL (outside a table) will come out as a second, different command input. SSH \u00b6 SSH only supports the text input/outputcommand. Web client \u00b6 Our web client uses pure JSON structures for all its communication, including text . This maps directly to the Evennia internal output/inputcommand, including eventual empty args/kwargs. So the same example (\"cmdname\", (\"arg\",), {}) will be sent/received as a valid JSON structure [\"cmdname, [\"arg\"], {}] Since JSON is native to Javascript, this becomes very easy for the webclient to handle.","title":"OOB"},{"location":"OOB.html#briefly-on-inputoutputcommands","text":"Inside Evennia, all server-client communication happens in the same way (so plain text is also an 'OOB message' as far as Evennia is concerned). The message follows the Message Path . You should read up on that if you are unfamiliar with it. As the message travels along the path it has a standardized internal form: a tuple with a string, a tuple and a dict: (\"cmdname\", (args), {kwargs}) This is often referred to as an inputcommand or outputcommand , depending on the direction it's traveling. The end point for an inputcommand, (the 'Evennia-end' of the message path) is a matching Inputfunc . This function is called as cmdname(session, *args, **kwargs) where session is the Session-source of the command. Inputfuncs can easily be added by the developer to support/map client commands to actions inside Evennia (see the inputfunc page for more details). When a message is outgoing (at the 'Client-end' of the message path) the outputcommand is handled by a matching Outputfunc . This is responsible for converting the internal Evennia representation to a form suitable to send over the wire to the Client. Outputfuncs are hard-coded. Which is chosen and how it processes the outgoing data depends on the nature of the client it's connected to. The only time one would want to add new outputfuncs is as part of developing support for a new Evennia Protocol .","title":"Briefly on input/outputcommands"},{"location":"OOB.html#sending-and-receiving-an-oob-message","text":"Sending is simple. You just use the normal msg method of the object whose session you want to send to. For example in a Command: caller.msg(cmdname=((args, ...), {key:value, ...})) A special case is the text input/outputfunc. It's so common that it's the default of the msg method. So these are equivalent: caller.msg(\"Hello\") caller.msg(text=\"Hello\") You don't have to specify the full output/input definition. So for example, if your particular command only needs kwargs, you can skip the (args) part. Like in the text case you can skip writing the tuple if there is only one arg ... and so on - the input is pretty flexible. If there are no args at all you need to give the empty tuple msg(cmdname=(,) (giving None would mean a single argument None ). Which commands you can send depends on the client. If the client does not support an explicit OOB protocol (like many old/legacy MUD clients) Evennia can only send text to them and will quietly drop any other types of outputfuncs. Remember that a given message may go to multiple clients with different capabilities. So unless you turn off telnet completely and only rely on the webclient, you should never rely on non- text OOB messages always reaching all targets. Inputfuncs lists the default inputfuncs available to handle incoming OOB messages. To accept more you need to add more inputfuncs (see that page for more info).","title":"Sending and receiving an OOB message"},{"location":"OOB.html#supported-oob-protocols","text":"Evennia supports clients using one of the following protocols:","title":"Supported OOB protocols"},{"location":"OOB.html#telnet","text":"By default telnet (and telnet+SSL) supports only the plain text outputcommand. Evennia however detects if the Client supports one of two MUD-specific OOB extensions to the standard telnet protocol - GMCP or MSDP. Evennia supports both simultaneously and will switch to the protocol the client uses. If the client supports both, GMCP will be used. Note that for Telnet, text has a special status as the \"in-band\" operation. So the text outputcommand sends the text argument directly over the wire, without going through the OOB translations described below.","title":"Telnet"},{"location":"OOB.html#telnet-gmcp","text":"GMCP , the Generic Mud Communication Protocol sends data on the form cmdname + JSONdata . Here the cmdname is expected to be on the form \"Package.Subpackage\". There could also be additional Sub-sub packages etc. The names of these 'packages' and 'subpackages' are not that well standardized beyond what individual MUDs or companies have chosen to go with over the years. You can decide on your own package names, but here are what others are using: Aardwolf GMCP Discworld GMCP Avatar GMCP IRE games GMCP Evennia will translate underscores to . and capitalize to fit the specification. So the outputcommand foo_bar will become a GMCP command-name Foo.Bar . A GMCP command \"Foo.Bar\" will be come foo_bar . To send a GMCP command that turns into an Evennia inputcommand without an underscore, use the Core package. So Core.Cmdname becomes just cmdname in Evennia and vice versa. On the wire, a GMCP instruction for (\"cmdname\", (\"arg\",), {}) will look like this: IAC SB GMCP \"cmdname\" \"arg\" IAC SE where all the capitalized words are telnet character constants specified in evennia/server/portal/telnet_oob.py . These are parsed/added by the protocol and we don't include these in the listings below. Input/Outputfunc GMCP-Command [cmd_name, [], {}] Cmd.Name [cmd_name, [arg], {}] Cmd.Name arg [cmd_na_me, [args],{}] Cmd.Na.Me [args] [cmd_name, [], {kwargs}] Cmd.Name {kwargs} [cmdname, [args, {kwargs}] Core.Cmdname [[args],{kwargs}] Since Evennia already supplies default inputfuncs that don't match the names expected by the most common GMCP implementations we have a few hard-coded mappings for those: GMCP command name Input/Outputfunc name \"Core.Hello\" \"client_options\" \"Core.Supports.Get\" \"client_options\" \"Core.Commands.Get\" \"get_inputfuncs\" \"Char.Value.Get\" \"get_value\" \"Char.Repeat.Update\" \"repeat\" \"Char.Monitor.Update\" \"monitor\"","title":"Telnet + GMCP"},{"location":"OOB.html#telnet-msdp","text":"MSDP , the Mud Server Data Protocol , is a competing standard to GMCP. The MSDP protocol page specifies a range of \"recommended\" available MSDP command names. Evennia does not support those - since MSDP doesn't specify a special format for its command names (like GMCP does) the client can and should just call the internal Evennia inputfunc by its actual name. MSDP uses Telnet character constants to package various structured data over the wire. MSDP supports strings, arrays (lists) and tables (dicts). These are used to define the cmdname, args and kwargs needed. When sending MSDP for (\"cmdname\", (\"arg\",), {}) the resulting MSDP instruction will look like this: IAC SB MSDP VAR cmdname VAL arg IAC SE The various available MSDP constants like VAR (variable), VAL (value), ARRAYOPEN / ARRAYCLOSE and TABLEOPEN / TABLECLOSE are specified in evennia/server/portal/telnet_oob . Outputfunc/Inputfunc MSDP instruction [cmdname, [], {}] VAR cmdname VAL [cmdname, [arg], {}] VAR cmdname VAL arg [cmdname, [args],{}] VAR cmdname VAL ARRAYOPEN VAL arg VAL arg ... ARRAYCLOSE [cmdname, [], {kwargs}] VAR cmdname VAL TABLEOPEN VAR key VAL val ... TABLECLOSE [cmdname, [args], {kwargs}] VAR cmdname VAL ARRAYOPEN VAL arg VAL arg ... ARRAYCLOSE VAR cmdname VAL TABLEOPEN VAR key VAL val ... TABLECLOSE Observe that VAR ... VAL always identifies cmdnames, so if there are multiple arrays/dicts tagged with the same cmdname they will be appended to the args, kwargs of that inputfunc. Vice-versa, a different VAR ... VAL (outside a table) will come out as a second, different command input.","title":"Telnet + MSDP"},{"location":"OOB.html#ssh","text":"SSH only supports the text input/outputcommand.","title":"SSH"},{"location":"OOB.html#web-client","text":"Our web client uses pure JSON structures for all its communication, including text . This maps directly to the Evennia internal output/inputcommand, including eventual empty args/kwargs. So the same example (\"cmdname\", (\"arg\",), {}) will be sent/received as a valid JSON structure [\"cmdname, [\"arg\"], {}] Since JSON is native to Javascript, this becomes very easy for the webclient to handle.","title":"Web client"},{"location":"Objects.html","text":"All in-game objects in Evennia, be it characters, chairs, monsters, rooms or hand grenades are represented by an Evennia Object . Objects form the core of Evennia and is probably what you'll spend most time working with. Objects are Typeclassed entities. How to create your own object types \u00b6 An Evennia Object is, per definition, a Python class that includes evennia.DefaultObject among its parents. In mygame/typeclasses/objects.py there is already a class Object that inherits from DefaultObject and that you can inherit from. You can put your new typeclass directly in that module or you could organize your code in some other way. Here we assume we make a new module mygame/typeclasses/flowers.py : # mygame/typeclasses/flowers.py from typeclasses.objects import Object class Rose(Object): \"\"\" This creates a simple rose object \"\"\" def at_object_creation(self): \"this is called only once, when object is first created\" # add a persistent attribute 'desc' # to object (silly example). self.db.desc = \"This is a pretty rose with thorns.\" You could save this in the mygame/typeclasses/objects.py (then you'd not need to import Object ) or you can put it in a new module. Let's say we do the latter, making a module typeclasses/flowers.py . Now you just need to point to the class Rose with the @create command to make a new rose: @create/drop MyRose:flowers.Rose What the @create command actually does is to use evennia.create_object . You can do the same thing yourself in code: from evennia import create_object new_rose = create_object(\"typeclasses.flowers.Rose\", key=\"MyRose\") (The @create command will auto-append the most likely path to your typeclass, if you enter the call manually you have to give the full path to the class. The create.create_object function is powerful and should be used for all coded object creating (so this is what you use when defining your own building commands). Check out the ev.create_* functions for how to build other entities like Scripts ). This particular Rose class doesn't really do much, all it does it make sure the attribute desc (which is what the look command looks for) is pre-set, which is pretty pointless since you will usually want to change this at build time (using the @desc command or using the Spawner ). The Object typeclass offers many more hooks that is available to use though - see next section. Properties and functions on Objects \u00b6 Beyond the properties assigned to all typeclassed objects (see that page for a list of those), the Object also has the following custom properties: aliases - a handler that allows you to add and remove aliases from this object. Use aliases.add() to add a new alias and aliases.remove() to remove one. location - a reference to the object currently containing this object. home is a backup location. The main motivation is to have a safe place to move the object to if its location is destroyed. All objects should usually have a home location for safety. destination - this holds a reference to another object this object links to in some way. Its main use is for Exits , it's otherwise usually unset. nicks - as opposed to aliases, a Nick holds a convenient nickname replacement for a real name, word or sequence, only valid for this object. This mainly makes sense if the Object is used as a game character - it can then store briefer shorts, example so as to quickly reference game commands or other characters. Use nicks.add(alias, realname) to add a new one. account - this holds a reference to a connected Account controlling this object (if any). Note that this is set also if the controlling account is not currently online - to test if an account is online, use the has_account property instead. sessions - if account field is set and the account is online , this is a list of all active sessions (server connections) to contact them through (it may be more than one if multiple connections are allowed in settings). has_account - a shorthand for checking if an online account is currently connected to this object. contents - this returns a list referencing all objects 'inside' this object (i,e. which has this object set as their location ). exits - this returns all objects inside this object that are Exits , that is, has the destination property set. The last two properties are special: cmdset - this is a handler that stores all command sets defined on the object (if any). scripts - this is a handler that manages Scripts attached to the object (if any). The Object also has a host of useful utility functions. See the function headers in src/objects/objects.py for their arguments and more details. msg() - this function is used to send messages from the server to an account connected to this object. msg_contents() - calls msg on all objects inside this object. search() - this is a convenient shorthand to search for a specific object, at a given location or globally. It's mainly useful when defining commands (in which case the object executing the command is named caller and one can do caller.search() to find objects in the room to operate on). execute_cmd() - Lets the object execute the given string as if it was given on the command line. move_to - perform a full move of this object to a new location. This is the main move method and will call all relevant hooks, do all checks etc. clear_exits() - will delete all Exits to and from this object. clear_contents() - this will not delete anything, but rather move all contents (except Exits) to their designated Home locations. delete() - deletes this object, first calling clear_exits() and clear_contents() . The Object Typeclass defines many more hook methods beyond at_object_creation . Evennia calls these hooks at various points. When implementing your custom objects, you will inherit from the base parent and overload these hooks with your own custom code. See evennia.objects.objects for an updated list of all the available hooks or the API for DefaultObject here . Subclasses of Object \u00b6 There are three special subclasses of Object in default Evennia - Characters , Rooms and Exits . The reason they are separated is because these particular object types are fundamental, something you will always need and in some cases requires some extra attention in order to be recognized by the game engine (there is nothing stopping you from redefining them though). In practice they are all pretty similar to the base Object. Characters \u00b6 Characters are objects controlled by Accounts . When a new Account logs in to Evennia for the first time, a new Character object is created and the Account object is assigned to the account attribute. A Character object must have a Default Commandset set on itself at creation, or the account will not be able to issue any commands! If you just inherit your own class from evennia.DefaultCharacter and make sure to use super() to call the parent methods you should be fine. In mygame/typeclasses/characters.py is an empty Character class ready for you to modify. Rooms \u00b6 Rooms are the root containers of all other objects. The only thing really separating a room from any other object is that they have no location of their own and that default commands like @dig creates objects of this class - so if you want to expand your rooms with more functionality, just inherit from ev.DefaultRoom . In mygame/typeclasses/rooms.py is an empty Room class ready for you to modify. Exits \u00b6 Exits are objects connecting other objects (usually Rooms ) together. An object named North or in might be an exit, as well as door , portal or jump out the window . An exit has two things that separate them from other objects. Firstly, their destination property is set and points to a valid object. This fact makes it easy and fast to locate exits in the database. Secondly, exits define a special Transit Command on themselves when they are created. This command is named the same as the exit object and will, when called, handle the practicalities of moving the character to the Exits's destination - this allows you to just enter the name of the exit on its own to move around, just as you would expect. The exit functionality is all defined on the Exit typeclass, so you could in principle completely change how exits work in your game (it's not recommended though, unless you really know what you are doing). Exits are locked using an access_type called traverse and also make use of a few hook methods for giving feedback if the traversal fails. See evennia.DefaultExit for more info. In mygame/typeclasses/exits.py there is an empty Exit class for you to modify. The process of traversing an exit is as follows: The traversing obj sends a command that matches the Exit-command name on the Exit object. The cmdhandler detects this and triggers the command defined on the Exit. Traversal always involves the \"source\" (the current location) and the destination (this is stored on the Exit object). The Exit command checks the traverse lock on the Exit object The Exit command triggers at_traverse(obj, destination) on the Exit object. In at_traverse , object.move_to(destination) is triggered. This triggers the following hooks, in order: obj.at_before_move(destination) - if this returns False, move is aborted. origin.at_before_leave(obj, destination) obj.announce_move_from(destination) Move is performed by changing obj.location from source location to destination . obj.announce_move_to(source) destination.at_object_receive(obj, source) obj.at_after_move(source) On the Exit object, at_after_traverse(obj, source) is triggered. If the move fails for whatever reason, the Exit will look for an Attribute err_traverse on itself and display this as an error message. If this is not found, the Exit will instead call at_failed_traverse(obj) on itself.","title":"Objects"},{"location":"Objects.html#how-to-create-your-own-object-types","text":"An Evennia Object is, per definition, a Python class that includes evennia.DefaultObject among its parents. In mygame/typeclasses/objects.py there is already a class Object that inherits from DefaultObject and that you can inherit from. You can put your new typeclass directly in that module or you could organize your code in some other way. Here we assume we make a new module mygame/typeclasses/flowers.py : # mygame/typeclasses/flowers.py from typeclasses.objects import Object class Rose(Object): \"\"\" This creates a simple rose object \"\"\" def at_object_creation(self): \"this is called only once, when object is first created\" # add a persistent attribute 'desc' # to object (silly example). self.db.desc = \"This is a pretty rose with thorns.\" You could save this in the mygame/typeclasses/objects.py (then you'd not need to import Object ) or you can put it in a new module. Let's say we do the latter, making a module typeclasses/flowers.py . Now you just need to point to the class Rose with the @create command to make a new rose: @create/drop MyRose:flowers.Rose What the @create command actually does is to use evennia.create_object . You can do the same thing yourself in code: from evennia import create_object new_rose = create_object(\"typeclasses.flowers.Rose\", key=\"MyRose\") (The @create command will auto-append the most likely path to your typeclass, if you enter the call manually you have to give the full path to the class. The create.create_object function is powerful and should be used for all coded object creating (so this is what you use when defining your own building commands). Check out the ev.create_* functions for how to build other entities like Scripts ). This particular Rose class doesn't really do much, all it does it make sure the attribute desc (which is what the look command looks for) is pre-set, which is pretty pointless since you will usually want to change this at build time (using the @desc command or using the Spawner ). The Object typeclass offers many more hooks that is available to use though - see next section.","title":"How to create your own object types"},{"location":"Objects.html#properties-and-functions-on-objects","text":"Beyond the properties assigned to all typeclassed objects (see that page for a list of those), the Object also has the following custom properties: aliases - a handler that allows you to add and remove aliases from this object. Use aliases.add() to add a new alias and aliases.remove() to remove one. location - a reference to the object currently containing this object. home is a backup location. The main motivation is to have a safe place to move the object to if its location is destroyed. All objects should usually have a home location for safety. destination - this holds a reference to another object this object links to in some way. Its main use is for Exits , it's otherwise usually unset. nicks - as opposed to aliases, a Nick holds a convenient nickname replacement for a real name, word or sequence, only valid for this object. This mainly makes sense if the Object is used as a game character - it can then store briefer shorts, example so as to quickly reference game commands or other characters. Use nicks.add(alias, realname) to add a new one. account - this holds a reference to a connected Account controlling this object (if any). Note that this is set also if the controlling account is not currently online - to test if an account is online, use the has_account property instead. sessions - if account field is set and the account is online , this is a list of all active sessions (server connections) to contact them through (it may be more than one if multiple connections are allowed in settings). has_account - a shorthand for checking if an online account is currently connected to this object. contents - this returns a list referencing all objects 'inside' this object (i,e. which has this object set as their location ). exits - this returns all objects inside this object that are Exits , that is, has the destination property set. The last two properties are special: cmdset - this is a handler that stores all command sets defined on the object (if any). scripts - this is a handler that manages Scripts attached to the object (if any). The Object also has a host of useful utility functions. See the function headers in src/objects/objects.py for their arguments and more details. msg() - this function is used to send messages from the server to an account connected to this object. msg_contents() - calls msg on all objects inside this object. search() - this is a convenient shorthand to search for a specific object, at a given location or globally. It's mainly useful when defining commands (in which case the object executing the command is named caller and one can do caller.search() to find objects in the room to operate on). execute_cmd() - Lets the object execute the given string as if it was given on the command line. move_to - perform a full move of this object to a new location. This is the main move method and will call all relevant hooks, do all checks etc. clear_exits() - will delete all Exits to and from this object. clear_contents() - this will not delete anything, but rather move all contents (except Exits) to their designated Home locations. delete() - deletes this object, first calling clear_exits() and clear_contents() . The Object Typeclass defines many more hook methods beyond at_object_creation . Evennia calls these hooks at various points. When implementing your custom objects, you will inherit from the base parent and overload these hooks with your own custom code. See evennia.objects.objects for an updated list of all the available hooks or the API for DefaultObject here .","title":"Properties and functions on Objects"},{"location":"Objects.html#subclasses-of-object","text":"There are three special subclasses of Object in default Evennia - Characters , Rooms and Exits . The reason they are separated is because these particular object types are fundamental, something you will always need and in some cases requires some extra attention in order to be recognized by the game engine (there is nothing stopping you from redefining them though). In practice they are all pretty similar to the base Object.","title":"Subclasses of Object"},{"location":"Objects.html#characters","text":"Characters are objects controlled by Accounts . When a new Account logs in to Evennia for the first time, a new Character object is created and the Account object is assigned to the account attribute. A Character object must have a Default Commandset set on itself at creation, or the account will not be able to issue any commands! If you just inherit your own class from evennia.DefaultCharacter and make sure to use super() to call the parent methods you should be fine. In mygame/typeclasses/characters.py is an empty Character class ready for you to modify.","title":"Characters"},{"location":"Objects.html#rooms","text":"Rooms are the root containers of all other objects. The only thing really separating a room from any other object is that they have no location of their own and that default commands like @dig creates objects of this class - so if you want to expand your rooms with more functionality, just inherit from ev.DefaultRoom . In mygame/typeclasses/rooms.py is an empty Room class ready for you to modify.","title":"Rooms"},{"location":"Objects.html#exits","text":"Exits are objects connecting other objects (usually Rooms ) together. An object named North or in might be an exit, as well as door , portal or jump out the window . An exit has two things that separate them from other objects. Firstly, their destination property is set and points to a valid object. This fact makes it easy and fast to locate exits in the database. Secondly, exits define a special Transit Command on themselves when they are created. This command is named the same as the exit object and will, when called, handle the practicalities of moving the character to the Exits's destination - this allows you to just enter the name of the exit on its own to move around, just as you would expect. The exit functionality is all defined on the Exit typeclass, so you could in principle completely change how exits work in your game (it's not recommended though, unless you really know what you are doing). Exits are locked using an access_type called traverse and also make use of a few hook methods for giving feedback if the traversal fails. See evennia.DefaultExit for more info. In mygame/typeclasses/exits.py there is an empty Exit class for you to modify. The process of traversing an exit is as follows: The traversing obj sends a command that matches the Exit-command name on the Exit object. The cmdhandler detects this and triggers the command defined on the Exit. Traversal always involves the \"source\" (the current location) and the destination (this is stored on the Exit object). The Exit command checks the traverse lock on the Exit object The Exit command triggers at_traverse(obj, destination) on the Exit object. In at_traverse , object.move_to(destination) is triggered. This triggers the following hooks, in order: obj.at_before_move(destination) - if this returns False, move is aborted. origin.at_before_leave(obj, destination) obj.announce_move_from(destination) Move is performed by changing obj.location from source location to destination . obj.announce_move_to(source) destination.at_object_receive(obj, source) obj.at_after_move(source) On the Exit object, at_after_traverse(obj, source) is triggered. If the move fails for whatever reason, the Exit will look for an Attribute err_traverse on itself and display this as an error message. If this is not found, the Exit will instead call at_failed_traverse(obj) on itself.","title":"Exits"},{"location":"Online-Setup.html","text":"Evennia development can be made without any Internet connection beyond fetching updates. At some point however, you are likely to want to make your game visible online, either as part opening it to the public or to allow other developers or beta testers access to it. Connecting from the outside \u00b6 It's actually very easy to get Evennia itself online if you just want to try hosting it on your own computer (other hosting solutions are discussed later). The problems are usually with the security measures of your own computer and network that blocks this from happening. Out of the box, Evennia uses three ports for outward communication. If your computer has a firewall, these should be open for in/out communication (and only these, other ports used by Evennia are internal to your computer only). - 4000 , telnet, for traditional mud clients - 4001 , HTTP for the website) - 4002 , websocket, for the web client Evennia will by default accept incoming connections on all interfaces ( 0.0.0.0 ) so in principle anyone knowing the ports to use and has the IP address to your machine should be able to connect to your game. To get your current internet-facing IP-address, Google for \"my ip\" or use any of the countless online services that shows this. Let's say your outward-facing IP is 203.0.113.0 . First, start the server and make sure you can connect with your web browser to http://localhost:4001 or, alternatively, http:127.0.0.1:4001 which is the same thing. You should get your Evennia web site and be able to play the game in the web client. Also check so that you can connect with a mud client to host localhost , port 4000 or host 127.0.0.1 , port 4000 . Next try your outward-facing IP by opening http://203.0.113.0:4001 . If this works, that's it! However, most likely it will not work. If so, read on. If your computer has a firewall, it may be blocking the ports we need (it may also block telnet overall). If so, you need to open the outward-facing ports to in/out communication. See the manual/instructions for your firewall software on how to do this. To test you could also temporarily turn off your firewall entirely to see if that was indeed the problem. Another common problem for not being able to connect is that you are using a hardware router (like a wifi router). The router sits 'between' your computer and the Internet. So the IP you find with Google is the router's IP, not that of your computer. To resolve this you need to configure your router to forward data it gets on its ports to the IP and ports of your computer sitting in your private network. How to do this depends on the make of your router; you usually configure it using a normal web browser. In the router interface, look for \"Port forwarding\" or maybe \"Virtual server\". If that doesn't work, try to temporarily wire your computer directly to the Internet outlet (assuming your computer has the ports for it). You'll need to check for your IP again. If that works, you know the problem is the router. Note: If you need to reconfigure a router, the router's Internet-facing ports do not have to have to have the same numbers as your computer's (and Evennia's) ports! For example, you might want to connect Evennia's outgoing port 4001 to an outgoing router port 80 - this is the port HTTP requests use and web browsers automatically look for - if you do that you could go to http://203.0.113.0 without having to add the port at the end. This would collide with any other web services you are running through this router though. Settings example \u00b6 You can connect Evennia to the Internet without any changes to your settings. The default settings are easy to use but are not necessarily the safest. You can customize your online presence in your settings file . To have Evennia recognize changed port settings you have to do a full stop of the server (not just a reload), via evennia stop before starting again. Below is an example of a simple set of settings, mostly using the defaults. Evennia will require access to five computer ports, of which three (only) should be open to the outside world. Below we continue to assume that our server address is 203.0.113.0 . # in mygame/server/conf/settings.py SERVERNAME = \"MyGame\" # open to the internet: 4000, 4001, 4002 # closed to the internet (internal use): 4005, 4006 TELNET_PORTS = [4000] WEBSOCKET_CLIENT_PORT = 4002 WEBSERVER_PORTS = [(4001, 4005)] AMP_PORT = 4006 # Optional - security measures limiting interface access # (don't set these before you know things work without them) TELNET_INTERFACES = ['203.0.113.0'] WEBSOCKET_CLIENT_INTERFACE = '203.0.113.0' ALLOWED_HOSTS = [\".mymudgame.com\"] # uncomment when you want to take server offline later # LOCKDOWN_MODE = True Read on for a description of the individual settings. Telnet \u00b6 # Required. Change to whichever outgoing Telnet port(s) # you are allowed to use on your host. TELNET_PORTS = [4000] # Optional for security. Restrict which telnet # interfaces we should accept. Should be set to your # outward-facing IP address(es). Default is \u00b40.0.0.0\u00b4 # which accepts all interfaces. TELNET_INTERFACES = ['0.0.0.0'] The TELNET_* settings are the most important ones for getting a traditional base game going. Which IP addresses you have available depends on your server hosting solution (see the next sections). Some hosts will restrict which ports you are allowed you use so make sure to check. Web server \u00b6 # Required. This is a list of tuples # (outgoing_port, internal_port). Only the outgoing # port should be open to the world! # set outgoing port to 80 if you want to run Evennia # as the only web server on your machine (if available). WEBSERVER_PORTS = [(4001, 4005)] # Optional for security. Change this to the IP your # server can be reached at (normally the same # as TELNET_INTERFACES) WEBSERVER_INTERFACES = ['0.0.0.0'] # Optional for security. Protects against # man-in-the-middle attacks. Change it to your server's # IP address or URL when you run a production server. ALLOWED_HOSTS = ['*'] The web server is always configured with two ports at a time. The outgoing port ( 4001 by default) is the port external connections can use. If you don't want users to have to specify the port when they connect, you should set this to 80 - this however only works if you are not running any other web server on the machine. The internal port ( 4005 by default) is used internally by Evennia to communicate between the Server and the Portal. It should not be available to the outside world. You usually only need to change the outgoing port unless the default internal port is clashing with some other program. Web client \u00b6 # Required. Change this to the main IP address of your server. WEBSOCKET_CLIENT_INTERFACE = '0.0.0.0' # Optional and needed only if using a proxy or similar. Change # to the IP or address where the client can reach # your server. The ws:// part is then required. If not given, the client # will use its host location. WEBSOCKET_CLIENT_URL = \"\" # Required. Change to a free port for the websocket client to reach # the server on. This will be automatically appended # to WEBSOCKET_CLIENT_URL by the web client. WEBSOCKET_CLIENT_PORT = 4002 The websocket-based web client needs to be able to call back to the server, and these settings must be changed for it to find where to look. If it cannot find the server you will get an warning in your browser's Console (in the dev tools of the browser), and the client will revert to the AJAX-based of the client instead, which tends to be slower. Other ports \u00b6 # Optional public facing. Only allows SSL connections (off by default). SSL_PORTS = [4003] SSL_INTERFACES = ['0.0.0.0'] # Optional public facing. Only if you allow SSH connections (off by default). SSH_PORTS = [4004] SSH_INTERFACES = ['0.0.0.0'] # Required private. You should only change this if there is a clash # with other services on your host. Should NOT be open to the # outside world. AMP_PORT = 4006 The AMP_PORT is required to work, since this is the internal port linking Evennia's Server and Portal components together. The other ports are encrypted ports that may be useful for custom protocols but are otherwise not used. Lockdown mode \u00b6 When you test things out and check configurations you may not want players to drop in on you. Similarly, if you are doing maintenance on a live game you may want to take it offline for a while to fix eventual problems without risking people connecting. To do this, stop the server with evennia stop and add LOCKDOWN_MODE = True to your settings file. When you start the server again, your game will only be accessible from localhost. Registering with the Evennia game directory \u00b6 Once your game is online you should make sure to register it with the Evennia Game Index . Registering with the index will help people find your server, drum up interest for your game and also shows people that Evennia is being used. You can do this even if you are just starting development - if you don't give any telnet/web address it will appear as Not yet public and just be a teaser. If so, pick pre-alpha as the development status. To register, stand in your game dir, run evennia connections and follow the instructions. See the Game client documentation for more info. SSL \u00b6 SSL can be very useful for web clients. It will protect the credentials and gameplay of your users over a web client if they are in a public place, and your websocket can also be switched to WSS for the same benefit. SSL certificates used to cost money on a yearly basis, but there is now a program that issues them for free with assisted setup to make the entire process less painful. Options that may be useful in combination with an SSL proxy: # See above for the section on Lockdown Mode. # Useful for a proxy on the public interface connecting to Evennia on localhost. LOCKDOWN_MODE = True # Have clients communicate via wss after connecting with https to port 4001. # Without this, you may get DOMException errors when the browser tries # to create an insecure websocket from a secure webpage. WEBSOCKET_CLIENT_URL = \"wss://fqdn:4002\" Let's Encrypt \u00b6 Let's Encrypt is a certificate authority offering free certificates to secure a website with HTTPS. To get started issuing a certificate for your web server using Let's Encrypt, see these links: Let's Encrypt - Getting Started The CertBot Client is a program for automatically obtaining a certificate, use it and maintain it with your website. Also, on Freenode visit the #letsencrypt channel for assistance from the community. For an additional resource, Let's Encrypt has a very active community forum . A blog where someone sets up Let's Encrypt The only process missing from all of the above documentation is how to pass verification. This is how Let's Encrypt verifies that you have control over your domain (not necessarily ownership, it's Domain Validation (DV)). This can be done either with configuring a certain path on your web server or through a TXT record in your DNS. Which one you will want to do is a personal preference, but can also be based on your hosting choice. In a controlled/cPanel environment, you will most likely have to use DNS verification. Relevant SSL Proxy Setup Information \u00b6 Apache webserver configuration (optional) HAProxy Config Hosting locally or remotely? \u00b6 Using your own computer as a server \u00b6 What we showed above is by far the simplest and probably cheapest option: Run Evennia on your own home computer. Moreover, since Evennia is its own web server, you don't need to install anything extra to have a website. Advantages - Free (except for internet costs and the electrical bill). - Full control over the server and hardware (it sits right there!). - Easy to set up. - Suitable for quick setups - e.g. to briefly show off results to your collaborators. Disadvantages - You need a good internet connection, ideally without any upload/download limits/costs. - If you want to run a full game this way, your computer needs to always be on. It could be noisy, and as mentioned, the electrical bill must be considered. - No support or safety - if your house burns down, so will your game. Also, you are yourself responsible for doing regular backups. - Potentially not as easy if you don't know how to open ports in your firewall or router. - Home IP numbers are often dynamically allocated, so for permanent online time you need to set up a DNS to always re-point to the right place (see below). Setting up your own machine as a server \u00b6 The first section of this page describes how to do this and allow users to connect to the IP address of your machine/router. A complication with using a specific IP address like this is that your home IP might not remain the same. Many ISPs (Internet Service Providers) allocates a dynamic IP to you which could change at any time. When that happens, that IP you told people to go to will be worthless. Also, that long string of numbers is not very pretty, is it? It's hard to remember and not easy to use in marketing your game. What you need is to alias it to a more sensible domain name - an alias that follows you around also when the IP changes. To set up a domain name alias, we recommend starting with a free domain name from FreeDNS . Once you register there (it's free) you have access to tens of thousands domain names that people have \"donated\" to allow you to use for your own sub domain. For example, strangled.net is one of those available domains. So tying our IP address to strangled.net using the subdomain evennia would mean that one could henceforth direct people to http://evennia.strangled.net:4001 for their gaming needs - far easier to remember! So how do we make this new, nice domain name follow us also if our IP changes? For this we need to set up a little program on our computer. It will check whenever our ISP decides to change our IP and tell FreeDNS that. There are many alternatives to be found from FreeDNS:s homepage, one that works on multiple platforms is inadyn . Get it from their page or, in Linux, through something like apt-get install inadyn . Next, you login to your account on FreeDNS and go to the Dynamic page. You should have a list of your subdomains. Click the Direct URL link and you'll get a page with a text message. Ignore that and look at the URL of the page. It should be ending in a lot of random letters. Everything after the question mark is your unique \"hash\". Copy this string. You now start inadyn with the following command (Linux): inadyn --dyndns_system default@freedns.afraid.org -a <my.domain>,<hash> & where <my.domain> would be evennia.strangled.net and <hash> the string of numbers we copied from FreeDNS. The & means we run in the background (might not be valid in other operating systems). inadyn will henceforth check for changes every 60 seconds. You should put the inadyn command string in a startup script somewhere so it kicks into gear whenever your computer starts. Remote hosting \u00b6 Your normal \"web hotel\" will probably not be enough to run Evennia. A web hotel is normally aimed at a very specific usage - delivering web pages, at the most with some dynamic content. The \"Python scripts\" they refer to on their home pages are usually only intended to be CGI-like scripts launched by their webserver. Even if they allow you shell access (so you can install the Evennia dependencies in the first place), resource usage will likely be very restricted. Running a full-fledged game server like Evennia will probably be shunned upon or be outright impossible. If you are unsure, contact your web hotel and ask about their policy on you running third-party servers that will want to open custom ports. The options you probably need to look for are shell account services , VPS:es or Cloud services . A \"Shell account\" service means that you get a shell account on a server and can log in like any normal user. By contrast, a VPS (Virtual Private Server) service usually means that you get root access, but in a virtual machine. There are also Cloud -type services which allows for starting up multiple virtual machines and pay for what resources you use. Advantages - Shell accounts/VPS/clouds offer more flexibility than your average web hotel - it's the ability to log onto a shared computer away from home. - Usually runs a Linux flavor, making it easy to install Evennia. - Support. You don't need to maintain the server hardware. If your house burns down, at least your game stays online. Many services guarantee a certain level of up-time and also do regular backups for you. Make sure to check, some offer lower rates in exchange for you yourself being fully responsible for your data/backups. - Usually offers a fixed domain name, so no need to mess with IP addresses. - May have the ability to easily deploy docker versions of evennia and/or your game. Disadvantages - Might be pretty expensive (more so than a web hotel). Note that Evennia will normally need at least 100MB RAM and likely much more for a large production game. - Linux flavors might feel unfamiliar to users not used to ssh/PuTTy and the Linux command line. - You are probably sharing the server with many others, so you are not completely in charge. CPU usage might be limited. Also, if the server people decides to take the server down for maintenance, you have no choice but to sit it out (but you'll hopefully be warned ahead of time). Installing Evennia on a remote server \u00b6 Firstly, if you are familiar with server infrastructure, consider using Docker to deploy your game to the remote server; it will likely ease installation and deployment. Docker images may be a little confusing if you are completely new to them though. If not using docker, and assuming you know how to connect to your account over ssh/PuTTy, you should be able to follow the Getting Started instructions normally. You only need Python and GIT pre-installed; these should both be available on any servers (if not you should be able to easily ask for them to be installed). On a VPS or Cloud service you can install them yourself as needed. If virtualenv is not available and you can't get it, you can download it (it's just a single file) from the virtualenv pypi . Using virtualenv you can install everything without actually needing to have further root access. Ports might be an issue, so make sure you know which ports are available to use and reconfigure Evennia accordingly. Hosting options \u00b6 To find commercial solutions, browse the web for \"shell access\", \"VPS\" or \"Cloud services\" in your region. You may find useful offers for \"low cost\" VPS hosting on Low End Box . The associated Low End Talk forum can be useful for health checking the many small businesses that offer \"value\" hosting, and occasionally for technical suggestions. There are all sorts of services available. Below are some international suggestions offered by Evennia users: Hosting name Type Lowest price Comments silvren.com Shell account Free for MU* Private hobby provider so don't assume backups or expect immediate support. To ask for an account, connect with a MUD client to iweb.localecho.net, port 4201 and ask for \"Jarin\". Digital Ocean VPS $5/month You can get a $50 credit if you use the referral link https://m.do.co/c/8f64fec2670c - if you do, once you've had it long enough to have paid $25 we will get that as a referral bonus to help Evennia development. Amazon Web services Cloud ~$5/month / on-demand Free Tier first 12 months. Regions available around the globe. Amazon Lightsail Cloud $5/month Free first month. AWS's new \"fixed cost\" offering. Genesis MUD hosting Shell account $8/month Dedicated MUD host with very limited memory offerings. As for 2017, runs a 13 years old Python version (2.4) so you'd need to either convince them to update or compile yourself. Note that Evennia needs at least the \"Deluxe\" package (50MB RAM) and probably a lot higher for a production game. This host is not recommended for Evennia. Host1Plus VPS & Cloud $4/month $4-$8/month depending on length of sign-up period. Scaleway Cloud \u20ac3/month / on-demand EU based (Paris, Amsterdam). Smallest option provides 2GB RAM. Prgmr VPS $5/month 1 month free with a year prepay. You likely want some experience with servers with this option as they don't have a lot of support. Linode Cloud $5/month / on-demand Multiple regions. Smallest option provides 1GB RAM Please help us expand this list. Cloud9 \u00b6 If you are interested in running Evennia in the online dev environment Cloud9 , you can spin it up through their normal online setup using the Evennia Linux install instructions. The one extra thing you will have to do is update mygame/server/conf/settings.py and add WEBSERVER_PORTS = [(8080, 4001)] . This will then let you access the web server and do everything else as normal. Note that, as of December 2017, Cloud9 was re-released by Amazon as a service within their AWS cloud service offering. New customers entitled to the 1 year AWS \"free tier\" may find it provides sufficient resources to operate a Cloud9 development environment without charge. https://aws.amazon.com/cloud9/","title":"Online Setup"},{"location":"Online-Setup.html#connecting-from-the-outside","text":"It's actually very easy to get Evennia itself online if you just want to try hosting it on your own computer (other hosting solutions are discussed later). The problems are usually with the security measures of your own computer and network that blocks this from happening. Out of the box, Evennia uses three ports for outward communication. If your computer has a firewall, these should be open for in/out communication (and only these, other ports used by Evennia are internal to your computer only). - 4000 , telnet, for traditional mud clients - 4001 , HTTP for the website) - 4002 , websocket, for the web client Evennia will by default accept incoming connections on all interfaces ( 0.0.0.0 ) so in principle anyone knowing the ports to use and has the IP address to your machine should be able to connect to your game. To get your current internet-facing IP-address, Google for \"my ip\" or use any of the countless online services that shows this. Let's say your outward-facing IP is 203.0.113.0 . First, start the server and make sure you can connect with your web browser to http://localhost:4001 or, alternatively, http:127.0.0.1:4001 which is the same thing. You should get your Evennia web site and be able to play the game in the web client. Also check so that you can connect with a mud client to host localhost , port 4000 or host 127.0.0.1 , port 4000 . Next try your outward-facing IP by opening http://203.0.113.0:4001 . If this works, that's it! However, most likely it will not work. If so, read on. If your computer has a firewall, it may be blocking the ports we need (it may also block telnet overall). If so, you need to open the outward-facing ports to in/out communication. See the manual/instructions for your firewall software on how to do this. To test you could also temporarily turn off your firewall entirely to see if that was indeed the problem. Another common problem for not being able to connect is that you are using a hardware router (like a wifi router). The router sits 'between' your computer and the Internet. So the IP you find with Google is the router's IP, not that of your computer. To resolve this you need to configure your router to forward data it gets on its ports to the IP and ports of your computer sitting in your private network. How to do this depends on the make of your router; you usually configure it using a normal web browser. In the router interface, look for \"Port forwarding\" or maybe \"Virtual server\". If that doesn't work, try to temporarily wire your computer directly to the Internet outlet (assuming your computer has the ports for it). You'll need to check for your IP again. If that works, you know the problem is the router. Note: If you need to reconfigure a router, the router's Internet-facing ports do not have to have to have the same numbers as your computer's (and Evennia's) ports! For example, you might want to connect Evennia's outgoing port 4001 to an outgoing router port 80 - this is the port HTTP requests use and web browsers automatically look for - if you do that you could go to http://203.0.113.0 without having to add the port at the end. This would collide with any other web services you are running through this router though.","title":"Connecting from the outside"},{"location":"Online-Setup.html#settings-example","text":"You can connect Evennia to the Internet without any changes to your settings. The default settings are easy to use but are not necessarily the safest. You can customize your online presence in your settings file . To have Evennia recognize changed port settings you have to do a full stop of the server (not just a reload), via evennia stop before starting again. Below is an example of a simple set of settings, mostly using the defaults. Evennia will require access to five computer ports, of which three (only) should be open to the outside world. Below we continue to assume that our server address is 203.0.113.0 . # in mygame/server/conf/settings.py SERVERNAME = \"MyGame\" # open to the internet: 4000, 4001, 4002 # closed to the internet (internal use): 4005, 4006 TELNET_PORTS = [4000] WEBSOCKET_CLIENT_PORT = 4002 WEBSERVER_PORTS = [(4001, 4005)] AMP_PORT = 4006 # Optional - security measures limiting interface access # (don't set these before you know things work without them) TELNET_INTERFACES = ['203.0.113.0'] WEBSOCKET_CLIENT_INTERFACE = '203.0.113.0' ALLOWED_HOSTS = [\".mymudgame.com\"] # uncomment when you want to take server offline later # LOCKDOWN_MODE = True Read on for a description of the individual settings.","title":"Settings example"},{"location":"Online-Setup.html#telnet","text":"# Required. Change to whichever outgoing Telnet port(s) # you are allowed to use on your host. TELNET_PORTS = [4000] # Optional for security. Restrict which telnet # interfaces we should accept. Should be set to your # outward-facing IP address(es). Default is \u00b40.0.0.0\u00b4 # which accepts all interfaces. TELNET_INTERFACES = ['0.0.0.0'] The TELNET_* settings are the most important ones for getting a traditional base game going. Which IP addresses you have available depends on your server hosting solution (see the next sections). Some hosts will restrict which ports you are allowed you use so make sure to check.","title":"Telnet"},{"location":"Online-Setup.html#web-server","text":"# Required. This is a list of tuples # (outgoing_port, internal_port). Only the outgoing # port should be open to the world! # set outgoing port to 80 if you want to run Evennia # as the only web server on your machine (if available). WEBSERVER_PORTS = [(4001, 4005)] # Optional for security. Change this to the IP your # server can be reached at (normally the same # as TELNET_INTERFACES) WEBSERVER_INTERFACES = ['0.0.0.0'] # Optional for security. Protects against # man-in-the-middle attacks. Change it to your server's # IP address or URL when you run a production server. ALLOWED_HOSTS = ['*'] The web server is always configured with two ports at a time. The outgoing port ( 4001 by default) is the port external connections can use. If you don't want users to have to specify the port when they connect, you should set this to 80 - this however only works if you are not running any other web server on the machine. The internal port ( 4005 by default) is used internally by Evennia to communicate between the Server and the Portal. It should not be available to the outside world. You usually only need to change the outgoing port unless the default internal port is clashing with some other program.","title":"Web server"},{"location":"Online-Setup.html#web-client","text":"# Required. Change this to the main IP address of your server. WEBSOCKET_CLIENT_INTERFACE = '0.0.0.0' # Optional and needed only if using a proxy or similar. Change # to the IP or address where the client can reach # your server. The ws:// part is then required. If not given, the client # will use its host location. WEBSOCKET_CLIENT_URL = \"\" # Required. Change to a free port for the websocket client to reach # the server on. This will be automatically appended # to WEBSOCKET_CLIENT_URL by the web client. WEBSOCKET_CLIENT_PORT = 4002 The websocket-based web client needs to be able to call back to the server, and these settings must be changed for it to find where to look. If it cannot find the server you will get an warning in your browser's Console (in the dev tools of the browser), and the client will revert to the AJAX-based of the client instead, which tends to be slower.","title":"Web client"},{"location":"Online-Setup.html#other-ports","text":"# Optional public facing. Only allows SSL connections (off by default). SSL_PORTS = [4003] SSL_INTERFACES = ['0.0.0.0'] # Optional public facing. Only if you allow SSH connections (off by default). SSH_PORTS = [4004] SSH_INTERFACES = ['0.0.0.0'] # Required private. You should only change this if there is a clash # with other services on your host. Should NOT be open to the # outside world. AMP_PORT = 4006 The AMP_PORT is required to work, since this is the internal port linking Evennia's Server and Portal components together. The other ports are encrypted ports that may be useful for custom protocols but are otherwise not used.","title":"Other ports"},{"location":"Online-Setup.html#lockdown-mode","text":"When you test things out and check configurations you may not want players to drop in on you. Similarly, if you are doing maintenance on a live game you may want to take it offline for a while to fix eventual problems without risking people connecting. To do this, stop the server with evennia stop and add LOCKDOWN_MODE = True to your settings file. When you start the server again, your game will only be accessible from localhost.","title":"Lockdown mode"},{"location":"Online-Setup.html#registering-with-the-evennia-game-directory","text":"Once your game is online you should make sure to register it with the Evennia Game Index . Registering with the index will help people find your server, drum up interest for your game and also shows people that Evennia is being used. You can do this even if you are just starting development - if you don't give any telnet/web address it will appear as Not yet public and just be a teaser. If so, pick pre-alpha as the development status. To register, stand in your game dir, run evennia connections and follow the instructions. See the Game client documentation for more info.","title":"Registering with the Evennia game directory"},{"location":"Online-Setup.html#ssl","text":"SSL can be very useful for web clients. It will protect the credentials and gameplay of your users over a web client if they are in a public place, and your websocket can also be switched to WSS for the same benefit. SSL certificates used to cost money on a yearly basis, but there is now a program that issues them for free with assisted setup to make the entire process less painful. Options that may be useful in combination with an SSL proxy: # See above for the section on Lockdown Mode. # Useful for a proxy on the public interface connecting to Evennia on localhost. LOCKDOWN_MODE = True # Have clients communicate via wss after connecting with https to port 4001. # Without this, you may get DOMException errors when the browser tries # to create an insecure websocket from a secure webpage. WEBSOCKET_CLIENT_URL = \"wss://fqdn:4002\"","title":"SSL"},{"location":"Online-Setup.html#lets-encrypt","text":"Let's Encrypt is a certificate authority offering free certificates to secure a website with HTTPS. To get started issuing a certificate for your web server using Let's Encrypt, see these links: Let's Encrypt - Getting Started The CertBot Client is a program for automatically obtaining a certificate, use it and maintain it with your website. Also, on Freenode visit the #letsencrypt channel for assistance from the community. For an additional resource, Let's Encrypt has a very active community forum . A blog where someone sets up Let's Encrypt The only process missing from all of the above documentation is how to pass verification. This is how Let's Encrypt verifies that you have control over your domain (not necessarily ownership, it's Domain Validation (DV)). This can be done either with configuring a certain path on your web server or through a TXT record in your DNS. Which one you will want to do is a personal preference, but can also be based on your hosting choice. In a controlled/cPanel environment, you will most likely have to use DNS verification.","title":"Let's Encrypt"},{"location":"Online-Setup.html#relevant-ssl-proxy-setup-information","text":"Apache webserver configuration (optional) HAProxy Config","title":"Relevant SSL Proxy Setup Information"},{"location":"Online-Setup.html#hosting-locally-or-remotely","text":"","title":"Hosting locally or remotely?"},{"location":"Online-Setup.html#using-your-own-computer-as-a-server","text":"What we showed above is by far the simplest and probably cheapest option: Run Evennia on your own home computer. Moreover, since Evennia is its own web server, you don't need to install anything extra to have a website. Advantages - Free (except for internet costs and the electrical bill). - Full control over the server and hardware (it sits right there!). - Easy to set up. - Suitable for quick setups - e.g. to briefly show off results to your collaborators. Disadvantages - You need a good internet connection, ideally without any upload/download limits/costs. - If you want to run a full game this way, your computer needs to always be on. It could be noisy, and as mentioned, the electrical bill must be considered. - No support or safety - if your house burns down, so will your game. Also, you are yourself responsible for doing regular backups. - Potentially not as easy if you don't know how to open ports in your firewall or router. - Home IP numbers are often dynamically allocated, so for permanent online time you need to set up a DNS to always re-point to the right place (see below).","title":"Using your own computer as a server"},{"location":"Online-Setup.html#setting-up-your-own-machine-as-a-server","text":"The first section of this page describes how to do this and allow users to connect to the IP address of your machine/router. A complication with using a specific IP address like this is that your home IP might not remain the same. Many ISPs (Internet Service Providers) allocates a dynamic IP to you which could change at any time. When that happens, that IP you told people to go to will be worthless. Also, that long string of numbers is not very pretty, is it? It's hard to remember and not easy to use in marketing your game. What you need is to alias it to a more sensible domain name - an alias that follows you around also when the IP changes. To set up a domain name alias, we recommend starting with a free domain name from FreeDNS . Once you register there (it's free) you have access to tens of thousands domain names that people have \"donated\" to allow you to use for your own sub domain. For example, strangled.net is one of those available domains. So tying our IP address to strangled.net using the subdomain evennia would mean that one could henceforth direct people to http://evennia.strangled.net:4001 for their gaming needs - far easier to remember! So how do we make this new, nice domain name follow us also if our IP changes? For this we need to set up a little program on our computer. It will check whenever our ISP decides to change our IP and tell FreeDNS that. There are many alternatives to be found from FreeDNS:s homepage, one that works on multiple platforms is inadyn . Get it from their page or, in Linux, through something like apt-get install inadyn . Next, you login to your account on FreeDNS and go to the Dynamic page. You should have a list of your subdomains. Click the Direct URL link and you'll get a page with a text message. Ignore that and look at the URL of the page. It should be ending in a lot of random letters. Everything after the question mark is your unique \"hash\". Copy this string. You now start inadyn with the following command (Linux): inadyn --dyndns_system default@freedns.afraid.org -a <my.domain>,<hash> & where <my.domain> would be evennia.strangled.net and <hash> the string of numbers we copied from FreeDNS. The & means we run in the background (might not be valid in other operating systems). inadyn will henceforth check for changes every 60 seconds. You should put the inadyn command string in a startup script somewhere so it kicks into gear whenever your computer starts.","title":"Setting up your own machine as a server"},{"location":"Online-Setup.html#remote-hosting","text":"Your normal \"web hotel\" will probably not be enough to run Evennia. A web hotel is normally aimed at a very specific usage - delivering web pages, at the most with some dynamic content. The \"Python scripts\" they refer to on their home pages are usually only intended to be CGI-like scripts launched by their webserver. Even if they allow you shell access (so you can install the Evennia dependencies in the first place), resource usage will likely be very restricted. Running a full-fledged game server like Evennia will probably be shunned upon or be outright impossible. If you are unsure, contact your web hotel and ask about their policy on you running third-party servers that will want to open custom ports. The options you probably need to look for are shell account services , VPS:es or Cloud services . A \"Shell account\" service means that you get a shell account on a server and can log in like any normal user. By contrast, a VPS (Virtual Private Server) service usually means that you get root access, but in a virtual machine. There are also Cloud -type services which allows for starting up multiple virtual machines and pay for what resources you use. Advantages - Shell accounts/VPS/clouds offer more flexibility than your average web hotel - it's the ability to log onto a shared computer away from home. - Usually runs a Linux flavor, making it easy to install Evennia. - Support. You don't need to maintain the server hardware. If your house burns down, at least your game stays online. Many services guarantee a certain level of up-time and also do regular backups for you. Make sure to check, some offer lower rates in exchange for you yourself being fully responsible for your data/backups. - Usually offers a fixed domain name, so no need to mess with IP addresses. - May have the ability to easily deploy docker versions of evennia and/or your game. Disadvantages - Might be pretty expensive (more so than a web hotel). Note that Evennia will normally need at least 100MB RAM and likely much more for a large production game. - Linux flavors might feel unfamiliar to users not used to ssh/PuTTy and the Linux command line. - You are probably sharing the server with many others, so you are not completely in charge. CPU usage might be limited. Also, if the server people decides to take the server down for maintenance, you have no choice but to sit it out (but you'll hopefully be warned ahead of time).","title":"Remote hosting"},{"location":"Online-Setup.html#installing-evennia-on-a-remote-server","text":"Firstly, if you are familiar with server infrastructure, consider using Docker to deploy your game to the remote server; it will likely ease installation and deployment. Docker images may be a little confusing if you are completely new to them though. If not using docker, and assuming you know how to connect to your account over ssh/PuTTy, you should be able to follow the Getting Started instructions normally. You only need Python and GIT pre-installed; these should both be available on any servers (if not you should be able to easily ask for them to be installed). On a VPS or Cloud service you can install them yourself as needed. If virtualenv is not available and you can't get it, you can download it (it's just a single file) from the virtualenv pypi . Using virtualenv you can install everything without actually needing to have further root access. Ports might be an issue, so make sure you know which ports are available to use and reconfigure Evennia accordingly.","title":"Installing Evennia on a remote server"},{"location":"Online-Setup.html#hosting-options","text":"To find commercial solutions, browse the web for \"shell access\", \"VPS\" or \"Cloud services\" in your region. You may find useful offers for \"low cost\" VPS hosting on Low End Box . The associated Low End Talk forum can be useful for health checking the many small businesses that offer \"value\" hosting, and occasionally for technical suggestions. There are all sorts of services available. Below are some international suggestions offered by Evennia users: Hosting name Type Lowest price Comments silvren.com Shell account Free for MU* Private hobby provider so don't assume backups or expect immediate support. To ask for an account, connect with a MUD client to iweb.localecho.net, port 4201 and ask for \"Jarin\". Digital Ocean VPS $5/month You can get a $50 credit if you use the referral link https://m.do.co/c/8f64fec2670c - if you do, once you've had it long enough to have paid $25 we will get that as a referral bonus to help Evennia development. Amazon Web services Cloud ~$5/month / on-demand Free Tier first 12 months. Regions available around the globe. Amazon Lightsail Cloud $5/month Free first month. AWS's new \"fixed cost\" offering. Genesis MUD hosting Shell account $8/month Dedicated MUD host with very limited memory offerings. As for 2017, runs a 13 years old Python version (2.4) so you'd need to either convince them to update or compile yourself. Note that Evennia needs at least the \"Deluxe\" package (50MB RAM) and probably a lot higher for a production game. This host is not recommended for Evennia. Host1Plus VPS & Cloud $4/month $4-$8/month depending on length of sign-up period. Scaleway Cloud \u20ac3/month / on-demand EU based (Paris, Amsterdam). Smallest option provides 2GB RAM. Prgmr VPS $5/month 1 month free with a year prepay. You likely want some experience with servers with this option as they don't have a lot of support. Linode Cloud $5/month / on-demand Multiple regions. Smallest option provides 1GB RAM Please help us expand this list.","title":"Hosting options"},{"location":"Online-Setup.html#cloud9","text":"If you are interested in running Evennia in the online dev environment Cloud9 , you can spin it up through their normal online setup using the Evennia Linux install instructions. The one extra thing you will have to do is update mygame/server/conf/settings.py and add WEBSERVER_PORTS = [(8080, 4001)] . This will then let you access the web server and do everything else as normal. Note that, as of December 2017, Cloud9 was re-released by Amazon as a service within their AWS cloud service offering. New customers entitled to the 1 year AWS \"free tier\" may find it provides sufficient resources to operate a Cloud9 development environment without charge. https://aws.amazon.com/cloud9/","title":"Cloud9"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html","text":"This tutorial will elaborate on the many ways one can parse command arguments. The first step after adding a command usually is to parse its arguments. There are lots of ways to do it, but some are indeed better than others and this tutorial will try to present them. If you're a Python beginner, this tutorial might help you a lot. If you're already familiar with Python syntax, this tutorial might still contain useful information. There are still a lot of things I find in the standard library that come as a surprise, though they were there all along. This might be true for others. In this tutorial we will: Parse arguments with numbers. Parse arguments with delimiters. Take a look at optional arguments. Parse argument containing object names. What are command arguments? \u00b6 I'm going to talk about command arguments and parsing a lot in this tutorial. So let's be sure we talk about the same thing before going any further: A command is an Evennia object that handles specific user input. For instance, the default look is a command. After having created your Evennia game, and connected to it, you should be able to type look to see what's around. In this context, look is a command. Command arguments are additional text passed after the command. Following the same example, you can type look self to look at yourself. In this context, self is the text specified after look . \" self\" is the argument to the look command. Part of our task as a game developer is to connect user inputs (mostly commands) with actions in the game. And most of the time, entering commands is not enough, we have to rely on arguments for specifying actions with more accuracy. Take the say command. If you couldn't specify what to say as a command argument ( say hello! ), you would have trouble communicating with others in the game. One would need to create a different command for every kind of word or sentence, which is, of course, not practical. Last thing: what is parsing? In our case, parsing is the process by which we convert command arguments into something we can work with. We don't usually use the command argument as is (which is just text, of type str in Python). We need to extract useful information. We might want to ask the user for a number, or the name of another character present in the same room. We're going to see how to do all that now. Working with strings \u00b6 In object terms, when you write a command in Evennia (when you write the Python class), the arguments are stored in the args attribute. Which is to say, inside your func method, you can access the command arguments in self.args . self.args \u00b6 To begin with, look at this example: class CmdTest(Command): \"\"\" Test command. Syntax: test [argument] Enter any argument after test. \"\"\" key = \"test\" def func(self): self.msg(f\"You have entered: {self.args}.\") If you add this command and test it, you will receive exactly what you have entered without any parsing: > test Whatever You have entered: Whatever. > test You have entered: . The lines starting with > indicate what you enter into your client. The other lines are what you receive from the game server. Notice two things here: The left space between our command key (\"test\", here) and our command argument is not removed. That's why there are two spaces in our output at line 2. Try entering something like \"testok\". Even if you don't enter command arguments, the command will still be called with an empty string in self.args . Perhaps a slight modification to our code would be appropriate to see what's happening. We will force Python to display the command arguments as a debug string using a little shortcut. class CmdTest(Command): \"\"\" Test command. Syntax: test [argument] Enter any argument after test. \"\"\" key = \"test\" def func(self): self.msg(f\"You have entered: {self.args!r}.\") The only line we have changed is the last one, and we have added !r between our braces to tell Python to print the debug version of the argument (the repr-ed version). Let's see the result: > test Whatever You have entered: ' Whatever'. > test You have entered: ''. > test And something with '? You have entered: \" And something with '?\". This displays the string in a way you could see in the Python interpreter. It might be easier to read... to debug, anyway. I insist so much on that point because it's crucial: the command argument is just a string (of type str ) and we will use this to parse it. What you will see is mostly not Evennia-specific, it's Python-specific and could be used in any other project where you have the same need. Stripping \u00b6 As you've seen, our command arguments are stored with the space. And the space between the command and the arguments is often of no importance. Why is it ever there? Evennia will try its best to find a matching command. If the user enters your command key with arguments (but omits the space), Evennia will still be able to find and call the command. You might have seen what happened if the user entered testok . In this case, testok could very well be a command (Evennia checks for that) but seeing none, and because there's a test command, Evennia calls it with the arguments \"ok\" . But most of the time, we don't really care about this left space, so you will often see code to remove it. There are different ways to do it in Python, but a command use case is the strip method on str and its cousins, lstrip and rstrip . strip : removes one or more characters (either spaces or other characters) from both ends of the string. lstrip : same thing but only removes from the left end (left strip) of the string. rstrip : same thing but only removes from the right end (right strip) of the string. Some Python examples might help: >>> ' this is '.strip() # remove spaces by default 'this is' >>> \" What if I'm right? \".lstrip() # strip spaces from the left \"What if I'm right? \" >>> 'Looks good to me...'.strip('.') # removes '.' 'Looks good to me' >>> '\"Now, what is it?\"'.strip('\"?') # removes '\"' and '?' from both ends 'Now, what is it' Usually, since we don't need the space separator, but still want our command to work if there's no separator, we call lstrip on the command arguments: class CmdTest(Command): \"\"\" Test command. Syntax: test [argument] Enter any argument after test. \"\"\" key = \"test\" def parse(self): \"\"\"Parse arguments, just strip them.\"\"\" self.args = self.args.lstrip() def func(self): self.msg(f\"You have entered: {self.args!r}.\") We are now beginning to override the command's parse method, which is typically useful just for argument parsing. This method is executed before func and so self.args in func() will contain our self.args.lstrip() . Let's try it: > test Whatever You have entered: 'Whatever'. > test You have entered: ''. > test And something with '? You have entered: \"And something with '?\". > test And something with lots of spaces You have entered: 'And something with lots of spaces'. Spaces at the end of the string are kept, but all spaces at the beginning are removed: strip , lstrip and rstrip without arguments will strip spaces, line breaks and other common separators. You can specify one or more characters as a parameter. If you specify more than one character, all of them will be stripped from your original string. Convert arguments to numbers \u00b6 As pointed out, self.args is a string (of type str ). What if we want the user to enter a number? Let's take a very simple example: creating a command, roll , that allows to roll a six-sided die. The player has to guess the number, specifying the number as argument. To win, the player has to match the number with the die. Let's see an example: > roll 3 You roll a die. It lands on the number 4. You played 3, you have lost. > dice 1 You roll a die. It lands on the number 2. You played 1, you have lost. > dice 1 You roll a die. It lands on the number 1. You played 1, you have won! If that's your first command, it's a good opportunity to try to write it. A command with a simple and finite role always is a good starting choice. Here's how we could (first) write it... but it won't work as is, I warn you: from random import randint from evennia import Command class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Usage: roll <number> Enter a valid number as argument. A random die will be rolled and you will win if you have specified the correct number. Example: roll 3 \"\"\" key = \"roll\" def parse(self): \"\"\"Convert the argument to a number.\"\"\" self.args = self.args.lstrip() def func(self): # Roll a random die figure = randint(1, 6) # return a pseudo-random number between 1 and 6, including both self.msg(f\"You roll a die. It lands on the number {figure}.\") if self.args == figure: # THAT WILL BREAK! self.msg(f\"You played {self.args}, you have won!\") else: self.msg(f\"You played {self.args}, you have lost.\") If you try this code, Python will complain that you try to compare a number with a string: figure is a number and self.args is a string and can't be compared as-is in Python. Python doesn't do \"implicit converting\" as some languages do. By the way, this might be annoying sometimes, and other times you will be glad it tries to encourage you to be explicit rather than implicit about what to do. This is an ongoing debate between programmers. Let's move on! So we need to convert the command argument from a str into an int . There are a few ways to do it. But the proper way is to try to convert and deal with the ValueError Python exception. Converting a str into an int in Python is extremely simple: just use the int function, give it the string and it returns an integer, if it could. If it can't, it will raise ValueError . So we'll need to catch that. However, we also have to indicate to Evennia that, should the number be invalid, no further parsing should be done. Here's a new attempt at our command with this converting: from random import randint from evennia import Command, InterruptCommand class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Usage: roll <number> Enter a valid number as argument. A random die will be rolled and you will win if you have specified the correct number. Example: roll 3 \"\"\" key = \"roll\" def parse(self): \"\"\"Convert the argument to number if possible.\"\"\" args = self.args.lstrip() # Convert to int if possible # If not, raise InterruptCommand. Evennia will catch this # exception and not call the 'func' method. try: self.entered = int(args) except ValueError: self.msg(f\"{args} is not a valid number.\") raise InterruptCommand def func(self): # Roll a random die figure = randint(1, 6) # return a pseudo-random number between 1 and 6, including both self.msg(f\"You roll a die. It lands on the number {figure}.\") if self.entered == figure: self.msg(f\"You played {self.entered}, you have won!\") else: self.msg(f\"You played {self.entered}, you have lost.\") Before enjoying the result, let's examine the parse method a little more: what it does is try to convert the entered argument from a str to an int . This might fail (if a user enters roll something ). In such a case, Python raises a ValueError exception. We catch it in our try/except block, send a message to the user and raise the InterruptCommand exception in response to tell Evennia to not run func() , since we have no valid number to give it. In the func method, instead of using self.args , we use self.entered which we have defined in our parse method. You can expect that, if func() is run, then self.entered contains a valid number. If you try this command, it will work as expected this time: the number is converted as it should and compared to the die roll. You might spend some minutes playing this game. Time out! Something else we could want to address: in our small example, we only want the user to enter a positive number between 1 and 6. And the user can enter roll 0 or roll -8 or roll 208 for that matter, the game still works. It might be worth addressing. Again, you could write a condition to do that, but since we're catching an exception, we might end up with something cleaner by grouping: from random import randint from evennia import Command, InterruptCommand class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Usage: roll <number> Enter a valid number as argument. A random die will be rolled and you will win if you have specified the correct number. Example: roll 3 \"\"\" key = \"roll\" def parse(self): \"\"\"Convert the argument to number if possible.\"\"\" args = self.args.lstrip() # Convert to int if possible try: self.entered = int(args) if not 1 <= self.entered <= 6: # self.entered is not between 1 and 6 (including both) raise ValueError except ValueError: self.msg(f\"{args} is not a valid number.\") raise InterruptCommand def func(self): # Roll a random die figure = randint(1, 6) # return a pseudo-random number between 1 and 6, including both self.msg(f\"You roll a die. It lands on the number {figure}.\") if self.entered == figure: self.msg(f\"You played {self.entered}, you have won!\") else: self.msg(f\"You played {self.entered}, you have lost.\") Using grouped exceptions like that makes our code easier to read, but if you feel more comfortable checking, afterward, that the number the user entered is in the right range, you can do so in a latter condition. Notice that we have updated our parse method only in this last attempt, not our func() method which remains the same. This is one goal of separating argument parsing from command processing, these two actions are best kept isolated. Working with several arguments \u00b6 Often a command expects several arguments. So far, in our example with the \"roll\" command, we only expect one argument: a number and just a number. What if we want the user to specify several numbers? First the number of dice to roll, then the guess? You won't win often if you roll 5 dice but that's for the example. So we would like to interpret a command like this: > roll 3 12 (To be understood: roll 3 dice, my guess is the total number will be 12.) What we need is to cut our command argument, which is a str , break it at the space (we use the space as a delimiter). Python provides the str.split method which we'll use. Again, here are some examples from the Python interpreter: >>> args = \"3 12\" >>> args.split(\" \") ['3', '12'] >>> args = \"a command with several arguments\" >>> args.split(\" \") ['a', 'command', 'with', 'several', 'arguments'] >>> As you can see, str.split will \"convert\" our strings into a list of strings. The specified argument ( \" \" in our case) is used as delimiter. So Python browses our original string. When it sees a delimiter, it takes whatever is before this delimiter and append it to a list. The point here is that str.split will be used to split our argument. But, as you can see from the above output, we can never be sure of the length of the list at this point: >>> args = \"something\" >>> args.split(\" \") ['something'] >>> args = \"\" >>> args.split(\" \") [''] >>> Again we could use a condition to check the number of split arguments, but Python offers a better approach, making use of its exception mechanism. We'll give a second argument to str.split , the maximum number of splits to do. Let's see an example, this feature might be confusing at first glance: >>> args = \"that is something great\" >>> args.split(\" \", 1) # one split, that is a list with two elements (before, after) ['that', 'is something great'] Read this example as many times as needed to understand it. The second argument we give to str.split is not the length of the list that should be returned, but the number of times we have to split. Therefore, we specify 1 here, but we get a list of two elements (before the separator, after the separator). What will happen if Python can't split the number of times we ask? It won't: >>> args = \"whatever\" >>> args.split(\" \", 1) # there isn't even a space here... ['whatever'] >>> This is one moment I would have hoped for an exception and didn't get one. But there's another way which will raise an exception if there is an error: variable unpacking. We won't talk about this feature in details here. It would be complicated. But the code is really straightforward to use. Let's take our example of the roll command but let's add a first argument: the number of dice to roll. from random import randint from evennia import Command, InterruptCommand class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Specify two numbers separated by a space. The first number is the number of dice to roll (1, 2, 3) and the second is the expected sum of the roll. Usage: roll <dice> <number> For instance, to roll two 6-figure dice, enter 2 as first argument. If you think the sum of these two dice roll will be 10, you could enter: roll 2 10 \"\"\" key = \"roll\" def parse(self): \"\"\"Split the arguments and convert them.\"\"\" args = self.args.lstrip() # Split: we expect two arguments separated by a space try: number, guess = args.split(\" \", 1) except ValueError: self.msg(\"Invalid usage. Enter two numbers separated by a space.\") raise InterruptCommand # Convert the entered number (first argument) try: self.number = int(number) if self.number <= 0: raise ValueError except ValueError: self.msg(f\"{number} is not a valid number of dice.\") raise InterruptCommand # Convert the entered guess (second argument) try: self.guess = int(guess) if not 1 <= self.guess <= self.number * 6: raise ValueError except ValueError: self.msg(f\"{self.guess} is not a valid guess.\") raise InterruptCommand def func(self): # Roll a random die X times (X being self.number) figure = 0 for _ in range(self.number): figure += randint(1, 6) self.msg(f\"You roll {self.number} dice and obtain the sum {figure}.\") if self.guess == figure: self.msg(f\"You played {self.guess}, you have won!\") else: self.msg(f\"You played {self.guess}, you have lost.\") The beginning of the parse() method is what interests us most: try: number, guess = args.split(\" \", 1) except ValueError: self.msg(\"Invalid usage. Enter two numbers separated by a space.\") raise InterruptCommand We split the argument using str.split but we capture the result in two variables. Python is smart enough to know that we want what's left of the space in the first variable, what's right of the space in the second variable. If there is not even a space in the string, Python will raise a ValueError exception. This code is much easier to read than browsing through the returned strings of str.split . We can convert both variables the way we did previously. Actually there are not so many changes in this version and the previous one, most of it is due to name changes for clarity. Splitting a string with a maximum of splits is a common occurrence while parsing command arguments. You can also see the str.rspli8t method that does the same thing but from the right of the string. Therefore, it will attempt to find delimiters at the end of the string and work toward the beginning of it. We have used a space as a delimiter. This is absolutely not necessary. You might remember that most default Evennia commands can take an = sign as a delimiter. Now you know how to parse them as well: >>> cmd_key = \"tel\" >>> cmd_args = \"book = chest\" >>> left, right = cmd_args.split(\"=\") # mighht raise ValueError! >>> left 'book ' >>> right ' chest' >>> Optional arguments \u00b6 Sometimes, you'll come across commands that have optional arguments. These arguments are not necessary but they can be set if more information is needed. I will not provide the entire command code here but just enough code to show the mechanism in Python: Again, we'll use str.split , knowing that we might not have any delimiter at all. For instance, the player could enter the \"tel\" command like this: > tel book > tell book = chest The equal sign is optional along with whatever is specified after it. A possible solution in our parse method would be: def parse(self): args = self.args.lstrip() # = is optional try: obj, destination = args.split(\"=\", 1) except ValueError: obj = args destination = None This code would place everything the user entered in obj if she didn't specify any equal sign. Otherwise, what's before the equal sign will go in obj , what's after the equal sign will go in destination . This makes for quick testing after that, more robust code with less conditions that might too easily break your code if you're not careful. Again, here we specified a maximum numbers of splits. If the users enters: > tel book = chest = chair Then destination will contain: \" chest = chair\" . This is often desired, but it's up to you to set parsing however you like. Evennia searches \u00b6 After this quick tour of some str methods, we'll take a look at some Evennia-specific features that you won't find in standard Python. One very common task is to convert a str into an Evennia object. Take the previous example: having \"book\" in a variable is great, but we would prefer to know what the user is talking about... what is this \"book\" ? To get an object from a string, we perform an Evennia search. Evennia provides a search method on all typeclassed objects (you will most likely use the one on characters or accounts). This method supports a very wide array of arguments and has its own tutorial . Some examples of useful cases follow: Local searches \u00b6 When an account or a character enters a command, the account or character is found in the caller attribute. Therefore, self.caller will contain an account or a character (or a session if that's a session command, though that's not as frequent). The search method will be available on this caller. Let's take the same example of our little \"tel\" command. The user can specify an object as argument: def parse(self): name = self.args.lstrip() We then need to \"convert\" this string into an Evennia object. The Evennia object will be searched in the caller's location and its contents by default (that is to say, if the command has been entered by a character, it will search the object in the character's room and the character's inventory). def parse(self): name = self.args.lstrip() self.obj = self.caller.search(name) We specify only one argument to the search method here: the string to search. If Evennia finds a match, it will return it and we keep it in the obj attribute. If it can't find anything, it will return None so we need to check for that: def parse(self): name = self.args.lstrip() self.obj = self.caller.search(name) if self.obj is None: # A proper error message has already been sent to the caller raise InterruptCommand That's it. After this condition, you know that whatever is in self.obj is a valid Evennia object (another character, an object, an exit...). Quiet searches \u00b6 By default, Evennia will handle the case when more than one match is found in the search. The user will be asked to narrow down and re-enter the command. You can, however, ask to be returned the list of matches and handle this list yourself: def parse(self): name = self.args.lstrip() objs = self.caller.search(name, quiet=True) if not objs: # This is an empty list, so no match self.msg(f\"No {name!r} was found.\") raise InterruptCommand self.obj = objs[0] # Take the first match even if there are several All we have changed to obtain a list is a keyword argument in the search method: quiet . If set to True , then errors are ignored and a list is always returned, so we need to handle it as such. Notice in this example, self.obj will contain a valid object too, but if several matches are found, self.obj will contain the first one, even if more matches are available. Global searches \u00b6 By default, Evennia will perform a local search, that is, a search limited by the location in which the caller is. If you want to perform a global search (search in the entire database), just set the global_search keyword argument to True : def parse(self): name = self.args.lstrip() self.obj = self.caller.search(name, global_search=True) Conclusion \u00b6 Parsing command arguments is vital for most game designers. If you design \"intelligent\" commands, users should be able to guess how to use them without reading the help, or with a very quick peek at said help. Good commands are intuitive to users. Better commands do what they're told to do. For game designers working on MUDs, commands are the main entry point for users into your game. This is no trivial. If commands execute correctly (if their argument is parsed, if they don't behave in unexpected ways and report back the right errors), you will have happier players that might stay longer on your game. I hope this tutorial gave you some pointers on ways to improve your command parsing. There are, of course, other ways you will discover, or ways you are already using in your code.","title":"Parsing command arguments, theory and best practices"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#what-are-command-arguments","text":"I'm going to talk about command arguments and parsing a lot in this tutorial. So let's be sure we talk about the same thing before going any further: A command is an Evennia object that handles specific user input. For instance, the default look is a command. After having created your Evennia game, and connected to it, you should be able to type look to see what's around. In this context, look is a command. Command arguments are additional text passed after the command. Following the same example, you can type look self to look at yourself. In this context, self is the text specified after look . \" self\" is the argument to the look command. Part of our task as a game developer is to connect user inputs (mostly commands) with actions in the game. And most of the time, entering commands is not enough, we have to rely on arguments for specifying actions with more accuracy. Take the say command. If you couldn't specify what to say as a command argument ( say hello! ), you would have trouble communicating with others in the game. One would need to create a different command for every kind of word or sentence, which is, of course, not practical. Last thing: what is parsing? In our case, parsing is the process by which we convert command arguments into something we can work with. We don't usually use the command argument as is (which is just text, of type str in Python). We need to extract useful information. We might want to ask the user for a number, or the name of another character present in the same room. We're going to see how to do all that now.","title":"What are command arguments?"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#working-with-strings","text":"In object terms, when you write a command in Evennia (when you write the Python class), the arguments are stored in the args attribute. Which is to say, inside your func method, you can access the command arguments in self.args .","title":"Working with strings"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#selfargs","text":"To begin with, look at this example: class CmdTest(Command): \"\"\" Test command. Syntax: test [argument] Enter any argument after test. \"\"\" key = \"test\" def func(self): self.msg(f\"You have entered: {self.args}.\") If you add this command and test it, you will receive exactly what you have entered without any parsing: > test Whatever You have entered: Whatever. > test You have entered: . The lines starting with > indicate what you enter into your client. The other lines are what you receive from the game server. Notice two things here: The left space between our command key (\"test\", here) and our command argument is not removed. That's why there are two spaces in our output at line 2. Try entering something like \"testok\". Even if you don't enter command arguments, the command will still be called with an empty string in self.args . Perhaps a slight modification to our code would be appropriate to see what's happening. We will force Python to display the command arguments as a debug string using a little shortcut. class CmdTest(Command): \"\"\" Test command. Syntax: test [argument] Enter any argument after test. \"\"\" key = \"test\" def func(self): self.msg(f\"You have entered: {self.args!r}.\") The only line we have changed is the last one, and we have added !r between our braces to tell Python to print the debug version of the argument (the repr-ed version). Let's see the result: > test Whatever You have entered: ' Whatever'. > test You have entered: ''. > test And something with '? You have entered: \" And something with '?\". This displays the string in a way you could see in the Python interpreter. It might be easier to read... to debug, anyway. I insist so much on that point because it's crucial: the command argument is just a string (of type str ) and we will use this to parse it. What you will see is mostly not Evennia-specific, it's Python-specific and could be used in any other project where you have the same need.","title":"self.args"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#stripping","text":"As you've seen, our command arguments are stored with the space. And the space between the command and the arguments is often of no importance. Why is it ever there? Evennia will try its best to find a matching command. If the user enters your command key with arguments (but omits the space), Evennia will still be able to find and call the command. You might have seen what happened if the user entered testok . In this case, testok could very well be a command (Evennia checks for that) but seeing none, and because there's a test command, Evennia calls it with the arguments \"ok\" . But most of the time, we don't really care about this left space, so you will often see code to remove it. There are different ways to do it in Python, but a command use case is the strip method on str and its cousins, lstrip and rstrip . strip : removes one or more characters (either spaces or other characters) from both ends of the string. lstrip : same thing but only removes from the left end (left strip) of the string. rstrip : same thing but only removes from the right end (right strip) of the string. Some Python examples might help: >>> ' this is '.strip() # remove spaces by default 'this is' >>> \" What if I'm right? \".lstrip() # strip spaces from the left \"What if I'm right? \" >>> 'Looks good to me...'.strip('.') # removes '.' 'Looks good to me' >>> '\"Now, what is it?\"'.strip('\"?') # removes '\"' and '?' from both ends 'Now, what is it' Usually, since we don't need the space separator, but still want our command to work if there's no separator, we call lstrip on the command arguments: class CmdTest(Command): \"\"\" Test command. Syntax: test [argument] Enter any argument after test. \"\"\" key = \"test\" def parse(self): \"\"\"Parse arguments, just strip them.\"\"\" self.args = self.args.lstrip() def func(self): self.msg(f\"You have entered: {self.args!r}.\") We are now beginning to override the command's parse method, which is typically useful just for argument parsing. This method is executed before func and so self.args in func() will contain our self.args.lstrip() . Let's try it: > test Whatever You have entered: 'Whatever'. > test You have entered: ''. > test And something with '? You have entered: \"And something with '?\". > test And something with lots of spaces You have entered: 'And something with lots of spaces'. Spaces at the end of the string are kept, but all spaces at the beginning are removed: strip , lstrip and rstrip without arguments will strip spaces, line breaks and other common separators. You can specify one or more characters as a parameter. If you specify more than one character, all of them will be stripped from your original string.","title":"Stripping"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#convert-arguments-to-numbers","text":"As pointed out, self.args is a string (of type str ). What if we want the user to enter a number? Let's take a very simple example: creating a command, roll , that allows to roll a six-sided die. The player has to guess the number, specifying the number as argument. To win, the player has to match the number with the die. Let's see an example: > roll 3 You roll a die. It lands on the number 4. You played 3, you have lost. > dice 1 You roll a die. It lands on the number 2. You played 1, you have lost. > dice 1 You roll a die. It lands on the number 1. You played 1, you have won! If that's your first command, it's a good opportunity to try to write it. A command with a simple and finite role always is a good starting choice. Here's how we could (first) write it... but it won't work as is, I warn you: from random import randint from evennia import Command class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Usage: roll <number> Enter a valid number as argument. A random die will be rolled and you will win if you have specified the correct number. Example: roll 3 \"\"\" key = \"roll\" def parse(self): \"\"\"Convert the argument to a number.\"\"\" self.args = self.args.lstrip() def func(self): # Roll a random die figure = randint(1, 6) # return a pseudo-random number between 1 and 6, including both self.msg(f\"You roll a die. It lands on the number {figure}.\") if self.args == figure: # THAT WILL BREAK! self.msg(f\"You played {self.args}, you have won!\") else: self.msg(f\"You played {self.args}, you have lost.\") If you try this code, Python will complain that you try to compare a number with a string: figure is a number and self.args is a string and can't be compared as-is in Python. Python doesn't do \"implicit converting\" as some languages do. By the way, this might be annoying sometimes, and other times you will be glad it tries to encourage you to be explicit rather than implicit about what to do. This is an ongoing debate between programmers. Let's move on! So we need to convert the command argument from a str into an int . There are a few ways to do it. But the proper way is to try to convert and deal with the ValueError Python exception. Converting a str into an int in Python is extremely simple: just use the int function, give it the string and it returns an integer, if it could. If it can't, it will raise ValueError . So we'll need to catch that. However, we also have to indicate to Evennia that, should the number be invalid, no further parsing should be done. Here's a new attempt at our command with this converting: from random import randint from evennia import Command, InterruptCommand class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Usage: roll <number> Enter a valid number as argument. A random die will be rolled and you will win if you have specified the correct number. Example: roll 3 \"\"\" key = \"roll\" def parse(self): \"\"\"Convert the argument to number if possible.\"\"\" args = self.args.lstrip() # Convert to int if possible # If not, raise InterruptCommand. Evennia will catch this # exception and not call the 'func' method. try: self.entered = int(args) except ValueError: self.msg(f\"{args} is not a valid number.\") raise InterruptCommand def func(self): # Roll a random die figure = randint(1, 6) # return a pseudo-random number between 1 and 6, including both self.msg(f\"You roll a die. It lands on the number {figure}.\") if self.entered == figure: self.msg(f\"You played {self.entered}, you have won!\") else: self.msg(f\"You played {self.entered}, you have lost.\") Before enjoying the result, let's examine the parse method a little more: what it does is try to convert the entered argument from a str to an int . This might fail (if a user enters roll something ). In such a case, Python raises a ValueError exception. We catch it in our try/except block, send a message to the user and raise the InterruptCommand exception in response to tell Evennia to not run func() , since we have no valid number to give it. In the func method, instead of using self.args , we use self.entered which we have defined in our parse method. You can expect that, if func() is run, then self.entered contains a valid number. If you try this command, it will work as expected this time: the number is converted as it should and compared to the die roll. You might spend some minutes playing this game. Time out! Something else we could want to address: in our small example, we only want the user to enter a positive number between 1 and 6. And the user can enter roll 0 or roll -8 or roll 208 for that matter, the game still works. It might be worth addressing. Again, you could write a condition to do that, but since we're catching an exception, we might end up with something cleaner by grouping: from random import randint from evennia import Command, InterruptCommand class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Usage: roll <number> Enter a valid number as argument. A random die will be rolled and you will win if you have specified the correct number. Example: roll 3 \"\"\" key = \"roll\" def parse(self): \"\"\"Convert the argument to number if possible.\"\"\" args = self.args.lstrip() # Convert to int if possible try: self.entered = int(args) if not 1 <= self.entered <= 6: # self.entered is not between 1 and 6 (including both) raise ValueError except ValueError: self.msg(f\"{args} is not a valid number.\") raise InterruptCommand def func(self): # Roll a random die figure = randint(1, 6) # return a pseudo-random number between 1 and 6, including both self.msg(f\"You roll a die. It lands on the number {figure}.\") if self.entered == figure: self.msg(f\"You played {self.entered}, you have won!\") else: self.msg(f\"You played {self.entered}, you have lost.\") Using grouped exceptions like that makes our code easier to read, but if you feel more comfortable checking, afterward, that the number the user entered is in the right range, you can do so in a latter condition. Notice that we have updated our parse method only in this last attempt, not our func() method which remains the same. This is one goal of separating argument parsing from command processing, these two actions are best kept isolated.","title":"Convert arguments to numbers"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#working-with-several-arguments","text":"Often a command expects several arguments. So far, in our example with the \"roll\" command, we only expect one argument: a number and just a number. What if we want the user to specify several numbers? First the number of dice to roll, then the guess? You won't win often if you roll 5 dice but that's for the example. So we would like to interpret a command like this: > roll 3 12 (To be understood: roll 3 dice, my guess is the total number will be 12.) What we need is to cut our command argument, which is a str , break it at the space (we use the space as a delimiter). Python provides the str.split method which we'll use. Again, here are some examples from the Python interpreter: >>> args = \"3 12\" >>> args.split(\" \") ['3', '12'] >>> args = \"a command with several arguments\" >>> args.split(\" \") ['a', 'command', 'with', 'several', 'arguments'] >>> As you can see, str.split will \"convert\" our strings into a list of strings. The specified argument ( \" \" in our case) is used as delimiter. So Python browses our original string. When it sees a delimiter, it takes whatever is before this delimiter and append it to a list. The point here is that str.split will be used to split our argument. But, as you can see from the above output, we can never be sure of the length of the list at this point: >>> args = \"something\" >>> args.split(\" \") ['something'] >>> args = \"\" >>> args.split(\" \") [''] >>> Again we could use a condition to check the number of split arguments, but Python offers a better approach, making use of its exception mechanism. We'll give a second argument to str.split , the maximum number of splits to do. Let's see an example, this feature might be confusing at first glance: >>> args = \"that is something great\" >>> args.split(\" \", 1) # one split, that is a list with two elements (before, after) ['that', 'is something great'] Read this example as many times as needed to understand it. The second argument we give to str.split is not the length of the list that should be returned, but the number of times we have to split. Therefore, we specify 1 here, but we get a list of two elements (before the separator, after the separator). What will happen if Python can't split the number of times we ask? It won't: >>> args = \"whatever\" >>> args.split(\" \", 1) # there isn't even a space here... ['whatever'] >>> This is one moment I would have hoped for an exception and didn't get one. But there's another way which will raise an exception if there is an error: variable unpacking. We won't talk about this feature in details here. It would be complicated. But the code is really straightforward to use. Let's take our example of the roll command but let's add a first argument: the number of dice to roll. from random import randint from evennia import Command, InterruptCommand class CmdRoll(Command): \"\"\" Play random, enter a number and try your luck. Specify two numbers separated by a space. The first number is the number of dice to roll (1, 2, 3) and the second is the expected sum of the roll. Usage: roll <dice> <number> For instance, to roll two 6-figure dice, enter 2 as first argument. If you think the sum of these two dice roll will be 10, you could enter: roll 2 10 \"\"\" key = \"roll\" def parse(self): \"\"\"Split the arguments and convert them.\"\"\" args = self.args.lstrip() # Split: we expect two arguments separated by a space try: number, guess = args.split(\" \", 1) except ValueError: self.msg(\"Invalid usage. Enter two numbers separated by a space.\") raise InterruptCommand # Convert the entered number (first argument) try: self.number = int(number) if self.number <= 0: raise ValueError except ValueError: self.msg(f\"{number} is not a valid number of dice.\") raise InterruptCommand # Convert the entered guess (second argument) try: self.guess = int(guess) if not 1 <= self.guess <= self.number * 6: raise ValueError except ValueError: self.msg(f\"{self.guess} is not a valid guess.\") raise InterruptCommand def func(self): # Roll a random die X times (X being self.number) figure = 0 for _ in range(self.number): figure += randint(1, 6) self.msg(f\"You roll {self.number} dice and obtain the sum {figure}.\") if self.guess == figure: self.msg(f\"You played {self.guess}, you have won!\") else: self.msg(f\"You played {self.guess}, you have lost.\") The beginning of the parse() method is what interests us most: try: number, guess = args.split(\" \", 1) except ValueError: self.msg(\"Invalid usage. Enter two numbers separated by a space.\") raise InterruptCommand We split the argument using str.split but we capture the result in two variables. Python is smart enough to know that we want what's left of the space in the first variable, what's right of the space in the second variable. If there is not even a space in the string, Python will raise a ValueError exception. This code is much easier to read than browsing through the returned strings of str.split . We can convert both variables the way we did previously. Actually there are not so many changes in this version and the previous one, most of it is due to name changes for clarity. Splitting a string with a maximum of splits is a common occurrence while parsing command arguments. You can also see the str.rspli8t method that does the same thing but from the right of the string. Therefore, it will attempt to find delimiters at the end of the string and work toward the beginning of it. We have used a space as a delimiter. This is absolutely not necessary. You might remember that most default Evennia commands can take an = sign as a delimiter. Now you know how to parse them as well: >>> cmd_key = \"tel\" >>> cmd_args = \"book = chest\" >>> left, right = cmd_args.split(\"=\") # mighht raise ValueError! >>> left 'book ' >>> right ' chest' >>>","title":"Working with several arguments"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#optional-arguments","text":"Sometimes, you'll come across commands that have optional arguments. These arguments are not necessary but they can be set if more information is needed. I will not provide the entire command code here but just enough code to show the mechanism in Python: Again, we'll use str.split , knowing that we might not have any delimiter at all. For instance, the player could enter the \"tel\" command like this: > tel book > tell book = chest The equal sign is optional along with whatever is specified after it. A possible solution in our parse method would be: def parse(self): args = self.args.lstrip() # = is optional try: obj, destination = args.split(\"=\", 1) except ValueError: obj = args destination = None This code would place everything the user entered in obj if she didn't specify any equal sign. Otherwise, what's before the equal sign will go in obj , what's after the equal sign will go in destination . This makes for quick testing after that, more robust code with less conditions that might too easily break your code if you're not careful. Again, here we specified a maximum numbers of splits. If the users enters: > tel book = chest = chair Then destination will contain: \" chest = chair\" . This is often desired, but it's up to you to set parsing however you like.","title":"Optional arguments"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#evennia-searches","text":"After this quick tour of some str methods, we'll take a look at some Evennia-specific features that you won't find in standard Python. One very common task is to convert a str into an Evennia object. Take the previous example: having \"book\" in a variable is great, but we would prefer to know what the user is talking about... what is this \"book\" ? To get an object from a string, we perform an Evennia search. Evennia provides a search method on all typeclassed objects (you will most likely use the one on characters or accounts). This method supports a very wide array of arguments and has its own tutorial . Some examples of useful cases follow:","title":"Evennia searches"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#local-searches","text":"When an account or a character enters a command, the account or character is found in the caller attribute. Therefore, self.caller will contain an account or a character (or a session if that's a session command, though that's not as frequent). The search method will be available on this caller. Let's take the same example of our little \"tel\" command. The user can specify an object as argument: def parse(self): name = self.args.lstrip() We then need to \"convert\" this string into an Evennia object. The Evennia object will be searched in the caller's location and its contents by default (that is to say, if the command has been entered by a character, it will search the object in the character's room and the character's inventory). def parse(self): name = self.args.lstrip() self.obj = self.caller.search(name) We specify only one argument to the search method here: the string to search. If Evennia finds a match, it will return it and we keep it in the obj attribute. If it can't find anything, it will return None so we need to check for that: def parse(self): name = self.args.lstrip() self.obj = self.caller.search(name) if self.obj is None: # A proper error message has already been sent to the caller raise InterruptCommand That's it. After this condition, you know that whatever is in self.obj is a valid Evennia object (another character, an object, an exit...).","title":"Local searches"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#quiet-searches","text":"By default, Evennia will handle the case when more than one match is found in the search. The user will be asked to narrow down and re-enter the command. You can, however, ask to be returned the list of matches and handle this list yourself: def parse(self): name = self.args.lstrip() objs = self.caller.search(name, quiet=True) if not objs: # This is an empty list, so no match self.msg(f\"No {name!r} was found.\") raise InterruptCommand self.obj = objs[0] # Take the first match even if there are several All we have changed to obtain a list is a keyword argument in the search method: quiet . If set to True , then errors are ignored and a list is always returned, so we need to handle it as such. Notice in this example, self.obj will contain a valid object too, but if several matches are found, self.obj will contain the first one, even if more matches are available.","title":"Quiet searches"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#global-searches","text":"By default, Evennia will perform a local search, that is, a search limited by the location in which the caller is. If you want to perform a global search (search in the entire database), just set the global_search keyword argument to True : def parse(self): name = self.args.lstrip() self.obj = self.caller.search(name, global_search=True)","title":"Global searches"},{"location":"Parsing-command-arguments,-theory-and-best-practices.html#conclusion","text":"Parsing command arguments is vital for most game designers. If you design \"intelligent\" commands, users should be able to guess how to use them without reading the help, or with a very quick peek at said help. Good commands are intuitive to users. Better commands do what they're told to do. For game designers working on MUDs, commands are the main entry point for users into your game. This is no trivial. If commands execute correctly (if their argument is parsed, if they don't behave in unexpected ways and report back the right errors), you will have happier players that might stay longer on your game. I hope this tutorial gave you some pointers on ways to improve your command parsing. There are, of course, other ways you will discover, or ways you are already using in your code.","title":"Conclusion"},{"location":"Portal-And-Server.html","text":"Evennia consists of two processes, known as Portal and Server . They can be controlled from inside the game or from the command line as described here . If you are new to the concept, the main purpose of separating the two is to have accounts connect to the Portal but keep the MUD running on the Server. This way one can restart/reload the game (the Server part) without Accounts getting disconnected. The Server and Portal are glued together via an AMP (Asynchronous Messaging Protocol) connection. This allows the two programs to communicate seamlessly.","title":"Portal And Server"},{"location":"Profiling.html","text":"This is considered an advanced topic mainly of interest to server developers. Introduction \u00b6 Sometimes it can be useful to try to determine just how efficient a particular piece of code is, or to figure out if one could speed up things more than they are. There are many ways to test the performance of Python and the running server. Before digging into this section, remember Donald Knuth's words of wisdom : [...]about 97% of the time: Premature optimization is the root of all evil . That is, don't start to try to optimize your code until you have actually identified a need to do so. This means your code must actually be working before you start to consider optimization. Optimization will also often make your code more complex and harder to read. Consider readability and maintainability and you may find that a small gain in speed is just not worth it. Simple timer tests \u00b6 Python's timeit module is very good for testing small things. For example, in order to test if it is faster to use a for loop or a list comprehension you could use the following code: import timeit # Time to do 1000000 for loops timeit.timeit(\"for i in range(100):\\n a.append(i)\", setup=\"a = []\") <<< 10.70982813835144 # Time to do 1000000 list comprehensions timeit.timeit(\"a = [i for i in range(100)]\") <<< 5.358283996582031 The setup keyword is used to set up things that should not be included in the time measurement, like a = [] in the first call. By default the timeit function will re-run the given test 1000000 times and returns the total time to do so (so not the average per test). A hint is to not use this default for testing something that includes database writes - for that you may want to use a lower number of repeats (say 100 or 1000) using the number=100 keyword. Using cProfile \u00b6 Python comes with its own profiler, named cProfile (this is for cPython, no tests have been done with pypy at this point). Due to the way Evennia's processes are handled, there is no point in using the normal way to start the profiler ( python -m cProfile evennia.py ). Instead you start the profiler through the launcher: evennia --profiler start This will start Evennia with the Server component running (in daemon mode) under cProfile. You could instead try --profile with the portal argument to profile the Portal (you would then need to start the Server separately ). Please note that while the profiler is running, your process will use a lot more memory than usual. Memory usage is even likely to climb over time. So don't leave it running perpetually but monitor it carefully (for example using the top command on Linux or the Task Manager's memory display on Windows). Once you have run the server for a while, you need to stop it so the profiler can give its report. Do not kill the program from your task manager or by sending it a kill signal - this will most likely also mess with the profiler. Instead either use evennia.py stop or (which may be even better), use @shutdown from inside the game. Once the server has fully shut down (this may be a lot slower than usual) you will find that profiler has created a new file mygame/server/logs/server.prof . Analyzing the profile \u00b6 The server.prof file is a binary file. There are many ways to analyze and display its contents, all of which has only been tested in Linux (If you are a Windows/Mac user, let us know what works). We recommend the Runsnake visualizer to see the processor usage of different processes in a graphical form. For more detailed listing of usage time, you can use KCachegrind . To make KCachegrind work with Python profiles you also need the wrapper script pyprof2calltree . You can get pyprof2calltree via pip whereas KCacheGrind is something you need to get via your package manager or their homepage. How to analyze and interpret profiling data is not a trivial issue and depends on what you are profiling for. Evennia being an asynchronous server can also confuse profiling. Ask on the mailing list if you need help and be ready to be able to supply your server.prof file for comparison, along with the exact conditions under which it was obtained. The Dummyrunner \u00b6 It is difficult to test \"actual\" game performance without having players in your game. For this reason Evennia comes with the Dummyrunner system. The Dummyrunner is a stress-testing system: a separate program that logs into your game with simulated players (aka \"bots\" or \"dummies\"). Once connected these dummies will semi-randomly perform various tasks from a list of possible actions. Use Ctrl-C to stop the Dummyrunner. Warning: You should not run the Dummyrunner on a production database. It will spawn many objects and also needs to run with general permissions. To launch the Dummyrunner, first start your server normally (with or without profiling, as above). Then start a new terminal/console window and active your virtualenv there too. In the new terminal, try to connect 10 dummy players: evennia --dummyrunner 10 The first time you do this you will most likely get a warning from Dummyrunner. It will tell you to copy an import string to the end of your settings file. Quit the Dummyrunner ( Ctrl-C ) and follow the instructions. Restart Evennia and try evennia --dummyrunner 10 again. Make sure to remove that extra settings line when running a public server. The actions perform by the dummies is controlled by a settings file. The default Dummyrunner settings file is evennia/server/server/profiling/dummyrunner_settings.py but you shouldn't modify this directly. Rather create/copy the default file to mygame/server/conf/ and modify it there. To make sure to use your file over the default, add the following line to your settings file: DUMMYRUNNER_SETTINGS_MODULE = \"server/conf/dummyrunner_settings.py\" Hint: Don't start with too many dummies. The Dummyrunner defaults to taxing the server much more intensely than an equal number of human players. A good dummy number to start with is 10-100. Once you have the dummyrunner running, stop it with Ctrl-C . Generally, the dummyrunner system makes for a decent test of general performance; but it is of course hard to actually mimic human user behavior. For this, actual real-game testing is required.","title":"Profiling"},{"location":"Profiling.html#introduction","text":"Sometimes it can be useful to try to determine just how efficient a particular piece of code is, or to figure out if one could speed up things more than they are. There are many ways to test the performance of Python and the running server. Before digging into this section, remember Donald Knuth's words of wisdom : [...]about 97% of the time: Premature optimization is the root of all evil . That is, don't start to try to optimize your code until you have actually identified a need to do so. This means your code must actually be working before you start to consider optimization. Optimization will also often make your code more complex and harder to read. Consider readability and maintainability and you may find that a small gain in speed is just not worth it.","title":"Introduction"},{"location":"Profiling.html#simple-timer-tests","text":"Python's timeit module is very good for testing small things. For example, in order to test if it is faster to use a for loop or a list comprehension you could use the following code: import timeit # Time to do 1000000 for loops timeit.timeit(\"for i in range(100):\\n a.append(i)\", setup=\"a = []\") <<< 10.70982813835144 # Time to do 1000000 list comprehensions timeit.timeit(\"a = [i for i in range(100)]\") <<< 5.358283996582031 The setup keyword is used to set up things that should not be included in the time measurement, like a = [] in the first call. By default the timeit function will re-run the given test 1000000 times and returns the total time to do so (so not the average per test). A hint is to not use this default for testing something that includes database writes - for that you may want to use a lower number of repeats (say 100 or 1000) using the number=100 keyword.","title":"Simple timer tests"},{"location":"Profiling.html#using-cprofile","text":"Python comes with its own profiler, named cProfile (this is for cPython, no tests have been done with pypy at this point). Due to the way Evennia's processes are handled, there is no point in using the normal way to start the profiler ( python -m cProfile evennia.py ). Instead you start the profiler through the launcher: evennia --profiler start This will start Evennia with the Server component running (in daemon mode) under cProfile. You could instead try --profile with the portal argument to profile the Portal (you would then need to start the Server separately ). Please note that while the profiler is running, your process will use a lot more memory than usual. Memory usage is even likely to climb over time. So don't leave it running perpetually but monitor it carefully (for example using the top command on Linux or the Task Manager's memory display on Windows). Once you have run the server for a while, you need to stop it so the profiler can give its report. Do not kill the program from your task manager or by sending it a kill signal - this will most likely also mess with the profiler. Instead either use evennia.py stop or (which may be even better), use @shutdown from inside the game. Once the server has fully shut down (this may be a lot slower than usual) you will find that profiler has created a new file mygame/server/logs/server.prof .","title":"Using cProfile"},{"location":"Profiling.html#analyzing-the-profile","text":"The server.prof file is a binary file. There are many ways to analyze and display its contents, all of which has only been tested in Linux (If you are a Windows/Mac user, let us know what works). We recommend the Runsnake visualizer to see the processor usage of different processes in a graphical form. For more detailed listing of usage time, you can use KCachegrind . To make KCachegrind work with Python profiles you also need the wrapper script pyprof2calltree . You can get pyprof2calltree via pip whereas KCacheGrind is something you need to get via your package manager or their homepage. How to analyze and interpret profiling data is not a trivial issue and depends on what you are profiling for. Evennia being an asynchronous server can also confuse profiling. Ask on the mailing list if you need help and be ready to be able to supply your server.prof file for comparison, along with the exact conditions under which it was obtained.","title":"Analyzing the profile"},{"location":"Profiling.html#the-dummyrunner","text":"It is difficult to test \"actual\" game performance without having players in your game. For this reason Evennia comes with the Dummyrunner system. The Dummyrunner is a stress-testing system: a separate program that logs into your game with simulated players (aka \"bots\" or \"dummies\"). Once connected these dummies will semi-randomly perform various tasks from a list of possible actions. Use Ctrl-C to stop the Dummyrunner. Warning: You should not run the Dummyrunner on a production database. It will spawn many objects and also needs to run with general permissions. To launch the Dummyrunner, first start your server normally (with or without profiling, as above). Then start a new terminal/console window and active your virtualenv there too. In the new terminal, try to connect 10 dummy players: evennia --dummyrunner 10 The first time you do this you will most likely get a warning from Dummyrunner. It will tell you to copy an import string to the end of your settings file. Quit the Dummyrunner ( Ctrl-C ) and follow the instructions. Restart Evennia and try evennia --dummyrunner 10 again. Make sure to remove that extra settings line when running a public server. The actions perform by the dummies is controlled by a settings file. The default Dummyrunner settings file is evennia/server/server/profiling/dummyrunner_settings.py but you shouldn't modify this directly. Rather create/copy the default file to mygame/server/conf/ and modify it there. To make sure to use your file over the default, add the following line to your settings file: DUMMYRUNNER_SETTINGS_MODULE = \"server/conf/dummyrunner_settings.py\" Hint: Don't start with too many dummies. The Dummyrunner defaults to taxing the server much more intensely than an equal number of human players. A good dummy number to start with is 10-100. Once you have the dummyrunner running, stop it with Ctrl-C . Generally, the dummyrunner system makes for a decent test of general performance; but it is of course hard to actually mimic human user behavior. For this, actual real-game testing is required.","title":"The Dummyrunner"},{"location":"Python-3.html","text":"Note: Evennia only supports Python 2.7+ at this time. This page gathers various development information relevant to server developers. Django can work with Python 2 and 3 already, though changes may be required to how the Evennia code uses it. Twisted has much Python 3 compatibility, but not all modules within it have been ported yet. The twisted.python.dist3 module gives some information about what's ported, and I'm compiling a list of missing modules with related bug reports which can be found below. The list is based on a search for import statements in the Evennia source code, please add anything that's missing. Part of this process is expected to be writing more tests for Evennia. One encouraging recent port to Python 3 in Twisted is its Trial test framework, which may need to be used by Evennia to ensure it still works correctly with Twisted on Python 3. \"Strings\" \u00b6 Broadly (and perhaps over-simplified): Twisted expects bytes Django expects \"\" to be unicode I think we should use (roughly speaking) \"\" for unicode and b\"\" for bytes everywhere, but I need to look at the impacts of this more closely. Links \u00b6 http://twistedmatrix.com/documents/current/core/howto/python3.html https://twistedmatrix.com/trac/wiki/Plan/Python3 Twisted Python3 bugs Twisted module status \u00b6 x = not ported to Python 3 / = ported to Python 3 twisted.application.internet / twisted.application.service / twisted.conch x (not used directly) ~https://twistedmatrix.com/trac/ticket/5102~ / ~https://twistedmatrix.com/trac/ticket/4993~ / twisted.conch.insults.insults x twisted.conch.interfaces x twisted.conch.manhole x twisted.conch.manhole_ssh x twisted.conch.ssh.common x twisted.conch.ssh.keys x ~https://twistedmatrix.com/trac/ticket/7998~ / \"twisted.conch.ssh.keys should be ported to Python 3\" twisted.conch.ssh.userauth x twisted.conch.telnet x twisted.cred.checkers / twisted.cred.portal / twisted.internet.defer / twisted.internet.interfaces / twisted.internet.protocol / twisted.internet.reactor / twisted.internet.ssl / twisted.internet.task / twisted.internet.threads / twisted.protocols.amp x ~https://twistedmatrix.com/trac/ticket/6833~ / \"Port twisted.protocols.amp to Python 3\" twisted.protocols.policies / twisted.python.components / twisted.python.log / twisted.python.threadpool / twisted.web.http (x) Partial support. Sufficient? twisted.web.resource / twisted.web.server (x) Partial support. Sufficient? twisted.web.static / twisted.web.proxy / twisted.web.wsgi x ~https://twistedmatrix.com/trac/ticket/7993~ / \"'twisted.web.wsgi' should be ported to Python 3\" Seems to be making good progress twisted.words.protocols.irc x https://twistedmatrix.com/trac/ticket/6320 \"Python 3 support for twisted.words.protocols.irc\" ~https://twistedmatrix.com/trac/ticket/6564~ \"Replace usage of builtin reduce in twisted.words\"","title":"Python 3"},{"location":"Python-3.html#strings","text":"Broadly (and perhaps over-simplified): Twisted expects bytes Django expects \"\" to be unicode I think we should use (roughly speaking) \"\" for unicode and b\"\" for bytes everywhere, but I need to look at the impacts of this more closely.","title":"\"Strings\""},{"location":"Python-3.html#links","text":"http://twistedmatrix.com/documents/current/core/howto/python3.html https://twistedmatrix.com/trac/wiki/Plan/Python3 Twisted Python3 bugs","title":"Links"},{"location":"Python-3.html#twisted-module-status","text":"x = not ported to Python 3 / = ported to Python 3 twisted.application.internet / twisted.application.service / twisted.conch x (not used directly) ~https://twistedmatrix.com/trac/ticket/5102~ / ~https://twistedmatrix.com/trac/ticket/4993~ / twisted.conch.insults.insults x twisted.conch.interfaces x twisted.conch.manhole x twisted.conch.manhole_ssh x twisted.conch.ssh.common x twisted.conch.ssh.keys x ~https://twistedmatrix.com/trac/ticket/7998~ / \"twisted.conch.ssh.keys should be ported to Python 3\" twisted.conch.ssh.userauth x twisted.conch.telnet x twisted.cred.checkers / twisted.cred.portal / twisted.internet.defer / twisted.internet.interfaces / twisted.internet.protocol / twisted.internet.reactor / twisted.internet.ssl / twisted.internet.task / twisted.internet.threads / twisted.protocols.amp x ~https://twistedmatrix.com/trac/ticket/6833~ / \"Port twisted.protocols.amp to Python 3\" twisted.protocols.policies / twisted.python.components / twisted.python.log / twisted.python.threadpool / twisted.web.http (x) Partial support. Sufficient? twisted.web.resource / twisted.web.server (x) Partial support. Sufficient? twisted.web.static / twisted.web.proxy / twisted.web.wsgi x ~https://twistedmatrix.com/trac/ticket/7993~ / \"'twisted.web.wsgi' should be ported to Python 3\" Seems to be making good progress twisted.words.protocols.irc x https://twistedmatrix.com/trac/ticket/6320 \"Python 3 support for twisted.words.protocols.irc\" ~https://twistedmatrix.com/trac/ticket/6564~ \"Replace usage of builtin reduce in twisted.words\"","title":"Twisted module status"},{"location":"Python-basic-introduction.html","text":"This is the first part of our beginner's guide to the basics of using Python with Evennia. It's aimed at you with limited or no programming/Python experience. But also if you are an experienced programmer new to Evennia or Python you might still pick up a thing or two. It is by necessity brief and low on detail. There are countless Python guides and tutorials, books and videos out there for learning more in-depth - use them! Contents: - Evennia Hello world - Importing modules - Parsing Python errors - Our first function - (continued in part 2 ) This quickstart assumes you have gotten Evennia started . You should make sure that you are able to see the output from the server in the console from which you started it. Log into the game either with a mud client on localhost:4000 or by pointing a web browser to localhost:4001/webclient . Log in as your superuser (the user you created during install). Below, lines starting with a single > means command input. Evennia Hello world \u00b6 The @py (or ! which is an alias) command allows you as a superuser to run raw Python from in-game. From the game's input line, enter the following: > @py print(\"Hello World!\") You won't see any return in Evennia though, instead you will just see: >>> print(\"Hello world!\") None To understand what is going on: some extra info: The print(...) function is the basic, in-built way to output text in Python. The quotes \"...\" means you are inputing a string (i.e. text). You could also have used single-quotes '...' , Python accepts both. The first return line (with >>> ) is just @py echoing what you input (we won't include that in the examples henceforth) and the last line just says the @py command finished. Where is our hello world? In Evennia, print does not print in-game. Instead it prints to the log. Open a terminal (or go back to the terminal you started Evennia in), make sure your virtualenv is active and that you are standing in your game directory (the one created with evennia --init during installation). Enter evennia -l to start tailing the log in the terminal (use Ctrl-C if you need to exit later). If you look towards the end you will find the print output next to the log time stamp: 2017-05-07T20:20:16+0000 [stdout#info] Hello world! As a game dev it is important to look at the console output when working in Evennia - many errors will only appear with full details here. You may sometimes have to scroll up in the history if you miss it. To show the greeting in-game, try the following instead: > @py me.msg(\"Hello world!\") Hello world! None Ignore the last None , that's just a return from the @py command itself we don't need to care about for now. The me is something uniquely available in the @py command (we could also use self , it's an alias). It represents \"us\", the ones calling the @py command. The me is an example of an Object instance . Objects are fundamental in Python and Evennia. The me object not only represents the character we play in the game, it also contains a lot of useful resources for doing things with that Object. One such resource is msg . msg works like print except it sends the text to the object it is attached to instead of to the console log. You access an Object's resources by using the full-stop character . . So self.msg accesses the msg resource and then we call it like we did print, with our \"Hello World!\" greeting in parentheses. Important: something like print(...) we refer to as a function , while msg(...) which sits on an object is called a method . You can try printing other things. Also try to include |r at the start of your string to make the output red in-game. Use @color to learn more color tags. Importing modules \u00b6 Keep your game running, then open a text editor of your choice. If your game folder is called mygame , create a new text file test.py in the subfolder mygame/world . This is how the file structure should look: mygame/ world/ test.py For now, only add one line to test.py : print(\"Hello World!\") Don't forget to save the file. A file with the ending .py is referred to as a Python module . To use this in-game we have to import it. Try this: > @py import world.test If you make some error (we'll cover how to handle errors below) you may need to run the @reload command for your changes to take effect. Think of the period . as replacing / (or \\ for Windows) in your path. The .py ending of test.py is never included in this \"Python-path\", but only files with that ending can be imported this way. Where is mygame in that Python-path? The answer is that Evennia has already told Python that your mygame folder is a good place to look for imports. So we don't include mygame in the path - Evennia handles this for us. When you import the module, the top \"level\" of it will execute. In this case, it will immediately print \"Hello World\" to the console window. If you look in the folder you'll also often find new files ending with .pyc . These are compiled Python binaries that Python auto-creates when running code. Just ignore them, you should never edit those anyway. Now try to run this a second time: > @py import world.test You will not see any output in the log this second time or any subsequent times! This is not a bug. Rather it is because Python is being clever - it stores all imported modules and to be efficient it will avoid importing them more than once. So your print will only run the first time. To see it again you need to @reload first, so Python forgets about the module and has to import it again. We'll get back to importing code in the second part of this tutorial. For now, let's press on. Parsing Python errors \u00b6 Next, erase the single print statement you had in test.py and replace it with this instead: me.msg(\"Hello World!\") As you recall we used this from @py earlier - it echoed \"Hello World!\" in-game. Save your file and @reload your server in-game - this makes sure Evennia sees the new version of your code. Try to import it from @py in the same way as earlier: > @py import world.test No go - this time you get an error! File \"./world/test.py\", line 1, in <module> me.msg(\"Hello world!\") NameError: name 'me' is not defined This is called a traceback . Python's errors are very friendly and will most of the time tell you exactly what and where things are wrong. It's important that you learn to parse tracebacks so you can fix your code. Let's look at this one. A traceback is to be read from the bottom up. The last line is the error Python balked at, while the two lines above it details exactly where that error was encountered. An error of type NameError is the problem ... ... more specifically it is due to the variable me not being defined. This happened on the line me.msg(\"Hello world!\") ... ... which is on line 1 of the file ./world/test.py . In our case the traceback is short. There may be many more lines above it, tracking just how different modules called each other until it got to the faulty line. That can sometimes be useful information, but reading from the bottom is always a good start. The NameError we see here is due to a module being its own isolated thing. It knows nothing about the environment into which it is imported. It knew what print is because that is a special reserved Python keyword . But me is not such a reserved word. As far as the module is concerned me is just there out of nowhere. Hence the NameError . Our first function \u00b6 Let's see if we can resolve that NameError from the previous section. We know that me is defined at the time we use the @py command because if we do @py me.msg(\"Hello World!\") directly in-game it works fine. What if we could send that me to the test.py module so it knows what it is? One way to do this is with a function . Change your mygame/world/test.py file to look like this: def hello_world(who): who.msg(\"Hello World!\") Now that we are moving onto multi-line Python code, there are some important things to remember: Capitalization matters in Python. It must be def and not DEF , who is not the same as Who etc. Indentation matters in Python. The second line must be indented or it's not valid code. You should also use a consistent indentation length. We strongly recommend that you set up your editor to always indent 4 spaces ( not a single tab-character) when you press the TAB key - it will make your life a lot easier. def is short for \"define\" and defines a function (or a method , if sitting on an object). This is a reserved Python keyword ; try not to use these words anywhere else. A function name can not have spaces but otherwise we could have called it almost anything. We call it hello_world . Evennia follows Python's standard naming style with lowercase letters and underscores. Use this style for now. who is what we call the argument to our function. Arguments are variables we pass to the function. We could have named it anything and we could also have multiple arguments separated by commas. What who is depends on what we pass to this function when we call it later (hint: we'll pass me to it). The colon ( : ) at the end of the first line indicates that the header of the function is complete. The indentation marks the beginning of the actual operating code of the function (the function's body ). If we wanted more lines to belong to this function those lines would all have to have to start at this indentation level. In the function body we take the who argument and treat it as we would have treated me earlier - we expect it to have a .msg method we can use to send \"Hello World\" to. First, @reload your game to make it aware of the updated Python module. Now we have defined our first function, let's use it. > @reload > @py import world.test Done (use self.msg() if you want to catch output) Nothing happened except the normal output from @py . That is because the function in our module won't do anything just by importing it. It will only act when we call it. We will need to enter the module we just imported and do so. > @py import world.test ; world.test.hello_world(me) Hello world! Done (use self.msg() if you want to catch output) There is our \"Hello World\"! The ; is the way to put multiple Python-statements on one line. Some MUD clients use ; for their own purposes to separate client-inputs. If so you'll get a NameError stating that world is not defined. Check so you understand why this is! Change the use of ; in your client or use the Evennia web client if this is a problem. In the second statement we access the module path we imported ( world.test ) and reach for the hello_world function within. We call the function with me , which becomes the who variable we use inside the hello_function . As an exercise, try to pass something else into hello_world . Try for example to pass who as the number 5 or the simple string \"foo\" . You'll get errors that they don't have the attribute msg . As we've seen, me does make msg available which is why it works (you'll learn more about Objects like me in the next part of this tutorial). If you are familiar with other programming languages you may be tempted to start validating who to make sure it works as expected. This is usually not recommended in Python which suggests it's better to handle the error if it happens rather than to make a lot of code to prevent it from happening. See also duck typing . This tutorial is continued in Part 2 , where we'll start learning about objects and to explore the Evennia library.","title":"Python basic introduction"},{"location":"Python-basic-introduction.html#evennia-hello-world","text":"The @py (or ! which is an alias) command allows you as a superuser to run raw Python from in-game. From the game's input line, enter the following: > @py print(\"Hello World!\") You won't see any return in Evennia though, instead you will just see: >>> print(\"Hello world!\") None To understand what is going on: some extra info: The print(...) function is the basic, in-built way to output text in Python. The quotes \"...\" means you are inputing a string (i.e. text). You could also have used single-quotes '...' , Python accepts both. The first return line (with >>> ) is just @py echoing what you input (we won't include that in the examples henceforth) and the last line just says the @py command finished. Where is our hello world? In Evennia, print does not print in-game. Instead it prints to the log. Open a terminal (or go back to the terminal you started Evennia in), make sure your virtualenv is active and that you are standing in your game directory (the one created with evennia --init during installation). Enter evennia -l to start tailing the log in the terminal (use Ctrl-C if you need to exit later). If you look towards the end you will find the print output next to the log time stamp: 2017-05-07T20:20:16+0000 [stdout#info] Hello world! As a game dev it is important to look at the console output when working in Evennia - many errors will only appear with full details here. You may sometimes have to scroll up in the history if you miss it. To show the greeting in-game, try the following instead: > @py me.msg(\"Hello world!\") Hello world! None Ignore the last None , that's just a return from the @py command itself we don't need to care about for now. The me is something uniquely available in the @py command (we could also use self , it's an alias). It represents \"us\", the ones calling the @py command. The me is an example of an Object instance . Objects are fundamental in Python and Evennia. The me object not only represents the character we play in the game, it also contains a lot of useful resources for doing things with that Object. One such resource is msg . msg works like print except it sends the text to the object it is attached to instead of to the console log. You access an Object's resources by using the full-stop character . . So self.msg accesses the msg resource and then we call it like we did print, with our \"Hello World!\" greeting in parentheses. Important: something like print(...) we refer to as a function , while msg(...) which sits on an object is called a method . You can try printing other things. Also try to include |r at the start of your string to make the output red in-game. Use @color to learn more color tags.","title":"Evennia Hello world"},{"location":"Python-basic-introduction.html#importing-modules","text":"Keep your game running, then open a text editor of your choice. If your game folder is called mygame , create a new text file test.py in the subfolder mygame/world . This is how the file structure should look: mygame/ world/ test.py For now, only add one line to test.py : print(\"Hello World!\") Don't forget to save the file. A file with the ending .py is referred to as a Python module . To use this in-game we have to import it. Try this: > @py import world.test If you make some error (we'll cover how to handle errors below) you may need to run the @reload command for your changes to take effect. Think of the period . as replacing / (or \\ for Windows) in your path. The .py ending of test.py is never included in this \"Python-path\", but only files with that ending can be imported this way. Where is mygame in that Python-path? The answer is that Evennia has already told Python that your mygame folder is a good place to look for imports. So we don't include mygame in the path - Evennia handles this for us. When you import the module, the top \"level\" of it will execute. In this case, it will immediately print \"Hello World\" to the console window. If you look in the folder you'll also often find new files ending with .pyc . These are compiled Python binaries that Python auto-creates when running code. Just ignore them, you should never edit those anyway. Now try to run this a second time: > @py import world.test You will not see any output in the log this second time or any subsequent times! This is not a bug. Rather it is because Python is being clever - it stores all imported modules and to be efficient it will avoid importing them more than once. So your print will only run the first time. To see it again you need to @reload first, so Python forgets about the module and has to import it again. We'll get back to importing code in the second part of this tutorial. For now, let's press on.","title":"Importing modules"},{"location":"Python-basic-introduction.html#parsing-python-errors","text":"Next, erase the single print statement you had in test.py and replace it with this instead: me.msg(\"Hello World!\") As you recall we used this from @py earlier - it echoed \"Hello World!\" in-game. Save your file and @reload your server in-game - this makes sure Evennia sees the new version of your code. Try to import it from @py in the same way as earlier: > @py import world.test No go - this time you get an error! File \"./world/test.py\", line 1, in <module> me.msg(\"Hello world!\") NameError: name 'me' is not defined This is called a traceback . Python's errors are very friendly and will most of the time tell you exactly what and where things are wrong. It's important that you learn to parse tracebacks so you can fix your code. Let's look at this one. A traceback is to be read from the bottom up. The last line is the error Python balked at, while the two lines above it details exactly where that error was encountered. An error of type NameError is the problem ... ... more specifically it is due to the variable me not being defined. This happened on the line me.msg(\"Hello world!\") ... ... which is on line 1 of the file ./world/test.py . In our case the traceback is short. There may be many more lines above it, tracking just how different modules called each other until it got to the faulty line. That can sometimes be useful information, but reading from the bottom is always a good start. The NameError we see here is due to a module being its own isolated thing. It knows nothing about the environment into which it is imported. It knew what print is because that is a special reserved Python keyword . But me is not such a reserved word. As far as the module is concerned me is just there out of nowhere. Hence the NameError .","title":"Parsing Python errors"},{"location":"Python-basic-introduction.html#our-first-function","text":"Let's see if we can resolve that NameError from the previous section. We know that me is defined at the time we use the @py command because if we do @py me.msg(\"Hello World!\") directly in-game it works fine. What if we could send that me to the test.py module so it knows what it is? One way to do this is with a function . Change your mygame/world/test.py file to look like this: def hello_world(who): who.msg(\"Hello World!\") Now that we are moving onto multi-line Python code, there are some important things to remember: Capitalization matters in Python. It must be def and not DEF , who is not the same as Who etc. Indentation matters in Python. The second line must be indented or it's not valid code. You should also use a consistent indentation length. We strongly recommend that you set up your editor to always indent 4 spaces ( not a single tab-character) when you press the TAB key - it will make your life a lot easier. def is short for \"define\" and defines a function (or a method , if sitting on an object). This is a reserved Python keyword ; try not to use these words anywhere else. A function name can not have spaces but otherwise we could have called it almost anything. We call it hello_world . Evennia follows Python's standard naming style with lowercase letters and underscores. Use this style for now. who is what we call the argument to our function. Arguments are variables we pass to the function. We could have named it anything and we could also have multiple arguments separated by commas. What who is depends on what we pass to this function when we call it later (hint: we'll pass me to it). The colon ( : ) at the end of the first line indicates that the header of the function is complete. The indentation marks the beginning of the actual operating code of the function (the function's body ). If we wanted more lines to belong to this function those lines would all have to have to start at this indentation level. In the function body we take the who argument and treat it as we would have treated me earlier - we expect it to have a .msg method we can use to send \"Hello World\" to. First, @reload your game to make it aware of the updated Python module. Now we have defined our first function, let's use it. > @reload > @py import world.test Done (use self.msg() if you want to catch output) Nothing happened except the normal output from @py . That is because the function in our module won't do anything just by importing it. It will only act when we call it. We will need to enter the module we just imported and do so. > @py import world.test ; world.test.hello_world(me) Hello world! Done (use self.msg() if you want to catch output) There is our \"Hello World\"! The ; is the way to put multiple Python-statements on one line. Some MUD clients use ; for their own purposes to separate client-inputs. If so you'll get a NameError stating that world is not defined. Check so you understand why this is! Change the use of ; in your client or use the Evennia web client if this is a problem. In the second statement we access the module path we imported ( world.test ) and reach for the hello_world function within. We call the function with me , which becomes the who variable we use inside the hello_function . As an exercise, try to pass something else into hello_world . Try for example to pass who as the number 5 or the simple string \"foo\" . You'll get errors that they don't have the attribute msg . As we've seen, me does make msg available which is why it works (you'll learn more about Objects like me in the next part of this tutorial). If you are familiar with other programming languages you may be tempted to start validating who to make sure it works as expected. This is usually not recommended in Python which suggests it's better to handle the error if it happens rather than to make a lot of code to prevent it from happening. See also duck typing . This tutorial is continued in Part 2 , where we'll start learning about objects and to explore the Evennia library.","title":"Our first function"},{"location":"Python-basic-tutorial-part-two.html","text":"In the first part of this Python-for-Evennia basic tutorial we learned how to run some simple Python code from inside the game. We also made our first new module containing a function that we called. Now we're going to start exploring the very important subject of objects . Contents: - On the subject of objects - Exploring the Evennia library - Tweaking our Character class - The Evennia shell - Where to go from here On the subject of objects \u00b6 In the first part of the tutorial we did things like > @py me.msg(\"Hello World!\") To learn about functions and imports we also passed that me on to a function hello_world in another module. Let's learn some more about this me thing we are passing around all over the place. In the following we assume that we named our superuser Character \"Christine\". > @py me Christine > @py me.key Christine These returns look the same at first glance, but not if we examine them more closely: > @py type(me) <class 'typeclasses.characters.Character'> > @py type(me.key) <type str> Note: In some MU* clients, such as Mudlet and MUSHclient simply returning type(me) , you may not see the proper return from the above commands. This is likely due to the HTML-like tags, such as <...> , through @py . The type function is, like print , another in-built function in Python. It tells us that we ( me ) are of the class typeclasses.characters.Character . Meanwhile me.key is a property on us, a string. It holds the name of this object. When you do @py me , the me is defined in such a way that it will use its .key property to represent itself. That is why the result is the same as when doing @py me.key . Also, remember that as noted in the first part of the tutorial, the me is not a reserved Python word; it was just defined by the Evennia developers as a convenient short-hand when creating the @py command. So don't expect me to be available elsewhere. A class is like a \"factory\" or blueprint. From a class you then create individual instances . So if class is Dog , an instance of Dog might be fido . Our in-game persona is of a class Character . The superuser christine is an instance of the Character class (an instance is also often referred to as an object ). This is an important concept in object oriented programming . You are wise to familiarize yourself with it a little. In other terms: * class: A description of a thing, all the methods (code) and data (information) * object: A thing, defined as an instance of a class. So in \"Fido is a dog\", \"Fido\" is an object--a unique thing--and \"dog\" is a class. Coders would also say, \"Fido is an instance of Dog\". There can be other dogs too, such as Butch and Fifi. They, too, would be instances of Dog. As another example: \"Christine is a Character\", or \"Christine is an instance of typeclasses.characters.Character\". To start, all characters will be instances of typeclass.characters.Character. You'll be writing your own class soon! The important thing to know here is how classes and objects relate. The string 'typeclasses.characters.Character' we got from the type() function is not arbitrary. It exactly describes where to find the python code describing this class. Python treats source code files on your hard drive (known as modules ) as well as folders (known as packages ) as objects that you access with the . operator. It starts looking at a place that Evennia has set up for you - namely the root of your own game directory. Open and look at your game folder (named mygame if you exactly followed the Getting Started instructions) in a file editor or in a new terminal/console. Locate the file mygame/typeclasses/characters.py mygame/ typeclasses characters.py This represents the first part of the python path - typeclasses.characters (the .py file ending is never included in the python path). The last bit, .Character is the actual class name inside the characters.py module. Open that file in a text editor and you will see something like this: \"\"\" (Doc string for module) \"\"\" from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" (Doc string for class) \"\"\" pass There is Character , the last part of the path. Note how empty this file is. At first glance one would think a Character had no functionality at all. But from what we have used already we know it has at least the key property and the method msg ! Where is the code? The answer is that this 'emptiness' is an illusion caused by something called inheritance . Read on. Firstly, in the same way as the little hello.py we did in the first part of the tutorial, this is an example of full, multi-line Python code. Those triple-quoted strings are used for strings that have line breaks in them. When they appear on their own like this, at the top of a python module, class or similar they are called doc strings . Doc strings are read by Python and is used for producing online help about the function/method/class/module. By contrast, a line starting with # is a comment . It is ignored completely by Python and is only useful to help guide a human to understand the code. The line class Character(DefaultCharacter): means that the class Character is a child of the class DefaultCharacter . This is called inheritance and is another fundamental concept. The answer to the question \"where is the code?\" is that the code is inherited from its parent, DefaultCharacter . And that in turn may inherit code from its parent(s) and so on. Since our child, Character is empty, its functionality is exactly identical to that of its parent. The moment we add new things to Character, these will take precedence. And if we add something that already existed in the parent, our child-version will override the version in the parent. This is very practical: It means that we can let the parent do the heavy lifting and only tweak the things we want to change. It also means that we could easily have many different Character classes, all inheriting from DefaultCharacter but changing different things. And those can in turn also have children ... Let's go on an expedition up the inheritance tree. Exploring the Evennia library \u00b6 Let's figure out how to tweak Character . Right now we don't know much about DefaultCharacter though. Without knowing that we won't know what to override. At the top of the file you find from evennia import DefaultCharacter This is an import statement again, but on a different form to what we've seen before. from ... import ... is very commonly used and allows you to precisely dip into a module to extract just the component you need to use. In this case we head into the evennia package to get DefaultCharacter . Where is evennia ? To find it you need to go to the evennia folder (repository) you originally cloned from us. If you open it, this is how it looks: evennia/ __init__.py bin/ CHANGELOG.txt etc. ... evennia/ ... There are lots of things in there. There are some docs but most of those have to do with the distribution of Evennia and does not concern us right now. The evennia subfolder is what we are looking for. This is what you are accessing when you do from evennia import ... . It's set up by Evennia as a good place to find modules when the server starts. The exact layout of the Evennia library is covered by our directory overview . You can also explore it online on github . The structure of the library directly reflects how you import from it. To, for example, import the text justify function from evennia/utils/utils.py you would do from evennia.utils.utils import justify . In your code you could then just call justify(...) to access its functionality. You could also do from evennia.utils import utils . In code you would then have to write utils.justify(...) . This is practical if want a lot of stuff from that utils.py module and don't want to import each component separately. You could also do import evennia . You would then have to enter the full evennia.utils.utils.justify(...) every time you use it. Using from to only import the things you need is usually easier and more readable. See this overview about the different ways to import in Python. Now, remember that our characters.py module did from evennia import DefaultCharacter . But if we look at the contents of the evennia folder, there is no DefaultCharacter anywhere! This is because Evennia gives a large number of optional \"shortcuts\", known as the \"flat\" API . The intention is to make it easier to remember where to find stuff. The flat API is defined in that weirdly named __init__.py file. This file just basically imports useful things from all over Evennia so you can more easily find them in one place. We could just look at the documenation to find out where we can look at our DefaultCharacter parent. But for practice, let's figure it out. Here is where DefaultCharacter is imported from inside __init__.py : from .objects.objects import DefaultCharacter The period at the start means that it imports beginning from the same location this module sits(i.e. the evennia folder). The full python-path accessible from the outside is thus evennia.objects.objects.DefaultCharacter . So to import this into our game it'd be perfectly valid to do from evennia.objects.objects import DefaultCharacter Using from evennia import DefaultCharacter is the same thing, just a little easier to remember. To access the shortcuts of the flat API you must use from evennia import ... . Using something like import evennia.DefaultCharacter will not work. See more about the Flat API here . Tweaking our Character class \u00b6 In the previous section we traced the parent of our Character class to be DefaultCharacter in evennia/objects/objects.py . Open that file and locate the DefaultCharacter class. It's quite a bit down in this module so you might want to search using your editor's (or browser's) search function. Once you find it, you'll find that the class starts like this: class DefaultCharacter(DefaultObject): \"\"\" This implements an Object puppeted by a Session - that is, a character avatar controlled by an account. \"\"\" def basetype_setup(self): \"\"\" Setup character-specific security. You should normally not need to overload this, but if you do, make sure to reproduce at least the two last commands in this method (unless you want to fundamentally change how a Character object works). \"\"\" super().basetype_setup() self.locks.add(\";\".join([\"get:false()\", # noone can pick up the character \"call:false()\"])) # no commands can be called on character from outside # add the default cmdset self.cmdset.add_default(settings.CMDSET_CHARACTER, permanent=True) def at_after_move(self, source_location, **kwargs): \"\"\" We make sure to look around after a move. \"\"\" if self.location.access(self, \"view\"): self.msg(self.at_look(self.location)) def at_pre_puppet(self, account, session=None, **kwargs): \"\"\" Return the character from storage in None location in `at_post_unpuppet`. Args: ... ... And so on (you can see the full class online here ). Here we have functional code! These methods may not be directly visible in Character back in our game dir, but they are still available since Character is a child of DefaultCharacter above. Here is a brief summary of the methods we find in DefaultCharacter (follow in the code to see if you can see roughly where things happen):: basetype_setup is called by Evennia only once, when a Character is first created. In the DefaultCharacter class it sets some particular Locks so that people can't pick up and puppet Characters just like that. It also adds the Character Cmdset so that Characters always can accept command-input (this should usually not be modified - the normal hook to override is at_object_creation , which is called after basetype_setup (it's in the parent)). at_after_move makes it so that every time the Character moves, the look command is automatically fired (this would not make sense for just any regular Object). at_pre_puppet is called when an Account begins to puppet this Character. When not puppeted, the Character is hidden away to a None location. This brings it back to the location it was in before. Without this, \"headless\" Characters would remain in the game world just standing around. at_post_puppet is called when puppeting is complete. It echoes a message to the room that his Character has now connected. at_post_unpuppet is called once stopping puppeting of the Character. This hides away the Character to a None location again. There are also some utility properties which makes it easier to get some time stamps from the Character. Reading the class we notice another thing: class DefaultCharacter(DefaultObject): ... This means that DefaultCharacter is in itself a child of something called DefaultObject ! Let's see what this parent class provides. It's in the same module as DefaultCharacter , you just need to scroll up near the top : class DefaultObject(with_metaclass(TypeclassBase, ObjectDB)): ... This is a really big class where the bulk of code defining an in-game object resides. It consists of a large number of methods, all of which thus also becomes available on the DefaultCharacter class below and by extension in your Character class over in your game dir. In this class you can for example find the msg method we have been using before. You should probably not expect to understand all details yet, but as an exercise, find and read the doc string of msg . As seen, DefaultObject actually has multiple parents. In one of those the basic key property is defined, but we won't travel further up the inheritance tree in this tutorial. If you are interested to see them, you can find TypeclassBase in evennia/typeclasses/models.py and ObjectDB in evennia/objects/models.py . We will also not go into the details of Multiple Inheritance or Metaclasses here. The general rule is that if you realize that you need these features, you already know enough to use them. Remember the at_pre_puppet method we looked at in DefaultCharacter ? If you look at the at_pre_puppet hook as defined in DefaultObject you'll find it to be completely empty (just a pass ). So if you puppet a regular object it won't be hiding/retrieving the object when you unpuppet it. The DefaultCharacter class overrides its parent's functionality with a version of its own. And since it's DefaultCharacter that our Character class inherits back in our game dir, it's that version of at_pre_puppet we'll get. Anything not explicitly overridden will be passed down as-is. While it's useful to read the code, we should never actually modify anything inside the evennia folder. Only time you would want that is if you are planning to release a bug fix or new feature for Evennia itself. Instead you override the default functionality inside your game dir. So to conclude our little foray into classes, objects and inheritance, locate the simple little at_before_say method in the DefaultObject class: def at_before_say(self, message, **kwargs): \"\"\" (doc string here) \"\"\" return message If you read the doc string you'll find that this can be used to modify the output of say before it goes out. You can think of it like this: Evennia knows the name of this method, and when someone speaks, Evennia will make sure to redirect the outgoing message through this method. It makes it ripe for us to replace with a version of our own. In the Evennia documentation you may sometimes see the term hook used for a method explicitly meant to be overridden like this. As you can see, the first argument to at_before_say is self . In Python, the first argument of a method is always a back-reference to the object instance on which the method is defined . By convention this argument is always called self but it could in principle be named anything. The self is very useful. If you wanted to, say, send a message to the same object from inside at_before_say , you would do self.msg(...) . What can trip up newcomers is that you don't include self when you call the method. Try: > @py me.at_before_say(\"Hello World!\") Hello World! Note that we don't send self but only the message argument. Python will automatically add self for us. In this case, self will become equal to the Character instance me . By default the at_before_say method doesn't do anything. It just takes the message input and return s it just the way it was (the return is another reserved Python word). We won't go into **kwargs here, but it (and its sibling *args ) is also important to understand. To understand the meaning of self , and here for **kwargs . Now, open your game folder and edit mygame/typeclasses/characters.py . Locate your Character class and modify it as such: class Character(DefaultCharacter): \"\"\" (docstring here) \"\"\" def at_before_say(self, message, **kwargs): \"Called before say, allows for tweaking message\" return \"{} ...\".format(message) So we add our own version of at_before_say , duplicating the def line from the parent but putting new code in it. All we do in this tutorial is to add an ellipsis ( ... ) to the message as it passes through the method. The format is a standard method on Python strings. It looks for placeholders {} in the string and replaces that placeholder with its arguments in the same order. In this case we are inserting the original message into the place of the {} and follow it with ... . Python has very powerful string formatting and you are wise to learn those well. You could also copy & paste the relevant method from DefaultObject here to get the full doc string. For more complex methods, or if you only want to change some small part of the default behavior, copy & pasting will eliminate the need to constantly look up the original method and keep you sane. In-game, now try > @reload > say Hello You say, \"Hello ...\" An ellipsis ... is added to what you said! This is a silly example but you have just made your first code change to core functionality - without touching any of Evennia's original code! We just plugged in our own version of the at_before_say method and it replaced the default one. Evennia happily redirected the message through our version and we got a different output. For sane overriding of parent methods you should also be aware of Python's super , which allows you to call the methods defined on a parent in your child class. The Evennia shell \u00b6 Now on to some generally useful tools as you continue learning Python and Evennia. We have so far explored using @py and inserted Python directly in-game. We have also modified Evennia's behavior by overriding default functionality with our own. There is a third way to conveniently explore Evennia and Python - the Evennia shell. First cd to your game folder and make sure any needed virtualenv is running. Next: > pip install ipython # only needed once The IPython program is just a nicer interface to the Python interpreter - you only need to install it once, after which Evennia will use it automatically. > evennia shell You will now be in a Python prompt managed by the IPython program. IPython ... ... In [1]: IPython has some very nice ways to explore what Evennia has to offer. > import evennia > evennia.<TAB> That is, write evennia. and press the Tab key. You will be presented with a list of all available resources in the Evennia Flat API. We looked at the __init__.py file in the evennia folder earlier, so some of what you see should be familiar. From the IPython prompt do: > from evennia import DefaultCharacter > DefaultCharacter.at_before_say? Don't forget that you can use <TAB> to auto-complete code as you write. Appending a single ? to the end will show you the doc-string for at_before_say we looked at earlier. Use ?? to get the whole source code. Let's look at our over-ridden version instead. Since we must start IPython from our game dir we can easily get to our code too: > from typeclasses.characters import Character > Character.at_before_say?? This will show us the changed code we just did. Having a window with IPython running is very convenient for quickly exploring code without having to go digging through the file structure! Where to go from here \u00b6 This should give you a running start using Python with Evennia. If you are completely new to programming or Python you might want to look at a more formal Python tutorial. You can find links and resources on our link page . We have touched upon many of the concepts here but to use Evennia and to be able to follow along in the code, you will need basic understanding of Python modules , variables , conditional statements , loops , functions , lists, dictionaries, list comprehensions and string formatting . You should also have a basic understanding of object-oriented programming and what Python Classes are. Once you have familiarized yourself, or if you prefer to pick Python up as you go, continue to one of the beginning-level Evennia tutorials to gradually build up your understanding. Good luck!","title":"Python basic tutorial part two"},{"location":"Python-basic-tutorial-part-two.html#on-the-subject-of-objects","text":"In the first part of the tutorial we did things like > @py me.msg(\"Hello World!\") To learn about functions and imports we also passed that me on to a function hello_world in another module. Let's learn some more about this me thing we are passing around all over the place. In the following we assume that we named our superuser Character \"Christine\". > @py me Christine > @py me.key Christine These returns look the same at first glance, but not if we examine them more closely: > @py type(me) <class 'typeclasses.characters.Character'> > @py type(me.key) <type str> Note: In some MU* clients, such as Mudlet and MUSHclient simply returning type(me) , you may not see the proper return from the above commands. This is likely due to the HTML-like tags, such as <...> , through @py . The type function is, like print , another in-built function in Python. It tells us that we ( me ) are of the class typeclasses.characters.Character . Meanwhile me.key is a property on us, a string. It holds the name of this object. When you do @py me , the me is defined in such a way that it will use its .key property to represent itself. That is why the result is the same as when doing @py me.key . Also, remember that as noted in the first part of the tutorial, the me is not a reserved Python word; it was just defined by the Evennia developers as a convenient short-hand when creating the @py command. So don't expect me to be available elsewhere. A class is like a \"factory\" or blueprint. From a class you then create individual instances . So if class is Dog , an instance of Dog might be fido . Our in-game persona is of a class Character . The superuser christine is an instance of the Character class (an instance is also often referred to as an object ). This is an important concept in object oriented programming . You are wise to familiarize yourself with it a little. In other terms: * class: A description of a thing, all the methods (code) and data (information) * object: A thing, defined as an instance of a class. So in \"Fido is a dog\", \"Fido\" is an object--a unique thing--and \"dog\" is a class. Coders would also say, \"Fido is an instance of Dog\". There can be other dogs too, such as Butch and Fifi. They, too, would be instances of Dog. As another example: \"Christine is a Character\", or \"Christine is an instance of typeclasses.characters.Character\". To start, all characters will be instances of typeclass.characters.Character. You'll be writing your own class soon! The important thing to know here is how classes and objects relate. The string 'typeclasses.characters.Character' we got from the type() function is not arbitrary. It exactly describes where to find the python code describing this class. Python treats source code files on your hard drive (known as modules ) as well as folders (known as packages ) as objects that you access with the . operator. It starts looking at a place that Evennia has set up for you - namely the root of your own game directory. Open and look at your game folder (named mygame if you exactly followed the Getting Started instructions) in a file editor or in a new terminal/console. Locate the file mygame/typeclasses/characters.py mygame/ typeclasses characters.py This represents the first part of the python path - typeclasses.characters (the .py file ending is never included in the python path). The last bit, .Character is the actual class name inside the characters.py module. Open that file in a text editor and you will see something like this: \"\"\" (Doc string for module) \"\"\" from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" (Doc string for class) \"\"\" pass There is Character , the last part of the path. Note how empty this file is. At first glance one would think a Character had no functionality at all. But from what we have used already we know it has at least the key property and the method msg ! Where is the code? The answer is that this 'emptiness' is an illusion caused by something called inheritance . Read on. Firstly, in the same way as the little hello.py we did in the first part of the tutorial, this is an example of full, multi-line Python code. Those triple-quoted strings are used for strings that have line breaks in them. When they appear on their own like this, at the top of a python module, class or similar they are called doc strings . Doc strings are read by Python and is used for producing online help about the function/method/class/module. By contrast, a line starting with # is a comment . It is ignored completely by Python and is only useful to help guide a human to understand the code. The line class Character(DefaultCharacter): means that the class Character is a child of the class DefaultCharacter . This is called inheritance and is another fundamental concept. The answer to the question \"where is the code?\" is that the code is inherited from its parent, DefaultCharacter . And that in turn may inherit code from its parent(s) and so on. Since our child, Character is empty, its functionality is exactly identical to that of its parent. The moment we add new things to Character, these will take precedence. And if we add something that already existed in the parent, our child-version will override the version in the parent. This is very practical: It means that we can let the parent do the heavy lifting and only tweak the things we want to change. It also means that we could easily have many different Character classes, all inheriting from DefaultCharacter but changing different things. And those can in turn also have children ... Let's go on an expedition up the inheritance tree.","title":"On the subject of objects"},{"location":"Python-basic-tutorial-part-two.html#exploring-the-evennia-library","text":"Let's figure out how to tweak Character . Right now we don't know much about DefaultCharacter though. Without knowing that we won't know what to override. At the top of the file you find from evennia import DefaultCharacter This is an import statement again, but on a different form to what we've seen before. from ... import ... is very commonly used and allows you to precisely dip into a module to extract just the component you need to use. In this case we head into the evennia package to get DefaultCharacter . Where is evennia ? To find it you need to go to the evennia folder (repository) you originally cloned from us. If you open it, this is how it looks: evennia/ __init__.py bin/ CHANGELOG.txt etc. ... evennia/ ... There are lots of things in there. There are some docs but most of those have to do with the distribution of Evennia and does not concern us right now. The evennia subfolder is what we are looking for. This is what you are accessing when you do from evennia import ... . It's set up by Evennia as a good place to find modules when the server starts. The exact layout of the Evennia library is covered by our directory overview . You can also explore it online on github . The structure of the library directly reflects how you import from it. To, for example, import the text justify function from evennia/utils/utils.py you would do from evennia.utils.utils import justify . In your code you could then just call justify(...) to access its functionality. You could also do from evennia.utils import utils . In code you would then have to write utils.justify(...) . This is practical if want a lot of stuff from that utils.py module and don't want to import each component separately. You could also do import evennia . You would then have to enter the full evennia.utils.utils.justify(...) every time you use it. Using from to only import the things you need is usually easier and more readable. See this overview about the different ways to import in Python. Now, remember that our characters.py module did from evennia import DefaultCharacter . But if we look at the contents of the evennia folder, there is no DefaultCharacter anywhere! This is because Evennia gives a large number of optional \"shortcuts\", known as the \"flat\" API . The intention is to make it easier to remember where to find stuff. The flat API is defined in that weirdly named __init__.py file. This file just basically imports useful things from all over Evennia so you can more easily find them in one place. We could just look at the documenation to find out where we can look at our DefaultCharacter parent. But for practice, let's figure it out. Here is where DefaultCharacter is imported from inside __init__.py : from .objects.objects import DefaultCharacter The period at the start means that it imports beginning from the same location this module sits(i.e. the evennia folder). The full python-path accessible from the outside is thus evennia.objects.objects.DefaultCharacter . So to import this into our game it'd be perfectly valid to do from evennia.objects.objects import DefaultCharacter Using from evennia import DefaultCharacter is the same thing, just a little easier to remember. To access the shortcuts of the flat API you must use from evennia import ... . Using something like import evennia.DefaultCharacter will not work. See more about the Flat API here .","title":"Exploring the Evennia library"},{"location":"Python-basic-tutorial-part-two.html#tweaking-our-character-class","text":"In the previous section we traced the parent of our Character class to be DefaultCharacter in evennia/objects/objects.py . Open that file and locate the DefaultCharacter class. It's quite a bit down in this module so you might want to search using your editor's (or browser's) search function. Once you find it, you'll find that the class starts like this: class DefaultCharacter(DefaultObject): \"\"\" This implements an Object puppeted by a Session - that is, a character avatar controlled by an account. \"\"\" def basetype_setup(self): \"\"\" Setup character-specific security. You should normally not need to overload this, but if you do, make sure to reproduce at least the two last commands in this method (unless you want to fundamentally change how a Character object works). \"\"\" super().basetype_setup() self.locks.add(\";\".join([\"get:false()\", # noone can pick up the character \"call:false()\"])) # no commands can be called on character from outside # add the default cmdset self.cmdset.add_default(settings.CMDSET_CHARACTER, permanent=True) def at_after_move(self, source_location, **kwargs): \"\"\" We make sure to look around after a move. \"\"\" if self.location.access(self, \"view\"): self.msg(self.at_look(self.location)) def at_pre_puppet(self, account, session=None, **kwargs): \"\"\" Return the character from storage in None location in `at_post_unpuppet`. Args: ... ... And so on (you can see the full class online here ). Here we have functional code! These methods may not be directly visible in Character back in our game dir, but they are still available since Character is a child of DefaultCharacter above. Here is a brief summary of the methods we find in DefaultCharacter (follow in the code to see if you can see roughly where things happen):: basetype_setup is called by Evennia only once, when a Character is first created. In the DefaultCharacter class it sets some particular Locks so that people can't pick up and puppet Characters just like that. It also adds the Character Cmdset so that Characters always can accept command-input (this should usually not be modified - the normal hook to override is at_object_creation , which is called after basetype_setup (it's in the parent)). at_after_move makes it so that every time the Character moves, the look command is automatically fired (this would not make sense for just any regular Object). at_pre_puppet is called when an Account begins to puppet this Character. When not puppeted, the Character is hidden away to a None location. This brings it back to the location it was in before. Without this, \"headless\" Characters would remain in the game world just standing around. at_post_puppet is called when puppeting is complete. It echoes a message to the room that his Character has now connected. at_post_unpuppet is called once stopping puppeting of the Character. This hides away the Character to a None location again. There are also some utility properties which makes it easier to get some time stamps from the Character. Reading the class we notice another thing: class DefaultCharacter(DefaultObject): ... This means that DefaultCharacter is in itself a child of something called DefaultObject ! Let's see what this parent class provides. It's in the same module as DefaultCharacter , you just need to scroll up near the top : class DefaultObject(with_metaclass(TypeclassBase, ObjectDB)): ... This is a really big class where the bulk of code defining an in-game object resides. It consists of a large number of methods, all of which thus also becomes available on the DefaultCharacter class below and by extension in your Character class over in your game dir. In this class you can for example find the msg method we have been using before. You should probably not expect to understand all details yet, but as an exercise, find and read the doc string of msg . As seen, DefaultObject actually has multiple parents. In one of those the basic key property is defined, but we won't travel further up the inheritance tree in this tutorial. If you are interested to see them, you can find TypeclassBase in evennia/typeclasses/models.py and ObjectDB in evennia/objects/models.py . We will also not go into the details of Multiple Inheritance or Metaclasses here. The general rule is that if you realize that you need these features, you already know enough to use them. Remember the at_pre_puppet method we looked at in DefaultCharacter ? If you look at the at_pre_puppet hook as defined in DefaultObject you'll find it to be completely empty (just a pass ). So if you puppet a regular object it won't be hiding/retrieving the object when you unpuppet it. The DefaultCharacter class overrides its parent's functionality with a version of its own. And since it's DefaultCharacter that our Character class inherits back in our game dir, it's that version of at_pre_puppet we'll get. Anything not explicitly overridden will be passed down as-is. While it's useful to read the code, we should never actually modify anything inside the evennia folder. Only time you would want that is if you are planning to release a bug fix or new feature for Evennia itself. Instead you override the default functionality inside your game dir. So to conclude our little foray into classes, objects and inheritance, locate the simple little at_before_say method in the DefaultObject class: def at_before_say(self, message, **kwargs): \"\"\" (doc string here) \"\"\" return message If you read the doc string you'll find that this can be used to modify the output of say before it goes out. You can think of it like this: Evennia knows the name of this method, and when someone speaks, Evennia will make sure to redirect the outgoing message through this method. It makes it ripe for us to replace with a version of our own. In the Evennia documentation you may sometimes see the term hook used for a method explicitly meant to be overridden like this. As you can see, the first argument to at_before_say is self . In Python, the first argument of a method is always a back-reference to the object instance on which the method is defined . By convention this argument is always called self but it could in principle be named anything. The self is very useful. If you wanted to, say, send a message to the same object from inside at_before_say , you would do self.msg(...) . What can trip up newcomers is that you don't include self when you call the method. Try: > @py me.at_before_say(\"Hello World!\") Hello World! Note that we don't send self but only the message argument. Python will automatically add self for us. In this case, self will become equal to the Character instance me . By default the at_before_say method doesn't do anything. It just takes the message input and return s it just the way it was (the return is another reserved Python word). We won't go into **kwargs here, but it (and its sibling *args ) is also important to understand. To understand the meaning of self , and here for **kwargs . Now, open your game folder and edit mygame/typeclasses/characters.py . Locate your Character class and modify it as such: class Character(DefaultCharacter): \"\"\" (docstring here) \"\"\" def at_before_say(self, message, **kwargs): \"Called before say, allows for tweaking message\" return \"{} ...\".format(message) So we add our own version of at_before_say , duplicating the def line from the parent but putting new code in it. All we do in this tutorial is to add an ellipsis ( ... ) to the message as it passes through the method. The format is a standard method on Python strings. It looks for placeholders {} in the string and replaces that placeholder with its arguments in the same order. In this case we are inserting the original message into the place of the {} and follow it with ... . Python has very powerful string formatting and you are wise to learn those well. You could also copy & paste the relevant method from DefaultObject here to get the full doc string. For more complex methods, or if you only want to change some small part of the default behavior, copy & pasting will eliminate the need to constantly look up the original method and keep you sane. In-game, now try > @reload > say Hello You say, \"Hello ...\" An ellipsis ... is added to what you said! This is a silly example but you have just made your first code change to core functionality - without touching any of Evennia's original code! We just plugged in our own version of the at_before_say method and it replaced the default one. Evennia happily redirected the message through our version and we got a different output. For sane overriding of parent methods you should also be aware of Python's super , which allows you to call the methods defined on a parent in your child class.","title":"Tweaking our Character class"},{"location":"Python-basic-tutorial-part-two.html#the-evennia-shell","text":"Now on to some generally useful tools as you continue learning Python and Evennia. We have so far explored using @py and inserted Python directly in-game. We have also modified Evennia's behavior by overriding default functionality with our own. There is a third way to conveniently explore Evennia and Python - the Evennia shell. First cd to your game folder and make sure any needed virtualenv is running. Next: > pip install ipython # only needed once The IPython program is just a nicer interface to the Python interpreter - you only need to install it once, after which Evennia will use it automatically. > evennia shell You will now be in a Python prompt managed by the IPython program. IPython ... ... In [1]: IPython has some very nice ways to explore what Evennia has to offer. > import evennia > evennia.<TAB> That is, write evennia. and press the Tab key. You will be presented with a list of all available resources in the Evennia Flat API. We looked at the __init__.py file in the evennia folder earlier, so some of what you see should be familiar. From the IPython prompt do: > from evennia import DefaultCharacter > DefaultCharacter.at_before_say? Don't forget that you can use <TAB> to auto-complete code as you write. Appending a single ? to the end will show you the doc-string for at_before_say we looked at earlier. Use ?? to get the whole source code. Let's look at our over-ridden version instead. Since we must start IPython from our game dir we can easily get to our code too: > from typeclasses.characters import Character > Character.at_before_say?? This will show us the changed code we just did. Having a window with IPython running is very convenient for quickly exploring code without having to go digging through the file structure!","title":"The Evennia shell"},{"location":"Python-basic-tutorial-part-two.html#where-to-go-from-here","text":"This should give you a running start using Python with Evennia. If you are completely new to programming or Python you might want to look at a more formal Python tutorial. You can find links and resources on our link page . We have touched upon many of the concepts here but to use Evennia and to be able to follow along in the code, you will need basic understanding of Python modules , variables , conditional statements , loops , functions , lists, dictionaries, list comprehensions and string formatting . You should also have a basic understanding of object-oriented programming and what Python Classes are. Once you have familiarized yourself, or if you prefer to pick Python up as you go, continue to one of the beginning-level Evennia tutorials to gradually build up your understanding. Good luck!","title":"Where to go from here"},{"location":"Quirks.html","text":"This is a list of various quirks or common stumbling blocks that people often ask about or report when using (or trying to use) Evennia. They are not bugs. Forgetting to use @reload to see changes to your typeclasses \u00b6 Firstly: Reloading the server is a safe and usually quick operation which will not disconnect any accounts. New users tend to forget this step. When editing source code (such as when tweaking typeclasses and commands or adding new commands to command sets) you need to either use the in-game @reload command or, from the command line do python evennia.py reload before you see your changes. Web admin to create new Account \u00b6 If you use the default login system and are trying to use the Web admin to create a new Player account, you need to consider which MULTIACCOUNT_MODE you are in. If you are in MULTIACCOUNT_MODE 0 or 1 , the login system expects each Account to also have a Character object named the same as the Account - there is no character creation screen by default. If using the normal mud login screen, a Character with the same name is automatically created and connected to your Account. From the web interface you must do this manually. So, when creating the Account, make sure to also create the Character from the same form as you create the Account from. This should set everything up for you. Otherwise you need to manually set the \"account\" property on the Character and the \"character\" property on the Account to point to each other. You must also set the lockstring of the Character to allow the Account to \"puppet\" this particular character. Mutable attributes and their connection to the database \u00b6 When storing a mutable object (usually a list or a dictionary) in an Attribute object.db.mylist = [1,2,3] you should know that the connection to the database is retained also if you later extract that Attribute into another variable (what is stored and retrieved is actually a PackedList or a PackedDict that works just like their namesakes except they save themselves to the database when changed). So if you do alist = object.db.mylist alist.append(4) this updates the database behind the scenes, so both alist and object.db.mylist are now [1,2,3,4] If you don't want this, Evennia provides a way to stably disconnect the mutable from the database by use of evennia.utils.dbserialize.deserialize : from evennia.utils.dbserialize import deserialize blist = deserialize(object.db.mylist) blist.append(4) The property blist is now [1,2,3,4] whereas object.db.mylist remains unchanged. If you want to update the database you'd need to explicitly re-assign the updated data to the mylist Attribute. Commands are matched by name or alias \u00b6 When merging command sets it's important to remember that command objects are identified both by key or alias. So if you have a command with a key look and an alias ls , introducing another command with a key ls will be assumed by the system to be identical to the first one. This usually means merging cmdsets will overload one of them depending on priority. Whereas this is logical once you know how command objects are handled, it may be confusing if you are just looking at the command strings thinking they are parsed as-is. Objects turning to DefaultObject \u00b6 A common confusing error for new developers is finding that one or more objects in-game are suddenly of the type DefaultObject rather than the typeclass you wanted it to be. This happens when you introduce a critical Syntax error to the module holding your custom class. Since such a module is not valid Python, Evennia can't load it at all to get to the typeclasses within. To keep on running, Evennia will solve this by printing the full traceback to the terminal/console and temporarily fall back to the safe DefaultObject until you fix the problem and reload. Most errors of this kind will be caught by any good text editors. Keep an eye on the terminal/console during a reload to catch such errors - you may have to scroll up if your window is small. Overriding of magic methods \u00b6 Python implements a system of magic methods , usually prefixed and suffixed by double-underscores ( __example__ ) that allow object instances to have certain operations performed on them without needing to do things like turn them into strings or numbers first-- for example, is obj1 greater than or equal to obj2 ? Neither object is a number, but given obj1.size == \"small\" and obj2.size == \"large\" , how might one compare these two arbitrary English adjective strings to figure out which is greater than the other? By defining the __ge__ (greater than or equal to) magic method on the object class in which you figure out which word has greater significance, perhaps through use of a mapping table ( {'small':0, 'large':10} ) or other lookup and comparing the numeric values of each. Evennia extensively makes use of magic methods on typeclasses to do things like initialize objects, check object existence or iterate over objects in an inventory or container. If you override or interfere with the return values from the methods Evennia expects to be both present and working, it can result in very inconsistent and hard-to-diagnose errors. The moral of the story-- it can be dangerous to tinker with magic methods on typeclassed objects. Try to avoid doing so. Known upstream bugs \u00b6 There is currently (Autumn 2017) a bug in the zope.interface installer on some Linux Ubuntu distributions (notably Ubuntu 16.04 LTS). Zope is a dependency of Twisted. The error manifests in the server not starting with an error that zope.interface is not found even though pip list shows it's installed. The reason is a missing empty __init__.py file at the root of the zope package. If the virtualenv is named \"evenv\" as suggested in the Getting Started instructions, use the following command to fix it: shell touch evenv/local/lib/python2.7/site-packages/zope/__init__.py This will create the missing file and things should henceforth work correctly.","title":"Quirks"},{"location":"Quirks.html#forgetting-to-use-reload-to-see-changes-to-your-typeclasses","text":"Firstly: Reloading the server is a safe and usually quick operation which will not disconnect any accounts. New users tend to forget this step. When editing source code (such as when tweaking typeclasses and commands or adding new commands to command sets) you need to either use the in-game @reload command or, from the command line do python evennia.py reload before you see your changes.","title":"Forgetting to use @reload to see changes to your typeclasses"},{"location":"Quirks.html#web-admin-to-create-new-account","text":"If you use the default login system and are trying to use the Web admin to create a new Player account, you need to consider which MULTIACCOUNT_MODE you are in. If you are in MULTIACCOUNT_MODE 0 or 1 , the login system expects each Account to also have a Character object named the same as the Account - there is no character creation screen by default. If using the normal mud login screen, a Character with the same name is automatically created and connected to your Account. From the web interface you must do this manually. So, when creating the Account, make sure to also create the Character from the same form as you create the Account from. This should set everything up for you. Otherwise you need to manually set the \"account\" property on the Character and the \"character\" property on the Account to point to each other. You must also set the lockstring of the Character to allow the Account to \"puppet\" this particular character.","title":"Web admin to create new Account"},{"location":"Quirks.html#mutable-attributes-and-their-connection-to-the-database","text":"When storing a mutable object (usually a list or a dictionary) in an Attribute object.db.mylist = [1,2,3] you should know that the connection to the database is retained also if you later extract that Attribute into another variable (what is stored and retrieved is actually a PackedList or a PackedDict that works just like their namesakes except they save themselves to the database when changed). So if you do alist = object.db.mylist alist.append(4) this updates the database behind the scenes, so both alist and object.db.mylist are now [1,2,3,4] If you don't want this, Evennia provides a way to stably disconnect the mutable from the database by use of evennia.utils.dbserialize.deserialize : from evennia.utils.dbserialize import deserialize blist = deserialize(object.db.mylist) blist.append(4) The property blist is now [1,2,3,4] whereas object.db.mylist remains unchanged. If you want to update the database you'd need to explicitly re-assign the updated data to the mylist Attribute.","title":"Mutable attributes and their connection to the database"},{"location":"Quirks.html#commands-are-matched-by-name-or-alias","text":"When merging command sets it's important to remember that command objects are identified both by key or alias. So if you have a command with a key look and an alias ls , introducing another command with a key ls will be assumed by the system to be identical to the first one. This usually means merging cmdsets will overload one of them depending on priority. Whereas this is logical once you know how command objects are handled, it may be confusing if you are just looking at the command strings thinking they are parsed as-is.","title":"Commands are matched by name or alias"},{"location":"Quirks.html#objects-turning-to-defaultobject","text":"A common confusing error for new developers is finding that one or more objects in-game are suddenly of the type DefaultObject rather than the typeclass you wanted it to be. This happens when you introduce a critical Syntax error to the module holding your custom class. Since such a module is not valid Python, Evennia can't load it at all to get to the typeclasses within. To keep on running, Evennia will solve this by printing the full traceback to the terminal/console and temporarily fall back to the safe DefaultObject until you fix the problem and reload. Most errors of this kind will be caught by any good text editors. Keep an eye on the terminal/console during a reload to catch such errors - you may have to scroll up if your window is small.","title":"Objects turning to DefaultObject"},{"location":"Quirks.html#overriding-of-magic-methods","text":"Python implements a system of magic methods , usually prefixed and suffixed by double-underscores ( __example__ ) that allow object instances to have certain operations performed on them without needing to do things like turn them into strings or numbers first-- for example, is obj1 greater than or equal to obj2 ? Neither object is a number, but given obj1.size == \"small\" and obj2.size == \"large\" , how might one compare these two arbitrary English adjective strings to figure out which is greater than the other? By defining the __ge__ (greater than or equal to) magic method on the object class in which you figure out which word has greater significance, perhaps through use of a mapping table ( {'small':0, 'large':10} ) or other lookup and comparing the numeric values of each. Evennia extensively makes use of magic methods on typeclasses to do things like initialize objects, check object existence or iterate over objects in an inventory or container. If you override or interfere with the return values from the methods Evennia expects to be both present and working, it can result in very inconsistent and hard-to-diagnose errors. The moral of the story-- it can be dangerous to tinker with magic methods on typeclassed objects. Try to avoid doing so.","title":"Overriding of magic methods"},{"location":"Quirks.html#known-upstream-bugs","text":"There is currently (Autumn 2017) a bug in the zope.interface installer on some Linux Ubuntu distributions (notably Ubuntu 16.04 LTS). Zope is a dependency of Twisted. The error manifests in the server not starting with an error that zope.interface is not found even though pip list shows it's installed. The reason is a missing empty __init__.py file at the root of the zope package. If the virtualenv is named \"evenv\" as suggested in the Getting Started instructions, use the following command to fix it: shell touch evenv/local/lib/python2.7/site-packages/zope/__init__.py This will create the missing file and things should henceforth work correctly.","title":"Known upstream bugs"},{"location":"RSS.html","text":"RSS is a format for easily tracking updates on websites. The principle is simple - whenever a site is updated, a small text file is updated. An RSS reader can then regularly go online, check this file for updates and let the user know what's new. Evennia allows for connecting any number of RSS feeds to any number of in-game channels. Updates to the feed will be conveniently echoed to the channel. There are many potential uses for this: For example the MUD might use a separate website to host its forums. Through RSS, the players can then be notified when new posts are made. Another example is to let everyone know you updated your dev blog. Admins might also want to track the latest Evennia updates through our own RSS feed here . Configuring RSS \u00b6 To use RSS, you first need to install the feedparser python module. pip install feedparser Next you activate RSS support in your config file by settting RSS_ENABLED=True . Start/reload Evennia as a privileged user. You should now have a new command available, @rss2chan : @rss2chan <evennia_channel> = <rss_url> Setting up RSS, step by step \u00b6 You can connect RSS to any Evennia channel, but for testing, let's set up a new channel \"rss\". @ccreate rss = RSS feeds are echoed to this channel! Let's connect Evennia's code-update feed to this channel. The RSS url for evennia updates is https://github.com/evennia/evennia/commits/master.atom , so let's add that: @rss2chan rss = https://github.com/evennia/evennia/commits/master.atom That's it, really. New Evennia updates will now show up as a one-line title and link in the channel. Give the @rss2chan command on its own to show all connections. To remove a feed from a channel, you specify the connection again (use the command to see it in the list) but add the /delete switch: @rss2chan/delete rss = https://github.com/evennia/evennia/commits/master.atom You can connect any number of RSS feeds to a channel this way. You could also connect them to the same channels as IRC to have the feed echo to external chat channels as well.","title":"RSS"},{"location":"RSS.html#configuring-rss","text":"To use RSS, you first need to install the feedparser python module. pip install feedparser Next you activate RSS support in your config file by settting RSS_ENABLED=True . Start/reload Evennia as a privileged user. You should now have a new command available, @rss2chan : @rss2chan <evennia_channel> = <rss_url>","title":"Configuring RSS"},{"location":"RSS.html#setting-up-rss-step-by-step","text":"You can connect RSS to any Evennia channel, but for testing, let's set up a new channel \"rss\". @ccreate rss = RSS feeds are echoed to this channel! Let's connect Evennia's code-update feed to this channel. The RSS url for evennia updates is https://github.com/evennia/evennia/commits/master.atom , so let's add that: @rss2chan rss = https://github.com/evennia/evennia/commits/master.atom That's it, really. New Evennia updates will now show up as a one-line title and link in the channel. Give the @rss2chan command on its own to show all connections. To remove a feed from a channel, you specify the connection again (use the command to see it in the list) but add the /delete switch: @rss2chan/delete rss = https://github.com/evennia/evennia/commits/master.atom You can connect any number of RSS feeds to a channel this way. You could also connect them to the same channels as IRC to have the feed echo to external chat channels as well.","title":"Setting up RSS, step by step"},{"location":"Roadmap.html","text":"As of Autumn 2016, Evennia's development roadmap is tracked through the Evennia Projects Page .","title":"Roadmap"},{"location":"Running-Evennia-in-Docker.html","text":"Evennia has an official docker image which makes running an Evennia-based game in a Docker container easy. Install Evennia through docker \u00b6 First, install the docker program so you can run the Evennia container. You can get it freely from docker.com . Linux users can likely also get it through their normal package manager. docker pull evennia/evennia This is a good command to know. It will fetch the latest official docker image from docker hub and is how you upgrade to the latest in the future. cd to a place where your game dir is, or where you want to create it. Then run: docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 --rm -v $PWD:/usr/src/game evennia/evennia Having run this (see next section for a description of what's what), you will be at a prompt inside the docker container: evennia|docker /usr/src/game $ This is a normal shell prompt. We are in the /usr/src/game location inside the docker container. If you had anything in the folder you started from, you should see it here (with ls ) since we mounted the current directory to usr/src/game (with -v above). You have the evennia command available and can now proceed to create a new game as per the Getting Started instructions. You can run Evennia from inside this container if you want to, it's like you are root in a little isolated Linux environment. To exit the container and all processes in there, press Ctrl-D . If you created a new game folder, you will find that it has appeared on-disk. The game folder or any new files that you created from inside the container will appear as owned by root . If you want to edit the files outside of the container you should change the ownership. On Linux/Mac you do this with sudo chown myname:myname -R mygame , where you replace myname with your username and mygame with whatever your game folder is named. Description of the docker run command \u00b6 docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 --rm -v $PWD:/usr/src/game --user $UID:$GID evennia/evennia This is what it does: docker run ... evennia/evennia tells us that we want to run a new container based on the evennia/evennia docker image. Everything in between are options for this. The evennia/evennia is the name of our official docker image on the dockerhub repository . If you didn't do docker pull evennia/evennia first, the image will be downloaded when running this, otherwise your already downloaded version will be used. It contains everything needed to run Evennia. -it has to do with creating an interactive session inside the container we start. --rm will make sure to delete the container when it shuts down. This is nice to keep things tidy on your drive. -p 4000:4000 -p 4001:4001 -p 4002:4002 means that we map ports 4000 , 4001 and 4002 from inside the docker container to same-numbered ports on our host machine. These are ports for telnet, webserver and websockets. This is what allows your Evennia server to be accessed from outside the container (such as by your MUD client)! -v $PWD:/usr/src/game mounts the current directory ( outside the container) to the path /usr/src/game inside the container. This means that when you edit that path in the container you will actually be modifying the \"real\" place on your hard drive. If you didn't do this, any changes would only exist inside the container and be gone if we create a new one. Note that in linux a shortcut for the current directory is $PWD . If you don't have this for your OS, you can replace it with the full path to the current on-disk directory (like C:/Development/evennia/game or wherever you want your evennia files to appear). --user $UID:$GID ensures the container's modifications to $PWD are done with you user and group IDs instead of root's IDs (root is the user running evennia inside the container). This avoids having stale .pid files in your filesystem between container reboots which you have to force delete with sudo rm server/*.pid before each boot. Running your game as a docker image \u00b6 If you run the docker command given in the previous section from your game dir you can then easily start Evennia and have a running server without any further fuss. But apart from ease of install, the primary benefit to running an Evennia-based game in a container is to simplify its deployment into a public production environment. Most cloud-based hosting providers these days support the ability to run container-based applications. This makes deploying or updating your game as simple as building a new container image locally, pushing it to your Docker Hub account, and then pulling from Docker Hub into your AWS/Azure/other docker-enabled hosting account. The container eliminates the need to install Python, set up a virtualenv, or run pip to install dependencies. Start Evennia and run through docker \u00b6 For remote or automated deployment you may want to start Evennia immediately as soon as the docker container comes up. If you already have a game folder with a database set up you can also start the docker container and pass commands directly to it. The command you pass will be the main process to run in the container. From your game dir, run for example this command: docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 --rm -v $PWD:/usr/src/game evennia/evennia evennia start -l This will start Evennia as the foreground process, echoing the log to the terminal. Closing the terminal will kill the server. Note that you must use a foreground command like evennia start -l or evennia ipstart to start the server - otherwise the foreground process will finish immediately and the container go down. Create your own game image \u00b6 These steps assume that you have created or otherwise obtained a game directory already. First, cd to your game dir and create a new empty text file named Dockerfile . Save the following two lines into it: FROM evennia/evennia:latest ENTRYPOINT evennia start -l These are instructions for building a new docker image. This one is based on the official evennia/evennia image, but also makes sure to start evennia when it runs (so we don't need to enter it and run commands). To build the image: docker build -t mydhaccount/mygame . (don't forget the period at the end, it will use the Dockerfile from the current location). Here mydhaccount is the name of your dockerhub account. If you don't have a dockerhub account you can build the image locally only (name the container whatever you like in that case, like just mygame ). Docker images are stored centrally on your computer. You can see which ones you have available locally with docker images . Once built, you have a couple of options to run your game. Run container from your game image for development \u00b6 To run the container based on your game image locally for development, mount the local game directory as before: docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 -v $PWD:/usr/src/game --user $UID:$GID mydhaccount/mygame Evennia will start and you'll get output in the terminal, perfect for development. You should be able to connect to the game with your clients normally. Deploy game image for production \u00b6 Each time you rebuild the docker image as per the above instructions, the latest copy of your game directory is actually copied inside the image (at /usr/src/game/ ). If you don't mount your on-disk folder there, the internal one will be used. So for deploying evennia on a server, omit the -v option and just give the following command: docker run -it --rm -d -p 4000:4000 -p 4001:4001 -p 4002:4002 --user $UID:$GID mydhaccount/mygame Your game will be downloaded from your docker-hub account and a new container will be built using the image and started on the server! If your server environment forces you to use different ports, you can just map the normal ports differently in the command above. Above we added the -d option, which starts the container in daemon mode - you won't see any return in the console. You can see it running with docker ps : $ docker ps CONTAINER ID IMAGE COMMAND CREATED ... f6d4ca9b2b22 mygame \"/bin/sh -c 'evenn...\" About a minute ago ... Note the container ID, this is how you manage the container as it runs. docker logs f6d4ca9b2b22 Looks at the STDOUT output of the container (i.e. the normal server log) docker logs -f f6d4ca9b2b22 Tail the log (so it updates to your screen 'live'). docker pause f6d4ca9b2b22 Suspend the state of the container. docker unpause f6d4ca9b2b22 Un-suspend it again after a pause. It will pick up exactly where it were. docker stop f6d4ca9b2b22 Stop the container. To get it up again you need to use docker run , specifying ports etc. A new container will get a new container id to reference. How it Works \u00b6 The evennia/evennia docker image holds the evennia library and all of its dependencies. It also has an ONBUILD directive which is triggered during builds of images derived from it. This ONBUILD directive handles setting up a volume and copying your game directory code into the proper location within the container. In most cases, the Dockerfile for an Evennia-based game will only need the FROM evennia/evennia:latest directive, and optionally a MAINTAINER directive if you plan to publish your image on Docker Hub and would like to provide contact info. For more information on Dockerfile directives, see the Dockerfile Reference . For more information on volumes and Docker containers, see the Docker site's Manage data in containers page. What if I Don't Want \"LATEST\"? \u00b6 A new evennia/evennia image is built automatically whenever there is a new commit to the master branch of Evennia. It is possible to create your own custom evennia base docker image based on any arbitrary commit. Use git tools to checkout the commit that you want to base your image upon. (In the example below, we're checking out commit a8oc3d5b.) git checkout -b my-stable-branch a8oc3d5b Change your working directory to the evennia directory containing Dockerfile . Note that Dockerfile has changed over time, so if you are going far back in the commit history you might want to bring a copy of the latest Dockerfile with you and use that instead of whatever version was used at the time. Use the docker build command to build the image based off of the currently checked out commit. The example below assumes your docker account is mydhaccount . docker build -t mydhaccount/evennia . Now you have a base evennia docker image built off of a specific commit. To use this image to build your game, you would modify FROM directive in the Dockerfile for your game directory to be: FROM mydhacct/evennia:latest Note: From this point, you can also use the docker tag command to set a specific tag on your image and/or upload it into Docker Hub under your account. At this point, build your game using the same docker build command as usual. Change your working directory to be your game directory and run docker build -t mydhaccountt/mygame . Additional Creature Comforts \u00b6 The Docker ecosystem includes a tool called docker-compose , which can orchestrate complex multi-container applications, or in our case, store the default port and terminal parameters that we want specified every time we run our container. A sample docker-compose.yml file to run a containerized Evennia game in development might look like this: version: '2' services: evennia: image: mydhacct/mygame stdin_open: true tty: true ports: - \"4001-4002:4001-4002\" - \"4000:4000\" volumes: - .:/usr/src/game With this file in the game directory next to the Dockerfile , starting the container is as simple as docker-compose up For more information about docker-compose , see Getting Started with docker-compose . Note that with this setup you lose the --user $UID option. The problem is that the variable UID is not available inside the configuration file docker-compose.yml . A workaround is to hardcode your user and group id. In a terminal run echo $UID:$GID and if for example you get 1000:1000 you can add to docker-compose.yml a line user: 1000:1000 just below the image: ... line.","title":"Running Evennia in Docker"},{"location":"Running-Evennia-in-Docker.html#install-evennia-through-docker","text":"First, install the docker program so you can run the Evennia container. You can get it freely from docker.com . Linux users can likely also get it through their normal package manager. docker pull evennia/evennia This is a good command to know. It will fetch the latest official docker image from docker hub and is how you upgrade to the latest in the future. cd to a place where your game dir is, or where you want to create it. Then run: docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 --rm -v $PWD:/usr/src/game evennia/evennia Having run this (see next section for a description of what's what), you will be at a prompt inside the docker container: evennia|docker /usr/src/game $ This is a normal shell prompt. We are in the /usr/src/game location inside the docker container. If you had anything in the folder you started from, you should see it here (with ls ) since we mounted the current directory to usr/src/game (with -v above). You have the evennia command available and can now proceed to create a new game as per the Getting Started instructions. You can run Evennia from inside this container if you want to, it's like you are root in a little isolated Linux environment. To exit the container and all processes in there, press Ctrl-D . If you created a new game folder, you will find that it has appeared on-disk. The game folder or any new files that you created from inside the container will appear as owned by root . If you want to edit the files outside of the container you should change the ownership. On Linux/Mac you do this with sudo chown myname:myname -R mygame , where you replace myname with your username and mygame with whatever your game folder is named.","title":"Install Evennia through docker"},{"location":"Running-Evennia-in-Docker.html#description-of-the-docker-run-command","text":"docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 --rm -v $PWD:/usr/src/game --user $UID:$GID evennia/evennia This is what it does: docker run ... evennia/evennia tells us that we want to run a new container based on the evennia/evennia docker image. Everything in between are options for this. The evennia/evennia is the name of our official docker image on the dockerhub repository . If you didn't do docker pull evennia/evennia first, the image will be downloaded when running this, otherwise your already downloaded version will be used. It contains everything needed to run Evennia. -it has to do with creating an interactive session inside the container we start. --rm will make sure to delete the container when it shuts down. This is nice to keep things tidy on your drive. -p 4000:4000 -p 4001:4001 -p 4002:4002 means that we map ports 4000 , 4001 and 4002 from inside the docker container to same-numbered ports on our host machine. These are ports for telnet, webserver and websockets. This is what allows your Evennia server to be accessed from outside the container (such as by your MUD client)! -v $PWD:/usr/src/game mounts the current directory ( outside the container) to the path /usr/src/game inside the container. This means that when you edit that path in the container you will actually be modifying the \"real\" place on your hard drive. If you didn't do this, any changes would only exist inside the container and be gone if we create a new one. Note that in linux a shortcut for the current directory is $PWD . If you don't have this for your OS, you can replace it with the full path to the current on-disk directory (like C:/Development/evennia/game or wherever you want your evennia files to appear). --user $UID:$GID ensures the container's modifications to $PWD are done with you user and group IDs instead of root's IDs (root is the user running evennia inside the container). This avoids having stale .pid files in your filesystem between container reboots which you have to force delete with sudo rm server/*.pid before each boot.","title":"Description of the docker run command"},{"location":"Running-Evennia-in-Docker.html#running-your-game-as-a-docker-image","text":"If you run the docker command given in the previous section from your game dir you can then easily start Evennia and have a running server without any further fuss. But apart from ease of install, the primary benefit to running an Evennia-based game in a container is to simplify its deployment into a public production environment. Most cloud-based hosting providers these days support the ability to run container-based applications. This makes deploying or updating your game as simple as building a new container image locally, pushing it to your Docker Hub account, and then pulling from Docker Hub into your AWS/Azure/other docker-enabled hosting account. The container eliminates the need to install Python, set up a virtualenv, or run pip to install dependencies.","title":"Running your game as a docker image"},{"location":"Running-Evennia-in-Docker.html#start-evennia-and-run-through-docker","text":"For remote or automated deployment you may want to start Evennia immediately as soon as the docker container comes up. If you already have a game folder with a database set up you can also start the docker container and pass commands directly to it. The command you pass will be the main process to run in the container. From your game dir, run for example this command: docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 --rm -v $PWD:/usr/src/game evennia/evennia evennia start -l This will start Evennia as the foreground process, echoing the log to the terminal. Closing the terminal will kill the server. Note that you must use a foreground command like evennia start -l or evennia ipstart to start the server - otherwise the foreground process will finish immediately and the container go down.","title":"Start Evennia and run through docker"},{"location":"Running-Evennia-in-Docker.html#create-your-own-game-image","text":"These steps assume that you have created or otherwise obtained a game directory already. First, cd to your game dir and create a new empty text file named Dockerfile . Save the following two lines into it: FROM evennia/evennia:latest ENTRYPOINT evennia start -l These are instructions for building a new docker image. This one is based on the official evennia/evennia image, but also makes sure to start evennia when it runs (so we don't need to enter it and run commands). To build the image: docker build -t mydhaccount/mygame . (don't forget the period at the end, it will use the Dockerfile from the current location). Here mydhaccount is the name of your dockerhub account. If you don't have a dockerhub account you can build the image locally only (name the container whatever you like in that case, like just mygame ). Docker images are stored centrally on your computer. You can see which ones you have available locally with docker images . Once built, you have a couple of options to run your game.","title":"Create your own game image"},{"location":"Running-Evennia-in-Docker.html#run-container-from-your-game-image-for-development","text":"To run the container based on your game image locally for development, mount the local game directory as before: docker run -it --rm -p 4000:4000 -p 4001:4001 -p 4002:4002 -v $PWD:/usr/src/game --user $UID:$GID mydhaccount/mygame Evennia will start and you'll get output in the terminal, perfect for development. You should be able to connect to the game with your clients normally.","title":"Run container from your game image for development"},{"location":"Running-Evennia-in-Docker.html#deploy-game-image-for-production","text":"Each time you rebuild the docker image as per the above instructions, the latest copy of your game directory is actually copied inside the image (at /usr/src/game/ ). If you don't mount your on-disk folder there, the internal one will be used. So for deploying evennia on a server, omit the -v option and just give the following command: docker run -it --rm -d -p 4000:4000 -p 4001:4001 -p 4002:4002 --user $UID:$GID mydhaccount/mygame Your game will be downloaded from your docker-hub account and a new container will be built using the image and started on the server! If your server environment forces you to use different ports, you can just map the normal ports differently in the command above. Above we added the -d option, which starts the container in daemon mode - you won't see any return in the console. You can see it running with docker ps : $ docker ps CONTAINER ID IMAGE COMMAND CREATED ... f6d4ca9b2b22 mygame \"/bin/sh -c 'evenn...\" About a minute ago ... Note the container ID, this is how you manage the container as it runs. docker logs f6d4ca9b2b22 Looks at the STDOUT output of the container (i.e. the normal server log) docker logs -f f6d4ca9b2b22 Tail the log (so it updates to your screen 'live'). docker pause f6d4ca9b2b22 Suspend the state of the container. docker unpause f6d4ca9b2b22 Un-suspend it again after a pause. It will pick up exactly where it were. docker stop f6d4ca9b2b22 Stop the container. To get it up again you need to use docker run , specifying ports etc. A new container will get a new container id to reference.","title":"Deploy game image for production"},{"location":"Running-Evennia-in-Docker.html#how-it-works","text":"The evennia/evennia docker image holds the evennia library and all of its dependencies. It also has an ONBUILD directive which is triggered during builds of images derived from it. This ONBUILD directive handles setting up a volume and copying your game directory code into the proper location within the container. In most cases, the Dockerfile for an Evennia-based game will only need the FROM evennia/evennia:latest directive, and optionally a MAINTAINER directive if you plan to publish your image on Docker Hub and would like to provide contact info. For more information on Dockerfile directives, see the Dockerfile Reference . For more information on volumes and Docker containers, see the Docker site's Manage data in containers page.","title":"How it Works"},{"location":"Running-Evennia-in-Docker.html#what-if-i-dont-want-latest","text":"A new evennia/evennia image is built automatically whenever there is a new commit to the master branch of Evennia. It is possible to create your own custom evennia base docker image based on any arbitrary commit. Use git tools to checkout the commit that you want to base your image upon. (In the example below, we're checking out commit a8oc3d5b.) git checkout -b my-stable-branch a8oc3d5b Change your working directory to the evennia directory containing Dockerfile . Note that Dockerfile has changed over time, so if you are going far back in the commit history you might want to bring a copy of the latest Dockerfile with you and use that instead of whatever version was used at the time. Use the docker build command to build the image based off of the currently checked out commit. The example below assumes your docker account is mydhaccount . docker build -t mydhaccount/evennia . Now you have a base evennia docker image built off of a specific commit. To use this image to build your game, you would modify FROM directive in the Dockerfile for your game directory to be: FROM mydhacct/evennia:latest Note: From this point, you can also use the docker tag command to set a specific tag on your image and/or upload it into Docker Hub under your account. At this point, build your game using the same docker build command as usual. Change your working directory to be your game directory and run docker build -t mydhaccountt/mygame .","title":"What if I Don't Want \"LATEST\"?"},{"location":"Running-Evennia-in-Docker.html#additional-creature-comforts","text":"The Docker ecosystem includes a tool called docker-compose , which can orchestrate complex multi-container applications, or in our case, store the default port and terminal parameters that we want specified every time we run our container. A sample docker-compose.yml file to run a containerized Evennia game in development might look like this: version: '2' services: evennia: image: mydhacct/mygame stdin_open: true tty: true ports: - \"4001-4002:4001-4002\" - \"4000:4000\" volumes: - .:/usr/src/game With this file in the game directory next to the Dockerfile , starting the container is as simple as docker-compose up For more information about docker-compose , see Getting Started with docker-compose . Note that with this setup you lose the --user $UID option. The problem is that the variable UID is not available inside the configuration file docker-compose.yml . A workaround is to hardcode your user and group id. In a terminal run echo $UID:$GID and if for example you get 1000:1000 you can add to docker-compose.yml a line user: 1000:1000 just below the image: ... line.","title":"Additional Creature Comforts"},{"location":"Screenshot.html","text":"(right-click and choose your browser's equivalent of \"view image\" to see it full size) This screenshot shows a vanilla install of the just started Evennia MUD server. In the bottom window we can see the log messages from the running server. In the top left window we see the default website of our new game displayed in a web browser (it has shrunk to accomodate the smaller screen). Evennia contains its own webserver to serve this page. The default site shows some brief info about the database. From here you can also reach Django's admin interface for editing the database online. To the upper right is the included web-browser client showing a connection to the server on port 4001. This allows users to access the game without downloading a mud client separately. Bottom right we see a login into the stock game using a third-party MUD client ( Mudlet ). This connects to the server via the telnet protocol on port 4000.","title":"Screenshot"},{"location":"Scripts.html","text":"Scripts are the out-of-character siblings to the in-character Objects . Scripts are so flexible that the \"Script\" is a bit limiting - we had to pick something to name them after all. Other possible names (depending on what you'd use them for) would be OOBObjects , StorageContainers or TimerObjects . Scripts can be used for many different things in Evennia: They can attach to Objects to influence them in various ways - or exist independently of any one in-game entity (so-called Global Scripts ). They can work as timers and tickers - anything that may change with Time. But they can also have no time dependence at all. Note though that if all you want is just to have an object method called repeatedly, you should consider using the TickerHandler which is more limited but is specialized on just this task. They can describe State changes. A Script is an excellent platform for hosting a persistent, but unique system handler. For example, a Script could be used as the base to track the state of a turn-based combat system. Since Scripts can also operate on a timer they can also update themselves regularly to perform various actions. They can act as data stores for storing game data persistently in the database (thanks to its ability to have Attributes ). They can be used as OOC stores for sharing data between groups of objects, for example for tracking the turns in a turn-based combat system or barter exchange. Scripts are Typeclassed entities and are manipulated in a similar way to how it works for other such Evennia entities: # create a new script new_script = evennia.create_script(key=\"myscript\", typeclass=...) # search (this is always a list, also if there is only one match) list_of_myscript = evennia.search_script(\"myscript\") Defining new Scripts \u00b6 A Script is defined as a class and is created in the same way as other typeclassed entities. The class has several properties to control the timer-component of the scripts. These are all optional - leaving them out will just create a Script with no timer components (useful to act as a database store or to hold a persistent game system, for example). This you can do for example in the module evennia/typeclasses/scripts.py . Below is an example Script Typeclass. from evennia import DefaultScript class MyScript(DefaultScript): def at_script_creation(self): self.key = \"myscript\" self.interval = 60 # 1 min repeat def at_repeat(self): # do stuff every minute In mygame/typeclasses/scripts.py is the Script class which inherits from DefaultScript already. This is provided as your own base class to do with what you like: You can tweak Script if you want to change the default behavior and it is usually convenient to inherit from this instead. Here's an example: # for example in mygame/typeclasses/scripts.py # Script class is defined at the top of this module import random class Weather(Script): \"\"\" A timer script that displays weather info. Meant to be attached to a room. \"\"\" def at_script_creation(self): self.key = \"weather_script\" self.desc = \"Gives random weather messages.\" self.interval = 60 * 5 # every 5 minutes self.persistent = True # will survive reload def at_repeat(self): \"called every self.interval seconds.\" rand = random.random() if rand < 0.5: weather = \"A faint breeze is felt.\" elif rand < 0.7: weather = \"Clouds sweep across the sky.\" else: weather = \"There is a light drizzle of rain.\" # send this message to everyone inside the object this # script is attached to (likely a room) self.obj.msg_contents(weather) If we put this script on a room, it will randomly report some weather to everyone in the room every 5 minutes. To activate it, just add it to the script handler ( scripts ) on an Room . That object becomes self.obj in the example above. Here we put it on a room called myroom : myroom.scripts.add(scripts.Weather) Note that typeclasses in your game dir is added to the setting TYPECLASS_PATHS . Therefore we don't need to give the full path ( typeclasses.scripts.Weather but only scripts.Weather above. You can also create scripts using the evennia.create_script function: from evennia import create_script create_script('typeclasses.weather.Weather', obj=myroom) Note that if you were to give a keyword argument to create_script , that would override the default value in your Typeclass. So for example, here is an instance of the weather script that runs every 10 minutes instead (and also not survive a server reload): create_script('typeclasses.weather.Weather', obj=myroom, persistent=False, interval=10*60) From in-game you can use the @script command to launch the Script on things: @script here = weather.Weather You can conveniently view and kill running Scripts by using the @scripts command in-game. Properties and functions defined on Scripts \u00b6 A Script has all the properties of a typeclassed object, such as db and ndb (see Typeclasses ). Setting key is useful in order to manage scripts (delete them by name etc). These are usually set up in the Script's typeclass, but can also be assigned on the fly as keyword arguments to evennia.create_script . desc - an optional description of the script's function. Seen in script listings. interval - how often the script should run. If interval == 0 (default), this script has no timing component, will not repeat and will exist forever. This is useful for Scripts used for storage or acting as bases for various non-time dependent game systems. start_delay - (bool), if we should wait interval seconds before firing for the first time or not. repeats - How many times we should repeat, assuming interval > 0 . If repeats is set to <= 0 , the script will repeat indefinitely. Note that each firing of the script (including the first one) counts towards this value. So a Script with start_delay=False and repeats=1 will start, immediately fire and shut down right away. persistent - if this script should survive a server reset or server shutdown . (You don't need to set this for it to survive a normal reload - the script will be paused and seamlessly restart after the reload is complete). There is one special property: obj - the Object this script is attached to (if any). You should not need to set this manually. If you add the script to the Object with myobj.scripts.add(myscriptpath) or give myobj as an argument to the utils.create.create_script function, the obj property will be set to myobj for you. It's also imperative to know the hook functions. Normally, overriding these are all the customization you'll need to do in Scripts. You can find longer descriptions of these in src/scripts/scripts.py . at_script_creation() - this is usually where the script class sets things like interval and repeats ; things that control how the script runs. It is only called once - when the script is first created. is_valid() - determines if the script should still be running or not. This is called when running obj.scripts.validate() , which you can run manually, but which is also called by Evennia during certain situations such as reloads. This is also useful for using scripts as state managers. If the method returns False , the script is stopped and cleanly removed. at_start() - this is called when the script starts or is unpaused. For persistent scripts this is at least once ever server startup. Note that this will always be called right away, also if start_delay is True . at_repeat() - this is called every interval seconds, or not at all. It is called right away at startup, unless start_delay is True , in which case the system will wait interval seconds before calling. at_stop() - this is called when the script stops for whatever reason. It's a good place to do custom cleanup. at_server_reload() - this is called whenever the server is warm-rebooted (e.g. with the @reload command). It's a good place to save non-persistent data you might want to survive a reload. at_server_shutdown() - this is called when a system reset or systems shutdown is invoked. Running methods (usually called automatically by the engine, but possible to also invoke manually) start() - this will start the script. This is called automatically whenever you add a new script to a handler. at_start() will be called. stop() - this will stop the script and delete it. Removing a script from a handler will stop it automatically. at_stop() will be called. pause() - this pauses a running script, rendering it inactive, but not deleting it. All properties are saved and timers can be resumed. This is called automatically when the server reloads and will not lead to the at_stop() hook being called. This is a suspension of the script, not a change of state. unpause() - resumes a previously paused script. The at_start() hook will be called to allow it to reclaim its internal state. Timers etc are restored to what they were before pause. The server automatically unpauses all paused scripts after a server reload. force_repeat() - this will forcibly step the script, regardless of when it would otherwise have fired. The timer will reset and the at_repeat() hook is called as normal. This also counts towards the total number of repeats, if limited. time_until_next_repeat() - for timed scripts, this returns the time in seconds until it next fires. Returns None if interval==0 . remaining_repeats() - if the Script should run a limited amount of times, this tells us how many are currently left. reset_callcount(value=0) - this allows you to reset the number of times the Script has fired. It only makes sense if repeats > 0 . restart(interval=None, repeats=None, start_delay=None) - this method allows you to restart the Script in-place with different run settings. If you do, the at_stop hook will be called and the Script brought to a halt, then the at_start hook will be called as the Script starts up with your (possibly changed) settings. Any keyword left at None means to not change the original setting. Global Scripts \u00b6 A script does not have to be connected to an in-game object. If not it is called a Global script . You can create global scripts by simply not supplying an object to store it on: # adding a global script from evennia import create_script create_script(\"typeclasses.globals.MyGlobalEconomy\", key=\"economy\", persistent=True, obj=None) Henceforth you can then get it back by searching for its key or other identifier with evennia.search_script . In-game, the scripts command will show all scripts. Evennia supplies a convenient \"container\" called GLOBAL_SCRIPTS that can offer an easy way to access global scripts. If you know the name (key) of the script you can get it like so: from evennia import GLOBAL_SCRIPTS my_script = GLOBAL_SCRIPTS.my_script # needed if there are spaces in name or name determined on the fly another_script = GLOBAL_SCRIPTS.get(\"another script\") # get all global scripts (this returns a Queryset) all_scripts = GLOBAL_SCRIPTS.all() # you can operate directly on the script GLOBAL_SCRIPTS.weather.db.current_weather = \"Cloudy\" Note that global scripts appear as properties on GLOBAL_SCRIPTS based on their key . If you were to create two global scripts with the same key (even with different typeclasses), the GLOBAL_SCRIPTS container will only return one of them (which one depends on order in the database). Best is to organize your scripts so that this does not happen. Otherwise, use evennia.search_script to get exactly the script you want. There are two ways to make a script appear as a property on GLOBAL_SCRIPTS . The first is to manually create a new global script with create_script as mentioned above. Often you want this to happen automatically when the server starts though. For this you can use the setting GLOBAL_SCRIPTS : GLOBAL_SCRIPTS = { \"my_script\": { \"typeclass\": \"scripts.Weather\", \"repeats\": -1, \"interval\": 50, \"desc\": \"Weather script\" \"persistent\": True }, \"storagescript\": { \"typeclass\": \"scripts.Storage\", \"persistent\": True } } Here the key ( myscript and storagescript above) is required, all other fields are optional. If typeclass is not given, a script of type settings.BASE_SCRIPT_TYPECLASS is assumed. The keys related to timing and intervals are only needed if the script is timed. Evennia will use the information in settings.GLOBAL_SCRIPTS to automatically create and start these scripts when the server starts (unless they already exist, based on their key ). You need to reload the server before the setting is read and new scripts become available. You can then find the key you gave as properties on evennia.GLOBAL_SCRIPTS (such as evennia.GLOBAL_SCRIPTS.storagescript ). Note: Make sure that your Script typeclass does not have any critical errors. If so, you'll see errors in your log and your Script will temporarily fall back to being a DefaultScript type. Moreover, a script defined this way is guaranteed to exist when you try to access it: from evennia import GLOBAL_SCRIPTS # first stop the script GLOBAL_SCRIPTS.storagescript.stop() # running the `scripts` command now will show no storagescript # but below now it's recreated again! storage = GLOBAL_SCRIPTS.storagescript That is, if the script is deleted, next time you get it from GLOBAL_SCRIPTS , it will use the information in settings to recreate it for you. Note that if your goal with the Script is to store persistent data, you should set it as persistent=True , either in settings.GLOBAL_SCRIPTS or in the Scripts typeclass. Otherwise any data you wanted to store on it will be gone (since a new script of the same name is restarted instead). Dealing with Errors \u00b6 Errors inside an timed, executing script can sometimes be rather terse or point to parts of the execution mechanism that is hard to interpret. One way to make it easier to debug scripts is to import Evennia's native logger and wrap your functions in a try/catch block. Evennia's logger can show you where the traceback occurred in your script. from evennia.utils import logger class Weather(DefaultScript): # [...] def at_repeat(self): try: # [...] code as above except Exception: # logs the error logger.log_trace() Example of a timed script \u00b6 In-game you can try out scripts using the @script command. In the evennia/contrib/tutorial_examples/bodyfunctions.py is a little example script that makes you do little 'sounds' at random intervals. Try the following to apply an example time-based script to your character. > @script self = bodyfunctions.BodyFunctions Note: Since evennia/contrib/tutorial_examples is in the default setting TYPECLASS_PATHS , we only need to specify the final part of the path, that is, bodyfunctions.BodyFunctions . If you want to inflict your flatulence script on another person, place or thing, try something like the following: > @py self.location.search('matt').scripts.add('bodyfunctions.BodyFunctions') Here's how you stop it on yourself. > @script/stop self = bodyfunctions.BodyFunctions This will kill the script again. You can use the @scripts command to list all active scripts in the game, if any (there are none by default). For another example of a Script in use, check out the Turn Based Combat System tutorial .","title":"Scripts"},{"location":"Scripts.html#defining-new-scripts","text":"A Script is defined as a class and is created in the same way as other typeclassed entities. The class has several properties to control the timer-component of the scripts. These are all optional - leaving them out will just create a Script with no timer components (useful to act as a database store or to hold a persistent game system, for example). This you can do for example in the module evennia/typeclasses/scripts.py . Below is an example Script Typeclass. from evennia import DefaultScript class MyScript(DefaultScript): def at_script_creation(self): self.key = \"myscript\" self.interval = 60 # 1 min repeat def at_repeat(self): # do stuff every minute In mygame/typeclasses/scripts.py is the Script class which inherits from DefaultScript already. This is provided as your own base class to do with what you like: You can tweak Script if you want to change the default behavior and it is usually convenient to inherit from this instead. Here's an example: # for example in mygame/typeclasses/scripts.py # Script class is defined at the top of this module import random class Weather(Script): \"\"\" A timer script that displays weather info. Meant to be attached to a room. \"\"\" def at_script_creation(self): self.key = \"weather_script\" self.desc = \"Gives random weather messages.\" self.interval = 60 * 5 # every 5 minutes self.persistent = True # will survive reload def at_repeat(self): \"called every self.interval seconds.\" rand = random.random() if rand < 0.5: weather = \"A faint breeze is felt.\" elif rand < 0.7: weather = \"Clouds sweep across the sky.\" else: weather = \"There is a light drizzle of rain.\" # send this message to everyone inside the object this # script is attached to (likely a room) self.obj.msg_contents(weather) If we put this script on a room, it will randomly report some weather to everyone in the room every 5 minutes. To activate it, just add it to the script handler ( scripts ) on an Room . That object becomes self.obj in the example above. Here we put it on a room called myroom : myroom.scripts.add(scripts.Weather) Note that typeclasses in your game dir is added to the setting TYPECLASS_PATHS . Therefore we don't need to give the full path ( typeclasses.scripts.Weather but only scripts.Weather above. You can also create scripts using the evennia.create_script function: from evennia import create_script create_script('typeclasses.weather.Weather', obj=myroom) Note that if you were to give a keyword argument to create_script , that would override the default value in your Typeclass. So for example, here is an instance of the weather script that runs every 10 minutes instead (and also not survive a server reload): create_script('typeclasses.weather.Weather', obj=myroom, persistent=False, interval=10*60) From in-game you can use the @script command to launch the Script on things: @script here = weather.Weather You can conveniently view and kill running Scripts by using the @scripts command in-game.","title":"Defining new Scripts"},{"location":"Scripts.html#properties-and-functions-defined-on-scripts","text":"A Script has all the properties of a typeclassed object, such as db and ndb (see Typeclasses ). Setting key is useful in order to manage scripts (delete them by name etc). These are usually set up in the Script's typeclass, but can also be assigned on the fly as keyword arguments to evennia.create_script . desc - an optional description of the script's function. Seen in script listings. interval - how often the script should run. If interval == 0 (default), this script has no timing component, will not repeat and will exist forever. This is useful for Scripts used for storage or acting as bases for various non-time dependent game systems. start_delay - (bool), if we should wait interval seconds before firing for the first time or not. repeats - How many times we should repeat, assuming interval > 0 . If repeats is set to <= 0 , the script will repeat indefinitely. Note that each firing of the script (including the first one) counts towards this value. So a Script with start_delay=False and repeats=1 will start, immediately fire and shut down right away. persistent - if this script should survive a server reset or server shutdown . (You don't need to set this for it to survive a normal reload - the script will be paused and seamlessly restart after the reload is complete). There is one special property: obj - the Object this script is attached to (if any). You should not need to set this manually. If you add the script to the Object with myobj.scripts.add(myscriptpath) or give myobj as an argument to the utils.create.create_script function, the obj property will be set to myobj for you. It's also imperative to know the hook functions. Normally, overriding these are all the customization you'll need to do in Scripts. You can find longer descriptions of these in src/scripts/scripts.py . at_script_creation() - this is usually where the script class sets things like interval and repeats ; things that control how the script runs. It is only called once - when the script is first created. is_valid() - determines if the script should still be running or not. This is called when running obj.scripts.validate() , which you can run manually, but which is also called by Evennia during certain situations such as reloads. This is also useful for using scripts as state managers. If the method returns False , the script is stopped and cleanly removed. at_start() - this is called when the script starts or is unpaused. For persistent scripts this is at least once ever server startup. Note that this will always be called right away, also if start_delay is True . at_repeat() - this is called every interval seconds, or not at all. It is called right away at startup, unless start_delay is True , in which case the system will wait interval seconds before calling. at_stop() - this is called when the script stops for whatever reason. It's a good place to do custom cleanup. at_server_reload() - this is called whenever the server is warm-rebooted (e.g. with the @reload command). It's a good place to save non-persistent data you might want to survive a reload. at_server_shutdown() - this is called when a system reset or systems shutdown is invoked. Running methods (usually called automatically by the engine, but possible to also invoke manually) start() - this will start the script. This is called automatically whenever you add a new script to a handler. at_start() will be called. stop() - this will stop the script and delete it. Removing a script from a handler will stop it automatically. at_stop() will be called. pause() - this pauses a running script, rendering it inactive, but not deleting it. All properties are saved and timers can be resumed. This is called automatically when the server reloads and will not lead to the at_stop() hook being called. This is a suspension of the script, not a change of state. unpause() - resumes a previously paused script. The at_start() hook will be called to allow it to reclaim its internal state. Timers etc are restored to what they were before pause. The server automatically unpauses all paused scripts after a server reload. force_repeat() - this will forcibly step the script, regardless of when it would otherwise have fired. The timer will reset and the at_repeat() hook is called as normal. This also counts towards the total number of repeats, if limited. time_until_next_repeat() - for timed scripts, this returns the time in seconds until it next fires. Returns None if interval==0 . remaining_repeats() - if the Script should run a limited amount of times, this tells us how many are currently left. reset_callcount(value=0) - this allows you to reset the number of times the Script has fired. It only makes sense if repeats > 0 . restart(interval=None, repeats=None, start_delay=None) - this method allows you to restart the Script in-place with different run settings. If you do, the at_stop hook will be called and the Script brought to a halt, then the at_start hook will be called as the Script starts up with your (possibly changed) settings. Any keyword left at None means to not change the original setting.","title":"Properties and functions defined on Scripts"},{"location":"Scripts.html#global-scripts","text":"A script does not have to be connected to an in-game object. If not it is called a Global script . You can create global scripts by simply not supplying an object to store it on: # adding a global script from evennia import create_script create_script(\"typeclasses.globals.MyGlobalEconomy\", key=\"economy\", persistent=True, obj=None) Henceforth you can then get it back by searching for its key or other identifier with evennia.search_script . In-game, the scripts command will show all scripts. Evennia supplies a convenient \"container\" called GLOBAL_SCRIPTS that can offer an easy way to access global scripts. If you know the name (key) of the script you can get it like so: from evennia import GLOBAL_SCRIPTS my_script = GLOBAL_SCRIPTS.my_script # needed if there are spaces in name or name determined on the fly another_script = GLOBAL_SCRIPTS.get(\"another script\") # get all global scripts (this returns a Queryset) all_scripts = GLOBAL_SCRIPTS.all() # you can operate directly on the script GLOBAL_SCRIPTS.weather.db.current_weather = \"Cloudy\" Note that global scripts appear as properties on GLOBAL_SCRIPTS based on their key . If you were to create two global scripts with the same key (even with different typeclasses), the GLOBAL_SCRIPTS container will only return one of them (which one depends on order in the database). Best is to organize your scripts so that this does not happen. Otherwise, use evennia.search_script to get exactly the script you want. There are two ways to make a script appear as a property on GLOBAL_SCRIPTS . The first is to manually create a new global script with create_script as mentioned above. Often you want this to happen automatically when the server starts though. For this you can use the setting GLOBAL_SCRIPTS : GLOBAL_SCRIPTS = { \"my_script\": { \"typeclass\": \"scripts.Weather\", \"repeats\": -1, \"interval\": 50, \"desc\": \"Weather script\" \"persistent\": True }, \"storagescript\": { \"typeclass\": \"scripts.Storage\", \"persistent\": True } } Here the key ( myscript and storagescript above) is required, all other fields are optional. If typeclass is not given, a script of type settings.BASE_SCRIPT_TYPECLASS is assumed. The keys related to timing and intervals are only needed if the script is timed. Evennia will use the information in settings.GLOBAL_SCRIPTS to automatically create and start these scripts when the server starts (unless they already exist, based on their key ). You need to reload the server before the setting is read and new scripts become available. You can then find the key you gave as properties on evennia.GLOBAL_SCRIPTS (such as evennia.GLOBAL_SCRIPTS.storagescript ). Note: Make sure that your Script typeclass does not have any critical errors. If so, you'll see errors in your log and your Script will temporarily fall back to being a DefaultScript type. Moreover, a script defined this way is guaranteed to exist when you try to access it: from evennia import GLOBAL_SCRIPTS # first stop the script GLOBAL_SCRIPTS.storagescript.stop() # running the `scripts` command now will show no storagescript # but below now it's recreated again! storage = GLOBAL_SCRIPTS.storagescript That is, if the script is deleted, next time you get it from GLOBAL_SCRIPTS , it will use the information in settings to recreate it for you. Note that if your goal with the Script is to store persistent data, you should set it as persistent=True , either in settings.GLOBAL_SCRIPTS or in the Scripts typeclass. Otherwise any data you wanted to store on it will be gone (since a new script of the same name is restarted instead).","title":"Global Scripts"},{"location":"Scripts.html#dealing-with-errors","text":"Errors inside an timed, executing script can sometimes be rather terse or point to parts of the execution mechanism that is hard to interpret. One way to make it easier to debug scripts is to import Evennia's native logger and wrap your functions in a try/catch block. Evennia's logger can show you where the traceback occurred in your script. from evennia.utils import logger class Weather(DefaultScript): # [...] def at_repeat(self): try: # [...] code as above except Exception: # logs the error logger.log_trace()","title":"Dealing with Errors"},{"location":"Scripts.html#example-of-a-timed-script","text":"In-game you can try out scripts using the @script command. In the evennia/contrib/tutorial_examples/bodyfunctions.py is a little example script that makes you do little 'sounds' at random intervals. Try the following to apply an example time-based script to your character. > @script self = bodyfunctions.BodyFunctions Note: Since evennia/contrib/tutorial_examples is in the default setting TYPECLASS_PATHS , we only need to specify the final part of the path, that is, bodyfunctions.BodyFunctions . If you want to inflict your flatulence script on another person, place or thing, try something like the following: > @py self.location.search('matt').scripts.add('bodyfunctions.BodyFunctions') Here's how you stop it on yourself. > @script/stop self = bodyfunctions.BodyFunctions This will kill the script again. You can use the @scripts command to list all active scripts in the game, if any (there are none by default). For another example of a Script in use, check out the Turn Based Combat System tutorial .","title":"Example of a timed script"},{"location":"Security.html","text":"Hackers these days aren't discriminating, and their backgrounds range from bored teenagers to international intelligence agencies. Their scripts and bots endlessly crawl the web, looking for vulnerable systems they can break into. Who owns the system is irrelevant-- it doesn't matter if it belongs to you or the Pentagon, the goal is to take advantage of poorly-secured systems and see what resources can be controlled or stolen from them. If you're considering deploying to a cloud-based host, you have a vested interest in securing your applications-- you likely have a credit card on file that your host can freely bill. Hackers pegging your CPU to mine cryptocurrency or saturating your network connection to participate in a botnet or send spam can run up your hosting bill, get your service suspended or get your address/site blacklisted by ISPs. It can be a difficult legal or political battle to undo this damage after the fact. As a developer about to expose a web application to the threat landscape of the modern internet, here are a few tips to consider to increase the security of your Evennia install. Know your logs \u00b6 In case of emergency, check your logs! By default they are located in the server/logs/ folder. Here are some of the more important ones and why you should care: http_requests.log will show you what HTTP requests have been made against Evennia's built-in webserver (TwistedWeb). This is a good way to see if people are innocuously browsing your site or trying to break it through code injection. portal.log will show you various networking-related information. This is a good place to check for odd or unusual types or amounts of connections to your game, or other networking-related issues-- like when users are reporting an inability to connect. server.log is the MUX administrator's best friend. Here is where you'll find information pertaining to who's trying to break into your system by guessing at passwords, who created what objects, and more. If your game fails to start or crashes and you can't tell why, this is the first place you should look for answers. Security-related events are prefixed with an [SS] so when there's a problem you might want to pay special attention to those. Disable development/debugging options \u00b6 There are a few Evennia/Django options that are set when you first create your game to make it more obvious to you where problems arise. These options should be disabled before you push your game into production-- leaving them on can expose variables or code someone with malicious intent can easily abuse to compromise your environment. In server/conf/settings.py : # Disable Django's debug mode DEBUG = False # Disable the in-game equivalent IN_GAME_ERRORS = False # If you've registered a domain name, force Django to check host headers. Otherwise leave this as-is. # Note the leading period-- it is not a typo! ALLOWED_HOSTS = ['.example.com'] Handle user-uploaded images with care \u00b6 If you decide to allow users to upload their own images to be served from your site, special care must be taken. Django will read the file headers to confirm it's an image (as opposed to a document or zip archive), but code can be injected into an image file after the headers that can be interpreted as HTML and/or give an attacker a web shell through which they can access other filesystem resources. Django has a more comprehensive overview of how to handle user-uploaded files , but in short you should take care to do one of two things-- Serve all user-uploaded assets from a separate domain or CDN ( not a subdomain of the one you already have!). For example, you may be browsing reddit.com but note that all the user-submitted images are being served from the redd.it domain. There are both security and performance benefits to this (webservers tend to load local resources one-by-one, whereas they will request external resources in bulk). If you don't want to pay for a second domain, don't understand what any of this means or can't be bothered with additional infrastructure, then simply reprocess user images upon receipt using an image library. Convert them to a different format, for example. Destroy the originals! Disable the web interface \u00b6 The web interface allows visitors to see an informational page as well as log into a browser-based telnet client with which to access Evennia. It also provides authentication endpoints against which an attacker can attempt to validate stolen lists of credentials to see which ones might be shared by your users. Django's security is robust, but if you don't want/need these features and fully intend to force your users to use traditional clients to access your game, you might consider disabling either/both to minimize your attack surface. In server/conf/settings.py : # Disable the Javascript webclient WEBCLIENT_ENABLED = False # Disable the website altogether WEBSERVER_ENABLED = False Change your ssh port \u00b6 Automated attacks will often target port 22 seeing as how it's the standard port for SSH traffic. Also, many public wifi hotspots block ssh traffic over port 22 so you might not be able to access your server from these locations if you like to work remotely or don't have a home internet connection. If you don't intend on running a website or securing it with TLS, you can mitigate both problems by changing the port used for ssh to 443, which most/all hotspot providers assume is HTTPS traffic and allows through. (Ubuntu) In /etc/ssh/sshd_config, change the following variable: # What ports, IPs and protocols we listen for Port 443 Save, close, then run the following command: sudo service ssh restart Set up a firewall \u00b6 Ubuntu users can make use of the simple ufw utility. Anybody else can use iptables. # Install ufw (if not already) sudo apt-get install ufw UFW's default policy is to deny everything. We must specify what we want to allow through our firewall. # Allow terminal connections to your game sudo ufw allow 4000/tcp # Allow browser connections to your website sudo ufw allow 4001/tcp Use ONE of the next two commands depending on which port your ssh daemon is listening on: sudo ufw allow 22/tcp sudo ufw allow 443/tcp Finally: sudo ufw enable Now the only ports open will be your administrative ssh port (whichever you chose), and Evennia on 4000-4001. Use an external webserver \u00b6 Though not officially supported, there are some benefits to deploying a webserver to handle/proxy traffic to your Evennia instance. For example, Evennia's game engine and webservice are tightly integrated. If you bring your game down for maintenance (or if it simply crashes) your website will go down with it. In these cases a standalone webserver can still be used to display a maintenance page or otherwise communicate to your users the reason for the downtime, instead of disappearing off the face of the earth and returning opaque SERVER NOT FOUND error messages. Proper webservers are also written in more efficient programming languages than Python, and while Twisted can handle its own, putting a webserver in front of it is like hiring a bouncer to deal with nuisances and crowds before they even get in the door. Many of the popular webservers also let you plug in additional modules (like mod_security for Apache) that can be used to detect (and block!) malicious users or requests before they even touch your game or site. There are also automated solutions for installing and configuring TLS (via Certbot/Let's Encrypt ) to secure your website against hotspot and ISP snooping.","title":"Security"},{"location":"Security.html#know-your-logs","text":"In case of emergency, check your logs! By default they are located in the server/logs/ folder. Here are some of the more important ones and why you should care: http_requests.log will show you what HTTP requests have been made against Evennia's built-in webserver (TwistedWeb). This is a good way to see if people are innocuously browsing your site or trying to break it through code injection. portal.log will show you various networking-related information. This is a good place to check for odd or unusual types or amounts of connections to your game, or other networking-related issues-- like when users are reporting an inability to connect. server.log is the MUX administrator's best friend. Here is where you'll find information pertaining to who's trying to break into your system by guessing at passwords, who created what objects, and more. If your game fails to start or crashes and you can't tell why, this is the first place you should look for answers. Security-related events are prefixed with an [SS] so when there's a problem you might want to pay special attention to those.","title":"Know your logs"},{"location":"Security.html#disable-developmentdebugging-options","text":"There are a few Evennia/Django options that are set when you first create your game to make it more obvious to you where problems arise. These options should be disabled before you push your game into production-- leaving them on can expose variables or code someone with malicious intent can easily abuse to compromise your environment. In server/conf/settings.py : # Disable Django's debug mode DEBUG = False # Disable the in-game equivalent IN_GAME_ERRORS = False # If you've registered a domain name, force Django to check host headers. Otherwise leave this as-is. # Note the leading period-- it is not a typo! ALLOWED_HOSTS = ['.example.com']","title":"Disable development/debugging options"},{"location":"Security.html#handle-user-uploaded-images-with-care","text":"If you decide to allow users to upload their own images to be served from your site, special care must be taken. Django will read the file headers to confirm it's an image (as opposed to a document or zip archive), but code can be injected into an image file after the headers that can be interpreted as HTML and/or give an attacker a web shell through which they can access other filesystem resources. Django has a more comprehensive overview of how to handle user-uploaded files , but in short you should take care to do one of two things-- Serve all user-uploaded assets from a separate domain or CDN ( not a subdomain of the one you already have!). For example, you may be browsing reddit.com but note that all the user-submitted images are being served from the redd.it domain. There are both security and performance benefits to this (webservers tend to load local resources one-by-one, whereas they will request external resources in bulk). If you don't want to pay for a second domain, don't understand what any of this means or can't be bothered with additional infrastructure, then simply reprocess user images upon receipt using an image library. Convert them to a different format, for example. Destroy the originals!","title":"Handle user-uploaded images with care"},{"location":"Security.html#disable-the-web-interface","text":"The web interface allows visitors to see an informational page as well as log into a browser-based telnet client with which to access Evennia. It also provides authentication endpoints against which an attacker can attempt to validate stolen lists of credentials to see which ones might be shared by your users. Django's security is robust, but if you don't want/need these features and fully intend to force your users to use traditional clients to access your game, you might consider disabling either/both to minimize your attack surface. In server/conf/settings.py : # Disable the Javascript webclient WEBCLIENT_ENABLED = False # Disable the website altogether WEBSERVER_ENABLED = False","title":"Disable the web interface"},{"location":"Security.html#change-your-ssh-port","text":"Automated attacks will often target port 22 seeing as how it's the standard port for SSH traffic. Also, many public wifi hotspots block ssh traffic over port 22 so you might not be able to access your server from these locations if you like to work remotely or don't have a home internet connection. If you don't intend on running a website or securing it with TLS, you can mitigate both problems by changing the port used for ssh to 443, which most/all hotspot providers assume is HTTPS traffic and allows through. (Ubuntu) In /etc/ssh/sshd_config, change the following variable: # What ports, IPs and protocols we listen for Port 443 Save, close, then run the following command: sudo service ssh restart","title":"Change your ssh port"},{"location":"Security.html#set-up-a-firewall","text":"Ubuntu users can make use of the simple ufw utility. Anybody else can use iptables. # Install ufw (if not already) sudo apt-get install ufw UFW's default policy is to deny everything. We must specify what we want to allow through our firewall. # Allow terminal connections to your game sudo ufw allow 4000/tcp # Allow browser connections to your website sudo ufw allow 4001/tcp Use ONE of the next two commands depending on which port your ssh daemon is listening on: sudo ufw allow 22/tcp sudo ufw allow 443/tcp Finally: sudo ufw enable Now the only ports open will be your administrative ssh port (whichever you chose), and Evennia on 4000-4001.","title":"Set up a firewall"},{"location":"Security.html#use-an-external-webserver","text":"Though not officially supported, there are some benefits to deploying a webserver to handle/proxy traffic to your Evennia instance. For example, Evennia's game engine and webservice are tightly integrated. If you bring your game down for maintenance (or if it simply crashes) your website will go down with it. In these cases a standalone webserver can still be used to display a maintenance page or otherwise communicate to your users the reason for the downtime, instead of disappearing off the face of the earth and returning opaque SERVER NOT FOUND error messages. Proper webservers are also written in more efficient programming languages than Python, and while Twisted can handle its own, putting a webserver in front of it is like hiring a bouncer to deal with nuisances and crowds before they even get in the door. Many of the popular webservers also let you plug in additional modules (like mod_security for Apache) that can be used to detect (and block!) malicious users or requests before they even touch your game or site. There are also automated solutions for installing and configuring TLS (via Certbot/Let's Encrypt ) to secure your website against hotspot and ISP snooping.","title":"Use an external webserver"},{"location":"Server-Conf.html","text":"Evennia runs out of the box without any changes to its settings. But there are several important ways to customize the server and expand it with your own plugins. Settings file \u00b6 The \"Settings\" file referenced throughout the documentation is the file mygame/server/conf/settings.py . This is automatically created on the first run of evennia --init (see the Getting Started page). Your new settings.py is relatively bare out of the box. Evennia's core settings file is actually evennia/settings_default.py and is considerably more extensive (it is also heavily documented so you should refer to this file directly for the available settings). Since mygame/server/conf/settings.py is a normal Python module, it simply imports evennia/settings_default.py into itself at the top. This means that if any setting you want to change were to depend on some other default setting, you might need to copy & paste both in order to change them and get the effect you want (for most commonly changed settings, this is not something you need to worry about). You should never edit evennia/settings_default.py . Rather you should copy&paste the select variables you want to change into your settings.py and edit them there. This will overload the previously imported defaults. Warning: It may be tempting to copy everything from settings_default.py into your own settings file. There is a reason we don't do this out of the box though: it makes it directly clear what changes you did. Also, if you limit your copying to the things you really need you will directly be able to take advantage of upstream changes and additions to Evennia for anything you didn't customize. In code, the settings is accessed through from django.conf import settings # or (shorter): from evennia import settings # example: servername = settings.SERVER_NAME Each setting appears as a property on the imported settings object. You can also explore all possible options with evennia.settings_full (this also includes advanced Django defaults that are not touched in default Evennia). It should be pointed out that when importing settings into your code like this, it will be read only . You cannot edit your settings from your code! The only way to change an Evennia setting is to edit mygame/server/conf/settings.py directly. You also generally need to restart the server (possibly also the Portal) before a changed setting becomes available. Other files in the server/conf directory \u00b6 Apart from the main settings.py file, at_initial_setup.py - this allows you to add a custom startup method to be called (only) the very first time Evennia starts (at the same time as user #1 and Limbo is created). It can be made to start your own global scripts or set up other system/world-related things your game needs to have running from the start. at_server_startstop.py - this module contains two functions that Evennia will call every time the Server starts and stops respectively - this includes stopping due to reloading and resetting as well as shutting down completely. It's a useful place to put custom startup code for handlers and other things that must run in your game but which has no database persistence. connection_screens.py - all global string variables in this module are interpreted by Evennia as a greeting screen to show when an Account first connects. If more than one string variable is present in the module a random one will be picked. inlinefuncs.py - this is where you can define custom Inline functions . inputfuncs.py - this is where you define custom Input functions to handle data from the client. lockfuncs.py - this is one of many possible modules to hold your own \"safe\" lock functions to make available to Evennia's Locks . mssp.py - this holds meta information about your game. It is used by MUD search engines (which you often have to register with) in order to display what kind of game you are running along with statistics such as number of online accounts and online status. oobfuncs.py - in here you can define custom OOB functions . portal_services_plugin.py - this allows for adding your own custom services/protocols to the Portal. It must define one particular function that will be called by Evennia at startup. There can be any number of service plugin modules, all will be imported and used if defined. More info can be found here . server_services_plugin.py - this is equivalent to the previous one, but used for adding new services to the Server instead. More info can be found here . Some other Evennia systems can be customized by plugin modules but has no explicit template in conf/ : cmdparser.py - a custom module can be used to totally replace Evennia's default command parser. All this does is to split the incoming string into \"command name\" and \"the rest\". It also handles things like error messages for no-matches and multiple-matches among other things that makes this more complex than it sounds. The default parser is very generic, so you are most often best served by modifying things further down the line (on the command parse level) than here. at_search.py - this allows for replacing the way Evennia handles search results. It allows to change how errors are echoed and how multi-matches are resolved and reported (like how the default understands that \"2-ball\" should match the second \"ball\" object if there are two of them in the room). ServerConf \u00b6 There is a special database model called ServerConf that stores server internal data and settings such as current account count (for interfacing with the webserver), startup status and many other things. It's rarely of use outside the server core itself but may be good to know about if you are an Evennia developer.","title":"Server Conf"},{"location":"Server-Conf.html#settings-file","text":"The \"Settings\" file referenced throughout the documentation is the file mygame/server/conf/settings.py . This is automatically created on the first run of evennia --init (see the Getting Started page). Your new settings.py is relatively bare out of the box. Evennia's core settings file is actually evennia/settings_default.py and is considerably more extensive (it is also heavily documented so you should refer to this file directly for the available settings). Since mygame/server/conf/settings.py is a normal Python module, it simply imports evennia/settings_default.py into itself at the top. This means that if any setting you want to change were to depend on some other default setting, you might need to copy & paste both in order to change them and get the effect you want (for most commonly changed settings, this is not something you need to worry about). You should never edit evennia/settings_default.py . Rather you should copy&paste the select variables you want to change into your settings.py and edit them there. This will overload the previously imported defaults. Warning: It may be tempting to copy everything from settings_default.py into your own settings file. There is a reason we don't do this out of the box though: it makes it directly clear what changes you did. Also, if you limit your copying to the things you really need you will directly be able to take advantage of upstream changes and additions to Evennia for anything you didn't customize. In code, the settings is accessed through from django.conf import settings # or (shorter): from evennia import settings # example: servername = settings.SERVER_NAME Each setting appears as a property on the imported settings object. You can also explore all possible options with evennia.settings_full (this also includes advanced Django defaults that are not touched in default Evennia). It should be pointed out that when importing settings into your code like this, it will be read only . You cannot edit your settings from your code! The only way to change an Evennia setting is to edit mygame/server/conf/settings.py directly. You also generally need to restart the server (possibly also the Portal) before a changed setting becomes available.","title":"Settings file"},{"location":"Server-Conf.html#other-files-in-the-serverconf-directory","text":"Apart from the main settings.py file, at_initial_setup.py - this allows you to add a custom startup method to be called (only) the very first time Evennia starts (at the same time as user #1 and Limbo is created). It can be made to start your own global scripts or set up other system/world-related things your game needs to have running from the start. at_server_startstop.py - this module contains two functions that Evennia will call every time the Server starts and stops respectively - this includes stopping due to reloading and resetting as well as shutting down completely. It's a useful place to put custom startup code for handlers and other things that must run in your game but which has no database persistence. connection_screens.py - all global string variables in this module are interpreted by Evennia as a greeting screen to show when an Account first connects. If more than one string variable is present in the module a random one will be picked. inlinefuncs.py - this is where you can define custom Inline functions . inputfuncs.py - this is where you define custom Input functions to handle data from the client. lockfuncs.py - this is one of many possible modules to hold your own \"safe\" lock functions to make available to Evennia's Locks . mssp.py - this holds meta information about your game. It is used by MUD search engines (which you often have to register with) in order to display what kind of game you are running along with statistics such as number of online accounts and online status. oobfuncs.py - in here you can define custom OOB functions . portal_services_plugin.py - this allows for adding your own custom services/protocols to the Portal. It must define one particular function that will be called by Evennia at startup. There can be any number of service plugin modules, all will be imported and used if defined. More info can be found here . server_services_plugin.py - this is equivalent to the previous one, but used for adding new services to the Server instead. More info can be found here . Some other Evennia systems can be customized by plugin modules but has no explicit template in conf/ : cmdparser.py - a custom module can be used to totally replace Evennia's default command parser. All this does is to split the incoming string into \"command name\" and \"the rest\". It also handles things like error messages for no-matches and multiple-matches among other things that makes this more complex than it sounds. The default parser is very generic, so you are most often best served by modifying things further down the line (on the command parse level) than here. at_search.py - this allows for replacing the way Evennia handles search results. It allows to change how errors are echoed and how multi-matches are resolved and reported (like how the default understands that \"2-ball\" should match the second \"ball\" object if there are two of them in the room).","title":"Other files in the server/conf directory"},{"location":"Server-Conf.html#serverconf","text":"There is a special database model called ServerConf that stores server internal data and settings such as current account count (for interfacing with the webserver), startup status and many other things. It's rarely of use outside the server core itself but may be good to know about if you are an Evennia developer.","title":"ServerConf"},{"location":"Sessions.html","text":"An Evennia Session represents one single established connection to the server. Depending on the Evennia session, it is possible for a person to connect multiple times, for example using different clients in multiple windows. Each such connection is represented by a session object. A session object has its own cmdset , usually the \"unloggedin\" cmdset. This is what is used to show the login screen and to handle commands to create a new account (or Account in evennia lingo) read initial help and to log into the game with an existing account. A session object can either be \"logged in\" or not. Logged in means that the user has authenticated. When this happens the session is associated with an Account object (which is what holds account-centric stuff). The account can then in turn puppet any number of objects/characters. Warning: A Session is not persistent - it is not a Typeclass and has no connection to the database. The Session will go away when a user disconnects and you will lose any custom data on it if the server reloads. The .db handler on Sessions is there to present a uniform API (so you can assume .db exists even if you don't know if you receive an Object or a Session), but this is just an alias to .ndb . So don't store any data on Sessions that you can't afford to lose in a reload. You have been warned. Properties on Sessions \u00b6 Here are some important properties available on (Server-)Sessions sessid - The unique session-id. This is an integer starting from 1. address - The connected client's address. Different protocols give different information here. logged_in - True if the user authenticated to this session. account - The Account this Session is attached to. If not logged in yet, this is None . puppet - The Character/Object currently puppeted by this Account/Session combo. If not logged in or in OOC mode, this is None . ndb - The Non-persistent Attribute handler. db - As noted above, Sessions don't have regular Attributes. This is an alias to ndb . cmdset - The Session's CmdSetHandler Session statistics are mainly used internally by Evennia. conn_time - How long this Session has been connected cmd_last - Last active time stamp. This will be reset by sending idle keepalives. cmd_last_visible - last active time stamp. This ignores idle keepalives and representes the last time this session was truly visibly active. cmd_total - Total number of Commands passed through this Session. Multisession mode \u00b6 The number of sessions possible to connect to a given account at the same time and how it works is given by the MULTISESSION_MODE setting: MULTISESSION_MODE=0 : One session per account. When connecting with a new session the old one is disconnected. This is the default mode and emulates many classic mud code bases. In default Evennia, this mode also changes how the create account Command works - it will automatically create a Character with the same name as the Account. When logging in, the login command is also modified to have the player automatically puppet that Character. This makes the distinction between Account and Character minimal from the player's perspective. MULTISESSION_MODE=1 : Many sessions per account, input/output from/to each session is treated the same. For the player this means they can connect to the game from multiple clients and see the same output in all of them. The result of a command given in one client (that is, through one Session) will be returned to all connected Sessions/clients with no distinction. This mode will have the Session(s) auto-create and puppet a Character in the same way as mode 0. MULTISESSION_MODE=2 : Many sessions per account, one character per session. In this mode, puppeting an Object/Character will link the puppet back only to the particular Session doing the puppeting. That is, input from that Session will make use of the CmdSet of that Object/Character and outgoing messages (such as the result of a look ) will be passed back only to that puppeting Session. If another Session tries to puppet the same Character, the old Session will automatically un-puppet it. From the player's perspective, this will mean that they can open separate game clients and play a different Character in each using one game account. This mode will not auto-create a Character and not auto-puppet on login like in modes 0 and 1. Instead it changes how the account-cmdsets's OOCLook command works so as to show a simple 'character select' menu. MULTISESSION_MODE=3 : Many sessions per account and character. This is the full multi-puppeting mode, where multiple sessions may not only connect to the player account but multiple sessions may also puppet a single character at the same time. From the user's perspective it means one can open multiple client windows, some for controlling different Characters and some that share a Character's input/output like in mode 1. This mode otherwise works the same as mode 2. Note that even if multiple Sessions puppet one Character, there is only ever one instance of that Character. Returning data to the session \u00b6 When you use msg() to return data to a user, the object on which you call the msg() matters. The MULTISESSION_MODE also matters, especially if greater than 1. For example, if you use account.msg(\"hello\") there is no way for evennia to know which session it should send the greeting to. In this case it will send it to all sessions. If you want a specific session you need to supply its session to the msg call ( account.msg(\"hello\", session=mysession) ). On the other hand, if you call the msg() message on a puppeted object, like character.msg(\"hello\") , the character already knows the session that controls it - it will cleverly auto-add this for you (you can specify a different session if you specifically want to send stuff to another session). Finally, there is a wrapper for msg() on all command classes: command.msg() . This will transparently detect which session was triggering the command (if any) and redirects to that session (this is most often what you want). If you are having trouble redirecting to a given session, command.msg() is often the safest bet. You can get the session in two main ways: * Accounts and Objects (including Characters) have a sessions property. This is a handler that tracks all Sessions attached to or puppeting them. Use e.g. accounts.sessions.get() to get a list of Sessions attached to that entity. * A Command instance has a session property that always points back to the Session that triggered it (it's always a single one). It will be None if no session is involved, like when a mob or script triggers the Command. Customizing the Session object \u00b6 When would one want to customize the Session object? Consider for example a character creation system: You might decide to keep this on the out-of-character level. This would mean that you create the character at the end of some sort of menu choice. The actual char-create cmdset would then normally be put on the account. This works fine as long as you are MULTISESSION_MODE below 2. For higher modes, replacing the Account cmdset will affect all your connected sessions, also those not involved in character creation. In this case you want to instead put the char-create cmdset on the Session level - then all other sessions will keep working normally despite you creating a new character in one of them. By default, the session object gets the commands.default_cmdsets.UnloggedinCmdSet when the user first connects. Once the session is authenticated it has no default sets. To add a \"logged-in\" cmdset to the Session, give the path to the cmdset class with settings.CMDSET_SESSION . This set will then henceforth always be present as soon as the account logs in. To customize further you can completely override the Session with your own subclass. To replace the default Session class, change settings.SERVER_SESSION_CLASS to point to your custom class. This is a dangerous practice and errors can easily make your game unplayable. Make sure to take heed of the original and make your changes carefully. Portal and Server Sessions \u00b6 Note: This is considered an advanced topic. You don't need to know this on a first read-through. Evennia is split into two parts, the Portal and the Server . Each side tracks its own Sessions, syncing them to each other. The \"Session\" we normally refer to is actually the ServerSession . Its counter-part on the Portal side is the PortalSession . Whereas the server sessions deal with game states, the portal session deals with details of the connection-protocol itself. The two are also acting as backups of critical data such as when the server reboots. New Account connections are listened for and handled by the Portal using the protocols it understands (such as telnet, ssh, webclient etc). When a new connection is established, a PortalSession is created on the Portal side. This session object looks different depending on which protocol is used to connect, but all still have a minimum set of attributes that are generic to all sessions. These common properties are piped from the Portal, through the AMP connection, to the Server, which is now informed a new connection has been established. On the Server side, a ServerSession object is created to represent this. There is only one type of ServerSession ; It looks the same regardless of how the Account connects. From now on, there is a one-to-one match between the ServerSession on one side of the AMP connection and the PortalSession on the other. Data arriving to the Portal Session is sent on to its mirror Server session and vice versa. During certain situations, the portal- and server-side sessions are \"synced\" with each other: - The Player closes their client, killing the Portal Session. The Portal syncs with the Server to make sure the corresponding Server Session is also deleted. - The Player quits from inside the game, killing the Server Session. The Server then syncs with the Portal to make sure to close the Portal connection cleanly. - The Server is rebooted/reset/shutdown - The Server Sessions are copied over (\"saved\") to the Portal side. When the Server comes back up, this data is returned by the Portal so the two are again in sync. This way an Account's login status and other connection-critical things can survive a server reboot (assuming the Portal is not stopped at the same time, obviously). Sessionhandlers \u00b6 Both the Portal and Server each have a sessionhandler to manage the connections. These handlers are global entities contain all methods for relaying data across the AMP bridge. All types of Sessions hold a reference to their respective Sessionhandler (the property is called sessionhandler ) so they can relay data. See protocols for more info on building new protocols. To get all Sessions in the game (i.e. all currently connected clients), you access the server-side Session handler, which you get by from evennia.server.sessionhandler import SESSION_HANDLER Note: The SESSION_HANDLER singleton has an older alias SESSIONS that is commonly seen in various places as well. See the sessionhandler.py module for details on the capabilities of the ServerSessionHandler .","title":"Sessions"},{"location":"Sessions.html#properties-on-sessions","text":"Here are some important properties available on (Server-)Sessions sessid - The unique session-id. This is an integer starting from 1. address - The connected client's address. Different protocols give different information here. logged_in - True if the user authenticated to this session. account - The Account this Session is attached to. If not logged in yet, this is None . puppet - The Character/Object currently puppeted by this Account/Session combo. If not logged in or in OOC mode, this is None . ndb - The Non-persistent Attribute handler. db - As noted above, Sessions don't have regular Attributes. This is an alias to ndb . cmdset - The Session's CmdSetHandler Session statistics are mainly used internally by Evennia. conn_time - How long this Session has been connected cmd_last - Last active time stamp. This will be reset by sending idle keepalives. cmd_last_visible - last active time stamp. This ignores idle keepalives and representes the last time this session was truly visibly active. cmd_total - Total number of Commands passed through this Session.","title":"Properties on Sessions"},{"location":"Sessions.html#multisession-mode","text":"The number of sessions possible to connect to a given account at the same time and how it works is given by the MULTISESSION_MODE setting: MULTISESSION_MODE=0 : One session per account. When connecting with a new session the old one is disconnected. This is the default mode and emulates many classic mud code bases. In default Evennia, this mode also changes how the create account Command works - it will automatically create a Character with the same name as the Account. When logging in, the login command is also modified to have the player automatically puppet that Character. This makes the distinction between Account and Character minimal from the player's perspective. MULTISESSION_MODE=1 : Many sessions per account, input/output from/to each session is treated the same. For the player this means they can connect to the game from multiple clients and see the same output in all of them. The result of a command given in one client (that is, through one Session) will be returned to all connected Sessions/clients with no distinction. This mode will have the Session(s) auto-create and puppet a Character in the same way as mode 0. MULTISESSION_MODE=2 : Many sessions per account, one character per session. In this mode, puppeting an Object/Character will link the puppet back only to the particular Session doing the puppeting. That is, input from that Session will make use of the CmdSet of that Object/Character and outgoing messages (such as the result of a look ) will be passed back only to that puppeting Session. If another Session tries to puppet the same Character, the old Session will automatically un-puppet it. From the player's perspective, this will mean that they can open separate game clients and play a different Character in each using one game account. This mode will not auto-create a Character and not auto-puppet on login like in modes 0 and 1. Instead it changes how the account-cmdsets's OOCLook command works so as to show a simple 'character select' menu. MULTISESSION_MODE=3 : Many sessions per account and character. This is the full multi-puppeting mode, where multiple sessions may not only connect to the player account but multiple sessions may also puppet a single character at the same time. From the user's perspective it means one can open multiple client windows, some for controlling different Characters and some that share a Character's input/output like in mode 1. This mode otherwise works the same as mode 2. Note that even if multiple Sessions puppet one Character, there is only ever one instance of that Character.","title":"Multisession mode"},{"location":"Sessions.html#returning-data-to-the-session","text":"When you use msg() to return data to a user, the object on which you call the msg() matters. The MULTISESSION_MODE also matters, especially if greater than 1. For example, if you use account.msg(\"hello\") there is no way for evennia to know which session it should send the greeting to. In this case it will send it to all sessions. If you want a specific session you need to supply its session to the msg call ( account.msg(\"hello\", session=mysession) ). On the other hand, if you call the msg() message on a puppeted object, like character.msg(\"hello\") , the character already knows the session that controls it - it will cleverly auto-add this for you (you can specify a different session if you specifically want to send stuff to another session). Finally, there is a wrapper for msg() on all command classes: command.msg() . This will transparently detect which session was triggering the command (if any) and redirects to that session (this is most often what you want). If you are having trouble redirecting to a given session, command.msg() is often the safest bet. You can get the session in two main ways: * Accounts and Objects (including Characters) have a sessions property. This is a handler that tracks all Sessions attached to or puppeting them. Use e.g. accounts.sessions.get() to get a list of Sessions attached to that entity. * A Command instance has a session property that always points back to the Session that triggered it (it's always a single one). It will be None if no session is involved, like when a mob or script triggers the Command.","title":"Returning data to the session"},{"location":"Sessions.html#customizing-the-session-object","text":"When would one want to customize the Session object? Consider for example a character creation system: You might decide to keep this on the out-of-character level. This would mean that you create the character at the end of some sort of menu choice. The actual char-create cmdset would then normally be put on the account. This works fine as long as you are MULTISESSION_MODE below 2. For higher modes, replacing the Account cmdset will affect all your connected sessions, also those not involved in character creation. In this case you want to instead put the char-create cmdset on the Session level - then all other sessions will keep working normally despite you creating a new character in one of them. By default, the session object gets the commands.default_cmdsets.UnloggedinCmdSet when the user first connects. Once the session is authenticated it has no default sets. To add a \"logged-in\" cmdset to the Session, give the path to the cmdset class with settings.CMDSET_SESSION . This set will then henceforth always be present as soon as the account logs in. To customize further you can completely override the Session with your own subclass. To replace the default Session class, change settings.SERVER_SESSION_CLASS to point to your custom class. This is a dangerous practice and errors can easily make your game unplayable. Make sure to take heed of the original and make your changes carefully.","title":"Customizing the Session object"},{"location":"Sessions.html#portal-and-server-sessions","text":"Note: This is considered an advanced topic. You don't need to know this on a first read-through. Evennia is split into two parts, the Portal and the Server . Each side tracks its own Sessions, syncing them to each other. The \"Session\" we normally refer to is actually the ServerSession . Its counter-part on the Portal side is the PortalSession . Whereas the server sessions deal with game states, the portal session deals with details of the connection-protocol itself. The two are also acting as backups of critical data such as when the server reboots. New Account connections are listened for and handled by the Portal using the protocols it understands (such as telnet, ssh, webclient etc). When a new connection is established, a PortalSession is created on the Portal side. This session object looks different depending on which protocol is used to connect, but all still have a minimum set of attributes that are generic to all sessions. These common properties are piped from the Portal, through the AMP connection, to the Server, which is now informed a new connection has been established. On the Server side, a ServerSession object is created to represent this. There is only one type of ServerSession ; It looks the same regardless of how the Account connects. From now on, there is a one-to-one match between the ServerSession on one side of the AMP connection and the PortalSession on the other. Data arriving to the Portal Session is sent on to its mirror Server session and vice versa. During certain situations, the portal- and server-side sessions are \"synced\" with each other: - The Player closes their client, killing the Portal Session. The Portal syncs with the Server to make sure the corresponding Server Session is also deleted. - The Player quits from inside the game, killing the Server Session. The Server then syncs with the Portal to make sure to close the Portal connection cleanly. - The Server is rebooted/reset/shutdown - The Server Sessions are copied over (\"saved\") to the Portal side. When the Server comes back up, this data is returned by the Portal so the two are again in sync. This way an Account's login status and other connection-critical things can survive a server reboot (assuming the Portal is not stopped at the same time, obviously).","title":"Portal and Server Sessions"},{"location":"Sessions.html#sessionhandlers","text":"Both the Portal and Server each have a sessionhandler to manage the connections. These handlers are global entities contain all methods for relaying data across the AMP bridge. All types of Sessions hold a reference to their respective Sessionhandler (the property is called sessionhandler ) so they can relay data. See protocols for more info on building new protocols. To get all Sessions in the game (i.e. all currently connected clients), you access the server-side Session handler, which you get by from evennia.server.sessionhandler import SESSION_HANDLER Note: The SESSION_HANDLER singleton has an older alias SESSIONS that is commonly seen in various places as well. See the sessionhandler.py module for details on the capabilities of the ServerSessionHandler .","title":"Sessionhandlers"},{"location":"Setting-up-PyCharm.html","text":"Directions for setting up PyCharm with Evennia \u00b6 PyCharm is a Python developer's IDE from Jetbrains available for Windows, Mac and Linux. It is a commercial product but offer free trials, a scaled-down community edition and also generous licenses for OSS projects like Evennia. This page was originally tested on Windows (so use Windows-style path examples), but should work the same for all platforms. First, install Evennia on your local machine with Getting Started . If you're new to PyCharm, loading your project is as easy as selecting the Open option when PyCharm starts, and browsing to your game folder (the one created with evennia --init ). We refer to it as mygame here. If you want to be able to examine evennia's core code or the scripts inside your virtualenv, you'll need to add them to your project too: 1. Go to File > Open... 1. Select the folder (i.e. the evennia root) 1. Select \"Open in current window\" and \"Add to currently opened projects\" Setting up the project interpreter \u00b6 It's a good idea to do this before attempting anything further. The rest of this page assumes your project is already configured in PyCharm. Go to File > Settings... > Project: \\<mygame\\> > Project Interpreter Click the Gear symbol > Add local Navigate to your evenv/scripts directory , and select Python.exe Enjoy seeing all your imports checked properly, setting breakpoints, and live variable watching! Attaching PyCharm debugger to Evennia \u00b6 Launch Evennia in your preferred way (usually from a console/terminal) Open your project in PyCharm In the PyCharm menu, select Run > Attach to Local Process... From the list, pick the twistd process with the server.py parameter (Example: twistd.exe --nodaemon --logfile=\\<mygame\\>\\server\\logs\\server.log --python=\\<evennia repo\\>\\evennia\\server\\server.py ) Of course you can attach to the portal process as well. If you want to debug the Evennia launcher or runner for some reason (or just learn how they work!), see Run Configuration below. NOTE: Whenever you reload Evennia, the old Server process will die and a new one start. So when you restart you have to detach from the old and then reattach to the new process that was created. To make the process less tedious you can apply a filter in settings to show only the server.py process in the list. To do that navigate to: Settings/Preferences | Build, Execution, Deployment | Python Debugger and then in Attach to process field put in: twistd.exe\" --nodaemon . This is an example for windows, I don't have a working mac/linux box. Setting up an Evennia run configuration \u00b6 This configuration allows you to launch Evennia from inside PyCharm. Besides convenience, it also allows suspending and debugging the evennia_launcher or evennia_runner at points earlier than you could by running them externally and attaching. In fact by the time the server and/or portal are running the launcher will have exited already. Go to Run > Edit Configutations... Click the plus-symbol to add a new configuration and choose Python Add the script: \\<yourrepo\\>\\evenv\\Scripts\\evennia_launcher.py (substitute your virtualenv if it's not named evenv ) Set script parameters to: start -l (-l enables console logging) Ensure the chosen interpreter is from your virtualenv Set Working directory to your mygame folder (not evenv nor evennia) You can refer to the PyCharm documentation for general info, but you'll want to set at least a config name (like \"MyMUD start\" or similar). Now set up a \"stop\" configuration by following the same steps as above, but set your Script parameters to: stop (and name the configuration appropriately). A dropdown box holding your new configurations should appear next to your PyCharm run button. Select MyMUD start and press the debug icon to begin debugging. Depending on how far you let the program run, you may need to run your \"MyMUD stop\" config to actually stop the server, before you'll be able start it again. Alternative run configuration - utilizing logfiles as source of data \u00b6 This configuration takes a bit different approach as instead of focusing on getting the data back through logfiles. Reason for that is this way you can easily separate data streams, for example you rarely want to follow both server and portal at the same time, and this will allow it. This will also make sure to stop the evennia before starting it, essentially working as reload command (it will also include instructions how to disable that part of functionality). We will start by defining a configuration that will stop evennia. This assumes that upfire is your pycharm project name, and also the game name, hence the upfire/upfire path. Go to Run > Edit Configutations... \\ Click the plus-symbol to add a new configuration and choose the python interpreter to use (should be project default) Name the configuration as \"stop evennia\" and fill rest of the fields accordingly to the image: Press Apply Now we will define the start/reload command that will make sure that evennia is not running already, and then start the server in one go. 1. Go to Run > Edit Configutations... \\ 1. Click the plus-symbol to add a new configuration and choose the python interpreter to use (should be project default) 1. Name the configuration as \"start evennia\" and fill rest of the fields accordingly to the image: 1. Navigate to the Logs tab and add the log files you would like to follow. The picture shows adding portal.log which will show itself in portal tab when running: 1. Skip the following steps if you don't want the launcher to stop evennia before starting. 1. Head back to Configuration tab and press the + sign at the bottom, under Before launch.... and select Run another configuration from the submenu that will pop up. 1. Click stop evennia and make sure that it's added to the list like on the image above. 1. Click Apply and close the run configuration window. You are now ready to go, and if you will fire up start evennia configuration you should see following in the bottom panel: and you can click through the tabs to check appropriate logs, or even the console output as it is still running in interactive mode.","title":"Directions for setting up PyCharm with Evennia"},{"location":"Setting-up-PyCharm.html#directions-for-setting-up-pycharm-with-evennia","text":"PyCharm is a Python developer's IDE from Jetbrains available for Windows, Mac and Linux. It is a commercial product but offer free trials, a scaled-down community edition and also generous licenses for OSS projects like Evennia. This page was originally tested on Windows (so use Windows-style path examples), but should work the same for all platforms. First, install Evennia on your local machine with Getting Started . If you're new to PyCharm, loading your project is as easy as selecting the Open option when PyCharm starts, and browsing to your game folder (the one created with evennia --init ). We refer to it as mygame here. If you want to be able to examine evennia's core code or the scripts inside your virtualenv, you'll need to add them to your project too: 1. Go to File > Open... 1. Select the folder (i.e. the evennia root) 1. Select \"Open in current window\" and \"Add to currently opened projects\"","title":"Directions for setting up PyCharm with Evennia"},{"location":"Setting-up-PyCharm.html#setting-up-the-project-interpreter","text":"It's a good idea to do this before attempting anything further. The rest of this page assumes your project is already configured in PyCharm. Go to File > Settings... > Project: \\<mygame\\> > Project Interpreter Click the Gear symbol > Add local Navigate to your evenv/scripts directory , and select Python.exe Enjoy seeing all your imports checked properly, setting breakpoints, and live variable watching!","title":"Setting up the project interpreter"},{"location":"Setting-up-PyCharm.html#attaching-pycharm-debugger-to-evennia","text":"Launch Evennia in your preferred way (usually from a console/terminal) Open your project in PyCharm In the PyCharm menu, select Run > Attach to Local Process... From the list, pick the twistd process with the server.py parameter (Example: twistd.exe --nodaemon --logfile=\\<mygame\\>\\server\\logs\\server.log --python=\\<evennia repo\\>\\evennia\\server\\server.py ) Of course you can attach to the portal process as well. If you want to debug the Evennia launcher or runner for some reason (or just learn how they work!), see Run Configuration below. NOTE: Whenever you reload Evennia, the old Server process will die and a new one start. So when you restart you have to detach from the old and then reattach to the new process that was created. To make the process less tedious you can apply a filter in settings to show only the server.py process in the list. To do that navigate to: Settings/Preferences | Build, Execution, Deployment | Python Debugger and then in Attach to process field put in: twistd.exe\" --nodaemon . This is an example for windows, I don't have a working mac/linux box.","title":"Attaching PyCharm debugger to Evennia"},{"location":"Setting-up-PyCharm.html#setting-up-an-evennia-run-configuration","text":"This configuration allows you to launch Evennia from inside PyCharm. Besides convenience, it also allows suspending and debugging the evennia_launcher or evennia_runner at points earlier than you could by running them externally and attaching. In fact by the time the server and/or portal are running the launcher will have exited already. Go to Run > Edit Configutations... Click the plus-symbol to add a new configuration and choose Python Add the script: \\<yourrepo\\>\\evenv\\Scripts\\evennia_launcher.py (substitute your virtualenv if it's not named evenv ) Set script parameters to: start -l (-l enables console logging) Ensure the chosen interpreter is from your virtualenv Set Working directory to your mygame folder (not evenv nor evennia) You can refer to the PyCharm documentation for general info, but you'll want to set at least a config name (like \"MyMUD start\" or similar). Now set up a \"stop\" configuration by following the same steps as above, but set your Script parameters to: stop (and name the configuration appropriately). A dropdown box holding your new configurations should appear next to your PyCharm run button. Select MyMUD start and press the debug icon to begin debugging. Depending on how far you let the program run, you may need to run your \"MyMUD stop\" config to actually stop the server, before you'll be able start it again.","title":"Setting up an Evennia run configuration"},{"location":"Setting-up-PyCharm.html#alternative-run-configuration-utilizing-logfiles-as-source-of-data","text":"This configuration takes a bit different approach as instead of focusing on getting the data back through logfiles. Reason for that is this way you can easily separate data streams, for example you rarely want to follow both server and portal at the same time, and this will allow it. This will also make sure to stop the evennia before starting it, essentially working as reload command (it will also include instructions how to disable that part of functionality). We will start by defining a configuration that will stop evennia. This assumes that upfire is your pycharm project name, and also the game name, hence the upfire/upfire path. Go to Run > Edit Configutations... \\ Click the plus-symbol to add a new configuration and choose the python interpreter to use (should be project default) Name the configuration as \"stop evennia\" and fill rest of the fields accordingly to the image: Press Apply Now we will define the start/reload command that will make sure that evennia is not running already, and then start the server in one go. 1. Go to Run > Edit Configutations... \\ 1. Click the plus-symbol to add a new configuration and choose the python interpreter to use (should be project default) 1. Name the configuration as \"start evennia\" and fill rest of the fields accordingly to the image: 1. Navigate to the Logs tab and add the log files you would like to follow. The picture shows adding portal.log which will show itself in portal tab when running: 1. Skip the following steps if you don't want the launcher to stop evennia before starting. 1. Head back to Configuration tab and press the + sign at the bottom, under Before launch.... and select Run another configuration from the submenu that will pop up. 1. Click stop evennia and make sure that it's added to the list like on the image above. 1. Click Apply and close the run configuration window. You are now ready to go, and if you will fire up start evennia configuration you should see following in the bottom panel: and you can click through the tabs to check appropriate logs, or even the console output as it is still running in interactive mode.","title":"Alternative run configuration - utilizing logfiles as source of data"},{"location":"Signals.html","text":"This is feature available from evennia 0.9 and onward . There are multiple ways for you to plug in your own functionality into Evennia. The most common way to do so is through hooks - methods on typeclasses that gets called at particular events. Hooks are great when you want a game entity to behave a certain way when something happens to it. Signals complements hooks for cases when you want to easily attach new functionality without overriding things on the typeclass. When certain events happen in Evennia, a Signal is fired. The idea is that you can \"attach\" any number of event-handlers to these signals. You can attach any number of handlers and they'll all fire whenever any entity triggers the signal. Evennia uses the Django Signal system . Attaching a handler to a signal \u00b6 First you create your handler def myhandler(sender, **kwargs): # do stuff The **kwargs is mandatory. Then you attach it to the signal of your choice: from evennia.server import signals signals.SIGNAL_OBJECT_POST_CREATE.connect(myhandler) This particular signal fires after (post) an Account has connected to the game. When that happens, myhandler will fire with the sender being the Account that just connected. If you want to respond only to the effects of a specific entity you can do so like this: from evennia import search_account from evennia import signals account = search_account(\"foo\")[0] signals.SIGNAL_ACCOUNT_POST_CONNECT.connect(myhandler, account) Available signals \u00b6 All signals (including some django-specific defaults) are available in the module evennia.server.signals (with a shortcut evennia.signals ). Signals are named by the sender type. So SIGNAL_ACCOUNT_* returns Account instances as senders, SIGNAL_OBJECT_* returns Object s etc. Extra keywords (kwargs) should be extracted from the **kwargs dict in the signal handler. SIGNAL_ACCOUNT_POST_CREATE - this is triggered at the very end of Account.create() . Note that calling evennia.create.create_account (which is called internally by Account.create ) will not trigger this signal. This is because using Account.create() is expected to be the most commonly used way for users to themselves create accounts during login. It passes and extra kwarg ip with the client IP of the connecting account. SIGNAL_ACCOUNT_POST_LOGIN - this will always fire when the account has authenticated. Sends extra kwarg session with the new Session object involved. SIGNAL_ACCCOUNT_POST_FIRST_LOGIN - this fires just before SIGNAL_ACCOUNT_POST_LOGIN but only if this is the first connection done (that is, if there are no previous sessions connected). Also passes the session along as a kwarg. SIGNAL_ACCOUNT_POST_LOGIN_FAIL - sent when someone tried to log into an account by failed. Passes the session as an extra kwarg. SIGNAL_ACCOUNT_POST_LOGOUT - always fires when an account logs off, no matter if other sessions remain or not. Passes the disconnecting session along as a kwarg. SIGNAL_ACCOUNT_POST_LAST_LOGOUT - fires before SIGNAL_ACCOUNT_POST_LOGOUT , but only if this is the last Session to disconnect for that account. Passes the session as a kwarg. SIGNAL_OBJECT_POST_PUPPET - fires when an account puppets this object. Extra kwargs session and account represent the puppeting entities. SIGNAL_OBJECT_POST_UNPUPPET - fires when the sending object is unpuppeted. Extra kwargs are session and account . SIGNAL_ACCOUNT_POST_RENAME - triggered by the setting of Account.username . Passes extra kwargs old_name , new_name . SIGNAL_TYPED_OBJECT_POST_RENAME - triggered when any Typeclassed entity's key is changed. Extra kwargs passed are old_key and new_key . SIGNAL_SCRIPT_POST_CREATE - fires when a script is first created, after any hooks. SIGNAL_CHANNEL_POST_CREATE - fires when a Channel is first created, after any hooks. SIGNAL_HELPENTRY_POST_CREATE - fires when a help entry is first created. The evennia.signals module also gives you conveneient access to the default Django signals (these use a different naming convention). pre_save - fired when any database entitiy's .save method fires, before any saving has happened. post_save - fires after saving a database entity. pre_delete - fires just before a database entity is deleted. post_delete - fires after a database entity was deleted. pre_init - fires before a typeclass' __init__ method (which in turn happens before the at_init hook fires). post_init - triggers at the end of __init__ (still before the at_init hook). These are highly specialized Django signals that are unlikely to be useful to most users. But they are included here for completeness. m2m_changed - fires after a Many-to-Many field (like db_attributes ) changes. pre_migrate - fires before database migration starts with evennia migrate . post_migrate - fires after database migration finished. request_started - sent when HTTP request begins. request_finished - sent when HTTP request ends. settings_changed - sent when changing settings due to @override_settings decorator (only relevant for unit testing) template_rendered - sent when test system renders http template (only useful for unit tests). connection_creation - sent when making initial connection to database.","title":"Signals"},{"location":"Signals.html#attaching-a-handler-to-a-signal","text":"First you create your handler def myhandler(sender, **kwargs): # do stuff The **kwargs is mandatory. Then you attach it to the signal of your choice: from evennia.server import signals signals.SIGNAL_OBJECT_POST_CREATE.connect(myhandler) This particular signal fires after (post) an Account has connected to the game. When that happens, myhandler will fire with the sender being the Account that just connected. If you want to respond only to the effects of a specific entity you can do so like this: from evennia import search_account from evennia import signals account = search_account(\"foo\")[0] signals.SIGNAL_ACCOUNT_POST_CONNECT.connect(myhandler, account)","title":"Attaching a handler to a signal"},{"location":"Signals.html#available-signals","text":"All signals (including some django-specific defaults) are available in the module evennia.server.signals (with a shortcut evennia.signals ). Signals are named by the sender type. So SIGNAL_ACCOUNT_* returns Account instances as senders, SIGNAL_OBJECT_* returns Object s etc. Extra keywords (kwargs) should be extracted from the **kwargs dict in the signal handler. SIGNAL_ACCOUNT_POST_CREATE - this is triggered at the very end of Account.create() . Note that calling evennia.create.create_account (which is called internally by Account.create ) will not trigger this signal. This is because using Account.create() is expected to be the most commonly used way for users to themselves create accounts during login. It passes and extra kwarg ip with the client IP of the connecting account. SIGNAL_ACCOUNT_POST_LOGIN - this will always fire when the account has authenticated. Sends extra kwarg session with the new Session object involved. SIGNAL_ACCCOUNT_POST_FIRST_LOGIN - this fires just before SIGNAL_ACCOUNT_POST_LOGIN but only if this is the first connection done (that is, if there are no previous sessions connected). Also passes the session along as a kwarg. SIGNAL_ACCOUNT_POST_LOGIN_FAIL - sent when someone tried to log into an account by failed. Passes the session as an extra kwarg. SIGNAL_ACCOUNT_POST_LOGOUT - always fires when an account logs off, no matter if other sessions remain or not. Passes the disconnecting session along as a kwarg. SIGNAL_ACCOUNT_POST_LAST_LOGOUT - fires before SIGNAL_ACCOUNT_POST_LOGOUT , but only if this is the last Session to disconnect for that account. Passes the session as a kwarg. SIGNAL_OBJECT_POST_PUPPET - fires when an account puppets this object. Extra kwargs session and account represent the puppeting entities. SIGNAL_OBJECT_POST_UNPUPPET - fires when the sending object is unpuppeted. Extra kwargs are session and account . SIGNAL_ACCOUNT_POST_RENAME - triggered by the setting of Account.username . Passes extra kwargs old_name , new_name . SIGNAL_TYPED_OBJECT_POST_RENAME - triggered when any Typeclassed entity's key is changed. Extra kwargs passed are old_key and new_key . SIGNAL_SCRIPT_POST_CREATE - fires when a script is first created, after any hooks. SIGNAL_CHANNEL_POST_CREATE - fires when a Channel is first created, after any hooks. SIGNAL_HELPENTRY_POST_CREATE - fires when a help entry is first created. The evennia.signals module also gives you conveneient access to the default Django signals (these use a different naming convention). pre_save - fired when any database entitiy's .save method fires, before any saving has happened. post_save - fires after saving a database entity. pre_delete - fires just before a database entity is deleted. post_delete - fires after a database entity was deleted. pre_init - fires before a typeclass' __init__ method (which in turn happens before the at_init hook fires). post_init - triggers at the end of __init__ (still before the at_init hook). These are highly specialized Django signals that are unlikely to be useful to most users. But they are included here for completeness. m2m_changed - fires after a Many-to-Many field (like db_attributes ) changes. pre_migrate - fires before database migration starts with evennia migrate . post_migrate - fires after database migration finished. request_started - sent when HTTP request begins. request_finished - sent when HTTP request ends. settings_changed - sent when changing settings due to @override_settings decorator (only relevant for unit testing) template_rendered - sent when test system renders http template (only useful for unit tests). connection_creation - sent when making initial connection to database.","title":"Available signals"},{"location":"Soft-Code.html","text":"Softcode is a very simple programming language that was created for in-game development on TinyMUD derivatives such as MUX, PennMUSH, TinyMUSH, and RhostMUSH. The idea is that by providing a stripped down, minimalistic language for in-game use, you can allow quick and easy building and game development to happen without having to learn C/C++. There is an added benefit of not having to have to hand out shell access to all developers, and permissions can be used to alleviate many security problems. Writing and installing softcode is done through a MUD client. Thus it is not a formatted language. Each softcode function is a single line of varying size. Some functions can be a half of a page long or more which is obviously not very readable nor (easily) maintainable over time. Examples of Softcode \u00b6 Here is a simple 'Hello World!' command: @set me=HELLO_WORLD.C:$hello:@pemit %#=Hello World! Pasting this into a MUX/MUSH and typing 'hello' will theoretically yield 'Hello World!', assuming certain flags are not set on your account object. Setting attributes is done via @set . Softcode also allows the use of the ampersand ( & ) symbol. This shorter version looks like this: &HELLO_WORLD.C me=$hello:@pemit %#=Hello World! Perhaps I want to break the Hello World into an attribute which is retrieved when emitting: &HELLO_VALUE.D me=Hello World &HELLO_WORLD.C me=$hello:@pemit %#=[v(HELLO_VALUE.D)] The v() function returns the HELLO_VALUE.D attribute on the object that the command resides ( me , which is yourself in this case). This should yield the same output as the first example. If you are still curious about how Softcode works, take a look at some external resources: http://www.tinymux.com/wiki/index.php/Softcode http://www.duh.com/discordia/mushman/man2x1 Problems with Softcode \u00b6 Softcode is excellent at what it was intended for: simple things . It is a great tool for making an interactive object, a room with ambiance, simple global commands, simple economies and coded systems. However, once you start to try to write something like a complex combat system or a higher end economy, you're likely to find yourself buried under a mountain of functions that span multiple objects across your entire code. Not to mention, softcode is not an inherently fast language. It is not compiled, it is parsed with each calling of a function. While MUX and MUSH parsers have jumped light years ahead of where they once were they can still stutter under the weight of more complex systems if not designed properly. Changing Times \u00b6 Now that starting text-based games is easy and an option for even the most technically inarticulate, new projects are a dime a dozen. People are starting new MUDs every day with varying levels of commitment and ability. Because of this shift from fewer, larger, well-staffed games to a bunch of small, one or two developer games, some of the benefit of softcode fades. Softcode is great in that it allows a mid to large sized staff all work on the same game without stepping on one another's toes. As mentioned before, shell access is not necessary to develop a MUX or a MUSH. However, now that we are seeing a lot more small, one or two-man shops, the issue of shell access and stepping on each other's toes is a lot less. Our Solution \u00b6 Evennia shuns in-game softcode for on-disk Python modules. Python is a popular, mature and professional programming language. You code it using the conveniences of modern text editors. Evennia developers have access to the entire library of Python modules out there in the wild - not to mention the vast online help resources available. Python code is not bound to one-line functions on objects but complex systems may be organized neatly into real source code modules, sub-modules, or even broken out into entire Python packages as desired. So what is not included in Evennia is a MUX/MOO-like online player-coding system. Advanced coding in Evennia is primarily intended to be done outside the game, in full-fledged Python modules. Advanced building is best handled by extending Evennia's command system with your own sophisticated building commands. We feel that with a small development team you are better off using a professional source-control system (svn, git, bazaar, mercurial etc) anyway. Your Solution \u00b6 Adding advanced and flexible building commands to your game is easy and will probably be enough to satisfy most creative builders. However, if you really, really want to offer online coding, there is of course nothing stopping you from adding that to Evennia, no matter our recommendations. You could even re-implement MUX' softcode in Python should you be very ambitious. The in-game-python is an optional pseudo-softcode plugin aimed at developers wanting to script their game from inside it.","title":"Soft Code"},{"location":"Soft-Code.html#examples-of-softcode","text":"Here is a simple 'Hello World!' command: @set me=HELLO_WORLD.C:$hello:@pemit %#=Hello World! Pasting this into a MUX/MUSH and typing 'hello' will theoretically yield 'Hello World!', assuming certain flags are not set on your account object. Setting attributes is done via @set . Softcode also allows the use of the ampersand ( & ) symbol. This shorter version looks like this: &HELLO_WORLD.C me=$hello:@pemit %#=Hello World! Perhaps I want to break the Hello World into an attribute which is retrieved when emitting: &HELLO_VALUE.D me=Hello World &HELLO_WORLD.C me=$hello:@pemit %#=[v(HELLO_VALUE.D)] The v() function returns the HELLO_VALUE.D attribute on the object that the command resides ( me , which is yourself in this case). This should yield the same output as the first example. If you are still curious about how Softcode works, take a look at some external resources: http://www.tinymux.com/wiki/index.php/Softcode http://www.duh.com/discordia/mushman/man2x1","title":"Examples of Softcode"},{"location":"Soft-Code.html#problems-with-softcode","text":"Softcode is excellent at what it was intended for: simple things . It is a great tool for making an interactive object, a room with ambiance, simple global commands, simple economies and coded systems. However, once you start to try to write something like a complex combat system or a higher end economy, you're likely to find yourself buried under a mountain of functions that span multiple objects across your entire code. Not to mention, softcode is not an inherently fast language. It is not compiled, it is parsed with each calling of a function. While MUX and MUSH parsers have jumped light years ahead of where they once were they can still stutter under the weight of more complex systems if not designed properly.","title":"Problems with Softcode"},{"location":"Soft-Code.html#changing-times","text":"Now that starting text-based games is easy and an option for even the most technically inarticulate, new projects are a dime a dozen. People are starting new MUDs every day with varying levels of commitment and ability. Because of this shift from fewer, larger, well-staffed games to a bunch of small, one or two developer games, some of the benefit of softcode fades. Softcode is great in that it allows a mid to large sized staff all work on the same game without stepping on one another's toes. As mentioned before, shell access is not necessary to develop a MUX or a MUSH. However, now that we are seeing a lot more small, one or two-man shops, the issue of shell access and stepping on each other's toes is a lot less.","title":"Changing Times"},{"location":"Soft-Code.html#our-solution","text":"Evennia shuns in-game softcode for on-disk Python modules. Python is a popular, mature and professional programming language. You code it using the conveniences of modern text editors. Evennia developers have access to the entire library of Python modules out there in the wild - not to mention the vast online help resources available. Python code is not bound to one-line functions on objects but complex systems may be organized neatly into real source code modules, sub-modules, or even broken out into entire Python packages as desired. So what is not included in Evennia is a MUX/MOO-like online player-coding system. Advanced coding in Evennia is primarily intended to be done outside the game, in full-fledged Python modules. Advanced building is best handled by extending Evennia's command system with your own sophisticated building commands. We feel that with a small development team you are better off using a professional source-control system (svn, git, bazaar, mercurial etc) anyway.","title":"Our Solution"},{"location":"Soft-Code.html#your-solution","text":"Adding advanced and flexible building commands to your game is easy and will probably be enough to satisfy most creative builders. However, if you really, really want to offer online coding, there is of course nothing stopping you from adding that to Evennia, no matter our recommendations. You could even re-implement MUX' softcode in Python should you be very ambitious. The in-game-python is an optional pseudo-softcode plugin aimed at developers wanting to script their game from inside it.","title":"Your Solution"},{"location":"Spawner-and-Prototypes.html","text":"The spawner is a system for defining and creating individual objects from a base template called a prototype . It is only designed for use with in-game Objects , not any other type of entity. The normal way to create a custom object in Evennia is to make a Typeclass . If you haven't read up on Typeclasses yet, think of them as normal Python classes that save to the database behind the scenes. Say you wanted to create a \"Goblin\" enemy. A common way to do this would be to first create a Mobile typeclass that holds everything common to mobiles in the game, like generic AI, combat code and various movement methods. A Goblin subclass is then made to inherit from Mobile . The Goblin class adds stuff unique to goblins, like group-based AI (because goblins are smarter in a group), the ability to panic, dig for gold etc. But now it's time to actually start to create some goblins and put them in the world. What if we wanted those goblins to not all look the same? Maybe we want grey-skinned and green-skinned goblins or some goblins that can cast spells or which wield different weapons? We could make subclasses of Goblin , like GreySkinnedGoblin and GoblinWieldingClub . But that seems a bit excessive (and a lot of Python code for every little thing). Using classes can also become impractical when wanting to combine them - what if we want a grey-skinned goblin shaman wielding a spear - setting up a web of classes inheriting each other with multiple inheritance can be tricky. This is what the prototype is for. It is a Python dictionary that describes these per-instance changes to an object. The prototype also has the advantage of allowing an in-game builder to customize an object without access to the Python backend. Evennia also allows for saving and searching prototypes so other builders can find and use (and tweak) them later. Having a library of interesting prototypes is a good reasource for builders. The OLC system allows for creating, saving, loading and manipulating prototypes using a menu system. The spawner takes a prototype and uses it to create (spawn) new, custom objects. Using the OLC \u00b6 Enter the olc command or @spawn/olc to enter the prototype wizard. This is a menu system for creating, loading, saving and manipulating prototypes. It's intended to be used by in-game builders and will give a better understanding of prototypes in general. Use help on each node of the menu for more information. Below are further details about how prototypes work and how they are used. The prototype \u00b6 The prototype dictionary can either be created for you by the OLC (see above), be written manually in a Python module (and then referenced by the @spawn command/OLC), or created on-the-fly and manually loaded into the spawner function or @spawn command. The dictionary defines all possible database-properties of an Object. It has a fixed set of allowed keys. When preparing to store the prototype in the database (or when using the OLC), some of these keys are mandatory. When just passing a one-time prototype-dict to the spawner the system is more lenient and will use defaults for keys not explicitly provided. In dictionary form, a prototype can look something like this: { \"prototype_key\": \"house\" \"key\": \"Large house\" \"typeclass\": \"typeclasses.rooms.house.House\" } If you wanted to load it into the spawner in-game you could just put all on one line: @spawn {\"prototype_key=\"house\", \"key\": \"Large house\", ...} Note that the prototype dict as given on the command line must be a valid Python structure - so you need to put quotes around strings etc. For security reasons, a dict inserted from-in game cannot have any other advanced Python functionality, such as executable code, lambda etc. If builders are supposed to be able to use such features, you need to offer them through $protfuncs , embedded runnable functions that you have full control to check and vet before running. Prototype keys \u00b6 All keys starting with prototype_ are for book keeping. prototype_key - the 'name' of the prototype. While this can sometimes be skipped (such as when defining a prototype in a module or feeding a prototype-dict manually to the spawner function), it's good practice to try to include this. It is used for book-keeping and storing of the prototype so you can find it later. prototype_parent - If given, this should be the prototype_key of another prototype stored in the system or available in a module. This makes this prototype inherit the keys from the parent and only override what is needed. Give a tuple (parent1, parent2, ...) for multiple left-right inheritance. If this is not given, a typeclass should usually be defined (below). prototype_desc - this is optional and used when listing the prototype in in-game listings. protototype_tags - this is optional and allows for tagging the prototype in order to find it easier later. prototype_locks - two lock types are supported: edit and spawn . The first lock restricts the copying and editing of the prototype when loaded through the OLC. The second determines who may use the prototype to create new objects. The remaining keys determine actual aspects of the objects to spawn from this prototype: key - the main object identifier. Defaults to \"Spawned Object X \", where X is a random integer. typeclass - A full python-path (from your gamedir) to the typeclass you want to use. If not set, the prototype_parent should be defined, with typeclass defined somewhere in the parent chain. When creating a one-time prototype dict just for spawning, one could omit this - settings.BASE_OBJECT_TYPECLASS will be used instead. location - this should be a #dbref . home - a valid #dbref . Defaults to location or settings.DEFAULT_HOME if location does not exist. destination - a valid #dbref . Only used by exits. permissions - list of permission strings, like [\"Accounts\", \"may_use_red_door\"] locks - a lock-string like \"edit:all();control:perm(Builder)\" aliases - list of strings for use as aliases tags - list Tags . These are given as tuples (tag, category, data) . attrs - list of Attributes . These are given as tuples (attrname, value, category, lockstring) Any other keywords are interpreted as non-category Attributes and their values. This is convenient for simple Attributes - use attrs for full control of Attributes. Deprecated as of Evennia 0.8: ndb_<name> - sets the value of a non-persistent attribute ( \"ndb_\" is stripped from the name). This is simply not useful in a prototype and is deprecated. exec - This accepts a code snippet or a list of code snippets to run. This should not be used - use callables or $protfuncs instead (see below). Prototype values \u00b6 The prototype supports values of several different types. It can be a hard-coded value: {\"key\": \"An ugly goblin\", ...} It can also be a callable . This callable is called without arguments whenever the prototype is used to spawn a new object: {\"key\": _get_a_random_goblin_name, ...} By use of Python lambda one can wrap the callable so as to make immediate settings in the prototype: {\"key\": lambda: random.choice((\"Urfgar\", \"Rick the smelly\", \"Blargh the foul\", ...)), ...} Protfuncs \u00b6 Finally, the value can be a prototype function ( Protfunc ). These look like simple function calls that you embed in strings and that has a $ in front, like {\"key\": \"$choice(Urfgar, Rick the smelly, Blargh the foul)\", \"attrs\": {\"desc\": \"This is a large $red(and very red) demon. \" \"He has $randint(2,5) skulls in a chain around his neck.\"} At execution time, the place of the protfunc will be replaced with the result of that protfunc being called (this is always a string). A protfunc works in much the same way as an InlineFunc - they are actually parsed using the same parser - except protfuncs are run every time the prototype is used to spawn a new object (whereas an inlinefunc is called when a text is returned to the user). Here is how a protfunc is defined (same as an inlinefunc). # this is a silly example, you can just color the text red with |r directly! def red(*args, **kwargs): \"\"\" Usage: $red(<text>) Returns the same text you entered, but red. \"\"\" if not args or len(args) > 1: raise ValueError(\"Must have one argument, the text to color red!\") return \"|r{}|n\".format(args[0]) Note that we must make sure to validate input and raise ValueError if that fails. Also, it is not possible to use keywords in the call to the protfunc (so something like $echo(text, align=left) is invalid). The kwargs requred is for internal evennia use and not used at all for protfuncs (only by inlinefuncs). To make this protfunc available to builders in-game, add it to a new module and add the path to that module to settings.PROT_FUNC_MODULES : # in mygame/server/conf/settings.py PROT_FUNC_MODULES += [\"world.myprotfuncs\"] All global callables in your added module will be considered a new protfunc. To avoid this (e.g. to have helper functions that are not protfuncs on their own), name your function something starting with _ . The default protfuncs available out of the box are defined in evennia/prototypes/profuncs.py . To override the ones available, just add the same-named function in your own protfunc module. Protfunc Description $random() Returns random value in range [0, 1) $randint(start, end) Returns random value in range [start, end] $left_justify(<text>) Left-justify text $right_justify(<text>) Right-justify text to screen width $center_justify(<text>) Center-justify text to screen width $full_justify(<text>) Spread text across screen width by adding spaces $protkey(<name>) Returns value of another key in this prototype (self-reference) $add(<value1>, <value2>) Returns value1 + value2. Can also be lists, dicts etc $sub(<value1>, <value2>) Returns value1 - value2 $mult(<value1>, <value2>) Returns value1 * value2 $div(<value1>, <value2>) Returns value2 / value1 $toint(<value>) Returns value converted to integer (or value if not possible) $eval(<code>) Returns result of literal-eval of code string. Only simple python expressions. $obj(<query>) Returns object #dbref searched globally by key, tag or #dbref. Error if more than one found.\" $objlist(<query>) Like $obj , except always returns a list of zero, one or more results. $dbref(dbref) Returns argument if it is formed as a #dbref (e.g. #1234), otherwise error. For developers with access to Python, using protfuncs in prototypes is generally not useful. Passing real Python functions is a lot more powerful and flexible. Their main use is to allow in-game builders to do limited coding/scripting for their prototypes without giving them direct access to raw Python. Storing prototypes \u00b6 A prototype can be defined and stored in two ways, either in the database or as a dict in a module. Database prototypes \u00b6 Stored as Scripts in the database. These are sometimes referred to as database-prototypes This is the only way for in-game builders to modify and add prototypes. They have the advantage of being easily modifiable and sharable between builders but you need to work with them using in-game tools. Module-based prototypes \u00b6 These prototypes are defined as dictionaries assigned to global variables in one of the modules defined in settings.PROTOTYPE_MODULES . They can only be modified from outside the game so they are are necessarily \"read-only\" from in-game and cannot be modified (but copies of them could be made into database-prototypes). These were the only prototypes available before Evennia 0.8. Module based prototypes can be useful in order for developers to provide read-only \"starting\" or \"base\" prototypes to build from or if they just prefer to work offline in an external code editor. By default mygame/world/prototypes.py is set up for you to add your own prototypes. All global dicts in this module will be considered by Evennia to be a prototype. You could also tell Evennia to look for prototypes in more modules if you want: # in mygame/server/conf.py PROTOTYPE_MODULES = += [\"world.myownprototypes\", \"combat.prototypes\"] Here is an example of a prototype defined in a module: ```python # in a module Evennia looks at for prototypes, # (like mygame/world/prototypes.py) ORC_SHAMAN = {\"key\":\"Orc shaman\", \"typeclass\": \"typeclasses.monsters.Orc\", \"weapon\": \"wooden staff\", \"health\": 20} ``` Note that in the example above, \"ORC_SHAMAN\" will become the prototype_key of this prototype. It's the only case when prototype_key can be skipped in a prototype. However, if prototype_key was given explicitly, that would take precedence. This is a legacy behavior and it's recommended that you always add prototype_key to be consistent. Using @spawn \u00b6 The spawner can be used from inside the game through the Builder-only @spawn command. Assuming the \"goblin\" typeclass is available to the system (either as a database-prototype or read from module), you can spawn a new goblin with @spawn goblin You can also specify the prototype directly as a valid Python dictionary: @spawn {\"prototype_key\": \"shaman\", \\ \"key\":\"Orc shaman\", \\ \"prototype_parent\": \"goblin\", \\ \"weapon\": \"wooden staff\", \\ \"health\": 20} Note: The @spawn command is more lenient about the prototype dictionary than shown here. So you can for example skip the prototype_key if you are just testing a throw-away prototype. A random hash will be used to please the validation. You could also skip prototype_parent/typeclass - then the typeclass given by settings.BASE_OBJECT_TYPECLASS will be used. Using evennia.prototypes.spawner() \u00b6 In code you access the spawner mechanism directly via the call new_objects = evennia.prototypes.spawner.spawn(*prototypes) All arguments are prototype dictionaries. The function will return a matching list of created objects. Example: obj1, obj2 = evennia.prototypes.spawner.spawn({\"key\": \"Obj1\", \"desc\": \"A test\"}, {\"key\": \"Obj2\", \"desc\": \"Another test\"}) Hint: Same as when using @spawn , when spawning from a one-time prototype dict like this, you can skip otherwise required keys, like prototype_key or typeclass / prototype_parent . Defaults will be used. Note that no location will be set automatically when using evennia.prototypes.spawner.spawn() , you have to specify location explicitly in the prototype dict. If the prototypes you supply are using prototype_parent keywords, the spawner will read prototypes from modules in settings.PROTOTYPE_MODULES as well as those saved to the database to determine the body of available parents. The spawn command takes many optional keywords, you can find its definition in the api docs .","title":"Spawner and Prototypes"},{"location":"Spawner-and-Prototypes.html#using-the-olc","text":"Enter the olc command or @spawn/olc to enter the prototype wizard. This is a menu system for creating, loading, saving and manipulating prototypes. It's intended to be used by in-game builders and will give a better understanding of prototypes in general. Use help on each node of the menu for more information. Below are further details about how prototypes work and how they are used.","title":"Using the OLC"},{"location":"Spawner-and-Prototypes.html#the-prototype","text":"The prototype dictionary can either be created for you by the OLC (see above), be written manually in a Python module (and then referenced by the @spawn command/OLC), or created on-the-fly and manually loaded into the spawner function or @spawn command. The dictionary defines all possible database-properties of an Object. It has a fixed set of allowed keys. When preparing to store the prototype in the database (or when using the OLC), some of these keys are mandatory. When just passing a one-time prototype-dict to the spawner the system is more lenient and will use defaults for keys not explicitly provided. In dictionary form, a prototype can look something like this: { \"prototype_key\": \"house\" \"key\": \"Large house\" \"typeclass\": \"typeclasses.rooms.house.House\" } If you wanted to load it into the spawner in-game you could just put all on one line: @spawn {\"prototype_key=\"house\", \"key\": \"Large house\", ...} Note that the prototype dict as given on the command line must be a valid Python structure - so you need to put quotes around strings etc. For security reasons, a dict inserted from-in game cannot have any other advanced Python functionality, such as executable code, lambda etc. If builders are supposed to be able to use such features, you need to offer them through $protfuncs , embedded runnable functions that you have full control to check and vet before running.","title":"The prototype"},{"location":"Spawner-and-Prototypes.html#prototype-keys","text":"All keys starting with prototype_ are for book keeping. prototype_key - the 'name' of the prototype. While this can sometimes be skipped (such as when defining a prototype in a module or feeding a prototype-dict manually to the spawner function), it's good practice to try to include this. It is used for book-keeping and storing of the prototype so you can find it later. prototype_parent - If given, this should be the prototype_key of another prototype stored in the system or available in a module. This makes this prototype inherit the keys from the parent and only override what is needed. Give a tuple (parent1, parent2, ...) for multiple left-right inheritance. If this is not given, a typeclass should usually be defined (below). prototype_desc - this is optional and used when listing the prototype in in-game listings. protototype_tags - this is optional and allows for tagging the prototype in order to find it easier later. prototype_locks - two lock types are supported: edit and spawn . The first lock restricts the copying and editing of the prototype when loaded through the OLC. The second determines who may use the prototype to create new objects. The remaining keys determine actual aspects of the objects to spawn from this prototype: key - the main object identifier. Defaults to \"Spawned Object X \", where X is a random integer. typeclass - A full python-path (from your gamedir) to the typeclass you want to use. If not set, the prototype_parent should be defined, with typeclass defined somewhere in the parent chain. When creating a one-time prototype dict just for spawning, one could omit this - settings.BASE_OBJECT_TYPECLASS will be used instead. location - this should be a #dbref . home - a valid #dbref . Defaults to location or settings.DEFAULT_HOME if location does not exist. destination - a valid #dbref . Only used by exits. permissions - list of permission strings, like [\"Accounts\", \"may_use_red_door\"] locks - a lock-string like \"edit:all();control:perm(Builder)\" aliases - list of strings for use as aliases tags - list Tags . These are given as tuples (tag, category, data) . attrs - list of Attributes . These are given as tuples (attrname, value, category, lockstring) Any other keywords are interpreted as non-category Attributes and their values. This is convenient for simple Attributes - use attrs for full control of Attributes. Deprecated as of Evennia 0.8: ndb_<name> - sets the value of a non-persistent attribute ( \"ndb_\" is stripped from the name). This is simply not useful in a prototype and is deprecated. exec - This accepts a code snippet or a list of code snippets to run. This should not be used - use callables or $protfuncs instead (see below).","title":"Prototype keys"},{"location":"Spawner-and-Prototypes.html#prototype-values","text":"The prototype supports values of several different types. It can be a hard-coded value: {\"key\": \"An ugly goblin\", ...} It can also be a callable . This callable is called without arguments whenever the prototype is used to spawn a new object: {\"key\": _get_a_random_goblin_name, ...} By use of Python lambda one can wrap the callable so as to make immediate settings in the prototype: {\"key\": lambda: random.choice((\"Urfgar\", \"Rick the smelly\", \"Blargh the foul\", ...)), ...}","title":"Prototype values"},{"location":"Spawner-and-Prototypes.html#protfuncs","text":"Finally, the value can be a prototype function ( Protfunc ). These look like simple function calls that you embed in strings and that has a $ in front, like {\"key\": \"$choice(Urfgar, Rick the smelly, Blargh the foul)\", \"attrs\": {\"desc\": \"This is a large $red(and very red) demon. \" \"He has $randint(2,5) skulls in a chain around his neck.\"} At execution time, the place of the protfunc will be replaced with the result of that protfunc being called (this is always a string). A protfunc works in much the same way as an InlineFunc - they are actually parsed using the same parser - except protfuncs are run every time the prototype is used to spawn a new object (whereas an inlinefunc is called when a text is returned to the user). Here is how a protfunc is defined (same as an inlinefunc). # this is a silly example, you can just color the text red with |r directly! def red(*args, **kwargs): \"\"\" Usage: $red(<text>) Returns the same text you entered, but red. \"\"\" if not args or len(args) > 1: raise ValueError(\"Must have one argument, the text to color red!\") return \"|r{}|n\".format(args[0]) Note that we must make sure to validate input and raise ValueError if that fails. Also, it is not possible to use keywords in the call to the protfunc (so something like $echo(text, align=left) is invalid). The kwargs requred is for internal evennia use and not used at all for protfuncs (only by inlinefuncs). To make this protfunc available to builders in-game, add it to a new module and add the path to that module to settings.PROT_FUNC_MODULES : # in mygame/server/conf/settings.py PROT_FUNC_MODULES += [\"world.myprotfuncs\"] All global callables in your added module will be considered a new protfunc. To avoid this (e.g. to have helper functions that are not protfuncs on their own), name your function something starting with _ . The default protfuncs available out of the box are defined in evennia/prototypes/profuncs.py . To override the ones available, just add the same-named function in your own protfunc module. Protfunc Description $random() Returns random value in range [0, 1) $randint(start, end) Returns random value in range [start, end] $left_justify(<text>) Left-justify text $right_justify(<text>) Right-justify text to screen width $center_justify(<text>) Center-justify text to screen width $full_justify(<text>) Spread text across screen width by adding spaces $protkey(<name>) Returns value of another key in this prototype (self-reference) $add(<value1>, <value2>) Returns value1 + value2. Can also be lists, dicts etc $sub(<value1>, <value2>) Returns value1 - value2 $mult(<value1>, <value2>) Returns value1 * value2 $div(<value1>, <value2>) Returns value2 / value1 $toint(<value>) Returns value converted to integer (or value if not possible) $eval(<code>) Returns result of literal-eval of code string. Only simple python expressions. $obj(<query>) Returns object #dbref searched globally by key, tag or #dbref. Error if more than one found.\" $objlist(<query>) Like $obj , except always returns a list of zero, one or more results. $dbref(dbref) Returns argument if it is formed as a #dbref (e.g. #1234), otherwise error. For developers with access to Python, using protfuncs in prototypes is generally not useful. Passing real Python functions is a lot more powerful and flexible. Their main use is to allow in-game builders to do limited coding/scripting for their prototypes without giving them direct access to raw Python.","title":"Protfuncs"},{"location":"Spawner-and-Prototypes.html#storing-prototypes","text":"A prototype can be defined and stored in two ways, either in the database or as a dict in a module.","title":"Storing prototypes"},{"location":"Spawner-and-Prototypes.html#database-prototypes","text":"Stored as Scripts in the database. These are sometimes referred to as database-prototypes This is the only way for in-game builders to modify and add prototypes. They have the advantage of being easily modifiable and sharable between builders but you need to work with them using in-game tools.","title":"Database prototypes"},{"location":"Spawner-and-Prototypes.html#module-based-prototypes","text":"These prototypes are defined as dictionaries assigned to global variables in one of the modules defined in settings.PROTOTYPE_MODULES . They can only be modified from outside the game so they are are necessarily \"read-only\" from in-game and cannot be modified (but copies of them could be made into database-prototypes). These were the only prototypes available before Evennia 0.8. Module based prototypes can be useful in order for developers to provide read-only \"starting\" or \"base\" prototypes to build from or if they just prefer to work offline in an external code editor. By default mygame/world/prototypes.py is set up for you to add your own prototypes. All global dicts in this module will be considered by Evennia to be a prototype. You could also tell Evennia to look for prototypes in more modules if you want: # in mygame/server/conf.py PROTOTYPE_MODULES = += [\"world.myownprototypes\", \"combat.prototypes\"] Here is an example of a prototype defined in a module: ```python # in a module Evennia looks at for prototypes, # (like mygame/world/prototypes.py) ORC_SHAMAN = {\"key\":\"Orc shaman\", \"typeclass\": \"typeclasses.monsters.Orc\", \"weapon\": \"wooden staff\", \"health\": 20} ``` Note that in the example above, \"ORC_SHAMAN\" will become the prototype_key of this prototype. It's the only case when prototype_key can be skipped in a prototype. However, if prototype_key was given explicitly, that would take precedence. This is a legacy behavior and it's recommended that you always add prototype_key to be consistent.","title":"Module-based prototypes"},{"location":"Spawner-and-Prototypes.html#using-spawn","text":"The spawner can be used from inside the game through the Builder-only @spawn command. Assuming the \"goblin\" typeclass is available to the system (either as a database-prototype or read from module), you can spawn a new goblin with @spawn goblin You can also specify the prototype directly as a valid Python dictionary: @spawn {\"prototype_key\": \"shaman\", \\ \"key\":\"Orc shaman\", \\ \"prototype_parent\": \"goblin\", \\ \"weapon\": \"wooden staff\", \\ \"health\": 20} Note: The @spawn command is more lenient about the prototype dictionary than shown here. So you can for example skip the prototype_key if you are just testing a throw-away prototype. A random hash will be used to please the validation. You could also skip prototype_parent/typeclass - then the typeclass given by settings.BASE_OBJECT_TYPECLASS will be used.","title":"Using @spawn"},{"location":"Spawner-and-Prototypes.html#using-evenniaprototypesspawner","text":"In code you access the spawner mechanism directly via the call new_objects = evennia.prototypes.spawner.spawn(*prototypes) All arguments are prototype dictionaries. The function will return a matching list of created objects. Example: obj1, obj2 = evennia.prototypes.spawner.spawn({\"key\": \"Obj1\", \"desc\": \"A test\"}, {\"key\": \"Obj2\", \"desc\": \"Another test\"}) Hint: Same as when using @spawn , when spawning from a one-time prototype dict like this, you can skip otherwise required keys, like prototype_key or typeclass / prototype_parent . Defaults will be used. Note that no location will be set automatically when using evennia.prototypes.spawner.spawn() , you have to specify location explicitly in the prototype dict. If the prototypes you supply are using prototype_parent keywords, the spawner will read prototypes from modules in settings.PROTOTYPE_MODULES as well as those saved to the database to determine the body of available parents. The spawn command takes many optional keywords, you can find its definition in the api docs .","title":"Using evennia.prototypes.spawner()"},{"location":"Start-Stop-Reload.html","text":"You control Evennia from your game folder (we refer to it as mygame/ here), using the evennia program. If the evennia program is not available on the command line you must first install Evennia as described in the Getting Started page. Hint: If you ever try the evennia command and get an error complaining that the command is not available, make sure your virtualenv is active. Below are described the various management options. Run evennia -h to give you a brief help and evennia menu to give you a menu with options. Starting Evennia \u00b6 Evennia consists of two components, the Evennia Server and Portal . Briefly, the Server is what is running the mud. It handles all game-specific things but doesn't care exactly how players connect, only that they have. The Portal is a gateway to which players connect. It knows everything about telnet, ssh, webclient protocols etc but very little about the game. Both are required for a functioning mud. evennia start The above command will start the Portal, which in turn will boot up the Server. The command will print a summary of the process and unless there is an error you will see no further output. Both components will instead log to log files in mygame/server/logs/ . For convenience you can follow those logs directly in your terminal by attaching -l to commands: evennia -l Will start following the logs of an already running server. When starting Evennia you can also do evennia start -l To stop viewing the log files, press Ctrl-C . Foreground mode \u00b6 Normally, Evennia runs as a 'daemon', in the background. If you want you can start either of the processes (but not both) as foreground processes in interactive mode. This means they will log directly to the terminal (rather than to log files that we then echo to the terminal) and you can kill the process (not just the log-file view) with Ctrl-C . evennia istart will start/restart the Server in interactive mode. This is required if you want to run a debugger . Next time you reload the server, it will return to normal mode. evennia ipstart will start the Portal in interactive mode. This is usually only necessary if you want to run Evennia under the control of some other type of process. Reloading \u00b6 The act of reloading means the Portal will tell the Server to shut down and then boot it back up again. Everyone will get a message and the game will be briefly paused for all accounts as the server reboots. Since they are connected to the Portal , their connections are not lost. Reloading is as close to a \"warm reboot\" you can get. It reinitializes all code of Evennia, but doesn't kill \"persistent\" Scripts . It also calls at_server_reload() hooks on all objects so you can save eventual temporary properties you want. From in-game the @reload command is used. You can also reload the server from outside the game: evennia reload Sometimes reloading from \"the outside\" is necessary in case you have added some sort of bug that blocks in-game input. Resetting \u00b6 Resetting is the equivalent of a \"cold reboot\" - the Server will shut down and then restarted again, but will behave as if it was fully shut down. As opposed to a \"real\" shutdown, no accounts will be disconnected during a reset. A reset will however purge all non-persistent scripts and will call at_server_shutdown() hooks. It can be a good way to clean unsafe scripts during development, for example. From in-game the @reset command is used. From the terminal: evennia reset Rebooting \u00b6 This will shut down both Server and Portal, which means all connected players will loose their connection. It can only be initiated from the terminal: evennia reboot This is identical to doing these two commands: evennia stop evennia start Shutting down \u00b6 A full shutdown closes Evennia completely, both Server and Portal. All accounts will be booted and systems saved and turned off cleanly. From inside the game you initiate a shutdown with the @shutdown command. From command line you do evennia stop You will see messages of both Server and Portal closing down. All accounts will see the shutdown message and then be disconnected. The same effect happens if you press Ctrl+C while the server runs in interactive mode. Status and info \u00b6 To check basic Evennia settings, such as which ports and services are active, this will repeat the initial return given when starting the server: evennia info You can also get a briefer run-status from both components with this command evennia status This can be useful for automating checks to make sure the game is running and is responding. Killing (Linux/Mac only) \u00b6 In the extreme case that neither of the server processes locks up and does not respond to commands, you can send them kill-signals to force them to shut down. To kill only the Server: evennia skill To kill both Server and Portal: evennia kill Note that this functionality is not supported on Windows. Django options \u00b6 The evennia program will also pass-through options used by the django-admin . These operate on the database in various ways. evennia migrate # migrate the database evennia shell # launch an interactive, django-aware python shell evennia dbshell # launch database shell For (many) more options, see the django-admin docs . Advanced handling of Evennia processes \u00b6 If you should need to manually manage Evennia's processors (or view them in a task manager program such as Linux' top or the more advanced htop ), you will find the following processes to be related to Evennia: 1 x twistd ... evennia/server/portal/portal.py - this is the Portal process. 3 x twistd ... server.py - One of these processes manages Evennia's Server component, the main game. The other processes (with the same name but different process id) handle's Evennia's internal web server threads. You can look at mygame/server/server.pid to determine which is the main process. Syntax errors during live development \u00b6 During development, you will usually modify code and then reload the server to see your changes. This is done by Evennia re-importing your custom modules from disk. Usually bugs in a module will just have you see a traceback in the game, in the log or on the command line. For some really serious syntax errors though, your module might not even be recognized as valid Python. Evennia may then fail to restart correctly. From inside the game you see a text about the Server restarting followed by an ever growing list of \"...\". Usually this only lasts a very short time (up to a few seconds). If it seems to go on, it means the Portal is still running (you are still connected to the game) but the Server-component of Evennia failed to restart (that is, it remains in a shut-down state). Look at your log files or terminal to see what the problem is - you will usually see a clear traceback showing what went wrong. Fix your bug then run evennia start Assuming the bug was fixed, this will start the Server manually (while not restarting the Portal). In-game you should now get the message that the Server has successfully restarted.","title":"Start Stop Reload"},{"location":"Start-Stop-Reload.html#starting-evennia","text":"Evennia consists of two components, the Evennia Server and Portal . Briefly, the Server is what is running the mud. It handles all game-specific things but doesn't care exactly how players connect, only that they have. The Portal is a gateway to which players connect. It knows everything about telnet, ssh, webclient protocols etc but very little about the game. Both are required for a functioning mud. evennia start The above command will start the Portal, which in turn will boot up the Server. The command will print a summary of the process and unless there is an error you will see no further output. Both components will instead log to log files in mygame/server/logs/ . For convenience you can follow those logs directly in your terminal by attaching -l to commands: evennia -l Will start following the logs of an already running server. When starting Evennia you can also do evennia start -l To stop viewing the log files, press Ctrl-C .","title":"Starting Evennia"},{"location":"Start-Stop-Reload.html#foreground-mode","text":"Normally, Evennia runs as a 'daemon', in the background. If you want you can start either of the processes (but not both) as foreground processes in interactive mode. This means they will log directly to the terminal (rather than to log files that we then echo to the terminal) and you can kill the process (not just the log-file view) with Ctrl-C . evennia istart will start/restart the Server in interactive mode. This is required if you want to run a debugger . Next time you reload the server, it will return to normal mode. evennia ipstart will start the Portal in interactive mode. This is usually only necessary if you want to run Evennia under the control of some other type of process.","title":"Foreground mode"},{"location":"Start-Stop-Reload.html#reloading","text":"The act of reloading means the Portal will tell the Server to shut down and then boot it back up again. Everyone will get a message and the game will be briefly paused for all accounts as the server reboots. Since they are connected to the Portal , their connections are not lost. Reloading is as close to a \"warm reboot\" you can get. It reinitializes all code of Evennia, but doesn't kill \"persistent\" Scripts . It also calls at_server_reload() hooks on all objects so you can save eventual temporary properties you want. From in-game the @reload command is used. You can also reload the server from outside the game: evennia reload Sometimes reloading from \"the outside\" is necessary in case you have added some sort of bug that blocks in-game input.","title":"Reloading"},{"location":"Start-Stop-Reload.html#resetting","text":"Resetting is the equivalent of a \"cold reboot\" - the Server will shut down and then restarted again, but will behave as if it was fully shut down. As opposed to a \"real\" shutdown, no accounts will be disconnected during a reset. A reset will however purge all non-persistent scripts and will call at_server_shutdown() hooks. It can be a good way to clean unsafe scripts during development, for example. From in-game the @reset command is used. From the terminal: evennia reset","title":"Resetting"},{"location":"Start-Stop-Reload.html#rebooting","text":"This will shut down both Server and Portal, which means all connected players will loose their connection. It can only be initiated from the terminal: evennia reboot This is identical to doing these two commands: evennia stop evennia start","title":"Rebooting"},{"location":"Start-Stop-Reload.html#shutting-down","text":"A full shutdown closes Evennia completely, both Server and Portal. All accounts will be booted and systems saved and turned off cleanly. From inside the game you initiate a shutdown with the @shutdown command. From command line you do evennia stop You will see messages of both Server and Portal closing down. All accounts will see the shutdown message and then be disconnected. The same effect happens if you press Ctrl+C while the server runs in interactive mode.","title":"Shutting down"},{"location":"Start-Stop-Reload.html#status-and-info","text":"To check basic Evennia settings, such as which ports and services are active, this will repeat the initial return given when starting the server: evennia info You can also get a briefer run-status from both components with this command evennia status This can be useful for automating checks to make sure the game is running and is responding.","title":"Status and info"},{"location":"Start-Stop-Reload.html#killing-linuxmac-only","text":"In the extreme case that neither of the server processes locks up and does not respond to commands, you can send them kill-signals to force them to shut down. To kill only the Server: evennia skill To kill both Server and Portal: evennia kill Note that this functionality is not supported on Windows.","title":"Killing (Linux/Mac only)"},{"location":"Start-Stop-Reload.html#django-options","text":"The evennia program will also pass-through options used by the django-admin . These operate on the database in various ways. evennia migrate # migrate the database evennia shell # launch an interactive, django-aware python shell evennia dbshell # launch database shell For (many) more options, see the django-admin docs .","title":"Django options"},{"location":"Start-Stop-Reload.html#advanced-handling-of-evennia-processes","text":"If you should need to manually manage Evennia's processors (or view them in a task manager program such as Linux' top or the more advanced htop ), you will find the following processes to be related to Evennia: 1 x twistd ... evennia/server/portal/portal.py - this is the Portal process. 3 x twistd ... server.py - One of these processes manages Evennia's Server component, the main game. The other processes (with the same name but different process id) handle's Evennia's internal web server threads. You can look at mygame/server/server.pid to determine which is the main process.","title":"Advanced handling of Evennia processes"},{"location":"Start-Stop-Reload.html#syntax-errors-during-live-development","text":"During development, you will usually modify code and then reload the server to see your changes. This is done by Evennia re-importing your custom modules from disk. Usually bugs in a module will just have you see a traceback in the game, in the log or on the command line. For some really serious syntax errors though, your module might not even be recognized as valid Python. Evennia may then fail to restart correctly. From inside the game you see a text about the Server restarting followed by an ever growing list of \"...\". Usually this only lasts a very short time (up to a few seconds). If it seems to go on, it means the Portal is still running (you are still connected to the game) but the Server-component of Evennia failed to restart (that is, it remains in a shut-down state). Look at your log files or terminal to see what the problem is - you will usually see a clear traceback showing what went wrong. Fix your bug then run evennia start Assuming the bug was fixed, this will start the Server manually (while not restarting the Portal). In-game you should now get the message that the Server has successfully restarted.","title":"Syntax errors during live development"},{"location":"Static-In-Game-Map.html","text":"Introduction \u00b6 This tutorial describes the creation of an in-game map display based on a pre-drawn map. It also details how to use the Batch code processor for advanced building. There is also the Dynamic in-game map tutorial that works in the opposite direction, by generating a map from an existing grid of rooms. Evennia does not require its rooms to be positioned in a \"logical\" way. Your exits could be named anything. You could make an exit \"west\" that leads to a room described to be in the far north. You could have rooms inside one another, exits leading back to the same room or describing spatial geometries impossible in the real world. That said, most games do organize their rooms in a logical fashion, if nothing else to retain the sanity of their players. And when they do, the game becomes possible to map. This tutorial will give an example of a simple but flexible in-game map system to further help player's to navigate. We will To simplify development and error-checking we'll break down the work into bite-size chunks, each building on what came before. For this we'll make extensive use of the Batch code processor , so you may want to familiarize yourself with that. Planning the map - Here we'll come up with a small example map to use for the rest of the tutorial. Making a map object - This will showcase how to make a static in-game \"map\" object a Character could pick up and look at. Building the map areas - Here we'll actually create the small example area according to the map we designed before. Map code - This will link the map to the location so our output looks something like this: ``` crossroads(#3) \u2191\u255a\u221e\u255d\u2191 \u2248\u2191\u2502\u2191\u2229 The merger of two roads. To the north looms a mighty castle. O\u2500O\u2500O To the south, the glow of a campfire can be seen. To the east lie \u2248\u2191\u2502\u2191\u2229 the vast mountains and to the west is heard the waves of the sea. \u2191\u25b2O\u25b2\u2191 Exits: north(#8), east(#9), south(#10), west(#11) ``` We will henceforth assume your game folder is name named mygame and that you haven't modified the default commands. We will also not be using Colors for our map since they don't show in the documentation wiki. Planning the Map \u00b6 Let's begin with the fun part! Maps in MUDs come in many different shapes and sizes . Some appear as just boxes connected by lines. Others have complex graphics that are external to the game itself. Our map will be in-game text but that doesn't mean we're restricted to the normal alphabet! If you've ever selected the Wingdings font in Microsoft Word you will know there are a multitude of other characters around to use. When creating your game with Evennia you have access to the UTF-8 character encoding which put at your disposal thousands of letters, number and geometric shapes . For this exercise, we've copy-and-pasted from the pallet of special characters used over at Dwarf Fortress to create what is hopefully a pleasing and easy to understood landscape: \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2554\u2550\u2557\u2191\u2229\u2229 Places the account can visit are indicated by \"O\". \u2248\u2248\u2191\u2551O\u2551\u2191\u2229\u2229 Up the top is a castle visitable by the account. \u2248\u2248\u2191\u255a\u221e\u255d\u2191\u2229\u2229 To the right is a cottage and to the left the beach. \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 And down the bottom is a camp site with tents. \u2248\u2248O\u2500O\u2500O\u2302\u2229 In the center is the starting location, a crossroads \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 which connect the four other areas. \u2248\u2248\u2191\u25b2O\u25b2\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u25b2\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 There are many considerations when making a game map depending on the play style and requirements you intend to implement. Here we will display a 5x5 character map of the area surrounding the account. This means making sure to account for 2 characters around every visitable location. Good planning at this stage can solve many problems before they happen. Creating a Map Object \u00b6 In this section we will try to create an actual \"map\" object that an account can pick up and look at. Evennia offers a range of default commands for creating objects and rooms in-game . While readily accessible, these commands are made to do very specific, restricted things and will thus not offer as much flexibility to experiment (for an advanced exception see in-line functions ). Additionally, entering long descriptions and properties over and over in the game client can become tedious; especially when testing and you may want to delete and recreate things over and over. To overcome this, Evennia offers batch processors that work as input-files created out-of-game. In this tutorial we'll be using the more powerful of the two available batch processors, the Batch Code Processor , called with the @batchcode command. This is a very powerful tool. It allows you to craft Python files to act as blueprints of your entire game world. These files have access to use Evennia's Python API directly. Batchcode allows for easy editing and creation in whatever text editor you prefer, avoiding having to manually build the world line-by-line inside the game. Important warning: @batchcode 's power is only rivaled by the @py command. Batchcode is so powerful it should be reserved only for the superuser . Think carefully before you let others (such as Developer - level staff) run @batchcode on their own - make sure you are okay with them running arbitrary Python code on your server. While a simple example, the map object it serves as good way to try out @batchcode . Go to mygame/world and create a new file there named batchcode_map.py : # mygame/world/batchcode_map.py from evennia import create_object from evennia import DefaultObject # We use the create_object function to call into existence a # DefaultObject named \"Map\" wherever you are standing. map = create_object(DefaultObject, key=\"Map\", location=caller.location) # We then access its description directly to make it our map. map.db.desc = \"\"\" \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2554\u2550\u2557\u2191\u2229\u2229 \u2248\u2248\u2191\u2551O\u2551\u2191\u2229\u2229 \u2248\u2248\u2191\u255a\u221e\u255d\u2191\u2229\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248O\u2500O\u2500O\u2302\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248\u2191\u25b2O\u25b2\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u25b2\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \"\"\" # This message lets us know our map was created successfully. caller.msg(\"A map appears out of thin air and falls to the ground.\") Log into your game project as the superuser and run the command @batchcode batchcode_map This will load your batchcode_map.py file and execute the code (Evennia will look in your world/ folder automatically so you don't need to specify it). A new map object should have appeared on the ground. You can view the map by using look map . Let's take it with the get map command. We'll need it in case we get lost! Building the map areas \u00b6 We've just used batchcode to create an object useful for our adventures. But the locations on that map does not actually exist yet - we're all mapped up with nowhere to go! Let's use batchcode to build a game area based on our map. We have five areas outlined: a castle, a cottage, a campsite, a coastal beach and the crossroads which connects them. Create a new batchcode file for this in mygame/world , named batchcode_world.py . # mygame/world/batchcode_world.py from evennia import create_object, search_object from typeclasses import rooms, exits # We begin by creating our rooms so we can detail them later. centre = create_object(rooms.Room, key=\"crossroads\") north = create_object(rooms.Room, key=\"castle\") east = create_object(rooms.Room, key=\"cottage\") south = create_object(rooms.Room, key=\"camp\") west = create_object(rooms.Room, key=\"coast\") # This is where we set up the cross roads. # The rooms description is what we see with the 'look' command. centre.db.desc = \"\"\" The merger of two roads. A single lamp post dimly illuminates the lonely crossroads. To the north looms a mighty castle. To the south the glow of a campfire can be seen. To the east lie a wall of mountains and to the west the dull roar of the open sea. \"\"\" # Here we are creating exits from the centre \"crossroads\" location to # destinations to the north, east, south, and west. We will be able # to use the exit by typing it's key e.g. \"north\" or an alias e.g. \"n\". centre_north = create_object(exits.Exit, key=\"north\", aliases=[\"n\"], location=centre, destination=north) centre_east = create_object(exits.Exit, key=\"east\", aliases=[\"e\"], location=centre, destination=east) centre_south = create_object(exits.Exit, key=\"south\", aliases=[\"s\"], location=centre, destination=south) centre_west = create_object(exits.Exit, key=\"west\", aliases=[\"w\"], location=centre, destination=west) # Now we repeat this for the other rooms we'll be implementing. # This is where we set up the northern castle. north.db.desc = \"An impressive castle surrounds you. \" \\ \"There might be a princess in one of these towers.\" north_south = create_object(exits.Exit, key=\"south\", aliases=[\"s\"], location=north, destination=centre) # This is where we set up the eastern cottage. east.db.desc = \"A cosy cottage nestled among mountains \" \\ \"stretching east as far as the eye can see.\" east_west = create_object(exits.Exit, key=\"west\", aliases=[\"w\"], location=east, destination=centre) # This is where we set up the southern camp. south.db.desc = \"Surrounding a clearing are a number of \" \\ \"tribal tents and at their centre a roaring fire.\" south_north = create_object(exits.Exit, key=\"north\", aliases=[\"n\"], location=south, destination=centre) # This is where we set up the western coast. west.db.desc = \"The dark forest halts to a sandy beach. \" \\ \"The sound of crashing waves calms the soul.\" west_east = create_object(exits.Exit, key=\"east\", aliases=[\"e\"], location=west, destination=centre) # Lastly, lets make an entrance to our world from the default Limbo room. limbo = search_object('Limbo')[0] limbo_exit = create_object(exits.Exit, key=\"enter world\", aliases=[\"enter\"], location=limbo, destination=centre) Apply this new batch code with @batchcode batchcode_world . If there are no errors in the code we now have a nice mini-world to explore. Remember that if you get lost you can look at the map we created! In-game minimap \u00b6 Now we have a landscape and matching map, but what we really want is a mini-map that displays whenever we move to a room or use the look command. We could manually enter a part of the map into the description of every room like we did our map object description. But some MUDs have tens of thousands of rooms! Besides, if we ever changed our map we would have to potentially alter a lot of those room descriptions manually to match the change. So instead we will make one central module to hold our map. Rooms will reference this central location on creation and the map changes will thus come into effect when next running our batchcode. To make our mini-map we need to be able to cut our full map into parts. To do this we need to put it in a format which allows us to do that easily. Luckily, python allows us to treat strings as lists of characters allowing us to pick out the characters we need. mygame/world/map_module.py # We place our map into a sting here. world_map = \"\"\"\\ \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2554\u2550\u2557\u2191\u2229\u2229 \u2248\u2248\u2191\u2551O\u2551\u2191\u2229\u2229 \u2248\u2248\u2191\u255a\u221e\u255d\u2191\u2229\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248O\u2500O\u2500O\u2302\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248\u2191\u25b2O\u25b2\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u25b2\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \"\"\" # This turns our map string into a list of rows. Because python # allows us to treat strings as a list of characters, we can access # those characters with world_map[5][5] where world_map[row][column]. world_map = world_map.split('\\n') def return_map(): \"\"\" This function returns the whole map \"\"\" map = \"\" #For each row in our map, add it to map for valuey in world_map: map += valuey map += \"\\n\" return map def return_minimap(x, y, radius = 2): \"\"\" This function returns only part of the map. Returning all chars in a 2 char radius from (x,y) \"\"\" map = \"\" #For each row we need, add the characters we need. for valuey in world_map[y-radius:y+radius+1]: for valuex in valuey[x-radius:x+radius+1]: map += valuex map += \"\\n\" return map With our map_module set up, let's replace our hardcoded map in mygame/world/batchcode_map.py with a reference to our map module. Make sure to import our map_module! # mygame/world/batchcode_map.py from evennia import create_object from evennia import DefaultObject from world import map_module map = create_object(DefaultObject, key=\"Map\", location=caller.location) map.db.desc = map_module.return_map() caller.msg(\"A map appears out of thin air and falls to the ground.\") Log into Evennia as the superuser and run this batchcode. If everything worked our new map should look exactly the same as the old map - you can use @delete to delete the old one (use a number to pick which to delete). Now, lets turn our attention towards our game's rooms. Let's use the return_minimap method we created above in order to include a minimap in our room descriptions. This is a little more complicated. By itself we would have to settle for either the map being above the description with room.db.desc = map_string + description_string , or the map going below by reversing their order. Both options are rather unsatisfactory - we would like to have the map next to the text! For this solution we'll explore the utilities that ship with Evennia. Tucked away in evennia\\evennia\\utils is a little module called EvTable . This is an advanced ASCII table creator for you to utilize in your game. We'll use it by creating a basic table with 1 row and two columns (one for our map and one for our text) whilst also hiding the borders. Open the batchfile again # mygame\\world\\batchcode_world.py # Add to imports from evennia.utils import evtable from world import map_module # [...] # Replace the descriptions with the below code. # The cross roads. # We pass what we want in our table and EvTable does the rest. # Passing two arguments will create two columns but we could add more. # We also specify no border. centre.db.desc = evtable.EvTable(map_module.return_minimap(4,5), \"The merger of two roads. A single lamp post dimly \" \\ \"illuminates the lonely crossroads. To the north \" \\ \"looms a mighty castle. To the south the glow of \" \\ \"a campfire can be seen. To the east lie a wall of \" \\ \"mountains and to the west the dull roar of the open sea.\", border=None) # EvTable allows formatting individual columns and cells. We use that here # to set a maximum width for our description, but letting the map fill # whatever space it needs. centre.db.desc.reformat_column(1, width=70) # [...] # The northern castle. north.db.desc = evtable.EvTable(map_module.return_minimap(4,2), \"An impressive castle surrounds you. There might be \" \\ \"a princess in one of these towers.\", border=None) north.db.desc.reformat_column(1, width=70) # [...] # The eastern cottage. east.db.desc = evtable.EvTable(map_module.return_minimap(6,5), \"A cosy cottage nestled among mountains stretching \" \\ \"east as far as the eye can see.\", border=None) east.db.desc.reformat_column(1, width=70) # [...] # The southern camp. south.db.desc = evtable.EvTable(map_module.return_minimap(4,7), \"Surrounding a clearing are a number of tribal tents \" \\ \"and at their centre a roaring fire.\", border=None) south.db.desc.reformat_column(1, width=70) # [...] # The western coast. west.db.desc = evtable.EvTable(map_module.return_minimap(2,5), \"The dark forest halts to a sandy beach. The sound of \" \\ \"crashing waves calms the soul.\", border=None) west.db.desc.reformat_column(1, width=70) Before we run our new batchcode, if you are anything like me you would have something like 100 maps lying around and 3-4 different versions of our rooms extending from limbo. Let's wipe it all and start with a clean slate. In Command Prompt you can run evennia flush to clear the database and start anew. It won't reset dbref values however, so if you are at #100 it will start from there. Alternatively you can navigate to mygame/server and delete the evennia.db3 file. Now in Command Prompt use evennia migrate to have a completely freshly made database. Log in to evennia and run @batchcode batchcode_world and you'll have a little world to explore. Conclusions \u00b6 You should now have a mapped little world and a basic understanding of batchcode, EvTable and how easily new game defining features can be added to Evennia. You can easily build from this tutorial by expanding the map and creating more rooms to explore. Why not add more features to your game by trying other tutorials: Add weather to your world , fill your world with NPC's or implement a combat system .","title":"Static In Game Map"},{"location":"Static-In-Game-Map.html#introduction","text":"This tutorial describes the creation of an in-game map display based on a pre-drawn map. It also details how to use the Batch code processor for advanced building. There is also the Dynamic in-game map tutorial that works in the opposite direction, by generating a map from an existing grid of rooms. Evennia does not require its rooms to be positioned in a \"logical\" way. Your exits could be named anything. You could make an exit \"west\" that leads to a room described to be in the far north. You could have rooms inside one another, exits leading back to the same room or describing spatial geometries impossible in the real world. That said, most games do organize their rooms in a logical fashion, if nothing else to retain the sanity of their players. And when they do, the game becomes possible to map. This tutorial will give an example of a simple but flexible in-game map system to further help player's to navigate. We will To simplify development and error-checking we'll break down the work into bite-size chunks, each building on what came before. For this we'll make extensive use of the Batch code processor , so you may want to familiarize yourself with that. Planning the map - Here we'll come up with a small example map to use for the rest of the tutorial. Making a map object - This will showcase how to make a static in-game \"map\" object a Character could pick up and look at. Building the map areas - Here we'll actually create the small example area according to the map we designed before. Map code - This will link the map to the location so our output looks something like this: ``` crossroads(#3) \u2191\u255a\u221e\u255d\u2191 \u2248\u2191\u2502\u2191\u2229 The merger of two roads. To the north looms a mighty castle. O\u2500O\u2500O To the south, the glow of a campfire can be seen. To the east lie \u2248\u2191\u2502\u2191\u2229 the vast mountains and to the west is heard the waves of the sea. \u2191\u25b2O\u25b2\u2191 Exits: north(#8), east(#9), south(#10), west(#11) ``` We will henceforth assume your game folder is name named mygame and that you haven't modified the default commands. We will also not be using Colors for our map since they don't show in the documentation wiki.","title":"Introduction"},{"location":"Static-In-Game-Map.html#planning-the-map","text":"Let's begin with the fun part! Maps in MUDs come in many different shapes and sizes . Some appear as just boxes connected by lines. Others have complex graphics that are external to the game itself. Our map will be in-game text but that doesn't mean we're restricted to the normal alphabet! If you've ever selected the Wingdings font in Microsoft Word you will know there are a multitude of other characters around to use. When creating your game with Evennia you have access to the UTF-8 character encoding which put at your disposal thousands of letters, number and geometric shapes . For this exercise, we've copy-and-pasted from the pallet of special characters used over at Dwarf Fortress to create what is hopefully a pleasing and easy to understood landscape: \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2554\u2550\u2557\u2191\u2229\u2229 Places the account can visit are indicated by \"O\". \u2248\u2248\u2191\u2551O\u2551\u2191\u2229\u2229 Up the top is a castle visitable by the account. \u2248\u2248\u2191\u255a\u221e\u255d\u2191\u2229\u2229 To the right is a cottage and to the left the beach. \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 And down the bottom is a camp site with tents. \u2248\u2248O\u2500O\u2500O\u2302\u2229 In the center is the starting location, a crossroads \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 which connect the four other areas. \u2248\u2248\u2191\u25b2O\u25b2\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u25b2\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 There are many considerations when making a game map depending on the play style and requirements you intend to implement. Here we will display a 5x5 character map of the area surrounding the account. This means making sure to account for 2 characters around every visitable location. Good planning at this stage can solve many problems before they happen.","title":"Planning the Map"},{"location":"Static-In-Game-Map.html#creating-a-map-object","text":"In this section we will try to create an actual \"map\" object that an account can pick up and look at. Evennia offers a range of default commands for creating objects and rooms in-game . While readily accessible, these commands are made to do very specific, restricted things and will thus not offer as much flexibility to experiment (for an advanced exception see in-line functions ). Additionally, entering long descriptions and properties over and over in the game client can become tedious; especially when testing and you may want to delete and recreate things over and over. To overcome this, Evennia offers batch processors that work as input-files created out-of-game. In this tutorial we'll be using the more powerful of the two available batch processors, the Batch Code Processor , called with the @batchcode command. This is a very powerful tool. It allows you to craft Python files to act as blueprints of your entire game world. These files have access to use Evennia's Python API directly. Batchcode allows for easy editing and creation in whatever text editor you prefer, avoiding having to manually build the world line-by-line inside the game. Important warning: @batchcode 's power is only rivaled by the @py command. Batchcode is so powerful it should be reserved only for the superuser . Think carefully before you let others (such as Developer - level staff) run @batchcode on their own - make sure you are okay with them running arbitrary Python code on your server. While a simple example, the map object it serves as good way to try out @batchcode . Go to mygame/world and create a new file there named batchcode_map.py : # mygame/world/batchcode_map.py from evennia import create_object from evennia import DefaultObject # We use the create_object function to call into existence a # DefaultObject named \"Map\" wherever you are standing. map = create_object(DefaultObject, key=\"Map\", location=caller.location) # We then access its description directly to make it our map. map.db.desc = \"\"\" \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2554\u2550\u2557\u2191\u2229\u2229 \u2248\u2248\u2191\u2551O\u2551\u2191\u2229\u2229 \u2248\u2248\u2191\u255a\u221e\u255d\u2191\u2229\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248O\u2500O\u2500O\u2302\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248\u2191\u25b2O\u25b2\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u25b2\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \"\"\" # This message lets us know our map was created successfully. caller.msg(\"A map appears out of thin air and falls to the ground.\") Log into your game project as the superuser and run the command @batchcode batchcode_map This will load your batchcode_map.py file and execute the code (Evennia will look in your world/ folder automatically so you don't need to specify it). A new map object should have appeared on the ground. You can view the map by using look map . Let's take it with the get map command. We'll need it in case we get lost!","title":"Creating a Map Object"},{"location":"Static-In-Game-Map.html#building-the-map-areas","text":"We've just used batchcode to create an object useful for our adventures. But the locations on that map does not actually exist yet - we're all mapped up with nowhere to go! Let's use batchcode to build a game area based on our map. We have five areas outlined: a castle, a cottage, a campsite, a coastal beach and the crossroads which connects them. Create a new batchcode file for this in mygame/world , named batchcode_world.py . # mygame/world/batchcode_world.py from evennia import create_object, search_object from typeclasses import rooms, exits # We begin by creating our rooms so we can detail them later. centre = create_object(rooms.Room, key=\"crossroads\") north = create_object(rooms.Room, key=\"castle\") east = create_object(rooms.Room, key=\"cottage\") south = create_object(rooms.Room, key=\"camp\") west = create_object(rooms.Room, key=\"coast\") # This is where we set up the cross roads. # The rooms description is what we see with the 'look' command. centre.db.desc = \"\"\" The merger of two roads. A single lamp post dimly illuminates the lonely crossroads. To the north looms a mighty castle. To the south the glow of a campfire can be seen. To the east lie a wall of mountains and to the west the dull roar of the open sea. \"\"\" # Here we are creating exits from the centre \"crossroads\" location to # destinations to the north, east, south, and west. We will be able # to use the exit by typing it's key e.g. \"north\" or an alias e.g. \"n\". centre_north = create_object(exits.Exit, key=\"north\", aliases=[\"n\"], location=centre, destination=north) centre_east = create_object(exits.Exit, key=\"east\", aliases=[\"e\"], location=centre, destination=east) centre_south = create_object(exits.Exit, key=\"south\", aliases=[\"s\"], location=centre, destination=south) centre_west = create_object(exits.Exit, key=\"west\", aliases=[\"w\"], location=centre, destination=west) # Now we repeat this for the other rooms we'll be implementing. # This is where we set up the northern castle. north.db.desc = \"An impressive castle surrounds you. \" \\ \"There might be a princess in one of these towers.\" north_south = create_object(exits.Exit, key=\"south\", aliases=[\"s\"], location=north, destination=centre) # This is where we set up the eastern cottage. east.db.desc = \"A cosy cottage nestled among mountains \" \\ \"stretching east as far as the eye can see.\" east_west = create_object(exits.Exit, key=\"west\", aliases=[\"w\"], location=east, destination=centre) # This is where we set up the southern camp. south.db.desc = \"Surrounding a clearing are a number of \" \\ \"tribal tents and at their centre a roaring fire.\" south_north = create_object(exits.Exit, key=\"north\", aliases=[\"n\"], location=south, destination=centre) # This is where we set up the western coast. west.db.desc = \"The dark forest halts to a sandy beach. \" \\ \"The sound of crashing waves calms the soul.\" west_east = create_object(exits.Exit, key=\"east\", aliases=[\"e\"], location=west, destination=centre) # Lastly, lets make an entrance to our world from the default Limbo room. limbo = search_object('Limbo')[0] limbo_exit = create_object(exits.Exit, key=\"enter world\", aliases=[\"enter\"], location=limbo, destination=centre) Apply this new batch code with @batchcode batchcode_world . If there are no errors in the code we now have a nice mini-world to explore. Remember that if you get lost you can look at the map we created!","title":"Building the map areas"},{"location":"Static-In-Game-Map.html#in-game-minimap","text":"Now we have a landscape and matching map, but what we really want is a mini-map that displays whenever we move to a room or use the look command. We could manually enter a part of the map into the description of every room like we did our map object description. But some MUDs have tens of thousands of rooms! Besides, if we ever changed our map we would have to potentially alter a lot of those room descriptions manually to match the change. So instead we will make one central module to hold our map. Rooms will reference this central location on creation and the map changes will thus come into effect when next running our batchcode. To make our mini-map we need to be able to cut our full map into parts. To do this we need to put it in a format which allows us to do that easily. Luckily, python allows us to treat strings as lists of characters allowing us to pick out the characters we need. mygame/world/map_module.py # We place our map into a sting here. world_map = \"\"\"\\ \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2554\u2550\u2557\u2191\u2229\u2229 \u2248\u2248\u2191\u2551O\u2551\u2191\u2229\u2229 \u2248\u2248\u2191\u255a\u221e\u255d\u2191\u2229\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248O\u2500O\u2500O\u2302\u2229 \u2248\u2248\u2248\u2191\u2502\u2191\u2229\u2229\u2229 \u2248\u2248\u2191\u25b2O\u25b2\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u25b2\u2191\u2191\u2229\u2229 \u2248\u2248\u2191\u2191\u2191\u2191\u2191\u2229\u2229 \"\"\" # This turns our map string into a list of rows. Because python # allows us to treat strings as a list of characters, we can access # those characters with world_map[5][5] where world_map[row][column]. world_map = world_map.split('\\n') def return_map(): \"\"\" This function returns the whole map \"\"\" map = \"\" #For each row in our map, add it to map for valuey in world_map: map += valuey map += \"\\n\" return map def return_minimap(x, y, radius = 2): \"\"\" This function returns only part of the map. Returning all chars in a 2 char radius from (x,y) \"\"\" map = \"\" #For each row we need, add the characters we need. for valuey in world_map[y-radius:y+radius+1]: for valuex in valuey[x-radius:x+radius+1]: map += valuex map += \"\\n\" return map With our map_module set up, let's replace our hardcoded map in mygame/world/batchcode_map.py with a reference to our map module. Make sure to import our map_module! # mygame/world/batchcode_map.py from evennia import create_object from evennia import DefaultObject from world import map_module map = create_object(DefaultObject, key=\"Map\", location=caller.location) map.db.desc = map_module.return_map() caller.msg(\"A map appears out of thin air and falls to the ground.\") Log into Evennia as the superuser and run this batchcode. If everything worked our new map should look exactly the same as the old map - you can use @delete to delete the old one (use a number to pick which to delete). Now, lets turn our attention towards our game's rooms. Let's use the return_minimap method we created above in order to include a minimap in our room descriptions. This is a little more complicated. By itself we would have to settle for either the map being above the description with room.db.desc = map_string + description_string , or the map going below by reversing their order. Both options are rather unsatisfactory - we would like to have the map next to the text! For this solution we'll explore the utilities that ship with Evennia. Tucked away in evennia\\evennia\\utils is a little module called EvTable . This is an advanced ASCII table creator for you to utilize in your game. We'll use it by creating a basic table with 1 row and two columns (one for our map and one for our text) whilst also hiding the borders. Open the batchfile again # mygame\\world\\batchcode_world.py # Add to imports from evennia.utils import evtable from world import map_module # [...] # Replace the descriptions with the below code. # The cross roads. # We pass what we want in our table and EvTable does the rest. # Passing two arguments will create two columns but we could add more. # We also specify no border. centre.db.desc = evtable.EvTable(map_module.return_minimap(4,5), \"The merger of two roads. A single lamp post dimly \" \\ \"illuminates the lonely crossroads. To the north \" \\ \"looms a mighty castle. To the south the glow of \" \\ \"a campfire can be seen. To the east lie a wall of \" \\ \"mountains and to the west the dull roar of the open sea.\", border=None) # EvTable allows formatting individual columns and cells. We use that here # to set a maximum width for our description, but letting the map fill # whatever space it needs. centre.db.desc.reformat_column(1, width=70) # [...] # The northern castle. north.db.desc = evtable.EvTable(map_module.return_minimap(4,2), \"An impressive castle surrounds you. There might be \" \\ \"a princess in one of these towers.\", border=None) north.db.desc.reformat_column(1, width=70) # [...] # The eastern cottage. east.db.desc = evtable.EvTable(map_module.return_minimap(6,5), \"A cosy cottage nestled among mountains stretching \" \\ \"east as far as the eye can see.\", border=None) east.db.desc.reformat_column(1, width=70) # [...] # The southern camp. south.db.desc = evtable.EvTable(map_module.return_minimap(4,7), \"Surrounding a clearing are a number of tribal tents \" \\ \"and at their centre a roaring fire.\", border=None) south.db.desc.reformat_column(1, width=70) # [...] # The western coast. west.db.desc = evtable.EvTable(map_module.return_minimap(2,5), \"The dark forest halts to a sandy beach. The sound of \" \\ \"crashing waves calms the soul.\", border=None) west.db.desc.reformat_column(1, width=70) Before we run our new batchcode, if you are anything like me you would have something like 100 maps lying around and 3-4 different versions of our rooms extending from limbo. Let's wipe it all and start with a clean slate. In Command Prompt you can run evennia flush to clear the database and start anew. It won't reset dbref values however, so if you are at #100 it will start from there. Alternatively you can navigate to mygame/server and delete the evennia.db3 file. Now in Command Prompt use evennia migrate to have a completely freshly made database. Log in to evennia and run @batchcode batchcode_world and you'll have a little world to explore.","title":"In-game minimap"},{"location":"Static-In-Game-Map.html#conclusions","text":"You should now have a mapped little world and a basic understanding of batchcode, EvTable and how easily new game defining features can be added to Evennia. You can easily build from this tutorial by expanding the map and creating more rooms to explore. Why not add more features to your game by trying other tutorials: Add weather to your world , fill your world with NPC's or implement a combat system .","title":"Conclusions"},{"location":"Tags.html","text":"A common task of a game designer is to organize and find groups of objects and do operations on them. A classic example is to have a weather script affect all \"outside\" rooms. Another would be for a player casting a magic spell that affects every location \"in the dungeon\", but not those \"outside\". Another would be to quickly find everyone joined with a particular guild or everyone currently dead. Tags are short text labels that you attach to objects so as to easily be able to retrieve and group them. An Evennia entity can be tagged with any number of Tags. On the database side, Tag entities are shared between all objects with that tag. This makes them very efficient but also fundamentally different from Attributes , each of which always belongs to one single object. In Evennia, Tags are technically also used to implement Aliases (alternative names for objects) and Permissions (simple strings for Locks to check for). Properties of Tags (and Aliases and Permissions) \u00b6 Tags are unique . This means that there is only ever one Tag object with a given key and category. When Tags are assigned to game entities, these entities are actually sharing the same Tag. This means that Tags are not suitable for storing information about a single object - use an Attribute for this instead. Tags are a lot more limited than Attributes but this also makes them very quick to lookup in the database - this is the whole point. Tags have the following properties, stored in the database: key - the name of the Tag. This is the main property to search for when looking up a Tag. category - this category allows for retrieving only specific subsets of tags used for different purposes. You could have one category of tags for \"zones\", another for \"outdoor locations\", for example. data - this is an optional text field with information about the tag. Remember that Tags are shared between entities, so this field cannot hold any object-specific information. Usually it would be used to hold info about the group of entities the Tag is tagging - possibly used for contextual help like a tool tip. It is not used by default. There are also two special properties. These should usually not need to be changed or set, it is used internally by Evennia to implement various other uses it makes of the Tag object: - model - this holds a natural-key description of the model object that this tag deals with, on the form application.modelclass , for example objects.objectdb . It used by the TagHandler of each entity type for correctly storing the data behind the scenes. - tagtype - this is a \"top-level category\" of sorts for the inbuilt children of Tags, namely Aliases and Permissions . The Taghandlers using this special field are especially intended to free up the category property for any use you desire. Adding/Removing Tags \u00b6 You can tag any typeclassed object, namely Objects , Accounts , Scripts and Channels . General tags are added by the Taghandler . The tag handler is accessed as a property tags on the relevant entity: mychair.tags.add(\"furniture\") myroom.tags.add(\"dungeon#01\") myscript.tags.add(\"weather\", category=\"climate\") myaccount.tags.add(\"guestaccount\") mychair.tags.all() # returns a list of Tags mychair.tags.remove(\"furniture\") mychair.tags.clear() Adding a new tag will either create a new Tag or re-use an already existing one. When using remove , the Tag is not deleted but are just disconnected from the tagged object. This makes for very quick operations. The clear method removes (disconnects) all Tags from the object. You can also use the default @tag command: @tag mychair = furniture Searching for objects with a given tag \u00b6 Usually tags are used as a quick way to find tagged database entities. You can retrieve all objects with a given Tag like this in code: import evennia # all methods return Querysets # search for objects objs = evennia.search_tag(\"furniture\") dungeon = evennia.search_tag(\"dungeon#01\") forest_rooms = evennia.search_tag(category=\"forest\") forest_meadows = evennia.search_tag(\"meadow\", category=\"forest\") magic_meadows = evennia.search_tag(\"meadow\", category=\"magical\") # search for scripts weather = evennia.search_tag_script(\"weather\") climates = evennia.search_tag_script(category=\"climate\") # search for accounts accounts = evennia.search_tag_account(\"guestaccount\") Using any of the search_tag variants will all return Django Querysets , including if you only have one match. You can treat querysets as lists and iterate over them, or continue building search queries with them. Remember when searching that not setting a category means setting it to None - this does not mean that category is undefined, rather None is considered the default, unnamed category. import evennia myobj1.tags.add(\"foo\") # implies category=None myobj2.tags.add(\"foo\", category=\"bar\") # this returns a queryset with *only* myobj1 objs = evennia.search_tag(\"foo\") # these return a queryset with *only* myobj2 objs = evennia.search_tag(\"foo\", category=\"bar\") # or objs = evennia.search_tag(category=\"bar\") There is also an in-game command that deals with assigning and using ( Object- ) tags: @tag/search furniture Using Aliases and Permissions \u00b6 Aliases and Permissions are implemented using normal TagHandlers that simply save Tags with a different tagtype . These handlers are named aliases and permissions on all Objects. They are used in the same way as Tags above: boy.aliases.add(\"rascal\") boy.permissions.add(\"Builders\") boy.permissions.remove(\"Builders\") all_aliases = boy.aliases.all() and so on. Similarly to how @tag works in-game, there is also the @perm command for assigning permissions and @alias command for aliases. Assorted notes \u00b6 Generally, tags are enough on their own for grouping objects. Having no tag category is perfectly fine and the normal operation. Simply adding a new Tag for grouping objects is often better than making a new category. So think hard before deciding you really need to categorize your Tags. That said, tag categories can be useful if you build some game system that uses tags. You can then use tag categories to make sure to separate tags created with this system from any other tags created elsewhere. You can then supply custom search methods that only find objects tagged with tags of that category. An example of this is found in the Zone tutorial .","title":"Tags"},{"location":"Tags.html#properties-of-tags-and-aliases-and-permissions","text":"Tags are unique . This means that there is only ever one Tag object with a given key and category. When Tags are assigned to game entities, these entities are actually sharing the same Tag. This means that Tags are not suitable for storing information about a single object - use an Attribute for this instead. Tags are a lot more limited than Attributes but this also makes them very quick to lookup in the database - this is the whole point. Tags have the following properties, stored in the database: key - the name of the Tag. This is the main property to search for when looking up a Tag. category - this category allows for retrieving only specific subsets of tags used for different purposes. You could have one category of tags for \"zones\", another for \"outdoor locations\", for example. data - this is an optional text field with information about the tag. Remember that Tags are shared between entities, so this field cannot hold any object-specific information. Usually it would be used to hold info about the group of entities the Tag is tagging - possibly used for contextual help like a tool tip. It is not used by default. There are also two special properties. These should usually not need to be changed or set, it is used internally by Evennia to implement various other uses it makes of the Tag object: - model - this holds a natural-key description of the model object that this tag deals with, on the form application.modelclass , for example objects.objectdb . It used by the TagHandler of each entity type for correctly storing the data behind the scenes. - tagtype - this is a \"top-level category\" of sorts for the inbuilt children of Tags, namely Aliases and Permissions . The Taghandlers using this special field are especially intended to free up the category property for any use you desire.","title":"Properties of Tags (and Aliases and Permissions)"},{"location":"Tags.html#addingremoving-tags","text":"You can tag any typeclassed object, namely Objects , Accounts , Scripts and Channels . General tags are added by the Taghandler . The tag handler is accessed as a property tags on the relevant entity: mychair.tags.add(\"furniture\") myroom.tags.add(\"dungeon#01\") myscript.tags.add(\"weather\", category=\"climate\") myaccount.tags.add(\"guestaccount\") mychair.tags.all() # returns a list of Tags mychair.tags.remove(\"furniture\") mychair.tags.clear() Adding a new tag will either create a new Tag or re-use an already existing one. When using remove , the Tag is not deleted but are just disconnected from the tagged object. This makes for very quick operations. The clear method removes (disconnects) all Tags from the object. You can also use the default @tag command: @tag mychair = furniture","title":"Adding/Removing Tags"},{"location":"Tags.html#searching-for-objects-with-a-given-tag","text":"Usually tags are used as a quick way to find tagged database entities. You can retrieve all objects with a given Tag like this in code: import evennia # all methods return Querysets # search for objects objs = evennia.search_tag(\"furniture\") dungeon = evennia.search_tag(\"dungeon#01\") forest_rooms = evennia.search_tag(category=\"forest\") forest_meadows = evennia.search_tag(\"meadow\", category=\"forest\") magic_meadows = evennia.search_tag(\"meadow\", category=\"magical\") # search for scripts weather = evennia.search_tag_script(\"weather\") climates = evennia.search_tag_script(category=\"climate\") # search for accounts accounts = evennia.search_tag_account(\"guestaccount\") Using any of the search_tag variants will all return Django Querysets , including if you only have one match. You can treat querysets as lists and iterate over them, or continue building search queries with them. Remember when searching that not setting a category means setting it to None - this does not mean that category is undefined, rather None is considered the default, unnamed category. import evennia myobj1.tags.add(\"foo\") # implies category=None myobj2.tags.add(\"foo\", category=\"bar\") # this returns a queryset with *only* myobj1 objs = evennia.search_tag(\"foo\") # these return a queryset with *only* myobj2 objs = evennia.search_tag(\"foo\", category=\"bar\") # or objs = evennia.search_tag(category=\"bar\") There is also an in-game command that deals with assigning and using ( Object- ) tags: @tag/search furniture","title":"Searching for objects with a given tag"},{"location":"Tags.html#using-aliases-and-permissions","text":"Aliases and Permissions are implemented using normal TagHandlers that simply save Tags with a different tagtype . These handlers are named aliases and permissions on all Objects. They are used in the same way as Tags above: boy.aliases.add(\"rascal\") boy.permissions.add(\"Builders\") boy.permissions.remove(\"Builders\") all_aliases = boy.aliases.all() and so on. Similarly to how @tag works in-game, there is also the @perm command for assigning permissions and @alias command for aliases.","title":"Using Aliases and Permissions"},{"location":"Tags.html#assorted-notes","text":"Generally, tags are enough on their own for grouping objects. Having no tag category is perfectly fine and the normal operation. Simply adding a new Tag for grouping objects is often better than making a new category. So think hard before deciding you really need to categorize your Tags. That said, tag categories can be useful if you build some game system that uses tags. You can then use tag categories to make sure to separate tags created with this system from any other tags created elsewhere. You can then supply custom search methods that only find objects tagged with tags of that category. An example of this is found in the Zone tutorial .","title":"Assorted notes"},{"location":"Text-Encodings.html","text":"Evennia is a text-based game server. This makes it important to understand how it actually deals with data in the form of text. Text byte encodings describe how a string of text is actually stored in the computer - that is, the particular sequence of bytes used to represent the letters of your particular alphabet. A common encoding used in English-speaking languages is the ASCII encoding. This describes the letters in the English alphabet (Aa-Zz) as well as a bunch of special characters. For describing other character sets (such as that of other languages with other letters than English), sets with names such as Latin-1 , ISO-8859-3 and ARMSCII-8 are used. There are hundreds of different byte encodings in use around the world. A string of letters in a byte encoding is represented with the bytes type. In contrast to the byte encoding is the unicode representation . In Python this is the str type. The unicode is an internationally agreed-upon table describing essentially all available letters you could ever want to print. Everything from English to Chinese alphabets and all in between. So what Evennia (as well as Python and Django) does is to store everything in Unicode internally, but then converts the data to one of the encodings whenever outputting data to the user. An easy memory aid is that bytes are what are sent over the network wire. At all other times, str (unicode) is used. This means that we must convert between the two at the points where we send/receive network data. The problem is that when receiving a string of bytes over the network it's impossible for Evennia to guess which encoding was used - it's just a bunch of bytes! Evennia must know the encoding in order to convert back and from the correct unicode representation. How to customize encodings \u00b6 As long as you stick to the standard ASCII character set (which means the normal English characters, basically) you should not have to worry much about this section. If you want to build your game in another language however, or expect your users to want to use special characters not in ASCII, you need to consider which encodings you want to support. As mentioned, there are many, many byte-encodings used around the world. It should be clear at this point that Evennia can't guess but has to assume or somehow be told which encoding you want to use to communicate with the server. Basically the encoding used by your client must be the same encoding used by the server. This can be customized in two complementary ways. Point users to the default @encoding command or the @options command. This allows them to themselves set which encoding they (and their client of choice) uses. Whereas data will remain stored as unicode strings internally in Evennia, all data received from and sent to this particular player will be converted to the given format before transmitting. As a back-up, in case the user-set encoding translation is erroneous or fails in some other way, Evennia will fall back to trying with the names defined in the settings variable ENCODINGS . This is a list of encoding names Evennia will try, in order, before giving up and giving an encoding error message. Note that having to try several different encodings every input/output adds unneccesary overhead. Try to guess the most common encodings you players will use and make sure these are tried first. The International UTF-8 encoding is what Evennia assumes by default (and also what Python/Django use normally). See the Wikipedia article here for more help.","title":"Text Encodings"},{"location":"Text-Encodings.html#how-to-customize-encodings","text":"As long as you stick to the standard ASCII character set (which means the normal English characters, basically) you should not have to worry much about this section. If you want to build your game in another language however, or expect your users to want to use special characters not in ASCII, you need to consider which encodings you want to support. As mentioned, there are many, many byte-encodings used around the world. It should be clear at this point that Evennia can't guess but has to assume or somehow be told which encoding you want to use to communicate with the server. Basically the encoding used by your client must be the same encoding used by the server. This can be customized in two complementary ways. Point users to the default @encoding command or the @options command. This allows them to themselves set which encoding they (and their client of choice) uses. Whereas data will remain stored as unicode strings internally in Evennia, all data received from and sent to this particular player will be converted to the given format before transmitting. As a back-up, in case the user-set encoding translation is erroneous or fails in some other way, Evennia will fall back to trying with the names defined in the settings variable ENCODINGS . This is a list of encoding names Evennia will try, in order, before giving up and giving an encoding error message. Note that having to try several different encodings every input/output adds unneccesary overhead. Try to guess the most common encodings you players will use and make sure these are tried first. The International UTF-8 encoding is what Evennia assumes by default (and also what Python/Django use normally). See the Wikipedia article here for more help.","title":"How to customize encodings"},{"location":"TextTags.html","text":"This documentation details the various text tags supported by Evennia, namely colours , command links and inline functions . There is also an Understanding Color Tags tutorial which expands on the use of ANSI color tags and the pitfalls of mixing ANSI and Xterms256 color tags in the same context. Coloured text \u00b6 Note that the Documentation does not display colour the way it would look on the screen. Color can be a very useful tool for your game. It can be used to increase readability and make your game more appealing visually. Remember however that, with the exception of the webclient, you generally don't control the client used to connect to the game. There is, for example, one special tag meaning \"yellow\". But exactly which hue of yellow is actually displayed on the user's screen depends on the settings of their particular mud client. They could even swap the colours around or turn them off altogether if so desired. Some clients don't even support color - text games are also played with special reading equipment by people who are blind or have otherwise diminished eyesight. So a good rule of thumb is to use colour to enhance your game but don't rely on it to display critical information. If you are coding the game, you can add functionality to let users disable colours as they please, as described here . To see which colours your client support, use the default @color command. This will list all available colours for ANSI and Xterm256 along with the codes you use for them. You can find a list of all the parsed ANSI -colour codes in evennia/utils/ansi.py . ANSI colours \u00b6 Evennia supports the ANSI standard for text. This is by far the most supported MUD-color standard, available in all but the most ancient mud clients. The ANSI colours are r ed, g reen, y ellow, b lue, m agenta, c yan, w hite and black. They are abbreviated by their first letter except for black which is abbreviated with the letter x . In ANSI there are \"bright\" and \"normal\" (darker) versions of each color, adding up to a total of 16 colours to use for foreground text. There are also 8 \"background\" colours. These have no bright alternative in ANSI (but Evennia uses the Xterm256 extension behind the scenes to offer them anyway). To colour your text you put special tags in it. Evennia will parse these and convert them to the correct markup for the client used. If the user's client/console/display supports ANSI colour, they will see the text in the specified colour, otherwise the tags will be stripped (uncolored text). This works also for non-terminal clients, such as the webclient. For the webclient, Evennia will translate the codes to HTML RGB colors. Here is an example of the tags in action: |rThis text is bright red.|n This is normal text. |RThis is a dark red text.|n This is normal text. |[rThis text has red background.|n This is normal text. |b|[yThis is bright blue text on yellow background.|n This is normal text. |n - this tag will turn off all color formatting, including background colors. |# - markup marks the start of foreground color. The case defines if the text is \"bright\" or \"normal\". So |g is a bright green and |G is \"normal\" (darker) green. |[# is used to add a background colour to the text. The case again specifies if it is \"bright\" or \"normal\", so |[c starts a bright cyan background and |[C a darker cyan background. |!# is used to add foreground color without any enforced brightness/normal information. These are normal-intensity and are thus always given as uppercase, such as |!R for red. The difference between e.g. |!R and |R is that |!R will \"inherit\" the brightness setting from previously set color tags, whereas |R will always reset to the normal-intensity red. The |# format contains an implicit |h / |H tag in it: disabling highlighting when switching to a normal color, and enabling it for bright ones. So |btest |!Rtest2 will result in a bright red test2 since the brightness setting from |b \"bleeds over\". You could use this to for example quickly switch the intensity of a multitude of color tags. There is no background-color equivalent to |! style tags. |h is used to make any following foreground ANSI colors bright (it has no effect on Xterm colors). This is only relevant to use with |! type tags and will be valid until the next |n , |H or normal (upper-case) |# tag. This tag will never affect background colors, those have to be set bright/normal explicitly. Technically, |h|!G is identical to |g . |H negates the effects |h and returns all ANSI foreground colors ( |! and | types) to 'normal' intensity. It has no effect on background and Xterm colors. Note: The ANSI standard does not actually support bright backgrounds like |[r - the standard only supports \"normal\" intensity backgrounds. To get around this Evennia instead implements these as Xterm256 colours behind the scenes. If the client does not support Xterm256 the ANSI colors will be used instead and there will be no visible difference between using upper- and lower-case background tags. If you want to display an ANSI marker as output text (without having any effect), you need to escape it by preceding its | with another | : say The ||r ANSI marker changes text color to bright red. This will output the raw |r without any color change. This can also be necessary if you are doing ansi art that uses | with a letter directly following it. Use the command @color ansi to get a list of all supported ANSI colours and the tags used to produce them. A few additional ANSI codes are supported: |/ A line break. You cannot put the normal Python \\n line breaks in text entered inside the game (Evennia will filter this for security reasons). This is what you use instead: use the |/ marker to format text with line breaks from the game command line. |- This will translate into a TAB character. This will not always show (or show differently) to the client since it depends on their local settings. It's often better to use multiple spaces. |_ This is a space. You can usually use the normal space character, but if the space is at the end of the line , Evennia will likely crop it. This tag will not be cropped but always result in a space. |* This will invert the current text/background colours. Can be useful to mark things (but see below). Caveats of |* \u00b6 The |* tag (inverse video) is an old ANSI standard and should usually not be used for more than to mark short snippets of text. If combined with other tags it comes with a series of potentially confusing behaviors: The |* tag will only work once in a row:, ie: after using it once it won't have an effect again until you declare another tag. This is an example: Normal text, |*reversed text|*, still reversed text. that is, it will not reverse to normal at the second |* . You need to reset it manually: ``` Normal text, |*reversed text|n, normal again. ``` The |* tag does not take \"bright\" colors into account: |RNormal red, |hnow brightened. |*BG is normal red. So |* only considers the 'true' foreground color, ignoring any highlighting. Think of the bright state ( |h ) as something like like <strong> in HTML: it modifies the appearance of a normal foreground color to match its bright counterpart, without changing its normal color. * Finally, after a |* , if the previous background was set to a dark color (via |[ ), |!# ) will actually change the background color instead of the foreground: ``` |*reversed text |!R now BG is red. ``` For a detailed explanation of these caveats, see the Understanding Color Tags tutorial. But most of the time you might be better off to simply avoid |* and mark your text manually instead. Xterm256 Colours \u00b6 The Xterm256 standard is a colour scheme that supports 256 colours for text and/or background. While this offers many more possibilities than traditional ANSI colours, be wary that too many text colors will be confusing to the eye. Also, not all clients support Xterm256 - these will instead see the closest equivalent ANSI color. You can mix Xterm256 tags with ANSI tags as you please. |555 This is pure white text.|n This is normal text. |230 This is olive green text. |[300 This text has a dark red background. |005|[054 This is dark blue text on a bright cyan background. |=a This is a greyscale value, equal to black. |=m This is a greyscale value, midway between white and black. |=z This is a greyscale value, equal to white. |[=m This is a background greyscale value. |### - markup consists of three digits, each an integer from 0 to 5. The three digits describe the amount of r ed, g reen and b lue (RGB) components used in the colour. So |500 means maximum red and none of the other colours - the result is a bright red. |520 is red with a touch of green - the result is orange. As opposed to ANSI colors, Xterm256 syntax does not worry about bright/normal intensity, a brighter (lighter) color is just achieved by upping all RGB values with the same amount. |[### - this works the same way but produces a coloured background. |=# - markup produces the xterm256 gray scale tones, where # is a letter from a (black) to z (white). This offers many more nuances of gray than the normal |### markup (which only has four gray tones between solid black and white ( |000 , |111 , |222 , |333 and |444 )). |[=# - this works in the same way but produces background gray scale tones. If you have a client that supports Xterm256, you can use @color xterm256 to get a table of all the 256 colours and the codes that produce them. If the table looks broken up into a few blocks of colors, it means Xterm256 is not supported and ANSI are used as a replacement. You can use the @options command to see if xterm256 is active for you. This depends on if your client told Evennia what it supports - if not, and you know what your client supports, you may have to activate some features manually. Clickable links \u00b6 Evennia supports clickable links for clients that supports it. This marks certain text so it can be clicked by a mouse and trigger a given Evennia command. To support clickable links, Evennia requires the webclient or an third-party telnet client with MXP support ( Note: Evennia only supports clickable links, no other MXP features ). |lc to start the link, by defining the command to execute. |lt to continue with the text to show to the user (the link text). |le to end the link text and the link definition. All elements must appear in exactly this order to make a valid link. For example, \"If you go |lcnorth|ltto the north|le you will find a cottage.\" This will display as \"If you go to the north you will find a cottage.\" where clicking the link will execute the command north . If the client does not support clickable links, only the link text will be shown. Inline functions \u00b6 Note: Inlinefuncs are not activated by default. To use them you need to add INLINEFUNC_ENABLED=True to your settings file. Evennia has its own inline text formatting language, known as inlinefuncs . It allows the builder to include special function calls in code. They are executed dynamically by each session that receives them. To add an inlinefunc, you embed it in a text string like this: \"A normal string with $funcname(arg, arg, ...) embedded inside it.\" When this string is sent to a session (with the msg() method), these embedded inlinefuncs will be parsed. Their return value (which always is a string) replace their call location in the finalized string. The interesting thing with this is that the function called will have access to which session is seeing the string, meaning the string can end up looking different depending on who is looking. It could of course also vary depending on other factors like game time. Any number of comma-separated arguments can be given (or none). No keywords are supported. You can also nest inlinefuncs by letting an argument itself also be another $funcname(arg, arg, ...) call (down to any depth of nesting). Function call resolution happens as in all programming languages inside-out, with the nested calls replacing the argument with their return strings before calling he parent. > say \"This is $pad(a center-padded text, 30,c,-) of width 30.\" You say, \"This is ---- a center-padded text----- of width 30.\" A special case happens if wanting to use an inlinefunc argument that itself includes a comma - this would be parsed as an argument separator. To escape commas you can either escape each comma manually with a backslash \\, , or you can embed the entire string in python triple-quotes \"\"\" or ''' - this will escape the entire argument, including commas and any nested inlinefunc calls within. Only certain functions are available to use as inlinefuncs and the game developer may add their own functions as needed. New inlinefuncs \u00b6 To add new inlinefuncs, edit the file mygame/server/conf/inlinefuncs.py . All globally defined functions in this module are considered inline functions by the system. The only exception is functions whose name starts with an underscore _ . An inlinefunc must be of the following form: def funcname(*args, **kwargs): # ... return modified_text where *args denotes all the arguments this function will accept as an $inlinefunc . The inline function is expected to clean arguments and check that they are valid. If needed arguments are not given, default values should be used. The function should always return a string (even if it's empty). An inlinefunc should never cause a traceback regardless of the input (but it could log errors if desired). Note that whereas the function should accept **kwargs , keyword inputs are not usable in the call to the inlinefunction. The kwargs part is instead intended for Evennia to be able to supply extra information. Currently Evennia sends a single keyword to every inline function and that is session , which holds the serversession this text is targeted at. Through the session object, a lot of dynamic possibilities are opened up for your inline functions. The settings.INLINEFUNC_MODULES configuration option is a list that decides which modules should be parsed for inline function definitions. This will include mygame/server/conf/inlinefuncs.py but more could be added. The list is read from left to right so if you want to overload default functions you just have to put your custom module-paths later in the list and name your functions the same as default ones. Here is an example, the crop default inlinefunction: from evennia.utils import utils def crop(*args, **kwargs): \"\"\" Inlinefunc. Crops ingoing text to given widths. Args: text (str, optional): Text to crop. width (str, optional): Will be converted to an integer. Width of crop in characters. suffix (str, optional): End string to mark the fact that a part of the string was cropped. Defaults to `[...]`. Kwargs: session (Session): Session performing the crop. Example: `$crop(text, 50, [...])` \"\"\" text, width, suffix = \"\", 78, \"[...]\" nargs = len(args) if nargs > 0: text = args[0] if nargs > 1: width = int(args[1]) if args[1].strip().isdigit() else 78 if nargs > 2: suffix = args[2] return utils.crop(text, width=width, suffix=suffix) Another example, making use of the Session: def charactername(*args, **kwargs): \"\"\" Inserts the character name of whomever sees the string (so everyone will see their own name). Uses the account name for OOC communications. Example: say \"This means YOU, $charactername()!\" \"\"\" session = kwargs[\"session\"] if session.puppet: return kwargs[\"session\"].puppet.key else: return session.account.key Evennia itself offers the following default inline functions (mostly as examples): crop(text, width, suffix) - See above. pad(text, width, align, fillchar) - this pads the text to width (default 78), alignment (\"c\", \"l\" or \"r\", defaulting to \"c\") and fill-in character (defaults to space). Example: $pad(40,l,-) clr(startclr, text, endclr) - A programmatic way to enter colored text for those who don't want to use the normal |c type color markers for some reason. The color argument is the same as the color markers except without the actual pre-marker, so |r would be just r . If endclr is not given, it defaults to resetting the color ( n ). Example: $clr(b, A blue text) space(number) - Inserts the given number of spaces. If no argument is given, use 4 spaces.","title":"TextTags"},{"location":"TextTags.html#coloured-text","text":"Note that the Documentation does not display colour the way it would look on the screen. Color can be a very useful tool for your game. It can be used to increase readability and make your game more appealing visually. Remember however that, with the exception of the webclient, you generally don't control the client used to connect to the game. There is, for example, one special tag meaning \"yellow\". But exactly which hue of yellow is actually displayed on the user's screen depends on the settings of their particular mud client. They could even swap the colours around or turn them off altogether if so desired. Some clients don't even support color - text games are also played with special reading equipment by people who are blind or have otherwise diminished eyesight. So a good rule of thumb is to use colour to enhance your game but don't rely on it to display critical information. If you are coding the game, you can add functionality to let users disable colours as they please, as described here . To see which colours your client support, use the default @color command. This will list all available colours for ANSI and Xterm256 along with the codes you use for them. You can find a list of all the parsed ANSI -colour codes in evennia/utils/ansi.py .","title":"Coloured text"},{"location":"TextTags.html#ansi-colours","text":"Evennia supports the ANSI standard for text. This is by far the most supported MUD-color standard, available in all but the most ancient mud clients. The ANSI colours are r ed, g reen, y ellow, b lue, m agenta, c yan, w hite and black. They are abbreviated by their first letter except for black which is abbreviated with the letter x . In ANSI there are \"bright\" and \"normal\" (darker) versions of each color, adding up to a total of 16 colours to use for foreground text. There are also 8 \"background\" colours. These have no bright alternative in ANSI (but Evennia uses the Xterm256 extension behind the scenes to offer them anyway). To colour your text you put special tags in it. Evennia will parse these and convert them to the correct markup for the client used. If the user's client/console/display supports ANSI colour, they will see the text in the specified colour, otherwise the tags will be stripped (uncolored text). This works also for non-terminal clients, such as the webclient. For the webclient, Evennia will translate the codes to HTML RGB colors. Here is an example of the tags in action: |rThis text is bright red.|n This is normal text. |RThis is a dark red text.|n This is normal text. |[rThis text has red background.|n This is normal text. |b|[yThis is bright blue text on yellow background.|n This is normal text. |n - this tag will turn off all color formatting, including background colors. |# - markup marks the start of foreground color. The case defines if the text is \"bright\" or \"normal\". So |g is a bright green and |G is \"normal\" (darker) green. |[# is used to add a background colour to the text. The case again specifies if it is \"bright\" or \"normal\", so |[c starts a bright cyan background and |[C a darker cyan background. |!# is used to add foreground color without any enforced brightness/normal information. These are normal-intensity and are thus always given as uppercase, such as |!R for red. The difference between e.g. |!R and |R is that |!R will \"inherit\" the brightness setting from previously set color tags, whereas |R will always reset to the normal-intensity red. The |# format contains an implicit |h / |H tag in it: disabling highlighting when switching to a normal color, and enabling it for bright ones. So |btest |!Rtest2 will result in a bright red test2 since the brightness setting from |b \"bleeds over\". You could use this to for example quickly switch the intensity of a multitude of color tags. There is no background-color equivalent to |! style tags. |h is used to make any following foreground ANSI colors bright (it has no effect on Xterm colors). This is only relevant to use with |! type tags and will be valid until the next |n , |H or normal (upper-case) |# tag. This tag will never affect background colors, those have to be set bright/normal explicitly. Technically, |h|!G is identical to |g . |H negates the effects |h and returns all ANSI foreground colors ( |! and | types) to 'normal' intensity. It has no effect on background and Xterm colors. Note: The ANSI standard does not actually support bright backgrounds like |[r - the standard only supports \"normal\" intensity backgrounds. To get around this Evennia instead implements these as Xterm256 colours behind the scenes. If the client does not support Xterm256 the ANSI colors will be used instead and there will be no visible difference between using upper- and lower-case background tags. If you want to display an ANSI marker as output text (without having any effect), you need to escape it by preceding its | with another | : say The ||r ANSI marker changes text color to bright red. This will output the raw |r without any color change. This can also be necessary if you are doing ansi art that uses | with a letter directly following it. Use the command @color ansi to get a list of all supported ANSI colours and the tags used to produce them. A few additional ANSI codes are supported: |/ A line break. You cannot put the normal Python \\n line breaks in text entered inside the game (Evennia will filter this for security reasons). This is what you use instead: use the |/ marker to format text with line breaks from the game command line. |- This will translate into a TAB character. This will not always show (or show differently) to the client since it depends on their local settings. It's often better to use multiple spaces. |_ This is a space. You can usually use the normal space character, but if the space is at the end of the line , Evennia will likely crop it. This tag will not be cropped but always result in a space. |* This will invert the current text/background colours. Can be useful to mark things (but see below).","title":"ANSI colours"},{"location":"TextTags.html#caveats-of","text":"The |* tag (inverse video) is an old ANSI standard and should usually not be used for more than to mark short snippets of text. If combined with other tags it comes with a series of potentially confusing behaviors: The |* tag will only work once in a row:, ie: after using it once it won't have an effect again until you declare another tag. This is an example: Normal text, |*reversed text|*, still reversed text. that is, it will not reverse to normal at the second |* . You need to reset it manually: ``` Normal text, |*reversed text|n, normal again. ``` The |* tag does not take \"bright\" colors into account: |RNormal red, |hnow brightened. |*BG is normal red. So |* only considers the 'true' foreground color, ignoring any highlighting. Think of the bright state ( |h ) as something like like <strong> in HTML: it modifies the appearance of a normal foreground color to match its bright counterpart, without changing its normal color. * Finally, after a |* , if the previous background was set to a dark color (via |[ ), |!# ) will actually change the background color instead of the foreground: ``` |*reversed text |!R now BG is red. ``` For a detailed explanation of these caveats, see the Understanding Color Tags tutorial. But most of the time you might be better off to simply avoid |* and mark your text manually instead.","title":"Caveats of |*"},{"location":"TextTags.html#xterm256-colours","text":"The Xterm256 standard is a colour scheme that supports 256 colours for text and/or background. While this offers many more possibilities than traditional ANSI colours, be wary that too many text colors will be confusing to the eye. Also, not all clients support Xterm256 - these will instead see the closest equivalent ANSI color. You can mix Xterm256 tags with ANSI tags as you please. |555 This is pure white text.|n This is normal text. |230 This is olive green text. |[300 This text has a dark red background. |005|[054 This is dark blue text on a bright cyan background. |=a This is a greyscale value, equal to black. |=m This is a greyscale value, midway between white and black. |=z This is a greyscale value, equal to white. |[=m This is a background greyscale value. |### - markup consists of three digits, each an integer from 0 to 5. The three digits describe the amount of r ed, g reen and b lue (RGB) components used in the colour. So |500 means maximum red and none of the other colours - the result is a bright red. |520 is red with a touch of green - the result is orange. As opposed to ANSI colors, Xterm256 syntax does not worry about bright/normal intensity, a brighter (lighter) color is just achieved by upping all RGB values with the same amount. |[### - this works the same way but produces a coloured background. |=# - markup produces the xterm256 gray scale tones, where # is a letter from a (black) to z (white). This offers many more nuances of gray than the normal |### markup (which only has four gray tones between solid black and white ( |000 , |111 , |222 , |333 and |444 )). |[=# - this works in the same way but produces background gray scale tones. If you have a client that supports Xterm256, you can use @color xterm256 to get a table of all the 256 colours and the codes that produce them. If the table looks broken up into a few blocks of colors, it means Xterm256 is not supported and ANSI are used as a replacement. You can use the @options command to see if xterm256 is active for you. This depends on if your client told Evennia what it supports - if not, and you know what your client supports, you may have to activate some features manually.","title":"Xterm256 Colours"},{"location":"TextTags.html#clickable-links","text":"Evennia supports clickable links for clients that supports it. This marks certain text so it can be clicked by a mouse and trigger a given Evennia command. To support clickable links, Evennia requires the webclient or an third-party telnet client with MXP support ( Note: Evennia only supports clickable links, no other MXP features ). |lc to start the link, by defining the command to execute. |lt to continue with the text to show to the user (the link text). |le to end the link text and the link definition. All elements must appear in exactly this order to make a valid link. For example, \"If you go |lcnorth|ltto the north|le you will find a cottage.\" This will display as \"If you go to the north you will find a cottage.\" where clicking the link will execute the command north . If the client does not support clickable links, only the link text will be shown.","title":"Clickable links"},{"location":"TextTags.html#inline-functions","text":"Note: Inlinefuncs are not activated by default. To use them you need to add INLINEFUNC_ENABLED=True to your settings file. Evennia has its own inline text formatting language, known as inlinefuncs . It allows the builder to include special function calls in code. They are executed dynamically by each session that receives them. To add an inlinefunc, you embed it in a text string like this: \"A normal string with $funcname(arg, arg, ...) embedded inside it.\" When this string is sent to a session (with the msg() method), these embedded inlinefuncs will be parsed. Their return value (which always is a string) replace their call location in the finalized string. The interesting thing with this is that the function called will have access to which session is seeing the string, meaning the string can end up looking different depending on who is looking. It could of course also vary depending on other factors like game time. Any number of comma-separated arguments can be given (or none). No keywords are supported. You can also nest inlinefuncs by letting an argument itself also be another $funcname(arg, arg, ...) call (down to any depth of nesting). Function call resolution happens as in all programming languages inside-out, with the nested calls replacing the argument with their return strings before calling he parent. > say \"This is $pad(a center-padded text, 30,c,-) of width 30.\" You say, \"This is ---- a center-padded text----- of width 30.\" A special case happens if wanting to use an inlinefunc argument that itself includes a comma - this would be parsed as an argument separator. To escape commas you can either escape each comma manually with a backslash \\, , or you can embed the entire string in python triple-quotes \"\"\" or ''' - this will escape the entire argument, including commas and any nested inlinefunc calls within. Only certain functions are available to use as inlinefuncs and the game developer may add their own functions as needed.","title":"Inline functions"},{"location":"TextTags.html#new-inlinefuncs","text":"To add new inlinefuncs, edit the file mygame/server/conf/inlinefuncs.py . All globally defined functions in this module are considered inline functions by the system. The only exception is functions whose name starts with an underscore _ . An inlinefunc must be of the following form: def funcname(*args, **kwargs): # ... return modified_text where *args denotes all the arguments this function will accept as an $inlinefunc . The inline function is expected to clean arguments and check that they are valid. If needed arguments are not given, default values should be used. The function should always return a string (even if it's empty). An inlinefunc should never cause a traceback regardless of the input (but it could log errors if desired). Note that whereas the function should accept **kwargs , keyword inputs are not usable in the call to the inlinefunction. The kwargs part is instead intended for Evennia to be able to supply extra information. Currently Evennia sends a single keyword to every inline function and that is session , which holds the serversession this text is targeted at. Through the session object, a lot of dynamic possibilities are opened up for your inline functions. The settings.INLINEFUNC_MODULES configuration option is a list that decides which modules should be parsed for inline function definitions. This will include mygame/server/conf/inlinefuncs.py but more could be added. The list is read from left to right so if you want to overload default functions you just have to put your custom module-paths later in the list and name your functions the same as default ones. Here is an example, the crop default inlinefunction: from evennia.utils import utils def crop(*args, **kwargs): \"\"\" Inlinefunc. Crops ingoing text to given widths. Args: text (str, optional): Text to crop. width (str, optional): Will be converted to an integer. Width of crop in characters. suffix (str, optional): End string to mark the fact that a part of the string was cropped. Defaults to `[...]`. Kwargs: session (Session): Session performing the crop. Example: `$crop(text, 50, [...])` \"\"\" text, width, suffix = \"\", 78, \"[...]\" nargs = len(args) if nargs > 0: text = args[0] if nargs > 1: width = int(args[1]) if args[1].strip().isdigit() else 78 if nargs > 2: suffix = args[2] return utils.crop(text, width=width, suffix=suffix) Another example, making use of the Session: def charactername(*args, **kwargs): \"\"\" Inserts the character name of whomever sees the string (so everyone will see their own name). Uses the account name for OOC communications. Example: say \"This means YOU, $charactername()!\" \"\"\" session = kwargs[\"session\"] if session.puppet: return kwargs[\"session\"].puppet.key else: return session.account.key Evennia itself offers the following default inline functions (mostly as examples): crop(text, width, suffix) - See above. pad(text, width, align, fillchar) - this pads the text to width (default 78), alignment (\"c\", \"l\" or \"r\", defaulting to \"c\") and fill-in character (defaults to space). Example: $pad(40,l,-) clr(startclr, text, endclr) - A programmatic way to enter colored text for those who don't want to use the normal |c type color markers for some reason. The color argument is the same as the color markers except without the actual pre-marker, so |r would be just r . If endclr is not given, it defaults to resetting the color ( n ). Example: $clr(b, A blue text) space(number) - Inserts the given number of spaces. If no argument is given, use 4 spaces.","title":"New inlinefuncs"},{"location":"TickerHandler.html","text":"One way to implement a dynamic MUD is by using \"tickers\", also known as \"heartbeats\". A ticker is a timer that fires (\"ticks\") at a given interval. The tick triggers updates in various game systems. About Tickers \u00b6 Tickers are very common or even unavoidable in other mud code bases. Certain code bases are even hard-coded to rely on the concept of the global 'tick'. Evennia has no such notion - the decision to use tickers is very much up to the need of your game and which requirements you have. The \"ticker recipe\" is just one way of cranking the wheels. The most fine-grained way to manage the flow of time is of course to use Scripts . Many types of operations (weather being the classic example) are however done on multiple objects in the same way at regular intervals, and for this, storing separate Scripts on each object is inefficient. The way to do this is to use a ticker with a \"subscription model\" - let objects sign up to be triggered at the same interval, unsubscribing when the updating is no longer desired. Evennia offers an optimized implementation of the subscription model - the TickerHandler . This is a singleton global handler reachable from evennia.TICKER_HANDLER . You can assign any callable (a function or, more commonly, a method on a database object) to this handler. The TickerHandler will then call this callable at an interval you specify, and with the arguments you supply when adding it. This continues until the callable un-subscribes from the ticker. The handler survives a reboot and is highly optimized in resource usage. Here is an example of importing TICKER_HANDLER and using it: # we assume that obj has a hook \"at_tick\" defined on itself from evennia import TICKER_HANDLER as tickerhandler tickerhandler.add(20, obj.at_tick) That's it - from now on, obj.at_tick() will be called every 20 seconds. You can also import function and tick that: from evennia import TICKER_HANDLER as tickerhandler from mymodule import myfunc tickerhandler.add(30, myfunc) Removing (stopping) the ticker works as expected: tickerhandler.remove(20, obj.at_tick) tickerhandler.remove(30, myfunc) Note that you have to also supply interval to identify which subscription to remove. This is because the TickerHandler maintains a pool of tickers and a given callable can subscribe to be ticked at any number of different intervals. The full definition of the tickerhandler.add method is tickerhandler.add(interval, callback, idstring=\"\", persistent=True, *args, **kwargs) Here *args and **kwargs will be passed to callback every interval seconds. If persistent is False , this subscription will not survive a server reload. Tickers are identified and stored by making a key of the callable itself, the ticker-interval, the persistent flag and the idstring (the latter being an empty string when not given explicitly). Since the arguments are not included in the ticker's identification, the idstring must be used to have a specific callback triggered multiple times on the same interval but with different arguments: tickerhandler.add(10, obj.update, \"ticker1\", True, 1, 2, 3) tickerhandler.add(10, obj.update, \"ticker2\", True, 4, 5) Note that, when we want to send arguments to our callback within a ticker handler, we need to specify idstring and persistent before, unless we call our arguments as keywords, which would often be more readable: tickerhandler.add(10, obj.update, caller=self, value=118) If you add a ticker with exactly the same combination of callback, interval and idstring, it will overload the existing ticker. This identification is also crucial for later removing (stopping) the subscription: tickerhandler.remove(10, obj.update, idstring=\"ticker1\") tickerhandler.remove(10, obj.update, idstring=\"ticker2\") The callable can be on any form as long as it accepts the arguments you give to send to it in TickerHandler.add . Note that everything you supply to the TickerHandler will need to be pickled at some point to be saved into the database. Most of the time the handler will correctly store things like database objects, but the same restrictions as for Attributes apply to what the TickerHandler may store. When testing, you can stop all tickers in the entire game with tickerhandler.clear() . You can also view the currently subscribed objects with tickerhandler.all() . See the Weather Tutorial for an example of using the TickerHandler. When not to use TickerHandler \u00b6 Using the TickerHandler may sound very useful but it is important to consider when not to use it. Even if you are used to habitually relying on tickers for everything in other code bases, stop and think about what you really need it for. This is the main point: You should never use a ticker to catch changes . Think about it - you might have to run the ticker every second to react to the change fast enough. Most likely nothing will have changed at a given moment. So you are doing pointless calls (since skipping the call gives the same result as doing it). Making sure nothing's changed might even be computationally expensive depending on the complexity of your system. Not to mention that you might need to run the check on every object in the database . Every second. Just to maintain status quo ... Rather than checking over and over on the off-chance that something changed, consider a more proactive approach. Could you implement your rarely changing system to itself report when its status changes? It's almost always much cheaper/efficient if you can do things \"on demand\". Evennia itself uses hook methods for this very reason. So, if you consider a ticker that will fire very often but which you expect to have no effect 99% of the time, consider handling things things some other way. A self-reporting on-demand solution is usually cheaper also for fast-updating properties. Also remember that some things may not need to be updated until someone actually is examining or using them - any interim changes happening up to that moment are pointless waste of computing time. The main reason for needing a ticker is when you want things to happen to multiple objects at the same time without input from something else.","title":"TickerHandler"},{"location":"TickerHandler.html#about-tickers","text":"Tickers are very common or even unavoidable in other mud code bases. Certain code bases are even hard-coded to rely on the concept of the global 'tick'. Evennia has no such notion - the decision to use tickers is very much up to the need of your game and which requirements you have. The \"ticker recipe\" is just one way of cranking the wheels. The most fine-grained way to manage the flow of time is of course to use Scripts . Many types of operations (weather being the classic example) are however done on multiple objects in the same way at regular intervals, and for this, storing separate Scripts on each object is inefficient. The way to do this is to use a ticker with a \"subscription model\" - let objects sign up to be triggered at the same interval, unsubscribing when the updating is no longer desired. Evennia offers an optimized implementation of the subscription model - the TickerHandler . This is a singleton global handler reachable from evennia.TICKER_HANDLER . You can assign any callable (a function or, more commonly, a method on a database object) to this handler. The TickerHandler will then call this callable at an interval you specify, and with the arguments you supply when adding it. This continues until the callable un-subscribes from the ticker. The handler survives a reboot and is highly optimized in resource usage. Here is an example of importing TICKER_HANDLER and using it: # we assume that obj has a hook \"at_tick\" defined on itself from evennia import TICKER_HANDLER as tickerhandler tickerhandler.add(20, obj.at_tick) That's it - from now on, obj.at_tick() will be called every 20 seconds. You can also import function and tick that: from evennia import TICKER_HANDLER as tickerhandler from mymodule import myfunc tickerhandler.add(30, myfunc) Removing (stopping) the ticker works as expected: tickerhandler.remove(20, obj.at_tick) tickerhandler.remove(30, myfunc) Note that you have to also supply interval to identify which subscription to remove. This is because the TickerHandler maintains a pool of tickers and a given callable can subscribe to be ticked at any number of different intervals. The full definition of the tickerhandler.add method is tickerhandler.add(interval, callback, idstring=\"\", persistent=True, *args, **kwargs) Here *args and **kwargs will be passed to callback every interval seconds. If persistent is False , this subscription will not survive a server reload. Tickers are identified and stored by making a key of the callable itself, the ticker-interval, the persistent flag and the idstring (the latter being an empty string when not given explicitly). Since the arguments are not included in the ticker's identification, the idstring must be used to have a specific callback triggered multiple times on the same interval but with different arguments: tickerhandler.add(10, obj.update, \"ticker1\", True, 1, 2, 3) tickerhandler.add(10, obj.update, \"ticker2\", True, 4, 5) Note that, when we want to send arguments to our callback within a ticker handler, we need to specify idstring and persistent before, unless we call our arguments as keywords, which would often be more readable: tickerhandler.add(10, obj.update, caller=self, value=118) If you add a ticker with exactly the same combination of callback, interval and idstring, it will overload the existing ticker. This identification is also crucial for later removing (stopping) the subscription: tickerhandler.remove(10, obj.update, idstring=\"ticker1\") tickerhandler.remove(10, obj.update, idstring=\"ticker2\") The callable can be on any form as long as it accepts the arguments you give to send to it in TickerHandler.add . Note that everything you supply to the TickerHandler will need to be pickled at some point to be saved into the database. Most of the time the handler will correctly store things like database objects, but the same restrictions as for Attributes apply to what the TickerHandler may store. When testing, you can stop all tickers in the entire game with tickerhandler.clear() . You can also view the currently subscribed objects with tickerhandler.all() . See the Weather Tutorial for an example of using the TickerHandler.","title":"About Tickers"},{"location":"TickerHandler.html#when-not-to-use-tickerhandler","text":"Using the TickerHandler may sound very useful but it is important to consider when not to use it. Even if you are used to habitually relying on tickers for everything in other code bases, stop and think about what you really need it for. This is the main point: You should never use a ticker to catch changes . Think about it - you might have to run the ticker every second to react to the change fast enough. Most likely nothing will have changed at a given moment. So you are doing pointless calls (since skipping the call gives the same result as doing it). Making sure nothing's changed might even be computationally expensive depending on the complexity of your system. Not to mention that you might need to run the check on every object in the database . Every second. Just to maintain status quo ... Rather than checking over and over on the off-chance that something changed, consider a more proactive approach. Could you implement your rarely changing system to itself report when its status changes? It's almost always much cheaper/efficient if you can do things \"on demand\". Evennia itself uses hook methods for this very reason. So, if you consider a ticker that will fire very often but which you expect to have no effect 99% of the time, consider handling things things some other way. A self-reporting on-demand solution is usually cheaper also for fast-updating properties. Also remember that some things may not need to be updated until someone actually is examining or using them - any interim changes happening up to that moment are pointless waste of computing time. The main reason for needing a ticker is when you want things to happen to multiple objects at the same time without input from something else.","title":"When not to use TickerHandler"},{"location":"Turn-based-Combat-System.html","text":"This tutorial gives an example of a full, if simplified, combat system for Evennia. It was inspired by the discussions held on the mailing list . Overview of combat system concepts \u00b6 Most MUDs will use some sort of combat system. There are several main variations: Freeform - the simplest form of combat to implement, common to MUSH-style roleplaying games. This means the system only supplies dice rollers or maybe commands to compare skills and spit out the result. Dice rolls are done to resolve combat according to the rules of the game and to direct the scene. A game master may be required to resolve rule disputes. Twitch - This is the traditional MUD hack&slash style combat. In a twitch system there is often no difference between your normal \"move-around-and-explore mode\" and the \"combat mode\". You enter an attack command and the system will calculate if the attack hits and how much damage was caused. Normally attack commands have some sort of timeout or notion of recovery/balance to reduce the advantage of spamming or client scripting. Whereas the simplest systems just means entering kill <target> over and over, more sophisticated twitch systems include anything from defensive stances to tactical positioning. Turn-based - a turn based system means that the system pauses to make sure all combatants can choose their actions before continuing. In some systems, such entered actions happen immediately (like twitch-based) whereas in others the resolution happens simultaneously at the end of the turn. The disadvantage of a turn-based system is that the game must switch to a \"combat mode\" and one also needs to take special care of how to handle new combatants and the passage of time. The advantage is that success is not dependent on typing speed or of setting up quick client macros. This potentially allows for emoting as part of combat which is an advantage for roleplay-heavy games. To implement a freeform combat system all you need is a dice roller and a roleplaying rulebook. See contrib/dice.py for an example dice roller. To implement at twitch-based system you basically need a few combat commands , possibly ones with a cooldown . You also need a game rule module that makes use of it. We will focus on the turn-based variety here. Tutorial overview \u00b6 This tutorial will implement the slightly more complex turn-based combat system. Our example has the following properties: Combat is initiated with attack <target> , this initiates the combat mode. Characters may join an ongoing battle using attack <target> against a character already in combat. Each turn every combating character will get to enter two commands, their internal order matters and they are compared one-to-one in the order given by each combatant. Use of say and pose is free. The commands are (in our example) simple; they can either hit <target> , feint <target> or parry <target> . They can also defend , a generic passive defense. Finally they may choose to disengage/flee . When attacking we use a classic rock-paper-scissors mechanic to determine success: hit defeats feint , which defeats parry which defeats hit . defend is a general passive action that has a percentage chance to win against hit (only). disengage/flee must be entered two times in a row and will only succeed if there is no hit against them in that time. If so they will leave combat mode. Once every player has entered two commands, all commands are resolved in order and the result is reported. A new turn then begins. If players are too slow the turn will time out and any unset commands will be set to defend . For creating the combat system we will need the following components: A combat handler. This is the main mechanic of the system. This is a Script object created for each combat. It is not assigned to a specific object but is shared by the combating characters and handles all the combat information. Since Scripts are database entities it also means that the combat will not be affected by a server reload. A combat command set with the relevant commands needed for combat, such as the various attack/defend options and the flee/disengage command to leave the combat mode. A rule resolution system. The basics of making such a module is described in the rule system tutorial . We will only sketch such a module here for our end-turn combat resolution. An attack command for initiating the combat mode. This is added to the default command set. It will create the combat handler and add the character(s) to it. It will also assign the combat command set to the characters. The combat handler \u00b6 The combat handler is implemented as a stand-alone Script . This Script is created when the first Character decides to attack another and is deleted when no one is fighting any more. Each handler represents one instance of combat and one combat only. Each instance of combat can hold any number of characters but each character can only be part of one combat at a time (a player would need to disengage from the first combat before they could join another). The reason we don't store this Script \"on\" any specific character is because any character may leave the combat at any time. Instead the script holds references to all characters involved in the combat. Vice-versa, all characters holds a back-reference to the current combat handler. While we don't use this very much here this might allow the combat commands on the characters to access and update the combat handler state directly. Note: Another way to implement a combat handler would be to use a normal Python object and handle time-keeping with the TickerHandler . This would require either adding custom hook methods on the character or to implement a custom child of the TickerHandler class to track turns. Whereas the TickerHandler is easy to use, a Script offers more power in this case. Here is a basic combat handler. Assuming our game folder is named mygame , we store it in mygame/typeclasses/combat_handler.py : # mygame/typeclasses/combat_handler.py import random from evennia import DefaultScript from world.rules import resolve_combat class CombatHandler(DefaultScript): \"\"\" This implements the combat handler. \"\"\" # standard Script hooks def at_script_creation(self): \"Called when script is first created\" self.key = \"combat_handler_%i\" % random.randint(1, 1000) self.desc = \"handles combat\" self.interval = 60 * 2 # two minute timeout self.start_delay = True self.persistent = True # store all combatants self.db.characters = {} # store all actions for each turn self.db.turn_actions = {} # number of actions entered per combatant self.db.action_count = {} def _init_character(self, character): \"\"\" This initializes handler back-reference and combat cmdset on a character \"\"\" character.ndb.combat_handler = self character.cmdset.add(\"commands.combat.CombatCmdSet\") def _cleanup_character(self, character): \"\"\" Remove character from handler and clean it of the back-reference and cmdset \"\"\" dbref = character.id del self.db.characters[dbref] del self.db.turn_actions[dbref] del self.db.action_count[dbref] del character.ndb.combat_handler character.cmdset.delete(\"commands.combat.CombatCmdSet\") def at_start(self): \"\"\" This is called on first start but also when the script is restarted after a server reboot. We need to re-assign this combat handler to all characters as well as re-assign the cmdset. \"\"\" for character in self.db.characters.values(): self._init_character(character) def at_stop(self): \"Called just before the script is stopped/destroyed.\" for character in list(self.db.characters.values()): # note: the list() call above disconnects list from database self._cleanup_character(character) def at_repeat(self): \"\"\" This is called every self.interval seconds (turn timeout) or when force_repeat is called (because everyone has entered their commands). We know this by checking the existence of the `normal_turn_end` NAttribute, set just before calling force_repeat. \"\"\" if self.ndb.normal_turn_end: # we get here because the turn ended normally # (force_repeat was called) - no msg output del self.ndb.normal_turn_end else: # turn timeout self.msg_all(\"Turn timer timed out. Continuing.\") self.end_turn() # Combat-handler methods def add_character(self, character): \"Add combatant to handler\" dbref = character.id self.db.characters[dbref] = character self.db.action_count[dbref] = 0 self.db.turn_actions[dbref] = [(\"defend\", character, None), (\"defend\", character, None)] # set up back-reference self._init_character(character) def remove_character(self, character): \"Remove combatant from handler\" if character.id in self.db.characters: self._cleanup_character(character) if not self.db.characters: # if no more characters in battle, kill this handler self.stop() def msg_all(self, message): \"Send message to all combatants\" for character in self.db.characters.values(): character.msg(message) def add_action(self, action, character, target): \"\"\" Called by combat commands to register an action with the handler. action - string identifying the action, like \"hit\" or \"parry\" character - the character performing the action target - the target character or None actions are stored in a dictionary keyed to each character, each of which holds a list of max 2 actions. An action is stored as a tuple (character, action, target). \"\"\" dbref = character.id count = self.db.action_count[dbref] if 0 <= count <= 1: # only allow 2 actions self.db.turn_actions[dbref][count] = (action, character, target) else: # report if we already used too many actions return False self.db.action_count[dbref] += 1 return True def check_end_turn(self): \"\"\" Called by the command to eventually trigger the resolution of the turn. We check if everyone has added all their actions; if so we call force the script to repeat immediately (which will call `self.at_repeat()` while resetting all timers). \"\"\" if all(count > 1 for count in self.db.action_count.values()): self.ndb.normal_turn_end = True self.force_repeat() def end_turn(self): \"\"\" This resolves all actions by calling the rules module. It then resets everything and starts the next turn. It is called by at_repeat(). \"\"\" resolve_combat(self, self.db.turn_actions) if len(self.db.characters) < 2: # less than 2 characters in battle, kill this handler self.msg_all(\"Combat has ended\") self.stop() else: # reset counters before next turn for character in self.db.characters.values(): self.db.characters[character.id] = character self.db.action_count[character.id] = 0 self.db.turn_actions[character.id] = [(\"defend\", character, None), (\"defend\", character, None)] self.msg_all(\"Next turn begins ...\") This implements all the useful properties of our combat handler. This Script will survive a reboot and will automatically re-assert itself when it comes back online. Even the current state of the combat should be unaffected since it is saved in Attributes at every turn. An important part to note is the use of the Script's standard at_repeat hook and the force_repeat method to end each turn. This allows for everything to go through the same mechanisms with minimal repetition of code. What is not present in this handler is a way for players to view the actions they set or to change their actions once they have been added (but before the last one has added theirs). We leave this as an exercise. Combat commands \u00b6 Our combat commands - the commands that are to be available to us during the combat - are (in our example) very simple. In a full implementation the commands available might be determined by the weapon(s) held by the player or by which skills they know. We create them in mygame/commands/combat.py . # mygame/commands/combat.py from evennia import Command class CmdHit(Command): \"\"\" hit an enemy Usage: hit <target> Strikes the given enemy with your current weapon. \"\"\" key = \"hit\" aliases = [\"strike\", \"slash\"] help_category = \"combat\" def func(self): \"Implements the command\" if not self.args: self.caller.msg(\"Usage: hit <target>\") return target = self.caller.search(self.args) if not target: return ok = self.caller.ndb.combat_handler.add_action(\"hit\", self.caller, target) if ok: self.caller.msg(\"You add 'hit' to the combat queue\") else: self.caller.msg(\"You can only queue two actions per turn!\") # tell the handler to check if turn is over self.caller.ndb.combat_handler.check_end_turn() The other commands CmdParry , CmdFeint , CmdDefend and CmdDisengage look basically the same. We should also add a custom help command to list all the available combat commands and what they do. We just need to put them all in a cmdset. We do this at the end of the same module: # mygame/commands/combat.py from evennia import CmdSet from evennia import default_cmds class CombatCmdSet(CmdSet): key = \"combat_cmdset\" mergetype = \"Replace\" priority = 10 no_exits = True def at_cmdset_creation(self): self.add(CmdHit()) self.add(CmdParry()) self.add(CmdFeint()) self.add(CmdDefend()) self.add(CmdDisengage()) self.add(CmdHelp()) self.add(default_cmds.CmdPose()) self.add(default_cmds.CmdSay()) Rules module \u00b6 A general way to implement a rule module is found in the rule system tutorial . Proper resolution would likely require us to change our Characters to store things like strength, weapon skills and so on. So for this example we will settle for a very simplistic rock-paper-scissors kind of setup with some randomness thrown in. We will not deal with damage here but just announce the results of each turn. In a real system the Character objects would hold stats to affect their skills, their chosen weapon affect the choices, they would be able to lose health etc. Within each turn, there are \"sub-turns\", each consisting of one action per character. The actions within each sub-turn happens simultaneously and only once they have all been resolved we move on to the next sub-turn (or end the full turn). Note: In our simple example the sub-turns don't affect each other (except for disengage/flee ), nor do any effects carry over between turns. The real power of a turn-based system would be to add real tactical possibilities here though; For example if your hit got parried you could be out of balance and your next action would be at a disadvantage. A successful feint would open up for a subsequent attack and so on ... Our rock-paper-scissor setup works like this: hit beats feint and flee/disengage . It has a random chance to fail against defend . parry beats hit . feint beats parry and is then counted as a hit . defend does nothing but has a chance to beat hit . flee/disengage must succeed two times in a row (i.e. not beaten by a hit once during the turn). If so the character leaves combat. # mygame/world/rules.py import random # messages def resolve_combat(combat_handler, actiondict): \"\"\" This is called by the combat handler actiondict is a dictionary with a list of two actions for each character: {char.id:[(action1, char, target), (action2, char, target)], ...} \"\"\" flee = {} # track number of flee commands per character for isub in range(2): # loop over sub-turns messages = [] for subturn in (sub[isub] for sub in actiondict.values()): # for each character, resolve the sub-turn action, char, target = subturn if target: taction, tchar, ttarget = actiondict[target.id][isub] if action == \"hit\": if taction == \"parry\" and ttarget == char: msg = \"%s tries to hit %s, but %s parries the attack!\" messages.append(msg % (char, tchar, tchar)) elif taction == \"defend\" and random.random() < 0.5: msg = \"%s defends against the attack by %s.\" messages.append(msg % (tchar, char)) elif taction == \"flee\": msg = \"%s stops %s from disengaging, with a hit!\" flee[tchar] = -2 messages.append(msg % (char, tchar)) else: msg = \"%s hits %s, bypassing their %s!\" messages.append(msg % (char, tchar, taction)) elif action == \"parry\": if taction == \"hit\": msg = \"%s parries the attack by %s.\" messages.append(msg % (char, tchar)) elif taction == \"feint\": msg = \"%s tries to parry, but %s feints and hits!\" messages.append(msg % (char, tchar)) else: msg = \"%s parries to no avail.\" messages.append(msg % char) elif action == \"feint\": if taction == \"parry\": msg = \"%s feints past %s's parry, landing a hit!\" messages.append(msg % (char, tchar)) elif taction == \"hit\": msg = \"%s feints but is defeated by %s hit!\" messages.append(msg % (char, tchar)) else: msg = \"%s feints to no avail.\" messages.append(msg % char) elif action == \"defend\": msg = \"%s defends.\" messages.append(msg % char) elif action == \"flee\": if char in flee: flee[char] += 1 else: flee[char] = 1 msg = \"%s tries to disengage (two subsequent turns needed)\" messages.append(msg % char) # echo results of each subturn combat_handler.msg_all(\"\\n\".join(messages)) # at the end of both sub-turns, test if anyone fled msg = \"%s withdraws from combat.\" for (char, fleevalue) in flee.items(): if fleevalue == 2: combat_handler.msg_all(msg % char) combat_handler.remove_character(char) To make it simple (and to save space), this example rule module actually resolves each interchange twice - first when it gets to each character and then again when handling the target. Also, since we use the combat handler's msg_all method here, the system will get pretty spammy. To clean it up, one could imagine tracking all the possible interactions to make sure each pair is only handled and reported once. Combat initiator command \u00b6 This is the last component we need, a command to initiate combat. This will tie everything together. We store this with the other combat commands. # mygame/commands/combat.py from evennia import create_script class CmdAttack(Command): \"\"\" initiates combat Usage: attack <target> This will initiate combat with <target>. If <target is already in combat, you will join the combat. \"\"\" key = \"attack\" help_category = \"General\" def func(self): \"Handle command\" if not self.args: self.caller.msg(\"Usage: attack <target>\") return target = self.caller.search(self.args) if not target: return # set up combat if target.ndb.combat_handler: # target is already in combat - join it target.ndb.combat_handler.add_character(self.caller) target.ndb.combat_handler.msg_all(\"%s joins combat!\" % self.caller) else: # create a new combat handler chandler = create_script(\"combat_handler.CombatHandler\") chandler.add_character(self.caller) chandler.add_character(target) self.caller.msg(\"You attack %s! You are in combat.\" % target) target.msg(\"%s attacks you! You are in combat.\" % self.caller) The attack command will not go into the combat cmdset but rather into the default cmdset. See e.g. the Adding Command Tutorial if you are unsure about how to do this. Expanding the example \u00b6 At this point you should have a simple but flexible turn-based combat system. We have taken several shortcuts and simplifications in this example. The output to the players is likely too verbose during combat and too limited when it comes to informing about things surrounding it. Methods for changing your commands or list them, view who is in combat etc is likely needed - this will require play testing for each game and style. There is also currently no information displayed for other people happening to be in the same room as the combat - some less detailed information should probably be echoed to the room to show others what's going on.","title":"Turn based Combat System"},{"location":"Turn-based-Combat-System.html#overview-of-combat-system-concepts","text":"Most MUDs will use some sort of combat system. There are several main variations: Freeform - the simplest form of combat to implement, common to MUSH-style roleplaying games. This means the system only supplies dice rollers or maybe commands to compare skills and spit out the result. Dice rolls are done to resolve combat according to the rules of the game and to direct the scene. A game master may be required to resolve rule disputes. Twitch - This is the traditional MUD hack&slash style combat. In a twitch system there is often no difference between your normal \"move-around-and-explore mode\" and the \"combat mode\". You enter an attack command and the system will calculate if the attack hits and how much damage was caused. Normally attack commands have some sort of timeout or notion of recovery/balance to reduce the advantage of spamming or client scripting. Whereas the simplest systems just means entering kill <target> over and over, more sophisticated twitch systems include anything from defensive stances to tactical positioning. Turn-based - a turn based system means that the system pauses to make sure all combatants can choose their actions before continuing. In some systems, such entered actions happen immediately (like twitch-based) whereas in others the resolution happens simultaneously at the end of the turn. The disadvantage of a turn-based system is that the game must switch to a \"combat mode\" and one also needs to take special care of how to handle new combatants and the passage of time. The advantage is that success is not dependent on typing speed or of setting up quick client macros. This potentially allows for emoting as part of combat which is an advantage for roleplay-heavy games. To implement a freeform combat system all you need is a dice roller and a roleplaying rulebook. See contrib/dice.py for an example dice roller. To implement at twitch-based system you basically need a few combat commands , possibly ones with a cooldown . You also need a game rule module that makes use of it. We will focus on the turn-based variety here.","title":"Overview of combat system concepts"},{"location":"Turn-based-Combat-System.html#tutorial-overview","text":"This tutorial will implement the slightly more complex turn-based combat system. Our example has the following properties: Combat is initiated with attack <target> , this initiates the combat mode. Characters may join an ongoing battle using attack <target> against a character already in combat. Each turn every combating character will get to enter two commands, their internal order matters and they are compared one-to-one in the order given by each combatant. Use of say and pose is free. The commands are (in our example) simple; they can either hit <target> , feint <target> or parry <target> . They can also defend , a generic passive defense. Finally they may choose to disengage/flee . When attacking we use a classic rock-paper-scissors mechanic to determine success: hit defeats feint , which defeats parry which defeats hit . defend is a general passive action that has a percentage chance to win against hit (only). disengage/flee must be entered two times in a row and will only succeed if there is no hit against them in that time. If so they will leave combat mode. Once every player has entered two commands, all commands are resolved in order and the result is reported. A new turn then begins. If players are too slow the turn will time out and any unset commands will be set to defend . For creating the combat system we will need the following components: A combat handler. This is the main mechanic of the system. This is a Script object created for each combat. It is not assigned to a specific object but is shared by the combating characters and handles all the combat information. Since Scripts are database entities it also means that the combat will not be affected by a server reload. A combat command set with the relevant commands needed for combat, such as the various attack/defend options and the flee/disengage command to leave the combat mode. A rule resolution system. The basics of making such a module is described in the rule system tutorial . We will only sketch such a module here for our end-turn combat resolution. An attack command for initiating the combat mode. This is added to the default command set. It will create the combat handler and add the character(s) to it. It will also assign the combat command set to the characters.","title":"Tutorial overview"},{"location":"Turn-based-Combat-System.html#the-combat-handler","text":"The combat handler is implemented as a stand-alone Script . This Script is created when the first Character decides to attack another and is deleted when no one is fighting any more. Each handler represents one instance of combat and one combat only. Each instance of combat can hold any number of characters but each character can only be part of one combat at a time (a player would need to disengage from the first combat before they could join another). The reason we don't store this Script \"on\" any specific character is because any character may leave the combat at any time. Instead the script holds references to all characters involved in the combat. Vice-versa, all characters holds a back-reference to the current combat handler. While we don't use this very much here this might allow the combat commands on the characters to access and update the combat handler state directly. Note: Another way to implement a combat handler would be to use a normal Python object and handle time-keeping with the TickerHandler . This would require either adding custom hook methods on the character or to implement a custom child of the TickerHandler class to track turns. Whereas the TickerHandler is easy to use, a Script offers more power in this case. Here is a basic combat handler. Assuming our game folder is named mygame , we store it in mygame/typeclasses/combat_handler.py : # mygame/typeclasses/combat_handler.py import random from evennia import DefaultScript from world.rules import resolve_combat class CombatHandler(DefaultScript): \"\"\" This implements the combat handler. \"\"\" # standard Script hooks def at_script_creation(self): \"Called when script is first created\" self.key = \"combat_handler_%i\" % random.randint(1, 1000) self.desc = \"handles combat\" self.interval = 60 * 2 # two minute timeout self.start_delay = True self.persistent = True # store all combatants self.db.characters = {} # store all actions for each turn self.db.turn_actions = {} # number of actions entered per combatant self.db.action_count = {} def _init_character(self, character): \"\"\" This initializes handler back-reference and combat cmdset on a character \"\"\" character.ndb.combat_handler = self character.cmdset.add(\"commands.combat.CombatCmdSet\") def _cleanup_character(self, character): \"\"\" Remove character from handler and clean it of the back-reference and cmdset \"\"\" dbref = character.id del self.db.characters[dbref] del self.db.turn_actions[dbref] del self.db.action_count[dbref] del character.ndb.combat_handler character.cmdset.delete(\"commands.combat.CombatCmdSet\") def at_start(self): \"\"\" This is called on first start but also when the script is restarted after a server reboot. We need to re-assign this combat handler to all characters as well as re-assign the cmdset. \"\"\" for character in self.db.characters.values(): self._init_character(character) def at_stop(self): \"Called just before the script is stopped/destroyed.\" for character in list(self.db.characters.values()): # note: the list() call above disconnects list from database self._cleanup_character(character) def at_repeat(self): \"\"\" This is called every self.interval seconds (turn timeout) or when force_repeat is called (because everyone has entered their commands). We know this by checking the existence of the `normal_turn_end` NAttribute, set just before calling force_repeat. \"\"\" if self.ndb.normal_turn_end: # we get here because the turn ended normally # (force_repeat was called) - no msg output del self.ndb.normal_turn_end else: # turn timeout self.msg_all(\"Turn timer timed out. Continuing.\") self.end_turn() # Combat-handler methods def add_character(self, character): \"Add combatant to handler\" dbref = character.id self.db.characters[dbref] = character self.db.action_count[dbref] = 0 self.db.turn_actions[dbref] = [(\"defend\", character, None), (\"defend\", character, None)] # set up back-reference self._init_character(character) def remove_character(self, character): \"Remove combatant from handler\" if character.id in self.db.characters: self._cleanup_character(character) if not self.db.characters: # if no more characters in battle, kill this handler self.stop() def msg_all(self, message): \"Send message to all combatants\" for character in self.db.characters.values(): character.msg(message) def add_action(self, action, character, target): \"\"\" Called by combat commands to register an action with the handler. action - string identifying the action, like \"hit\" or \"parry\" character - the character performing the action target - the target character or None actions are stored in a dictionary keyed to each character, each of which holds a list of max 2 actions. An action is stored as a tuple (character, action, target). \"\"\" dbref = character.id count = self.db.action_count[dbref] if 0 <= count <= 1: # only allow 2 actions self.db.turn_actions[dbref][count] = (action, character, target) else: # report if we already used too many actions return False self.db.action_count[dbref] += 1 return True def check_end_turn(self): \"\"\" Called by the command to eventually trigger the resolution of the turn. We check if everyone has added all their actions; if so we call force the script to repeat immediately (which will call `self.at_repeat()` while resetting all timers). \"\"\" if all(count > 1 for count in self.db.action_count.values()): self.ndb.normal_turn_end = True self.force_repeat() def end_turn(self): \"\"\" This resolves all actions by calling the rules module. It then resets everything and starts the next turn. It is called by at_repeat(). \"\"\" resolve_combat(self, self.db.turn_actions) if len(self.db.characters) < 2: # less than 2 characters in battle, kill this handler self.msg_all(\"Combat has ended\") self.stop() else: # reset counters before next turn for character in self.db.characters.values(): self.db.characters[character.id] = character self.db.action_count[character.id] = 0 self.db.turn_actions[character.id] = [(\"defend\", character, None), (\"defend\", character, None)] self.msg_all(\"Next turn begins ...\") This implements all the useful properties of our combat handler. This Script will survive a reboot and will automatically re-assert itself when it comes back online. Even the current state of the combat should be unaffected since it is saved in Attributes at every turn. An important part to note is the use of the Script's standard at_repeat hook and the force_repeat method to end each turn. This allows for everything to go through the same mechanisms with minimal repetition of code. What is not present in this handler is a way for players to view the actions they set or to change their actions once they have been added (but before the last one has added theirs). We leave this as an exercise.","title":"The combat handler"},{"location":"Turn-based-Combat-System.html#combat-commands","text":"Our combat commands - the commands that are to be available to us during the combat - are (in our example) very simple. In a full implementation the commands available might be determined by the weapon(s) held by the player or by which skills they know. We create them in mygame/commands/combat.py . # mygame/commands/combat.py from evennia import Command class CmdHit(Command): \"\"\" hit an enemy Usage: hit <target> Strikes the given enemy with your current weapon. \"\"\" key = \"hit\" aliases = [\"strike\", \"slash\"] help_category = \"combat\" def func(self): \"Implements the command\" if not self.args: self.caller.msg(\"Usage: hit <target>\") return target = self.caller.search(self.args) if not target: return ok = self.caller.ndb.combat_handler.add_action(\"hit\", self.caller, target) if ok: self.caller.msg(\"You add 'hit' to the combat queue\") else: self.caller.msg(\"You can only queue two actions per turn!\") # tell the handler to check if turn is over self.caller.ndb.combat_handler.check_end_turn() The other commands CmdParry , CmdFeint , CmdDefend and CmdDisengage look basically the same. We should also add a custom help command to list all the available combat commands and what they do. We just need to put them all in a cmdset. We do this at the end of the same module: # mygame/commands/combat.py from evennia import CmdSet from evennia import default_cmds class CombatCmdSet(CmdSet): key = \"combat_cmdset\" mergetype = \"Replace\" priority = 10 no_exits = True def at_cmdset_creation(self): self.add(CmdHit()) self.add(CmdParry()) self.add(CmdFeint()) self.add(CmdDefend()) self.add(CmdDisengage()) self.add(CmdHelp()) self.add(default_cmds.CmdPose()) self.add(default_cmds.CmdSay())","title":"Combat commands"},{"location":"Turn-based-Combat-System.html#rules-module","text":"A general way to implement a rule module is found in the rule system tutorial . Proper resolution would likely require us to change our Characters to store things like strength, weapon skills and so on. So for this example we will settle for a very simplistic rock-paper-scissors kind of setup with some randomness thrown in. We will not deal with damage here but just announce the results of each turn. In a real system the Character objects would hold stats to affect their skills, their chosen weapon affect the choices, they would be able to lose health etc. Within each turn, there are \"sub-turns\", each consisting of one action per character. The actions within each sub-turn happens simultaneously and only once they have all been resolved we move on to the next sub-turn (or end the full turn). Note: In our simple example the sub-turns don't affect each other (except for disengage/flee ), nor do any effects carry over between turns. The real power of a turn-based system would be to add real tactical possibilities here though; For example if your hit got parried you could be out of balance and your next action would be at a disadvantage. A successful feint would open up for a subsequent attack and so on ... Our rock-paper-scissor setup works like this: hit beats feint and flee/disengage . It has a random chance to fail against defend . parry beats hit . feint beats parry and is then counted as a hit . defend does nothing but has a chance to beat hit . flee/disengage must succeed two times in a row (i.e. not beaten by a hit once during the turn). If so the character leaves combat. # mygame/world/rules.py import random # messages def resolve_combat(combat_handler, actiondict): \"\"\" This is called by the combat handler actiondict is a dictionary with a list of two actions for each character: {char.id:[(action1, char, target), (action2, char, target)], ...} \"\"\" flee = {} # track number of flee commands per character for isub in range(2): # loop over sub-turns messages = [] for subturn in (sub[isub] for sub in actiondict.values()): # for each character, resolve the sub-turn action, char, target = subturn if target: taction, tchar, ttarget = actiondict[target.id][isub] if action == \"hit\": if taction == \"parry\" and ttarget == char: msg = \"%s tries to hit %s, but %s parries the attack!\" messages.append(msg % (char, tchar, tchar)) elif taction == \"defend\" and random.random() < 0.5: msg = \"%s defends against the attack by %s.\" messages.append(msg % (tchar, char)) elif taction == \"flee\": msg = \"%s stops %s from disengaging, with a hit!\" flee[tchar] = -2 messages.append(msg % (char, tchar)) else: msg = \"%s hits %s, bypassing their %s!\" messages.append(msg % (char, tchar, taction)) elif action == \"parry\": if taction == \"hit\": msg = \"%s parries the attack by %s.\" messages.append(msg % (char, tchar)) elif taction == \"feint\": msg = \"%s tries to parry, but %s feints and hits!\" messages.append(msg % (char, tchar)) else: msg = \"%s parries to no avail.\" messages.append(msg % char) elif action == \"feint\": if taction == \"parry\": msg = \"%s feints past %s's parry, landing a hit!\" messages.append(msg % (char, tchar)) elif taction == \"hit\": msg = \"%s feints but is defeated by %s hit!\" messages.append(msg % (char, tchar)) else: msg = \"%s feints to no avail.\" messages.append(msg % char) elif action == \"defend\": msg = \"%s defends.\" messages.append(msg % char) elif action == \"flee\": if char in flee: flee[char] += 1 else: flee[char] = 1 msg = \"%s tries to disengage (two subsequent turns needed)\" messages.append(msg % char) # echo results of each subturn combat_handler.msg_all(\"\\n\".join(messages)) # at the end of both sub-turns, test if anyone fled msg = \"%s withdraws from combat.\" for (char, fleevalue) in flee.items(): if fleevalue == 2: combat_handler.msg_all(msg % char) combat_handler.remove_character(char) To make it simple (and to save space), this example rule module actually resolves each interchange twice - first when it gets to each character and then again when handling the target. Also, since we use the combat handler's msg_all method here, the system will get pretty spammy. To clean it up, one could imagine tracking all the possible interactions to make sure each pair is only handled and reported once.","title":"Rules module"},{"location":"Turn-based-Combat-System.html#combat-initiator-command","text":"This is the last component we need, a command to initiate combat. This will tie everything together. We store this with the other combat commands. # mygame/commands/combat.py from evennia import create_script class CmdAttack(Command): \"\"\" initiates combat Usage: attack <target> This will initiate combat with <target>. If <target is already in combat, you will join the combat. \"\"\" key = \"attack\" help_category = \"General\" def func(self): \"Handle command\" if not self.args: self.caller.msg(\"Usage: attack <target>\") return target = self.caller.search(self.args) if not target: return # set up combat if target.ndb.combat_handler: # target is already in combat - join it target.ndb.combat_handler.add_character(self.caller) target.ndb.combat_handler.msg_all(\"%s joins combat!\" % self.caller) else: # create a new combat handler chandler = create_script(\"combat_handler.CombatHandler\") chandler.add_character(self.caller) chandler.add_character(target) self.caller.msg(\"You attack %s! You are in combat.\" % target) target.msg(\"%s attacks you! You are in combat.\" % self.caller) The attack command will not go into the combat cmdset but rather into the default cmdset. See e.g. the Adding Command Tutorial if you are unsure about how to do this.","title":"Combat initiator command"},{"location":"Turn-based-Combat-System.html#expanding-the-example","text":"At this point you should have a simple but flexible turn-based combat system. We have taken several shortcuts and simplifications in this example. The output to the players is likely too verbose during combat and too limited when it comes to informing about things surrounding it. Methods for changing your commands or list them, view who is in combat etc is likely needed - this will require play testing for each game and style. There is also currently no information displayed for other people happening to be in the same room as the combat - some less detailed information should probably be echoed to the room to show others what's going on.","title":"Expanding the example"},{"location":"Tutorial-World-Introduction.html","text":"The Tutorial World is a small and functioning MUD-style game world. It is intended to be deconstructed and used as a way to learn Evennia. The game consists of a single-player quest and has some 20 rooms that you can explore as you seek to discover the whereabouts of a mythical weapon. The source code is fully documented. You can find the whole thing in evennia/contrib/tutorial_world/ . Some features exemplified by the tutorial world: Tutorial command, giving \"behind-the-scenes\" help for every room and some of the special objects Rooms with custom return_appearance to show details. Hidden exits Objects with multiple custom interactions Large-area rooms Outdoor weather rooms Dark room, needing light source Puzzle object Multi-room puzzle Aggressive mobile with roam, pursue and battle state-engine AI Weapons, also used by mobs Simple combat system with attack/defend commands Object spawning Teleporter trap rooms Install \u00b6 The tutorial world consists of a few modules in evennia/contrib/tutorial_world/ containing custom Typeclasses for rooms and objects and associated Commands . These reusable bits and pieces are then put together into a functioning game area (\"world\" is maybe too big a word for such a small zone) using a batch script called build.ev . To install, log into the server as the superuser (user #1) and run: @batchcommand tutorial_world.build The world will be built (this might take a while, so don't rerun the command even if it seems the system has frozen). After finishing you will end up back in Limbo with a new exit called tutorial . An alternative is @batchcommand/interactive tutorial_world.build with the /interactive switch you are able to step through the building process at your own pace to see what happens in detail. To play the tutorial \"correctly\", you should not do so as superuser. The reason for this is that many game systems ignore the presence of a superuser and will thus not work as normal. Use the @quell command to limit your powers or log out and reconnect as a different user. As superuser you can of course examine things \"under the hood\" later if you want. Gameplay \u00b6 To get into the mood of this miniature quest, imagine you are an adventurer out to find fame and fortune. You have heard rumours of an old castle ruin by the coast. In its depth a warrior princess was buried together with her powerful magical weapon - a valuable prize, if it's true. Of course this is a chance to adventure that you cannot turn down! You reach the ocean in the midst of a raging thunderstorm. With wind and rain screaming in your face you stand where the moor meets the sea along a high, rocky coast ... Look at everything. Some objects are interactive in more than one way. Use the normal help command to get a feel for which commands are available at any given time. (use the command tutorial to get insight behind the scenes of the tutorial). In order to fight, you need to first find some type of weapon. slash is a normal attack stab launches an attack that makes more damage but has a lower chance to hit. defend will lower the chance to taking damage on your enemy's next attack. You can run from a fight that feels too deadly. Expect to be chased though. Being defeated is a part of the experience ... Uninstall \u00b6 Uninstalling the tutorial world basically means deleting all the rooms and objects it consists of. First, move out of the tutorial area. @find tut#01 @find tut#16 This should locate the first and last rooms created by build.ev - Intro and Outro . If you installed normally, everything created between these two numbers should be part of the tutorial. Note their dbref numbers, for example 5 and 80. Next we just delete all objects in that range: @del 5-80 You will see some errors since some objects are auto-deleted and so cannot be found when the delete mechanism gets to them. That's fine. You should have removed the tutorial completely once the command finishes. Notes \u00b6 When reading and learning from the code, keep in mind that Tutorial World was created with a very specific goal: to install easily and to not permanently modify the rest of the server. It therefore goes to some length to use only temporary solutions and to clean up after itself.","title":"Tutorial World Introduction"},{"location":"Tutorial-World-Introduction.html#install","text":"The tutorial world consists of a few modules in evennia/contrib/tutorial_world/ containing custom Typeclasses for rooms and objects and associated Commands . These reusable bits and pieces are then put together into a functioning game area (\"world\" is maybe too big a word for such a small zone) using a batch script called build.ev . To install, log into the server as the superuser (user #1) and run: @batchcommand tutorial_world.build The world will be built (this might take a while, so don't rerun the command even if it seems the system has frozen). After finishing you will end up back in Limbo with a new exit called tutorial . An alternative is @batchcommand/interactive tutorial_world.build with the /interactive switch you are able to step through the building process at your own pace to see what happens in detail. To play the tutorial \"correctly\", you should not do so as superuser. The reason for this is that many game systems ignore the presence of a superuser and will thus not work as normal. Use the @quell command to limit your powers or log out and reconnect as a different user. As superuser you can of course examine things \"under the hood\" later if you want.","title":"Install"},{"location":"Tutorial-World-Introduction.html#gameplay","text":"To get into the mood of this miniature quest, imagine you are an adventurer out to find fame and fortune. You have heard rumours of an old castle ruin by the coast. In its depth a warrior princess was buried together with her powerful magical weapon - a valuable prize, if it's true. Of course this is a chance to adventure that you cannot turn down! You reach the ocean in the midst of a raging thunderstorm. With wind and rain screaming in your face you stand where the moor meets the sea along a high, rocky coast ... Look at everything. Some objects are interactive in more than one way. Use the normal help command to get a feel for which commands are available at any given time. (use the command tutorial to get insight behind the scenes of the tutorial). In order to fight, you need to first find some type of weapon. slash is a normal attack stab launches an attack that makes more damage but has a lower chance to hit. defend will lower the chance to taking damage on your enemy's next attack. You can run from a fight that feels too deadly. Expect to be chased though. Being defeated is a part of the experience ...","title":"Gameplay"},{"location":"Tutorial-World-Introduction.html#uninstall","text":"Uninstalling the tutorial world basically means deleting all the rooms and objects it consists of. First, move out of the tutorial area. @find tut#01 @find tut#16 This should locate the first and last rooms created by build.ev - Intro and Outro . If you installed normally, everything created between these two numbers should be part of the tutorial. Note their dbref numbers, for example 5 and 80. Next we just delete all objects in that range: @del 5-80 You will see some errors since some objects are auto-deleted and so cannot be found when the delete mechanism gets to them. That's fine. You should have removed the tutorial completely once the command finishes.","title":"Uninstall"},{"location":"Tutorial-World-Introduction.html#notes","text":"When reading and learning from the code, keep in mind that Tutorial World was created with a very specific goal: to install easily and to not permanently modify the rest of the server. It therefore goes to some length to use only temporary solutions and to clean up after itself.","title":"Notes"},{"location":"Tutorial-for-basic-MUSH-like-game.html","text":"This tutorial lets you code a small but complete and functioning MUSH-like game in Evennia. A MUSH is, for our purposes, a class of roleplay-centric games focused on free form storytelling. Even if you are not interested in MUSH:es, this is still a good first game-type to try since it's not so code heavy. You will be able to use the same principles for building other types of games. The tutorial starts from scratch. If you did the First Steps Coding tutorial already you should have some ideas about how to do some of the steps already. The following are the (very simplistic and cut-down) features we will implement (this was taken from a feature request from a MUSH user new to Evennia). A Character in this system should: Have a \u201cPower\u201d score from 1 to 10 that measures how strong they are (stand-in for the stat system). Have a command (e.g. +setpower 4 ) that sets their power (stand-in for character generation code). Have a command (e.g. +attack ) that lets them roll their power and produce a \"Combat Score\" between 1 and 10*Power , displaying the result and editing their object to record this number (stand-in for +actions in the command code). Have a command that displays everyone in the room and what their most recent \"Combat Score\" roll was (stand-in for the combat code). Have a command (e.g. +createNPC Jenkins ) that creates an NPC with full abilities. Have a command to control NPCs, such as +npc/cmd (name)=(command) (stand-in for the NPC controlling code). In this tutorial we will assume you are starting from an empty database without any previous modifications. Server Settings \u00b6 To emulate a MUSH, the default MULTISESSION_MODE=0 is enough (one unique session per account/character). This is the default so you don't need to change anything. You will still be able to puppet/unpuppet objects you have permission to, but there is no character selection out of the box in this mode. We will assume our game folder is called mygame henceforth. You should be fine with the default SQLite3 database. Creating the Character \u00b6 First thing is to choose how our Character class works. We don't need to define a special NPC object -- an NPC is after all just a Character without an Account currently controlling them. Make your changes in the mygame/typeclasses/characters.py file: # mygame/typeclasses/characters.py from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" [...] \"\"\" def at_object_creation(self): \"This is called when object is first created, only.\" self.db.power = 1 self.db.combat_score = 1 We defined two new Attributes power and combat_score and set them to default values. Make sure to @reload the server if you had it already running (you need to reload every time you update your python code, don't worry, no accounts will be disconnected by the reload). Note that only new characters will see your new Attributes (since the at_object_creation hook is called when the object is first created, existing Characters won't have it). To update yourself, run @typeclass/force self This resets your own typeclass (the /force switch is a safety measure to not do this accidentally), this means that at_object_creation is re-run. examine self Under the \"Persistent attributes\" heading you should now find the new Attributes power and score set on yourself by at_object_creation . If you don't, first make sure you @reload ed into the new code, next look at your server log (in the terminal/console) to see if there were any syntax errors in your code that may have stopped your new code from loading correctly. Character Generation \u00b6 We assume in this example that Accounts first connect into a \"character generation area\". Evennia also supports full OOC menu-driven character generation, but for this example, a simple start room is enough. When in this room (or rooms) we allow character generation commands. In fact, character generation commands will only be available in such rooms. Note that this again is made so as to be easy to expand to a full-fledged game. With our simple example, we could simply set an is_in_chargen flag on the account and have the +setpower command check it. Using this method however will make it easy to add more functionality later. What we need are the following: One character generation Command to set the \"Power\" on the Character . A chargen CmdSet to hold this command. Lets call it ChargenCmdset . A custom ChargenRoom type that makes this set of commands available to players in such rooms. One such room to test things in. The +setpower command \u00b6 For this tutorial we will add all our new commands to mygame/commands/command.py but you could split your commands into multiple module if you prefered. For this tutorial character generation will only consist of one Command to set the Character s \"power\" stat. It will be called on the following MUSH-like form: +setpower 4 Open command.py file. It contains documented empty templates for the base command and the \"MuxCommand\" type used by default in Evennia. We will use the plain Command type here, the MuxCommand class offers some extra features like stripping whitespace that may be useful - if so, just import from that instead. Add the following to the end of the command.py file: # end of command.py from evennia import Command # just for clarity; already imported above class CmdSetPower(Command): \"\"\" set the power of a character Usage: +setpower <1-10> This sets the power of the current character. This can only be used during character generation. \"\"\" key = \"+setpower\" help_category = \"mush\" def func(self): \"This performs the actual command\" errmsg = \"You must supply a number between 1 and 10.\" if not self.args: self.caller.msg(errmsg) return try: power = int(self.args) except ValueError: self.caller.msg(errmsg) return if not (1 <= power <= 10): self.caller.msg(errmsg) return # at this point the argument is tested as valid. Let's set it. self.caller.db.power = power self.caller.msg(\"Your Power was set to %i.\" % power) This is a pretty straightforward command. We do some error checking, then set the power on ourself. We use a help_category of \"mush\" for all our commands, just so they are easy to find and separate in the help list. Save the file. We will now add it to a new CmdSet so it can be accessed (in a full chargen system you would of course have more than one command here). Open mygame/commands/default_cmdsets.py and import your command.py module at the top. We also import the default CmdSet class for the next step: from evennia import CmdSet from commands import command Next scroll down and define a new command set (based on the base CmdSet class we just imported at the end of this file, to hold only our chargen-specific command(s): # end of default_cmdsets.py class ChargenCmdset(CmdSet): \"\"\" This cmdset it used in character generation areas. \"\"\" key = \"Chargen\" def at_cmdset_creation(self): \"This is called at initialization\" self.add(command.CmdSetPower()) In the future you can add any number of commands to this cmdset, to expand your character generation system as you desire. Now we need to actually put that cmdset on something so it's made available to users. We could put it directly on the Character, but that would make it available all the time. It's cleaner to put it on a room, so it's only available when players are in that room. Chargen areas \u00b6 We will create a simple Room typeclass to act as a template for all our Chargen areas. Edit mygame/typeclasses/rooms.py next: # end of rooms.py from commands.default_cmdsets import ChargenCmdset class ChargenRoom(Room): \"\"\" This room class is used by character-generation rooms. It makes the ChargenCmdset available. \"\"\" def at_object_creation(self): \"this is called only at first creation\" self.cmdset.add(ChargenCmdset, permanent=True) Note how new rooms created with this typeclass will always start with ChargenCmdset on themselves. Don't forget the permanent=True keyword or you will lose the cmdset after a server reload. For more information about Command Sets and Commands , see the respective links. Testing chargen \u00b6 First, make sure you have @reload ed the server (or use evennia reload from the terminal) to have your new python code added to the game. Check your terminal and fix any errors you see - the error traceback lists exactly where the error is found - look line numbers in files you have changed. We can't test things unless we have some chargen areas to test. Log into the game (you should at this point be using the new, custom Character class). Let's dig a chargen area to test. @dig chargen:rooms.ChargenRoom = chargen,finish If you read the help for @dig you will find that this will create a new room named chargen . The part after the : is the python-path to the Typeclass you want to use. Since Evennia will automatically try the typeclasses folder of our game directory, we just specify rooms.ChargenRoom , meaning it will look inside the module rooms.py for a class named ChargenRoom (which is what we created above). The names given after = are the names of exits to and from the room from your current location. You could also append aliases to each one name, such as chargen;character generation . So in summary, this will create a new room of type ChargenRoom and open an exit chargen to it and an exit back here named finish . If you see errors at this stage, you must fix them in your code. @reload between fixes. Don't continue until the creation seems to have worked okay. chargen This should bring you to the chargen room. Being in there you should now have the +setpower command available, so test it out. When you leave (via the finish exit), the command will go away and trying +setpower should now give you a command-not-found error. Use ex me (as a privileged user) to check so the Power Attribute has been set correctly. If things are not working, make sure your typeclasses and commands are free of bugs and that you have entered the paths to the various command sets and commands correctly. Check the logs or command line for tracebacks and errors. Combat System \u00b6 We will add our combat command to the default command set, meaning it will be available to everyone at all times. The combat system consists of a +attack command to get how successful our attack is. We also change the default look command to display the current combat score. Attacking with the +attack command \u00b6 Attacking in this simple system means rolling a random \"combat score\" influenced by the power stat set during Character generation: > +attack You +attack with a combat score of 12! Go back to mygame/commands/command.py and add the command to the end like this: import random class CmdAttack(Command): \"\"\" issues an attack Usage: +attack This will calculate a new combat score based on your Power. Your combat score is visible to everyone in the same location. \"\"\" key = \"+attack\" help_category = \"mush\" def func(self): \"Calculate the random score between 1-10*Power\" caller = self.caller power = caller.db.power if not power: # this can happen if caller is not of # our custom Character typeclass power = 1 combat_score = random.randint(1, 10 * power) caller.db.combat_score = combat_score # announce message = \"%s +attack%s with a combat score of %s!\" caller.msg(message % (\"You\", \"\", combat_score)) caller.location.msg_contents(message % (caller.key, \"s\", combat_score), exclude=caller) What we do here is simply to generate a \"combat score\" using Python's inbuilt random.randint() function. We then store that and echo the result to everyone involved. To make the +attack command available to you in game, go back to mygame/commands/default_cmdsets.py and scroll down to the CharacterCmdSet class. At the correct place add this line: self.add(command.CmdAttack()) @reload Evennia and the +attack command should be available to you. Run it and use e.g. @ex to make sure the combat_score attribute is saved correctly. Have \"look\" show combat scores \u00b6 Players should be able to view all current combat scores in the room. We could do this by simply adding a second command named something like +combatscores , but we will instead let the default look command do the heavy lifting for us and display our scores as part of its normal output, like this: > look Tom Tom (combat score: 3) This is a great warrior. We don't actually have to modify the look command itself however. To understand why, take a look at how the default look is actually defined. It sits in evennia/commands/default/general.py (or browse it online here ). You will find that the actual return text is done by the look command calling a hook method named return_appearance on the object looked at. All the look does is to echo whatever this hook returns. So what we need to do is to edit our custom Character typeclass and overload its return_appearance to return what we want (this is where the advantage of having a custom typeclass comes into play for real). Go back to your custom Character typeclass in mygame/typeclasses/characters.py . The default implementation of return appearance is found in evennia.DefaultCharacter (or online here ). If you want to make bigger changes you could copy & paste the whole default thing into our overloading method. In our case the change is small though: class Character(DefaultCharacter): \"\"\" [...] \"\"\" def at_object_creation(self): \"This is called when object is first created, only.\" self.db.power = 1 self.db.combat_score = 1 def return_appearance(self, looker): \"\"\" The return from this method is what looker sees when looking at this object. \"\"\" text = super().return_appearance(looker) cscore = \" (combat score: %s)\" % self.db.combat_score if \"\\n\" in text: # text is multi-line, add score after first line first_line, rest = text.split(\"\\n\", 1) text = first_line + cscore + \"\\n\" + rest else: # text is only one line; add score to end text += cscore return text What we do is to simply let the default return_appearance do its thing ( super will call the parent's version of the same method). We then split out the first line of this text, append our combat_score and put it back together again. @reload the server and you should be able to look at other Characters and see their current combat scores. Note: A potentially more useful way to do this would be to overload the entire return_appearance of the Room s of your mush and change how they list their contents; in that way one could see all combat scores of all present Characters at the same time as looking at the room. We leave this as an exercise. NPC system \u00b6 Here we will re-use the Character class by introducing a command that can create NPC objects. We should also be able to set its Power and order it around. There are a few ways to define the NPC class. We could in theory create a custom typeclass for it and put a custom NPC-specific cmdset on all NPCs. This cmdset could hold all manipulation commands. Since we expect NPC manipulation to be a common occurrence among the user base however, we will instead put all relevant NPC commands in the default command set and limit eventual access with Permissions and Locks . Creating an NPC with +createNPC \u00b6 We need a command for creating the NPC, this is a very straightforward command: > +createnpc Anna You created the NPC 'Anna'. At the end of command.py , create our new command: from evennia import create_object class CmdCreateNPC(Command): \"\"\" create a new npc Usage: +createNPC <name> Creates a new, named NPC. The NPC will start with a Power of 1. \"\"\" key = \"+createnpc\" aliases = [\"+createNPC\"] locks = \"call:not perm(nonpcs)\" help_category = \"mush\" def func(self): \"creates the object and names it\" caller = self.caller if not self.args: caller.msg(\"Usage: +createNPC <name>\") return if not caller.location: # may not create npc when OOC caller.msg(\"You must have a location to create an npc.\") return # make name always start with capital letter name = self.args.strip().capitalize() # create npc in caller's location npc = create_object(\"characters.Character\", key=name, location=caller.location, locks=\"edit:id(%i) and perm(Builders);call:false()\" % caller.id) # announce message = \"%s created the NPC '%s'.\" caller.msg(message % (\"You\", name)) caller.location.msg_contents(message % (caller.key, name), exclude=caller) Here we define a +createnpc ( +createNPC works too) that is callable by everyone not having the nonpcs \" permission \" (in Evennia, a \"permission\" can just as well be used to block access, it depends on the lock we define). We create the NPC object in the caller's current location, using our custom Character typeclass to do so. We set an extra lock condition on the NPC, which we will use to check who may edit the NPC later -- we allow the creator to do so, and anyone with the Builders permission (or higher). See Locks for more information about the lock system. Note that we just give the object default permissions (by not specifying the permissions keyword to the create_object() call). In some games one might want to give the NPC the same permissions as the Character creating them, this might be a security risk though. Add this command to your default cmdset the same way you did the +attack command earlier. @reload and it will be available to test. Editing the NPC with +editNPC \u00b6 Since we re-used our custom character typeclass, our new NPC already has a Power value - it defaults to 1. How do we change this? There are a few ways we can do this. The easiest is to remember that the power attribute is just a simple Attribute stored on the NPC object. So as a Builder or Admin we could set this right away with the default @set command: @set mynpc/power = 6 The @set command is too generally powerful though, and thus only available to staff. We will add a custom command that only changes the things we want players to be allowed to change. We could in principle re-work our old +setpower command, but let's try something more useful. Let's make a +editNPC command. > +editNPC Anna/power = 10 Set Anna's property 'power' to 10. This is a slightly more complex command. It goes at the end of your command.py file as before. class CmdEditNPC(Command): \"\"\" edit an existing NPC Usage: +editnpc <name>[/<attribute> [= value]] Examples: +editnpc mynpc/power = 5 +editnpc mynpc/power - displays power value +editnpc mynpc - shows all editable attributes and values This command edits an existing NPC. You must have permission to edit the NPC to use this. \"\"\" key = \"+editnpc\" aliases = [\"+editNPC\"] locks = \"cmd:not perm(nonpcs)\" help_category = \"mush\" def parse(self): \"We need to do some parsing here\" args = self.args propname, propval = None, None if \"=\" in args: args, propval = [part.strip() for part in args.rsplit(\"=\", 1)] if \"/\" in args: args, propname = [part.strip() for part in args.rsplit(\"/\", 1)] # store, so we can access it below in func() self.name = args self.propname = propname # a propval without a propname is meaningless self.propval = propval if propname else None def func(self): \"do the editing\" allowed_propnames = (\"power\", \"attribute1\", \"attribute2\") caller = self.caller if not self.args or not self.name: caller.msg(\"Usage: +editnpc name[/propname][=propval]\") return npc = caller.search(self.name) if not npc: return if not npc.access(caller, \"edit\"): caller.msg(\"You cannot change this NPC.\") return if not self.propname: # this means we just list the values output = \"Properties of %s:\" % npc.key for propname in allowed_propnames: propvalue = npc.attributes.get(propname, default=\"N/A\") output += \"\\n %s = %s\" % (propname, propvalue) caller.msg(output) elif self.propname not in allowed_propnames: caller.msg(\"You may only change %s.\" % \", \".join(allowed_propnames)) elif self.propval: # assigning a new propvalue # in this example, the properties are all integers... intpropval = int(self.propval) npc.attributes.add(self.propname, intpropval) caller.msg(\"Set %s's property '%s' to %s\" % (npc.key, self.propname, self.propval)) else: # propname set, but not propval - show current value caller.msg(\"%s has property %s = %s\" % (npc.key, self.propname, npc.attributes.get(self.propname, default=\"N/A\"))) This command example shows off the use of more advanced parsing but otherwise it's mostly error checking. It searches for the given npc in the same room, and checks so the caller actually has permission to \"edit\" it before continuing. An account without the proper permission won't even be able to view the properties on the given NPC. It's up to each game if this is the way it should be. Add this to the default command set like before and you should be able to try it out. Note: If you wanted a player to use this command to change an on-object property like the NPC's name (the key property), you'd need to modify the command since \"key\" is not an Attribute (it is not retrievable via npc.attributes.get but directly via npc.key ). We leave this as an optional exercise. Making the NPC do stuff - the +npc command \u00b6 Finally, we will make a command to order our NPC around. For now, we will limit this command to only be usable by those having the \"edit\" permission on the NPC. This can be changed if it's possible for anyone to use the NPC. The NPC, since it inherited our Character typeclass has access to most commands a player does. What it doesn't have access to are Session and Player-based cmdsets (which means, among other things that they cannot chat on channels, but they could do that if you just added those commands). This makes the +npc command simple: +npc Anna = say Hello! Anna says, 'Hello!' Again, add to the end of your command.py module: class CmdNPC(Command): \"\"\" controls an NPC Usage: +npc <name> = <command> This causes the npc to perform a command as itself. It will do so with its own permissions and accesses. \"\"\" key = \"+npc\" locks = \"call:not perm(nonpcs)\" help_category = \"mush\" def parse(self): \"Simple split of the = sign\" name, cmdname = None, None if \"=\" in self.args: name, cmdname = [part.strip() for part in self.args.rsplit(\"=\", 1)] self.name, self.cmdname = name, cmdname def func(self): \"Run the command\" caller = self.caller if not self.cmdname: caller.msg(\"Usage: +npc <name> = <command>\") return npc = caller.search(self.name) if not npc: return if not npc.access(caller, \"edit\"): caller.msg(\"You may not order this NPC to do anything.\") return # send the command order npc.execute_cmd(self.cmdname) caller.msg(\"You told %s to do '%s'.\" % (npc.key, self.cmdname)) Note that if you give an erroneous command, you will not see any error message, since that error will be returned to the npc object, not to you. If you want players to see this, you can give the caller's session ID to the execute_cmd call, like this: npc.execute_cmd(self.cmdname, sessid=self.caller.sessid) Another thing to remember is however that this is a very simplistic way to control NPCs. Evennia supports full puppeting very easily. An Account (assuming the \"puppet\" permission was set correctly) could simply do @ic mynpc and be able to play the game \"as\" that NPC. This is in fact just what happens when an Account takes control of their normal Character as well. Concluding remarks \u00b6 This ends the tutorial. It looks like a lot of text but the amount of code you have to write is actually relatively short. At this point you should have a basic skeleton of a game and a feel for what is involved in coding your game. From here on you could build a few more ChargenRooms and link that to a bigger grid. The +setpower command can either be built upon or accompanied by many more to get a more elaborate character generation. The simple \"Power\" game mechanic should be easily expandable to something more full-fledged and useful, same is true for the combat score principle. The +attack could be made to target a specific player (or npc) and automatically compare their relevant attributes to determine a result. To continue from here, you can take a look at the Tutorial World . For more specific ideas, see the other tutorials and hints as well as the Developer Central .","title":"Tutorial for basic MUSH like game"},{"location":"Tutorial-for-basic-MUSH-like-game.html#server-settings","text":"To emulate a MUSH, the default MULTISESSION_MODE=0 is enough (one unique session per account/character). This is the default so you don't need to change anything. You will still be able to puppet/unpuppet objects you have permission to, but there is no character selection out of the box in this mode. We will assume our game folder is called mygame henceforth. You should be fine with the default SQLite3 database.","title":"Server Settings"},{"location":"Tutorial-for-basic-MUSH-like-game.html#creating-the-character","text":"First thing is to choose how our Character class works. We don't need to define a special NPC object -- an NPC is after all just a Character without an Account currently controlling them. Make your changes in the mygame/typeclasses/characters.py file: # mygame/typeclasses/characters.py from evennia import DefaultCharacter class Character(DefaultCharacter): \"\"\" [...] \"\"\" def at_object_creation(self): \"This is called when object is first created, only.\" self.db.power = 1 self.db.combat_score = 1 We defined two new Attributes power and combat_score and set them to default values. Make sure to @reload the server if you had it already running (you need to reload every time you update your python code, don't worry, no accounts will be disconnected by the reload). Note that only new characters will see your new Attributes (since the at_object_creation hook is called when the object is first created, existing Characters won't have it). To update yourself, run @typeclass/force self This resets your own typeclass (the /force switch is a safety measure to not do this accidentally), this means that at_object_creation is re-run. examine self Under the \"Persistent attributes\" heading you should now find the new Attributes power and score set on yourself by at_object_creation . If you don't, first make sure you @reload ed into the new code, next look at your server log (in the terminal/console) to see if there were any syntax errors in your code that may have stopped your new code from loading correctly.","title":"Creating the Character"},{"location":"Tutorial-for-basic-MUSH-like-game.html#character-generation","text":"We assume in this example that Accounts first connect into a \"character generation area\". Evennia also supports full OOC menu-driven character generation, but for this example, a simple start room is enough. When in this room (or rooms) we allow character generation commands. In fact, character generation commands will only be available in such rooms. Note that this again is made so as to be easy to expand to a full-fledged game. With our simple example, we could simply set an is_in_chargen flag on the account and have the +setpower command check it. Using this method however will make it easy to add more functionality later. What we need are the following: One character generation Command to set the \"Power\" on the Character . A chargen CmdSet to hold this command. Lets call it ChargenCmdset . A custom ChargenRoom type that makes this set of commands available to players in such rooms. One such room to test things in.","title":"Character Generation"},{"location":"Tutorial-for-basic-MUSH-like-game.html#the-setpower-command","text":"For this tutorial we will add all our new commands to mygame/commands/command.py but you could split your commands into multiple module if you prefered. For this tutorial character generation will only consist of one Command to set the Character s \"power\" stat. It will be called on the following MUSH-like form: +setpower 4 Open command.py file. It contains documented empty templates for the base command and the \"MuxCommand\" type used by default in Evennia. We will use the plain Command type here, the MuxCommand class offers some extra features like stripping whitespace that may be useful - if so, just import from that instead. Add the following to the end of the command.py file: # end of command.py from evennia import Command # just for clarity; already imported above class CmdSetPower(Command): \"\"\" set the power of a character Usage: +setpower <1-10> This sets the power of the current character. This can only be used during character generation. \"\"\" key = \"+setpower\" help_category = \"mush\" def func(self): \"This performs the actual command\" errmsg = \"You must supply a number between 1 and 10.\" if not self.args: self.caller.msg(errmsg) return try: power = int(self.args) except ValueError: self.caller.msg(errmsg) return if not (1 <= power <= 10): self.caller.msg(errmsg) return # at this point the argument is tested as valid. Let's set it. self.caller.db.power = power self.caller.msg(\"Your Power was set to %i.\" % power) This is a pretty straightforward command. We do some error checking, then set the power on ourself. We use a help_category of \"mush\" for all our commands, just so they are easy to find and separate in the help list. Save the file. We will now add it to a new CmdSet so it can be accessed (in a full chargen system you would of course have more than one command here). Open mygame/commands/default_cmdsets.py and import your command.py module at the top. We also import the default CmdSet class for the next step: from evennia import CmdSet from commands import command Next scroll down and define a new command set (based on the base CmdSet class we just imported at the end of this file, to hold only our chargen-specific command(s): # end of default_cmdsets.py class ChargenCmdset(CmdSet): \"\"\" This cmdset it used in character generation areas. \"\"\" key = \"Chargen\" def at_cmdset_creation(self): \"This is called at initialization\" self.add(command.CmdSetPower()) In the future you can add any number of commands to this cmdset, to expand your character generation system as you desire. Now we need to actually put that cmdset on something so it's made available to users. We could put it directly on the Character, but that would make it available all the time. It's cleaner to put it on a room, so it's only available when players are in that room.","title":"The +setpower command"},{"location":"Tutorial-for-basic-MUSH-like-game.html#chargen-areas","text":"We will create a simple Room typeclass to act as a template for all our Chargen areas. Edit mygame/typeclasses/rooms.py next: # end of rooms.py from commands.default_cmdsets import ChargenCmdset class ChargenRoom(Room): \"\"\" This room class is used by character-generation rooms. It makes the ChargenCmdset available. \"\"\" def at_object_creation(self): \"this is called only at first creation\" self.cmdset.add(ChargenCmdset, permanent=True) Note how new rooms created with this typeclass will always start with ChargenCmdset on themselves. Don't forget the permanent=True keyword or you will lose the cmdset after a server reload. For more information about Command Sets and Commands , see the respective links.","title":"Chargen areas"},{"location":"Tutorial-for-basic-MUSH-like-game.html#testing-chargen","text":"First, make sure you have @reload ed the server (or use evennia reload from the terminal) to have your new python code added to the game. Check your terminal and fix any errors you see - the error traceback lists exactly where the error is found - look line numbers in files you have changed. We can't test things unless we have some chargen areas to test. Log into the game (you should at this point be using the new, custom Character class). Let's dig a chargen area to test. @dig chargen:rooms.ChargenRoom = chargen,finish If you read the help for @dig you will find that this will create a new room named chargen . The part after the : is the python-path to the Typeclass you want to use. Since Evennia will automatically try the typeclasses folder of our game directory, we just specify rooms.ChargenRoom , meaning it will look inside the module rooms.py for a class named ChargenRoom (which is what we created above). The names given after = are the names of exits to and from the room from your current location. You could also append aliases to each one name, such as chargen;character generation . So in summary, this will create a new room of type ChargenRoom and open an exit chargen to it and an exit back here named finish . If you see errors at this stage, you must fix them in your code. @reload between fixes. Don't continue until the creation seems to have worked okay. chargen This should bring you to the chargen room. Being in there you should now have the +setpower command available, so test it out. When you leave (via the finish exit), the command will go away and trying +setpower should now give you a command-not-found error. Use ex me (as a privileged user) to check so the Power Attribute has been set correctly. If things are not working, make sure your typeclasses and commands are free of bugs and that you have entered the paths to the various command sets and commands correctly. Check the logs or command line for tracebacks and errors.","title":"Testing chargen"},{"location":"Tutorial-for-basic-MUSH-like-game.html#combat-system","text":"We will add our combat command to the default command set, meaning it will be available to everyone at all times. The combat system consists of a +attack command to get how successful our attack is. We also change the default look command to display the current combat score.","title":"Combat System"},{"location":"Tutorial-for-basic-MUSH-like-game.html#attacking-with-the-attack-command","text":"Attacking in this simple system means rolling a random \"combat score\" influenced by the power stat set during Character generation: > +attack You +attack with a combat score of 12! Go back to mygame/commands/command.py and add the command to the end like this: import random class CmdAttack(Command): \"\"\" issues an attack Usage: +attack This will calculate a new combat score based on your Power. Your combat score is visible to everyone in the same location. \"\"\" key = \"+attack\" help_category = \"mush\" def func(self): \"Calculate the random score between 1-10*Power\" caller = self.caller power = caller.db.power if not power: # this can happen if caller is not of # our custom Character typeclass power = 1 combat_score = random.randint(1, 10 * power) caller.db.combat_score = combat_score # announce message = \"%s +attack%s with a combat score of %s!\" caller.msg(message % (\"You\", \"\", combat_score)) caller.location.msg_contents(message % (caller.key, \"s\", combat_score), exclude=caller) What we do here is simply to generate a \"combat score\" using Python's inbuilt random.randint() function. We then store that and echo the result to everyone involved. To make the +attack command available to you in game, go back to mygame/commands/default_cmdsets.py and scroll down to the CharacterCmdSet class. At the correct place add this line: self.add(command.CmdAttack()) @reload Evennia and the +attack command should be available to you. Run it and use e.g. @ex to make sure the combat_score attribute is saved correctly.","title":"Attacking with the +attack command"},{"location":"Tutorial-for-basic-MUSH-like-game.html#have-look-show-combat-scores","text":"Players should be able to view all current combat scores in the room. We could do this by simply adding a second command named something like +combatscores , but we will instead let the default look command do the heavy lifting for us and display our scores as part of its normal output, like this: > look Tom Tom (combat score: 3) This is a great warrior. We don't actually have to modify the look command itself however. To understand why, take a look at how the default look is actually defined. It sits in evennia/commands/default/general.py (or browse it online here ). You will find that the actual return text is done by the look command calling a hook method named return_appearance on the object looked at. All the look does is to echo whatever this hook returns. So what we need to do is to edit our custom Character typeclass and overload its return_appearance to return what we want (this is where the advantage of having a custom typeclass comes into play for real). Go back to your custom Character typeclass in mygame/typeclasses/characters.py . The default implementation of return appearance is found in evennia.DefaultCharacter (or online here ). If you want to make bigger changes you could copy & paste the whole default thing into our overloading method. In our case the change is small though: class Character(DefaultCharacter): \"\"\" [...] \"\"\" def at_object_creation(self): \"This is called when object is first created, only.\" self.db.power = 1 self.db.combat_score = 1 def return_appearance(self, looker): \"\"\" The return from this method is what looker sees when looking at this object. \"\"\" text = super().return_appearance(looker) cscore = \" (combat score: %s)\" % self.db.combat_score if \"\\n\" in text: # text is multi-line, add score after first line first_line, rest = text.split(\"\\n\", 1) text = first_line + cscore + \"\\n\" + rest else: # text is only one line; add score to end text += cscore return text What we do is to simply let the default return_appearance do its thing ( super will call the parent's version of the same method). We then split out the first line of this text, append our combat_score and put it back together again. @reload the server and you should be able to look at other Characters and see their current combat scores. Note: A potentially more useful way to do this would be to overload the entire return_appearance of the Room s of your mush and change how they list their contents; in that way one could see all combat scores of all present Characters at the same time as looking at the room. We leave this as an exercise.","title":"Have \"look\" show combat scores"},{"location":"Tutorial-for-basic-MUSH-like-game.html#npc-system","text":"Here we will re-use the Character class by introducing a command that can create NPC objects. We should also be able to set its Power and order it around. There are a few ways to define the NPC class. We could in theory create a custom typeclass for it and put a custom NPC-specific cmdset on all NPCs. This cmdset could hold all manipulation commands. Since we expect NPC manipulation to be a common occurrence among the user base however, we will instead put all relevant NPC commands in the default command set and limit eventual access with Permissions and Locks .","title":"NPC system"},{"location":"Tutorial-for-basic-MUSH-like-game.html#creating-an-npc-with-createnpc","text":"We need a command for creating the NPC, this is a very straightforward command: > +createnpc Anna You created the NPC 'Anna'. At the end of command.py , create our new command: from evennia import create_object class CmdCreateNPC(Command): \"\"\" create a new npc Usage: +createNPC <name> Creates a new, named NPC. The NPC will start with a Power of 1. \"\"\" key = \"+createnpc\" aliases = [\"+createNPC\"] locks = \"call:not perm(nonpcs)\" help_category = \"mush\" def func(self): \"creates the object and names it\" caller = self.caller if not self.args: caller.msg(\"Usage: +createNPC <name>\") return if not caller.location: # may not create npc when OOC caller.msg(\"You must have a location to create an npc.\") return # make name always start with capital letter name = self.args.strip().capitalize() # create npc in caller's location npc = create_object(\"characters.Character\", key=name, location=caller.location, locks=\"edit:id(%i) and perm(Builders);call:false()\" % caller.id) # announce message = \"%s created the NPC '%s'.\" caller.msg(message % (\"You\", name)) caller.location.msg_contents(message % (caller.key, name), exclude=caller) Here we define a +createnpc ( +createNPC works too) that is callable by everyone not having the nonpcs \" permission \" (in Evennia, a \"permission\" can just as well be used to block access, it depends on the lock we define). We create the NPC object in the caller's current location, using our custom Character typeclass to do so. We set an extra lock condition on the NPC, which we will use to check who may edit the NPC later -- we allow the creator to do so, and anyone with the Builders permission (or higher). See Locks for more information about the lock system. Note that we just give the object default permissions (by not specifying the permissions keyword to the create_object() call). In some games one might want to give the NPC the same permissions as the Character creating them, this might be a security risk though. Add this command to your default cmdset the same way you did the +attack command earlier. @reload and it will be available to test.","title":"Creating an NPC with +createNPC"},{"location":"Tutorial-for-basic-MUSH-like-game.html#editing-the-npc-with-editnpc","text":"Since we re-used our custom character typeclass, our new NPC already has a Power value - it defaults to 1. How do we change this? There are a few ways we can do this. The easiest is to remember that the power attribute is just a simple Attribute stored on the NPC object. So as a Builder or Admin we could set this right away with the default @set command: @set mynpc/power = 6 The @set command is too generally powerful though, and thus only available to staff. We will add a custom command that only changes the things we want players to be allowed to change. We could in principle re-work our old +setpower command, but let's try something more useful. Let's make a +editNPC command. > +editNPC Anna/power = 10 Set Anna's property 'power' to 10. This is a slightly more complex command. It goes at the end of your command.py file as before. class CmdEditNPC(Command): \"\"\" edit an existing NPC Usage: +editnpc <name>[/<attribute> [= value]] Examples: +editnpc mynpc/power = 5 +editnpc mynpc/power - displays power value +editnpc mynpc - shows all editable attributes and values This command edits an existing NPC. You must have permission to edit the NPC to use this. \"\"\" key = \"+editnpc\" aliases = [\"+editNPC\"] locks = \"cmd:not perm(nonpcs)\" help_category = \"mush\" def parse(self): \"We need to do some parsing here\" args = self.args propname, propval = None, None if \"=\" in args: args, propval = [part.strip() for part in args.rsplit(\"=\", 1)] if \"/\" in args: args, propname = [part.strip() for part in args.rsplit(\"/\", 1)] # store, so we can access it below in func() self.name = args self.propname = propname # a propval without a propname is meaningless self.propval = propval if propname else None def func(self): \"do the editing\" allowed_propnames = (\"power\", \"attribute1\", \"attribute2\") caller = self.caller if not self.args or not self.name: caller.msg(\"Usage: +editnpc name[/propname][=propval]\") return npc = caller.search(self.name) if not npc: return if not npc.access(caller, \"edit\"): caller.msg(\"You cannot change this NPC.\") return if not self.propname: # this means we just list the values output = \"Properties of %s:\" % npc.key for propname in allowed_propnames: propvalue = npc.attributes.get(propname, default=\"N/A\") output += \"\\n %s = %s\" % (propname, propvalue) caller.msg(output) elif self.propname not in allowed_propnames: caller.msg(\"You may only change %s.\" % \", \".join(allowed_propnames)) elif self.propval: # assigning a new propvalue # in this example, the properties are all integers... intpropval = int(self.propval) npc.attributes.add(self.propname, intpropval) caller.msg(\"Set %s's property '%s' to %s\" % (npc.key, self.propname, self.propval)) else: # propname set, but not propval - show current value caller.msg(\"%s has property %s = %s\" % (npc.key, self.propname, npc.attributes.get(self.propname, default=\"N/A\"))) This command example shows off the use of more advanced parsing but otherwise it's mostly error checking. It searches for the given npc in the same room, and checks so the caller actually has permission to \"edit\" it before continuing. An account without the proper permission won't even be able to view the properties on the given NPC. It's up to each game if this is the way it should be. Add this to the default command set like before and you should be able to try it out. Note: If you wanted a player to use this command to change an on-object property like the NPC's name (the key property), you'd need to modify the command since \"key\" is not an Attribute (it is not retrievable via npc.attributes.get but directly via npc.key ). We leave this as an optional exercise.","title":"Editing the NPC with +editNPC"},{"location":"Tutorial-for-basic-MUSH-like-game.html#making-the-npc-do-stuff-the-npc-command","text":"Finally, we will make a command to order our NPC around. For now, we will limit this command to only be usable by those having the \"edit\" permission on the NPC. This can be changed if it's possible for anyone to use the NPC. The NPC, since it inherited our Character typeclass has access to most commands a player does. What it doesn't have access to are Session and Player-based cmdsets (which means, among other things that they cannot chat on channels, but they could do that if you just added those commands). This makes the +npc command simple: +npc Anna = say Hello! Anna says, 'Hello!' Again, add to the end of your command.py module: class CmdNPC(Command): \"\"\" controls an NPC Usage: +npc <name> = <command> This causes the npc to perform a command as itself. It will do so with its own permissions and accesses. \"\"\" key = \"+npc\" locks = \"call:not perm(nonpcs)\" help_category = \"mush\" def parse(self): \"Simple split of the = sign\" name, cmdname = None, None if \"=\" in self.args: name, cmdname = [part.strip() for part in self.args.rsplit(\"=\", 1)] self.name, self.cmdname = name, cmdname def func(self): \"Run the command\" caller = self.caller if not self.cmdname: caller.msg(\"Usage: +npc <name> = <command>\") return npc = caller.search(self.name) if not npc: return if not npc.access(caller, \"edit\"): caller.msg(\"You may not order this NPC to do anything.\") return # send the command order npc.execute_cmd(self.cmdname) caller.msg(\"You told %s to do '%s'.\" % (npc.key, self.cmdname)) Note that if you give an erroneous command, you will not see any error message, since that error will be returned to the npc object, not to you. If you want players to see this, you can give the caller's session ID to the execute_cmd call, like this: npc.execute_cmd(self.cmdname, sessid=self.caller.sessid) Another thing to remember is however that this is a very simplistic way to control NPCs. Evennia supports full puppeting very easily. An Account (assuming the \"puppet\" permission was set correctly) could simply do @ic mynpc and be able to play the game \"as\" that NPC. This is in fact just what happens when an Account takes control of their normal Character as well.","title":"Making the NPC do stuff - the +npc command"},{"location":"Tutorial-for-basic-MUSH-like-game.html#concluding-remarks","text":"This ends the tutorial. It looks like a lot of text but the amount of code you have to write is actually relatively short. At this point you should have a basic skeleton of a game and a feel for what is involved in coding your game. From here on you could build a few more ChargenRooms and link that to a bigger grid. The +setpower command can either be built upon or accompanied by many more to get a more elaborate character generation. The simple \"Power\" game mechanic should be easily expandable to something more full-fledged and useful, same is true for the combat score principle. The +attack could be made to target a specific player (or npc) and automatically compare their relevant attributes to determine a result. To continue from here, you can take a look at the Tutorial World . For more specific ideas, see the other tutorials and hints as well as the Developer Central .","title":"Concluding remarks"},{"location":"Tutorial:--Aggressive-NPCs.html","text":") This tutorial shows the implementation of an NPC object that responds to characters entering their location. In this example the NPC has the option to respond aggressively or not, but any actions could be triggered this way. One could imagine using a Script that is constantly checking for newcomers. This would be highly inefficient (most of the time its check would fail). Instead we handle this on-demand by using a couple of existing object hooks to inform the NPC that a Character has entered. It is assumed that you already know how to create custom room and character typeclasses, please see the Basic Game tutorial if you haven't already done this. What we will need is the following: An NPC typeclass that can react when someone enters A custom Room typeclass that can tell the NPC that someone entered We will also tweak our default Character typeclass a little. To begin with, we need to create an NPC typeclass. # mygame/typeclasses/npc.py from characters import Character class Npc(Character): \"\"\" A NPC typeclass which extends the character class. \"\"\" def at_char_entered(self, character): \"\"\" A simple is_aggressive check. Can be expanded upon later. \"\"\" if self.db.is_aggressive: self.execute_cmd(\"say Graaah, die %s!\" % character) else: self.execute_cmd(\"say Greetings, %s!\" % character) We will define our custom Character typeclass below. As for the new at_char_entered method we've just defined, we'll ensure that it will be called by the room where the NPC is located, when a player enters that room. You'll notice that right now, the NPC merely speaks. You can expand this part as you like and trigger all sorts of effects here (like combat code, fleeing, bartering or quest-giving) as your game design dictates. Now your room typeclass needs to have the following added: # mygame/typeclasses/rooms.py from evennia import utils from characters import Character from npc import Npc # ... inside your Room typeclass ... def at_object_receive(self, obj, source_location): if utils.inherits_from(obj, 'Npc'): # An NPC has entered pass else: if utils.inherits_from(obj, 'Character'): # A PC has entered, NPC is caught above. # Cause the character to look around obj.execute_cmd('look') for item in self.contents: if utils.inherits_from(item, 'Npc'): # An NPC is in the room item.at_char_entered(obj) Take particular note of the inherits at the top of this section, you'll need to ensure that they correctly point to your default Character class as well as the newly created Npc class. Note: at_object_receive is a default hook of the DefaultObject typeclass (and its children). Here we are overriding this hook in our customized room typeclass to suit our needs. This room checks the typeclass of objects entering it (using utils.inherits_from and responds to Characters , ignoring other NPCs or objects. When triggered the room will look through its contents and inform any Npc s inside by calling their at_char_entered method. You'll also see that we have added a 'look' into this code, this is because by default the at_object_receive is carried out before the characters' at_after_move which, we will now overload. This meant that a character entering would see the NPC perform its actions before the 'look' command. So we deactivate the look in our default Character class: # mygame/typeclasses/characters.py # inside the character class def at_after_move(self, source_location): \"\"\" Default is to look around after a move Note: This has been moved to room.at_object_receive \"\"\" #self.execute_cmd('look') pass Now that's done, let's create an NPC and make it aggressive. @reload @create/drop Orc:npc.Npc (you could also give the path as typeclasses.npc.Npc , but Evennia will look into the typeclasses folder automatically so this is a little shorter). When you enter the aggressive NPC's location, it will default to using its peaceful action (say your name is Anna): Orc says, \"Greetings, Anna!\" Now we turn on the aggressive mode (we do it manually but it could also be triggered by some sort of AI code). @set orc/is_aggressive = True Now it will perform its aggressive action whenever a character enters. Orc says, \"Graaah, die, Anna!\"","title":"Tutorial:  Aggressive NPCs"},{"location":"Tutorial:--NPC's-listening.html","text":") This tutorial shows the implementation of an NPC object that responds to characters speaking in their location. In this example the NPC parrots what is said, but any actions could be triggered this way. It is assumed that you already know how to create custom room and character typeclasses, please see the Basic Game tutorial if you haven't already done this. What we will need is simply a new NPC typeclass that can react when someone speaks. # mygame/typeclasses/npc.py from characters import Character class Npc(Character): \"\"\" A NPC typeclass which extends the character class. \"\"\" def at_heard_say(self, message, from_obj): \"\"\" A simple listener and response. This makes it easy to change for subclasses of NPCs reacting differently to says. \"\"\" # message will be on the form `<Person> says, \"say_text\"` # we want to get only say_text without the quotes and any spaces message = message.split('says, ')[1].strip(' \"') # we'll make use of this in .msg() below return \"%s said: '%s'\" % (from_obj, message) When someone in the room speaks to this NPC, its msg method will be called. We will modify the NPCs .msg method to catch says so the NPC can respond. # mygame/typeclasses/npc.py from characters import Character class Npc(Character): # [at_heard_say() goes here] def msg(self, text=None, from_obj=None, **kwargs): \"Custom msg() method reacting to say.\" if from_obj != self: # make sure to not repeat what we ourselves said or we'll create a loop try: # if text comes from a say, `text` is `('say_text', {'type': 'say'})` say_text, is_say = text[0], text[1]['type'] == 'say' except Exception: is_say = False if is_say: # First get the response (if any) response = self.at_heard_say(say_text, from_obj) # If there is a response if response != None: # speak ourselves, using the return self.execute_cmd(\"say %s\" % response) # this is needed if anyone ever puppets this NPC - without it you would never # get any feedback from the server (not even the results of look) super().msg(text=text, from_obj=from_obj, **kwargs) So if the NPC gets a say and that say is not coming from the NPC itself, it will echo it using the at_heard_say hook. Some things of note in the above example: The text input can be on many different forms depending on where this msg is called from. Instead of trying to analyze text in detail with a range of if statements we just assume the form we want and catch the error if it does not match. This simplifies the code considerably. It's called 'leap before you look' and is a Python paradigm that may feel unfamiliar if you are used to other languages. Here we 'swallow' the error silently, which is fine when the code checked is simple. If not we may want to import evennia.logger.log_trace and add log_trace() in the except clause. We use execute_cmd to fire the say command back. We could also have called self.location.msg_contents directly but using the Command makes sure all hooks are called (so those seeing the NPC's say can in turn react if they want). Note the comments about super at the end. This will trigger the 'default' msg (in the parent class) as well. It's not really necessary as long as no one puppets the NPC (by @ic <npcname> ) but it's wise to keep in there since the puppeting player will be totally blind if msg() is never returning anything to them! Now that's done, let's create an NPC and see what it has to say for itself. @reload @create/drop Guild Master:npc.Npc (you could also give the path as typeclasses.npc.Npc , but Evennia will look into the typeclasses folder automatically so this is a little shorter). > say hi You say, \"hi\" Guild Master says, \"Anna said: 'hi'\" Assorted notes \u00b6 There are many ways to implement this kind of functionality. An alternative example to overriding msg would be to modify the at_say hook on the Character instead. It could detect that it's sending to an NPC and call the at_heard_say hook directly. While the tutorial solution has the advantage of being contained only within the NPC class, combining this with using the Character class gives more direct control over how the NPC will react. Which way to go depends on the design requirements of your particular game.","title":"Tutorial:  NPC's listening"},{"location":"Tutorial:--NPC's-listening.html#assorted-notes","text":"There are many ways to implement this kind of functionality. An alternative example to overriding msg would be to modify the at_say hook on the Character instead. It could detect that it's sending to an NPC and call the at_heard_say hook directly. While the tutorial solution has the advantage of being contained only within the NPC class, combining this with using the Character class gives more direct control over how the NPC will react. Which way to go depends on the design requirements of your particular game.","title":"Assorted notes"},{"location":"Tutorial:--Vehicles.html","text":"This tutorial explains how you can create vehicles that can move around in your world. The tutorial will explain how to create a train, but this can be equally applied to create other kind of vehicles (cars, planes, boats, spaceships, submarines, ...). How it works \u00b6 Objects in Evennia have an interesting property: you can put any object inside another object. This is most obvious in rooms: a room in Evennia is just like any other game object (except rooms tend to not themselves be inside anything else). Our train will be similar: it will be an object that other objects can get inside. We then simply move the Train, which brings along everyone inside it. Creating our train object \u00b6 The first step we need to do is create our train object, including a new typeclass. To do this, create a new file, for instance in mygame/typeclasses/train.py with the following content: # file mygame/typeclasses/train.py from evennia import DefaultObject class TrainObject(DefaultObject): def at_object_creation(self): # We'll add in code here later. pass Now we can create our train in our game: @create/drop train:train.TrainObject Now this is just an object that doesn't do much yet... but we can already force our way inside it and back (assuming we created it in limbo). @tel train @tel limbo Entering and leaving the train \u00b6 Using the @tel command like shown above is obviously not what we want. @tel is an admin command and normal players will thus never be able to enter the train! It is also not really a good idea to use Exits to get in and out of the train - Exits are (at least by default) objects too. They point to a specific destination. If we put an Exit in this room leading inside the train it would stay here when the train moved away (still leading into the train like a magic portal!). In the same way, if we put an Exit object inside the train, it would always point back to this room, regardless of where the Train has moved. Now, one could define custom Exit types that move with the train or change their destination in the right way - but this seems to be a pretty cumbersome solution. What we will do instead is to create some new commands : one for entering the train and another for leaving it again. These will be stored on the train object and will thus be made available to whomever is either inside it or in the same room as the train. Let's create a new command module as mygame/commands/train.py : # mygame/commands/train.py from evennia import Command, CmdSet class CmdEnterTrain(Command): \"\"\" entering the train Usage: enter train This will be available to players in the same location as the train and allows them to embark. \"\"\" key = \"enter train\" locks = \"cmd:all()\" def func(self): train = self.obj self.caller.msg(\"You board the train.\") self.caller.move_to(train) class CmdLeaveTrain(Command): \"\"\" leaving the train Usage: leave train This will be available to everyone inside the train. It allows them to exit to the train's current location. \"\"\" key = \"leave train\" locks = \"cmd:all()\" def func(self): train = self.obj parent = train.location self.caller.move_to(parent) class CmdSetTrain(CmdSet): def at_cmdset_creation(self): self.add(CmdEnterTrain()) self.add(CmdLeaveTrain()) Note that while this seems like a lot of text, the majority of lines here are taken up by documentation. These commands are work in a pretty straightforward way: CmdEnterTrain moves the location of the player to inside the train and CmdLeaveTrain does the opposite: it moves the player back to the current location of the train (back outside to its current location). We stacked them in a cmdset CmdSetTrain so they can be used. To make the commands work we need to add this cmdset to our train typeclass: # file mygame/typeclasses/train.py from evennia import DefaultObject from commands.train import CmdSetTrain class TrainObject(DefaultObject): def at_object_creation(self): self.cmdset.add_default(CmdSetTrain) If we now @reload our game and reset our train, those commands should work and we can now enter and leave the train: @reload @typeclass/force/reset train = train.TrainObject enter train leave train Note the switches used with the @typeclass command: The /force switch is necessary to assign our object the same typeclass we already have. The /reset re-triggers the typeclass' at_object_creation() hook (which is otherwise only called the very first an instance is created). As seen above, when this hook is called on our train, our new cmdset will be loaded. Locking down the commands \u00b6 If you have played around a bit, you've probably figured out that you can use leave train when outside the train and enter train when inside. This doesn't make any sense ... so let's go ahead and fix that. We need to tell Evennia that you can not enter the train when you're already inside or leave the train when you're outside. One solution to this is locks : we will lock down the commands so that they can only be called if the player is at the correct location. Right now commands defaults to the lock cmd:all() . The cmd lock type in combination with the all() lock function means that everyone can run those commands as long as they are in the same room as the train or inside the train. We're going to change this to check the location of the player and only allow access if they are inside the train. First of all we need to create a new lock function. Evennia comes with many lock functions built-in already, but none that we can use for locking a command in this particular case. Create a new entry in mygame/server/conf/lockfuncs.py : # file mygame/server/conf/lockfuncs.py def cmdinside(accessing_obj, accessed_obj, *args, **kwargs): \"\"\" Usage: cmdinside() Used to lock commands and only allows access if the command is defined on an object which accessing_obj is inside of. \"\"\" return accessed_obj.obj == accessing_obj.location If you didn't know, Evennia is by default set up to use all functions in this module as lock functions (there is a setting variable that points to it). Our new lock function, cmdinside , is to be used by Commands. The accessed_obj is the Command object (in our case this will be CmdEnterTrain and CmdLeaveTrain ) \u2014 Every command has an obj property: this is the the object on which the command \"sits\". Since we added those commands to our train object, the .obj property will be set to the train object. Conversely, accessing_obj is the object that called the command: in our case it's the Character trying to enter or leave the train. What this function does is to check that the player's location is the same as the train object. If it is, it means the player is inside the train. Otherwise it means the player is somewhere else and the check will fail. The next step is to actually use this new lock function to create a lock of type cmd : # file commands/train.py ... class CmdEnterTrain(Command): key = \"enter train\" locks = \"cmd:not cmdinside()\" # ... class CmdLeaveTrain(Command): key = \"leave train\" locks = \"cmd:cmdinside()\" # ... Notice how we use the not here so that we can use the same cmdinside to check if we are inside and outside, without having to create two separate lock functions. After a @reload our commands should be locked down appropriately and you should only be able to use them at the right places. Note: If you're logged in as the super user (user #1 ) then this lock will not work: the super user ignores lock functions. In order to use this functionality you need to @quell first. Making our train move \u00b6 Now that we can enter and leave the train correctly, it's time to make it move. There are different things we need to consider for this: Who can control your vehicle? The first player to enter it, only players that have a certain \"drive\" skill, automatically? Where should it go? Can the player steer the vehicle to go somewhere else or will it always follow the same route? For our example train we're going to go with automatic movement through a predefined route (its track). The train will stop for a bit at the start and end of the route to allow players to enter and leave it. Go ahead and create some rooms for our train. Make a list of the room ids along the route (using the @ex command). @dig/tel South station @ex # note the id of the station @tunnel/tel n = Following a railroad @ex # note the id of the track @tunnel/tel n = Following a railroad ... @tunnel/tel n = North Station Put the train onto the tracks: @tel south station @tel train = here Next we will tell the train how to move and which route to take. # file typeclasses/train.py from evennia import DefaultObject, search_object from commands.train import CmdSetTrain class TrainObject(DefaultObject): def at_object_creation(self): self.cmdset.add_default(CmdSetTrain) self.db.driving = False # The direction our train is driving (1 for forward, -1 for backwards) self.db.direction = 1 # The rooms our train will pass through (change to fit your game) self.db.rooms = [\"#2\", \"#47\", \"#50\", \"#53\", \"#56\", \"#59\"] def start_driving(self): self.db.driving = True def stop_driving(self): self.db.driving = False def goto_next_room(self): currentroom = self.location.dbref idx = self.db.rooms.index(currentroom) + self.db.direction if idx < 0 or idx >= len(self.db.rooms): # We reached the end of our path self.stop_driving() # Reverse the direction of the train self.db.direction *= -1 else: roomref = self.db.rooms[idx] room = search_object(roomref)[0] self.move_to(room) self.msg_contents(\"The train is moving forward to %s.\" % (room.name, )) We added a lot of code here. Since we changed the at_object_creation to add in variables we will have to reset our train object like earlier (using the @typeclass/force/reset command). We are keeping track of a few different things now: whether the train is moving or standing still, which direction the train is heading to and what rooms the train will pass through. We also added some methods: one to start moving the train, another to stop and a third that actually moves the train to the next room in the list. Or makes it stop driving if it reaches the last stop. Let's try it out, using @py to call the new train functionality: @reload @typeclass/force/reset train = train.TrainObject enter train @py here.goto_next_room() You should see the train moving forward one step along the rail road. Adding in scripts \u00b6 If we wanted full control of the train we could now just add a command to step it along the track when desired. We want the train to move on its own though, without us having to force it by manually calling the goto_next_room method. To do this we will create two scripts : one script that runs when the train has stopped at a station and is responsible for starting the train again after a while. The other script will take care of the driving. Let's make a new file in mygame/typeclasses/trainscript.py # file mygame/typeclasses/trainscript.py from evennia import DefaultScript class TrainStoppedScript(DefaultScript): def at_script_creation(self): self.key = \"trainstopped\" self.interval = 30 self.persistent = True self.repeats = 1 self.start_delay = True def at_repeat(self): self.obj.start_driving() def at_stop(self): self.obj.scripts.add(TrainDrivingScript) class TrainDrivingScript(DefaultScript): def at_script_creation(self): self.key = \"traindriving\" self.interval = 1 self.persistent = True def is_valid(self): return self.obj.db.driving def at_repeat(self): if not self.obj.db.driving: self.stop() else: self.obj.goto_next_room() def at_stop(self): self.obj.scripts.add(TrainStoppedScript) Those scripts work as a state system: when the train is stopped, it waits for 30 seconds and then starts again. When the train is driving, it moves to the next room every second. The train is always in one of those two states - both scripts take care of adding the other one once they are done. As a last step we need to link the stopped-state script to our train, reload the game and reset our train again., and we're ready to ride it around! # file typeclasses/train.py from typeclasses.trainscript import TrainStoppedScript class TrainObject(DefaultObject): def at_object_creation(self): # ... self.scripts.add(TrainStoppedScript) @reload @typeclass/force/reset train = train.TrainObject enter train # output: < The train is moving forward to Following a railroad. < The train is moving forward to Following a railroad. < The train is moving forward to Following a railroad. ... < The train is moving forward to Following a railroad. < The train is moving forward to North station. leave train Our train will stop 30 seconds at each end station and then turn around to go back to the other end. Expanding \u00b6 This train is very basic and still has some flaws. Some more things to do: Make it look like a train. Make it impossible to exit and enter the train mid-ride. This could be made by having the enter/exit commands check so the train is not moving before allowing the caller to proceed. Have train conductor commands that can override the automatic start/stop. Allow for in-between stops between the start- and end station Have a rail road track instead of hard-coding the rooms in the train object. This could for example be a custom Exit only traversable by trains. The train will follow the track. Some track segments can split to lead to two different rooms and a player can switch the direction to which room it goes. Create another kind of vehicle!","title":"Tutorial:  Vehicles"},{"location":"Tutorial:--Vehicles.html#how-it-works","text":"Objects in Evennia have an interesting property: you can put any object inside another object. This is most obvious in rooms: a room in Evennia is just like any other game object (except rooms tend to not themselves be inside anything else). Our train will be similar: it will be an object that other objects can get inside. We then simply move the Train, which brings along everyone inside it.","title":"How it works"},{"location":"Tutorial:--Vehicles.html#creating-our-train-object","text":"The first step we need to do is create our train object, including a new typeclass. To do this, create a new file, for instance in mygame/typeclasses/train.py with the following content: # file mygame/typeclasses/train.py from evennia import DefaultObject class TrainObject(DefaultObject): def at_object_creation(self): # We'll add in code here later. pass Now we can create our train in our game: @create/drop train:train.TrainObject Now this is just an object that doesn't do much yet... but we can already force our way inside it and back (assuming we created it in limbo). @tel train @tel limbo","title":"Creating our train object"},{"location":"Tutorial:--Vehicles.html#entering-and-leaving-the-train","text":"Using the @tel command like shown above is obviously not what we want. @tel is an admin command and normal players will thus never be able to enter the train! It is also not really a good idea to use Exits to get in and out of the train - Exits are (at least by default) objects too. They point to a specific destination. If we put an Exit in this room leading inside the train it would stay here when the train moved away (still leading into the train like a magic portal!). In the same way, if we put an Exit object inside the train, it would always point back to this room, regardless of where the Train has moved. Now, one could define custom Exit types that move with the train or change their destination in the right way - but this seems to be a pretty cumbersome solution. What we will do instead is to create some new commands : one for entering the train and another for leaving it again. These will be stored on the train object and will thus be made available to whomever is either inside it or in the same room as the train. Let's create a new command module as mygame/commands/train.py : # mygame/commands/train.py from evennia import Command, CmdSet class CmdEnterTrain(Command): \"\"\" entering the train Usage: enter train This will be available to players in the same location as the train and allows them to embark. \"\"\" key = \"enter train\" locks = \"cmd:all()\" def func(self): train = self.obj self.caller.msg(\"You board the train.\") self.caller.move_to(train) class CmdLeaveTrain(Command): \"\"\" leaving the train Usage: leave train This will be available to everyone inside the train. It allows them to exit to the train's current location. \"\"\" key = \"leave train\" locks = \"cmd:all()\" def func(self): train = self.obj parent = train.location self.caller.move_to(parent) class CmdSetTrain(CmdSet): def at_cmdset_creation(self): self.add(CmdEnterTrain()) self.add(CmdLeaveTrain()) Note that while this seems like a lot of text, the majority of lines here are taken up by documentation. These commands are work in a pretty straightforward way: CmdEnterTrain moves the location of the player to inside the train and CmdLeaveTrain does the opposite: it moves the player back to the current location of the train (back outside to its current location). We stacked them in a cmdset CmdSetTrain so they can be used. To make the commands work we need to add this cmdset to our train typeclass: # file mygame/typeclasses/train.py from evennia import DefaultObject from commands.train import CmdSetTrain class TrainObject(DefaultObject): def at_object_creation(self): self.cmdset.add_default(CmdSetTrain) If we now @reload our game and reset our train, those commands should work and we can now enter and leave the train: @reload @typeclass/force/reset train = train.TrainObject enter train leave train Note the switches used with the @typeclass command: The /force switch is necessary to assign our object the same typeclass we already have. The /reset re-triggers the typeclass' at_object_creation() hook (which is otherwise only called the very first an instance is created). As seen above, when this hook is called on our train, our new cmdset will be loaded.","title":"Entering and leaving the train"},{"location":"Tutorial:--Vehicles.html#locking-down-the-commands","text":"If you have played around a bit, you've probably figured out that you can use leave train when outside the train and enter train when inside. This doesn't make any sense ... so let's go ahead and fix that. We need to tell Evennia that you can not enter the train when you're already inside or leave the train when you're outside. One solution to this is locks : we will lock down the commands so that they can only be called if the player is at the correct location. Right now commands defaults to the lock cmd:all() . The cmd lock type in combination with the all() lock function means that everyone can run those commands as long as they are in the same room as the train or inside the train. We're going to change this to check the location of the player and only allow access if they are inside the train. First of all we need to create a new lock function. Evennia comes with many lock functions built-in already, but none that we can use for locking a command in this particular case. Create a new entry in mygame/server/conf/lockfuncs.py : # file mygame/server/conf/lockfuncs.py def cmdinside(accessing_obj, accessed_obj, *args, **kwargs): \"\"\" Usage: cmdinside() Used to lock commands and only allows access if the command is defined on an object which accessing_obj is inside of. \"\"\" return accessed_obj.obj == accessing_obj.location If you didn't know, Evennia is by default set up to use all functions in this module as lock functions (there is a setting variable that points to it). Our new lock function, cmdinside , is to be used by Commands. The accessed_obj is the Command object (in our case this will be CmdEnterTrain and CmdLeaveTrain ) \u2014 Every command has an obj property: this is the the object on which the command \"sits\". Since we added those commands to our train object, the .obj property will be set to the train object. Conversely, accessing_obj is the object that called the command: in our case it's the Character trying to enter or leave the train. What this function does is to check that the player's location is the same as the train object. If it is, it means the player is inside the train. Otherwise it means the player is somewhere else and the check will fail. The next step is to actually use this new lock function to create a lock of type cmd : # file commands/train.py ... class CmdEnterTrain(Command): key = \"enter train\" locks = \"cmd:not cmdinside()\" # ... class CmdLeaveTrain(Command): key = \"leave train\" locks = \"cmd:cmdinside()\" # ... Notice how we use the not here so that we can use the same cmdinside to check if we are inside and outside, without having to create two separate lock functions. After a @reload our commands should be locked down appropriately and you should only be able to use them at the right places. Note: If you're logged in as the super user (user #1 ) then this lock will not work: the super user ignores lock functions. In order to use this functionality you need to @quell first.","title":"Locking down the commands"},{"location":"Tutorial:--Vehicles.html#making-our-train-move","text":"Now that we can enter and leave the train correctly, it's time to make it move. There are different things we need to consider for this: Who can control your vehicle? The first player to enter it, only players that have a certain \"drive\" skill, automatically? Where should it go? Can the player steer the vehicle to go somewhere else or will it always follow the same route? For our example train we're going to go with automatic movement through a predefined route (its track). The train will stop for a bit at the start and end of the route to allow players to enter and leave it. Go ahead and create some rooms for our train. Make a list of the room ids along the route (using the @ex command). @dig/tel South station @ex # note the id of the station @tunnel/tel n = Following a railroad @ex # note the id of the track @tunnel/tel n = Following a railroad ... @tunnel/tel n = North Station Put the train onto the tracks: @tel south station @tel train = here Next we will tell the train how to move and which route to take. # file typeclasses/train.py from evennia import DefaultObject, search_object from commands.train import CmdSetTrain class TrainObject(DefaultObject): def at_object_creation(self): self.cmdset.add_default(CmdSetTrain) self.db.driving = False # The direction our train is driving (1 for forward, -1 for backwards) self.db.direction = 1 # The rooms our train will pass through (change to fit your game) self.db.rooms = [\"#2\", \"#47\", \"#50\", \"#53\", \"#56\", \"#59\"] def start_driving(self): self.db.driving = True def stop_driving(self): self.db.driving = False def goto_next_room(self): currentroom = self.location.dbref idx = self.db.rooms.index(currentroom) + self.db.direction if idx < 0 or idx >= len(self.db.rooms): # We reached the end of our path self.stop_driving() # Reverse the direction of the train self.db.direction *= -1 else: roomref = self.db.rooms[idx] room = search_object(roomref)[0] self.move_to(room) self.msg_contents(\"The train is moving forward to %s.\" % (room.name, )) We added a lot of code here. Since we changed the at_object_creation to add in variables we will have to reset our train object like earlier (using the @typeclass/force/reset command). We are keeping track of a few different things now: whether the train is moving or standing still, which direction the train is heading to and what rooms the train will pass through. We also added some methods: one to start moving the train, another to stop and a third that actually moves the train to the next room in the list. Or makes it stop driving if it reaches the last stop. Let's try it out, using @py to call the new train functionality: @reload @typeclass/force/reset train = train.TrainObject enter train @py here.goto_next_room() You should see the train moving forward one step along the rail road.","title":"Making our train move"},{"location":"Tutorial:--Vehicles.html#adding-in-scripts","text":"If we wanted full control of the train we could now just add a command to step it along the track when desired. We want the train to move on its own though, without us having to force it by manually calling the goto_next_room method. To do this we will create two scripts : one script that runs when the train has stopped at a station and is responsible for starting the train again after a while. The other script will take care of the driving. Let's make a new file in mygame/typeclasses/trainscript.py # file mygame/typeclasses/trainscript.py from evennia import DefaultScript class TrainStoppedScript(DefaultScript): def at_script_creation(self): self.key = \"trainstopped\" self.interval = 30 self.persistent = True self.repeats = 1 self.start_delay = True def at_repeat(self): self.obj.start_driving() def at_stop(self): self.obj.scripts.add(TrainDrivingScript) class TrainDrivingScript(DefaultScript): def at_script_creation(self): self.key = \"traindriving\" self.interval = 1 self.persistent = True def is_valid(self): return self.obj.db.driving def at_repeat(self): if not self.obj.db.driving: self.stop() else: self.obj.goto_next_room() def at_stop(self): self.obj.scripts.add(TrainStoppedScript) Those scripts work as a state system: when the train is stopped, it waits for 30 seconds and then starts again. When the train is driving, it moves to the next room every second. The train is always in one of those two states - both scripts take care of adding the other one once they are done. As a last step we need to link the stopped-state script to our train, reload the game and reset our train again., and we're ready to ride it around! # file typeclasses/train.py from typeclasses.trainscript import TrainStoppedScript class TrainObject(DefaultObject): def at_object_creation(self): # ... self.scripts.add(TrainStoppedScript) @reload @typeclass/force/reset train = train.TrainObject enter train # output: < The train is moving forward to Following a railroad. < The train is moving forward to Following a railroad. < The train is moving forward to Following a railroad. ... < The train is moving forward to Following a railroad. < The train is moving forward to North station. leave train Our train will stop 30 seconds at each end station and then turn around to go back to the other end.","title":"Adding in scripts"},{"location":"Tutorial:--Vehicles.html#expanding","text":"This train is very basic and still has some flaws. Some more things to do: Make it look like a train. Make it impossible to exit and enter the train mid-ride. This could be made by having the enter/exit commands check so the train is not moving before allowing the caller to proceed. Have train conductor commands that can override the automatic start/stop. Allow for in-between stops between the start- and end station Have a rail road track instead of hard-coding the rooms in the train object. This could for example be a custom Exit only traversable by trains. The train will follow the track. Some track segments can split to lead to two different rooms and a player can switch the direction to which room it goes. Create another kind of vehicle!","title":"Expanding"},{"location":"Tutorial:-Searching-For-Objects.html","text":"You will often want to operate on a specific object in the database. For example when a player attacks a named target you'll need to find that target so it can be attacked. Or when a rain storm draws in you need to find all outdoor-rooms so you can show it raining in them. This tutorial explains Evennia's tools for searching. Things to search for \u00b6 The first thing to consider is the base type of the thing you are searching for. Evennia organizes its database into a few main tables: Objects , Accounts , Scripts , Channels , Messages and Help Entries . Most of the time you'll likely spend your time searching for Objects and the occasional Accounts. So to find an entity, what can be searched for? The key is the name of the entity. While you can get this from obj.key the database field is actually named obj.db_key - this is useful to know only when you do direct database queries . The one exception is Accounts , where the database field for .key is instead named username (this is a Django requirement). When you don't specify search-type, you'll usually search based on key. Aliases are extra names given to Objects using something like @alias or obj.aliases.add('name') . The main search functions (see below) will automatically search for aliases whenever you search by-key. Tags are the main way to group and identify objects in Evennia. Tags can most often be used (sometimes together with keys) to uniquely identify an object. For example, even though you have two locations with the same name, you can separate them by their tagging (this is how Evennia implements 'zones' seen in other systems). Tags can also have categories, to further organize your data for quick lookups. An object's Attributes can also used to find an object. This can be very useful but since Attributes can store almost any data they are far less optimized to search for than Tags or keys. The object's Typeclass indicate the sub-type of entity. A Character, Flower or Sword are all types of Objects. A Bot is a kind of Account. The database field is called typeclass_path and holds the full Python-path to the class. You can usually specify the typeclass as an argument to Evennia's search functions as well as use the class directly to limit queries. The location is only relevant for Objects but is a very common way to weed down the number of candidates before starting to search. The reason is that most in-game commands tend to operate on things nearby (in the same room) so the choices can be limited from the start. The database id or the '#dbref' is unique (and never re-used) within each database table. So while there is one and only one Object with dbref #42 there could also be an Account or Script with the dbref #42 at the same time. In almost all search methods you can replace the \"key\" search criterion with \"#dbref\" to search for that id. This can occasionally be practical and may be what you are used to from other code bases. But it is considered bad practice in Evennia to rely on hard-coded #dbrefs to do your searches. It makes your code tied to the exact layout of the database. It's also not very maintainable to have to remember abstract numbers. Passing the actual objects around and searching by Tags and/or keys will usually get you what you need. Getting objects inside another \u00b6 All in-game Objects have a .contents property that returns all objects 'inside' them (that is, all objects which has its .location property set to that object. This is a simple way to get everything in a room and is also faster since this lookup is cached and won't hit the database. roomobj.contents returns a list of all objects inside roomobj . obj.contents same as for a room, except this usually represents the object's inventory obj.location.contents gets everything in obj 's location (including obj itself). roomobj.exits returns all exits starting from roomobj (Exits are here defined as Objects with their destination field set). obj.location.contents_get(exclude=obj) - this helper method returns all objects in obj 's location except obj . Searching using Object.search \u00b6 Say you have a command , and you want it to do something to a target. You might be wondering how you retrieve that target in code, and that's where Evennia's search utilities come in. In the most common case, you'll often use the search method of the Object or Account typeclasses. In a command, the .caller property will refer back to the object using the command (usually a Character , which is a type of Object ) while .args will contain Command's arguments: # e.g. in file mygame/commands/command.py from evennia import default_cmds class CmdPoke(default_cmds.MuxCommand): \"\"\" Pokes someone. Usage: poke <target> \"\"\" key = \"poke\" def func(self): \"\"\"Executes poke command\"\"\" target = self.caller.search(self.args) if not target: # we didn't find anyone, but search has already let the # caller know. We'll just return, since we're done return # we found a target! we'll do stuff to them. target.msg(\"You have been poked by %s.\" % self.caller) self.caller.msg(\"You have poked %s.\" % target) By default, the search method of a Character will attempt to find a unique object match for the string sent to it ( self.args , in this case, which is the arguments passed to the command by the player) in the surroundings of the Character - the room or their inventory. If there is no match found, the return value (which is assigned to target ) will be None , and an appropriate failure message will be sent to the Character. If there's not a unique match, None will again be returned, and a different error message will be sent asking them to disambiguate the multi-match. By default, the user can then pick out a specific match using with a number and dash preceding the name of the object: character.search(\"2-pink unicorn\") will try to find the second pink unicorn in the room. The search method has many arguments that allow you to refine the search, such as by designating the location to search in or only matching specific typeclasses. Searching using utils.search \u00b6 Sometimes you will want to find something that isn't tied to the search methods of a character or account. In these cases, Evennia provides a utility module with a number of search functions . For example, suppose you want a command that will find and display all the rooms that are tagged as a 'hangout', for people to gather by. Here's a simple Command to do this: # e.g. in file mygame/commands/command.py from evennia import default_cmds from evennia.utils.search import search_tag class CmdListHangouts(default_cmds.MuxCommand): \"\"\"Lists hangouts\"\"\" key = \"hangouts\" def func(self): \"\"\"Executes 'hangouts' command\"\"\" hangouts = search_tag(key=\"hangout\", category=\"location tags\") self.caller.msg(\"Hangouts available: {}\".format( \", \".join(str(ob) for ob in hangouts))) This uses the search_tag function to find all objects previously tagged with Tags \"hangout\" and with category \"location tags\". Other important search methods in utils.search are search_object search_account search_scripts search_channel search_message search_help search_tag - find Objects with a given Tag. search_account_tag - find Accounts with a given Tag. search_script_tag - find Scripts with a given Tag. search_channel_tag - find Channels with a given Tag. search_object_attribute - find Objects with a given Attribute. search_account_attribute - find Accounts with a given Attribute. search_attribute_object - this returns the actual Attribute, not the object it sits on. Note: All search functions return a Django queryset which is technically a list-like representation of the database-query it's about to do. Only when you convert it to a real list, loop over it or try to slice or access any of its contents will the datbase-lookup happen. This means you could yourself customize the query further if you know what you are doing (see the next section). Queries in Django \u00b6 This is an advanced topic. Evennia's search methods should be sufficient for the vast majority of situations. But eventually you might find yourself trying to figure out how to get searches for unusual circumstances: Maybe you want to find all characters who are not in rooms tagged as hangouts and have the lycanthrope tag and whose names start with a vowel, but not with 'Ab', and only if they have 3 or more objects in their inventory ... You could in principle use one of the earlier search methods to find all candidates and then loop over them with a lot of if statements in raw Python. But you can do this much more efficiently by querying the database directly. Enter django's querysets . A QuerySet is the representation of a database query and can be modified as desired. Only once one tries to retrieve the data of that query is it evaluated and does an actual database request. This is useful because it means you can modify a query as much as you want (even pass it around) and only hit the database once you are happy with it. Evennia's search functions are themselves an even higher level wrapper around Django's queries, and many search methods return querysets. That means that you could get the result from a search function and modify the resulting query to your own ends to further tweak what you search for. Evaluated querysets can either contain objects such as Character objects, or lists of values derived from the objects. Queries usually use the 'manager' object of a class, which by convention is the .objects attribute of a class. For example, a query of Accounts that contain the letter 'a' could be: from typeclasses.accounts import Account queryset = Account.objects.filter(username__contains='a') The filter method of a manager takes arguments that allow you to define the query, and you can continue to refine the query by calling additional methods until you evaluate the queryset, causing the query to be executed and return a result. For example, if you have the result above, you could, without causing the queryset to be evaluated yet, get rid of matches that contain the letter 'e by doing this: queryset = result.exclude(username__contains='e') You could also have chained .exclude directly to the end of the previous line. Once you try to access the result, the queryset will be evaluated automatically under the hood: accounts = list(queryset) # this fills list with matches for account in queryset: # do something with account accounts = queryset[:4] # get first four matches account = queryset[0] # get first match # etc Limiting by typeclass \u00b6 Although Character s, Exit s, Room s, and other children of DefaultObject all shares the same underlying database table, Evennia provides a shortcut to do more specific queries only for those typeclasses. For example, to find only Character s whose names start with 'A', you might do: Character.objects.filter(db_key__startswith=\"A\") If Character has a subclass Npc and you wanted to find only Npc's you'd instead do Npc.objects.filter(db_key__startswith=\"A\") If you wanted to search both Characters and all its subclasses (like Npc) you use the *_family method which is added by Evennia: Character.objects.filter_family(db_key__startswith=\"A\") The higher up in the inheritance hierarchy you go the more objects will be included in these searches. There is one special case, if you really want to include everything from a given database table. You do that by searching on the database model itself. These are named ObjectDB , AccountDB , ScriptDB etc. from evennia import AccountDB # all Accounts in the database, regardless of typeclass all = AccountDB.objects.all() Here are the most commonly used methods to use with the objects managers: filter - query for a listing of objects based on search criteria. Gives empty queryset if none were found. get - query for a single match - raises exception if none were found, or more than one was found. all - get all instances of the particular type. filter_family - like filter , but search all sub classes as well. get_family - like get , but search all sub classes as well. all_family - like all , but return entities of all subclasses as well. Multiple conditions \u00b6 If you pass more than one keyword argument to a query method, the query becomes an AND relationship. For example, if we want to find characters whose names start with \"A\" and are also werewolves (have the lycanthrope tag), we might do: queryset = Character.objects.filter(db_key__startswith=\"A\", db_tags__db_key=\"lycanthrope\")` To exclude lycanthropes currently in rooms tagged as hangouts, we might tack on an .exclude as before: queryset = quersyet.exclude(db_location__db_tags__db_key=\"hangout\")`. Note the syntax of the keywords in building the queryset. For example, db_location is the name of the database field sitting on (in this case) the Character (Object). Double underscore __ works like dot-notation in normal Python (it's used since dots are not allowed in keyword names). So the instruction db_location__db_tags__db_key=\"hangout\" should be read as such: \"On the Character object ... (this comes from us building this queryset using the Character.objects manager) ... get the value of the db_location field ... (this references a Room object, normally) ... on that location, get the value of the db_tags field ... (this is a many-to-many field that can be treated like an object for this purpose. It references all tags on the location) ... through the db_tag manager, find all Tags having a field db_key set to the value \"hangout\".\" This may seem a little complex at first, but this syntax will work the same for all queries. Just remember that all database-fields in Evennia are prefaced with db_ . So even though Evennia is nice enough to alias the db_key field so you can normally just do char.key to get a character's name, the database field is actually called db_key and the real name must be used for the purpose of building a query. Don't confuse database fields with Attributes you set via obj.db.attr = 'foo' or obj.attributes.add() . Attributes are custom database entities linked to an object. They are not separate fields on that object like db_key or db_location are. You can get attached Attributes manually through the db_attributes many-to-many field in the same way as db_tags above. Complex queries \u00b6 What if you want to have a query with with OR conditions or negated requirements ( NOT )? Enter Django's Complex Query object, Q . Q() objects take a normal django keyword query as its arguments. The special thing is that these Q objects can then be chained together with set operations: | for OR, & for AND, and preceded with ~ for NOT to build a combined, complex query. In our original Lycanthrope example we wanted our werewolves to have names that could start with any vowel except for the specific beginning \"ab\". from django.db.models import Q from typeclasses.characters import Character query = Q() for letter in (\"aeiouy\"): query |= Q(db_key__istartswith=letter) query &= ~Q(db_key__istartswith=\"ab\") query = Character.objects.filter(query) list_of_lycanthropes = list(query) In the above example, we construct our query our of several Q objects that each represent one part of the query. We iterate over the list of vowels, and add an OR condition to the query using |= (this is the same idea as using += which may be more familiar). Each OR condition checks that the name starts with one of the valid vowels. Afterwards, we add (using &= ) an AND condition that is negated with the ~ symbol. In other words we require that any match should not start with the string \"ab\". Note that we don't actually hit the database until we convert the query to a list at the end (we didn't need to do that either, but could just have kept the query until we needed to do something with the matches). Annotations and F objects \u00b6 What if we wanted to filter on some condition that isn't represented easily by a field on the object? Maybe we want to find rooms only containing five or more objects? We could retrieve all interesting candidates and run them through a for-loop to get and count their .content properties. We'd then just return a list of only those objects with enough contents. It would look something like this (note: don't actually do this!): # probably not a good idea to do it this way from typeclasses.rooms import Room queryset = Room.objects.all() # get all Rooms rooms = [room for room in queryset if len(room.contents) >= 5] Once the number of rooms in your game increases, this could become quite expensive. Additionally, in some particular contexts, like when using the web features of Evennia, you must have the result as a queryset in order to use it in operations, such as in Django's admin interface when creating list filters. Enter F objects and annotations . So-called F expressions allow you to do a query that looks at a value of each object in the database, while annotations allow you to calculate and attach a value to a query. So, let's do the same example as before directly in the database: from typeclasses.rooms import Room from django.db.models import Count room_count = Room.objects.annotate(num_objects=Count('locations_set')) queryset = room_count.filter(num_objects__gte=5) rooms = (Room.objects.annotate(num_objects=Count('locations_set')) .filter(num_objects__gte=5)) rooms = list(rooms) Here we first create an annotation num_objects of type Count , which is a Django class. Note that use of location_set in that Count . The *_set is a back-reference automatically created by Django. In this case it allows you to find all objects that has the current object as location . Once we have those, they are counted. Next we filter on this annotation, using the name num_objects as something we can filter for. We use num_objects__gte=5 which means that num_objects should be greater than 5. This is a little harder to get one's head around but much more efficient than lopping over all objects in Python. What if we wanted to compare two parameters against one another in a query? For example, what if instead of having 5 or more objects, we only wanted objects that had a bigger inventory than they had tags? Here an F-object comes in handy: from django.db.models import Count, F from typeclasses.rooms import Room result = (Room.objects.annotate(num_objects=Count('locations_set'), num_tags=Count('db_tags')) .filter(num_objects__gt=F('num_tags'))) F-objects allows for wrapping an annotated structure on the right-hand-side of the expression. It will be evaluated on-the-fly as needed. Grouping By and Values \u00b6 Suppose you used tags to mark someone belonging an organization. Now you want to make a list and need to get the membership count of every organization all at once. That's where annotations and the .values_list queryset method come in. Values/Values Lists are an alternate way of returning a queryset - instead of objects, you get a list of dicts or tuples that hold selected properties from the the matches. It also allows you a way to 'group up' queries for returning information. For example, to get a display about each tag per Character and the names of the tag: result = (Character.objects.filter(db_tags__db_category=\"organization\") .values_list('db_tags__db_key') .annotate(cnt=Count('id')) .order_by('-cnt')) The result queryset will be a list of tuples ordered in descending order by the number of matches, in a format like the following: ``` [('Griatch Fanclub', 3872), (\"Chainsol's Ainneve Testers\", 2076), (\"Blaufeuer's Whitespace Fixers\", 1903), (\"Volund's Bikeshed Design Crew\", 1764), (\"Tehom's Misanthropes\", 1)]","title":"Tutorial: Searching For Objects"},{"location":"Tutorial:-Searching-For-Objects.html#things-to-search-for","text":"The first thing to consider is the base type of the thing you are searching for. Evennia organizes its database into a few main tables: Objects , Accounts , Scripts , Channels , Messages and Help Entries . Most of the time you'll likely spend your time searching for Objects and the occasional Accounts. So to find an entity, what can be searched for? The key is the name of the entity. While you can get this from obj.key the database field is actually named obj.db_key - this is useful to know only when you do direct database queries . The one exception is Accounts , where the database field for .key is instead named username (this is a Django requirement). When you don't specify search-type, you'll usually search based on key. Aliases are extra names given to Objects using something like @alias or obj.aliases.add('name') . The main search functions (see below) will automatically search for aliases whenever you search by-key. Tags are the main way to group and identify objects in Evennia. Tags can most often be used (sometimes together with keys) to uniquely identify an object. For example, even though you have two locations with the same name, you can separate them by their tagging (this is how Evennia implements 'zones' seen in other systems). Tags can also have categories, to further organize your data for quick lookups. An object's Attributes can also used to find an object. This can be very useful but since Attributes can store almost any data they are far less optimized to search for than Tags or keys. The object's Typeclass indicate the sub-type of entity. A Character, Flower or Sword are all types of Objects. A Bot is a kind of Account. The database field is called typeclass_path and holds the full Python-path to the class. You can usually specify the typeclass as an argument to Evennia's search functions as well as use the class directly to limit queries. The location is only relevant for Objects but is a very common way to weed down the number of candidates before starting to search. The reason is that most in-game commands tend to operate on things nearby (in the same room) so the choices can be limited from the start. The database id or the '#dbref' is unique (and never re-used) within each database table. So while there is one and only one Object with dbref #42 there could also be an Account or Script with the dbref #42 at the same time. In almost all search methods you can replace the \"key\" search criterion with \"#dbref\" to search for that id. This can occasionally be practical and may be what you are used to from other code bases. But it is considered bad practice in Evennia to rely on hard-coded #dbrefs to do your searches. It makes your code tied to the exact layout of the database. It's also not very maintainable to have to remember abstract numbers. Passing the actual objects around and searching by Tags and/or keys will usually get you what you need.","title":"Things to search for"},{"location":"Tutorial:-Searching-For-Objects.html#getting-objects-inside-another","text":"All in-game Objects have a .contents property that returns all objects 'inside' them (that is, all objects which has its .location property set to that object. This is a simple way to get everything in a room and is also faster since this lookup is cached and won't hit the database. roomobj.contents returns a list of all objects inside roomobj . obj.contents same as for a room, except this usually represents the object's inventory obj.location.contents gets everything in obj 's location (including obj itself). roomobj.exits returns all exits starting from roomobj (Exits are here defined as Objects with their destination field set). obj.location.contents_get(exclude=obj) - this helper method returns all objects in obj 's location except obj .","title":"Getting objects inside another"},{"location":"Tutorial:-Searching-For-Objects.html#searching-using-objectsearch","text":"Say you have a command , and you want it to do something to a target. You might be wondering how you retrieve that target in code, and that's where Evennia's search utilities come in. In the most common case, you'll often use the search method of the Object or Account typeclasses. In a command, the .caller property will refer back to the object using the command (usually a Character , which is a type of Object ) while .args will contain Command's arguments: # e.g. in file mygame/commands/command.py from evennia import default_cmds class CmdPoke(default_cmds.MuxCommand): \"\"\" Pokes someone. Usage: poke <target> \"\"\" key = \"poke\" def func(self): \"\"\"Executes poke command\"\"\" target = self.caller.search(self.args) if not target: # we didn't find anyone, but search has already let the # caller know. We'll just return, since we're done return # we found a target! we'll do stuff to them. target.msg(\"You have been poked by %s.\" % self.caller) self.caller.msg(\"You have poked %s.\" % target) By default, the search method of a Character will attempt to find a unique object match for the string sent to it ( self.args , in this case, which is the arguments passed to the command by the player) in the surroundings of the Character - the room or their inventory. If there is no match found, the return value (which is assigned to target ) will be None , and an appropriate failure message will be sent to the Character. If there's not a unique match, None will again be returned, and a different error message will be sent asking them to disambiguate the multi-match. By default, the user can then pick out a specific match using with a number and dash preceding the name of the object: character.search(\"2-pink unicorn\") will try to find the second pink unicorn in the room. The search method has many arguments that allow you to refine the search, such as by designating the location to search in or only matching specific typeclasses.","title":"Searching using Object.search"},{"location":"Tutorial:-Searching-For-Objects.html#searching-using-utilssearch","text":"Sometimes you will want to find something that isn't tied to the search methods of a character or account. In these cases, Evennia provides a utility module with a number of search functions . For example, suppose you want a command that will find and display all the rooms that are tagged as a 'hangout', for people to gather by. Here's a simple Command to do this: # e.g. in file mygame/commands/command.py from evennia import default_cmds from evennia.utils.search import search_tag class CmdListHangouts(default_cmds.MuxCommand): \"\"\"Lists hangouts\"\"\" key = \"hangouts\" def func(self): \"\"\"Executes 'hangouts' command\"\"\" hangouts = search_tag(key=\"hangout\", category=\"location tags\") self.caller.msg(\"Hangouts available: {}\".format( \", \".join(str(ob) for ob in hangouts))) This uses the search_tag function to find all objects previously tagged with Tags \"hangout\" and with category \"location tags\". Other important search methods in utils.search are search_object search_account search_scripts search_channel search_message search_help search_tag - find Objects with a given Tag. search_account_tag - find Accounts with a given Tag. search_script_tag - find Scripts with a given Tag. search_channel_tag - find Channels with a given Tag. search_object_attribute - find Objects with a given Attribute. search_account_attribute - find Accounts with a given Attribute. search_attribute_object - this returns the actual Attribute, not the object it sits on. Note: All search functions return a Django queryset which is technically a list-like representation of the database-query it's about to do. Only when you convert it to a real list, loop over it or try to slice or access any of its contents will the datbase-lookup happen. This means you could yourself customize the query further if you know what you are doing (see the next section).","title":"Searching using utils.search"},{"location":"Tutorial:-Searching-For-Objects.html#queries-in-django","text":"This is an advanced topic. Evennia's search methods should be sufficient for the vast majority of situations. But eventually you might find yourself trying to figure out how to get searches for unusual circumstances: Maybe you want to find all characters who are not in rooms tagged as hangouts and have the lycanthrope tag and whose names start with a vowel, but not with 'Ab', and only if they have 3 or more objects in their inventory ... You could in principle use one of the earlier search methods to find all candidates and then loop over them with a lot of if statements in raw Python. But you can do this much more efficiently by querying the database directly. Enter django's querysets . A QuerySet is the representation of a database query and can be modified as desired. Only once one tries to retrieve the data of that query is it evaluated and does an actual database request. This is useful because it means you can modify a query as much as you want (even pass it around) and only hit the database once you are happy with it. Evennia's search functions are themselves an even higher level wrapper around Django's queries, and many search methods return querysets. That means that you could get the result from a search function and modify the resulting query to your own ends to further tweak what you search for. Evaluated querysets can either contain objects such as Character objects, or lists of values derived from the objects. Queries usually use the 'manager' object of a class, which by convention is the .objects attribute of a class. For example, a query of Accounts that contain the letter 'a' could be: from typeclasses.accounts import Account queryset = Account.objects.filter(username__contains='a') The filter method of a manager takes arguments that allow you to define the query, and you can continue to refine the query by calling additional methods until you evaluate the queryset, causing the query to be executed and return a result. For example, if you have the result above, you could, without causing the queryset to be evaluated yet, get rid of matches that contain the letter 'e by doing this: queryset = result.exclude(username__contains='e') You could also have chained .exclude directly to the end of the previous line. Once you try to access the result, the queryset will be evaluated automatically under the hood: accounts = list(queryset) # this fills list with matches for account in queryset: # do something with account accounts = queryset[:4] # get first four matches account = queryset[0] # get first match # etc","title":"Queries in Django"},{"location":"Tutorial:-Searching-For-Objects.html#limiting-by-typeclass","text":"Although Character s, Exit s, Room s, and other children of DefaultObject all shares the same underlying database table, Evennia provides a shortcut to do more specific queries only for those typeclasses. For example, to find only Character s whose names start with 'A', you might do: Character.objects.filter(db_key__startswith=\"A\") If Character has a subclass Npc and you wanted to find only Npc's you'd instead do Npc.objects.filter(db_key__startswith=\"A\") If you wanted to search both Characters and all its subclasses (like Npc) you use the *_family method which is added by Evennia: Character.objects.filter_family(db_key__startswith=\"A\") The higher up in the inheritance hierarchy you go the more objects will be included in these searches. There is one special case, if you really want to include everything from a given database table. You do that by searching on the database model itself. These are named ObjectDB , AccountDB , ScriptDB etc. from evennia import AccountDB # all Accounts in the database, regardless of typeclass all = AccountDB.objects.all() Here are the most commonly used methods to use with the objects managers: filter - query for a listing of objects based on search criteria. Gives empty queryset if none were found. get - query for a single match - raises exception if none were found, or more than one was found. all - get all instances of the particular type. filter_family - like filter , but search all sub classes as well. get_family - like get , but search all sub classes as well. all_family - like all , but return entities of all subclasses as well.","title":"Limiting by typeclass"},{"location":"Tutorial:-Searching-For-Objects.html#multiple-conditions","text":"If you pass more than one keyword argument to a query method, the query becomes an AND relationship. For example, if we want to find characters whose names start with \"A\" and are also werewolves (have the lycanthrope tag), we might do: queryset = Character.objects.filter(db_key__startswith=\"A\", db_tags__db_key=\"lycanthrope\")` To exclude lycanthropes currently in rooms tagged as hangouts, we might tack on an .exclude as before: queryset = quersyet.exclude(db_location__db_tags__db_key=\"hangout\")`. Note the syntax of the keywords in building the queryset. For example, db_location is the name of the database field sitting on (in this case) the Character (Object). Double underscore __ works like dot-notation in normal Python (it's used since dots are not allowed in keyword names). So the instruction db_location__db_tags__db_key=\"hangout\" should be read as such: \"On the Character object ... (this comes from us building this queryset using the Character.objects manager) ... get the value of the db_location field ... (this references a Room object, normally) ... on that location, get the value of the db_tags field ... (this is a many-to-many field that can be treated like an object for this purpose. It references all tags on the location) ... through the db_tag manager, find all Tags having a field db_key set to the value \"hangout\".\" This may seem a little complex at first, but this syntax will work the same for all queries. Just remember that all database-fields in Evennia are prefaced with db_ . So even though Evennia is nice enough to alias the db_key field so you can normally just do char.key to get a character's name, the database field is actually called db_key and the real name must be used for the purpose of building a query. Don't confuse database fields with Attributes you set via obj.db.attr = 'foo' or obj.attributes.add() . Attributes are custom database entities linked to an object. They are not separate fields on that object like db_key or db_location are. You can get attached Attributes manually through the db_attributes many-to-many field in the same way as db_tags above.","title":"Multiple conditions"},{"location":"Tutorial:-Searching-For-Objects.html#complex-queries","text":"What if you want to have a query with with OR conditions or negated requirements ( NOT )? Enter Django's Complex Query object, Q . Q() objects take a normal django keyword query as its arguments. The special thing is that these Q objects can then be chained together with set operations: | for OR, & for AND, and preceded with ~ for NOT to build a combined, complex query. In our original Lycanthrope example we wanted our werewolves to have names that could start with any vowel except for the specific beginning \"ab\". from django.db.models import Q from typeclasses.characters import Character query = Q() for letter in (\"aeiouy\"): query |= Q(db_key__istartswith=letter) query &= ~Q(db_key__istartswith=\"ab\") query = Character.objects.filter(query) list_of_lycanthropes = list(query) In the above example, we construct our query our of several Q objects that each represent one part of the query. We iterate over the list of vowels, and add an OR condition to the query using |= (this is the same idea as using += which may be more familiar). Each OR condition checks that the name starts with one of the valid vowels. Afterwards, we add (using &= ) an AND condition that is negated with the ~ symbol. In other words we require that any match should not start with the string \"ab\". Note that we don't actually hit the database until we convert the query to a list at the end (we didn't need to do that either, but could just have kept the query until we needed to do something with the matches).","title":"Complex queries"},{"location":"Tutorial:-Searching-For-Objects.html#annotations-and-f-objects","text":"What if we wanted to filter on some condition that isn't represented easily by a field on the object? Maybe we want to find rooms only containing five or more objects? We could retrieve all interesting candidates and run them through a for-loop to get and count their .content properties. We'd then just return a list of only those objects with enough contents. It would look something like this (note: don't actually do this!): # probably not a good idea to do it this way from typeclasses.rooms import Room queryset = Room.objects.all() # get all Rooms rooms = [room for room in queryset if len(room.contents) >= 5] Once the number of rooms in your game increases, this could become quite expensive. Additionally, in some particular contexts, like when using the web features of Evennia, you must have the result as a queryset in order to use it in operations, such as in Django's admin interface when creating list filters. Enter F objects and annotations . So-called F expressions allow you to do a query that looks at a value of each object in the database, while annotations allow you to calculate and attach a value to a query. So, let's do the same example as before directly in the database: from typeclasses.rooms import Room from django.db.models import Count room_count = Room.objects.annotate(num_objects=Count('locations_set')) queryset = room_count.filter(num_objects__gte=5) rooms = (Room.objects.annotate(num_objects=Count('locations_set')) .filter(num_objects__gte=5)) rooms = list(rooms) Here we first create an annotation num_objects of type Count , which is a Django class. Note that use of location_set in that Count . The *_set is a back-reference automatically created by Django. In this case it allows you to find all objects that has the current object as location . Once we have those, they are counted. Next we filter on this annotation, using the name num_objects as something we can filter for. We use num_objects__gte=5 which means that num_objects should be greater than 5. This is a little harder to get one's head around but much more efficient than lopping over all objects in Python. What if we wanted to compare two parameters against one another in a query? For example, what if instead of having 5 or more objects, we only wanted objects that had a bigger inventory than they had tags? Here an F-object comes in handy: from django.db.models import Count, F from typeclasses.rooms import Room result = (Room.objects.annotate(num_objects=Count('locations_set'), num_tags=Count('db_tags')) .filter(num_objects__gt=F('num_tags'))) F-objects allows for wrapping an annotated structure on the right-hand-side of the expression. It will be evaluated on-the-fly as needed.","title":"Annotations and F objects"},{"location":"Tutorial:-Searching-For-Objects.html#grouping-by-and-values","text":"Suppose you used tags to mark someone belonging an organization. Now you want to make a list and need to get the membership count of every organization all at once. That's where annotations and the .values_list queryset method come in. Values/Values Lists are an alternate way of returning a queryset - instead of objects, you get a list of dicts or tuples that hold selected properties from the the matches. It also allows you a way to 'group up' queries for returning information. For example, to get a display about each tag per Character and the names of the tag: result = (Character.objects.filter(db_tags__db_category=\"organization\") .values_list('db_tags__db_key') .annotate(cnt=Count('id')) .order_by('-cnt')) The result queryset will be a list of tuples ordered in descending order by the number of matches, in a format like the following: ``` [('Griatch Fanclub', 3872), (\"Chainsol's Ainneve Testers\", 2076), (\"Blaufeuer's Whitespace Fixers\", 1903), (\"Volund's Bikeshed Design Crew\", 1764), (\"Tehom's Misanthropes\", 1)]","title":"Grouping By and Values"},{"location":"Tutorial:-Tweeting-Game-Stats.html","text":"This tutorial will create a simple script that will send a tweet to your already configured twitter account. Please see: How to connect Evennia to Twitter if you haven't already done so. The script could be expanded to cover a variety of statistics you might wish to tweet about regularly, from player deaths to how much currency is in the economy etc. # evennia/typeclasses/tweet_stats.py import twitter from random import randint from django.conf import settings from evennia import ObjectDB from evennia import spawner from evennia import logger from evennia import DefaultScript class TweetStats(DefaultScript): \"\"\" This implements the tweeting of stats to a registered twitter account \"\"\" # standard Script hooks def at_script_creation(self): \"Called when script is first created\" self.key = \"tweet_stats\" self.desc = \"Tweets interesting stats about the game\" self.interval = 86400 # 1 day timeout self.start_delay = False def at_repeat(self): \"\"\" This is called every self.interval seconds to tweet interesting stats about the game. \"\"\" api = twitter.Api(consumer_key='consumer_key', consumer_secret='consumer_secret', access_token_key='access_token_key', access_token_secret='access_token_secret') number_tweet_outputs = 2 tweet_output = randint(1, number_tweet_outputs) if tweet_output == 1: ##Game Chars, Rooms, Objects taken from @stats command nobjs = ObjectDB.objects.count() base_char_typeclass = settings.BASE_CHARACTER_TYPECLASS nchars = ObjectDB.objects.filter(db_typeclass_path=base_char_typeclass).count() nrooms = ObjectDB.objects.filter(db_location__isnull=True).exclude(db_typeclass_path=base_char_typeclass).count() nexits = ObjectDB.objects.filter(db_location__isnull=False, db_destination__isnull=False).count() nother = nobjs - nchars - nrooms - nexits tweet = \"Chars: %s, Rooms: %s, Objects: %s\" %(nchars, nrooms, nother) else: if tweet_output == 2: ##Number of prototypes and 3 random keys - taken from @spawn command prototypes = spawner.spawn(return_prototypes=True) keys = prototypes.keys() nprots = len(prototypes) tweet = \"Prototype Count: %s Random Keys: \" % nprots tweet += \" %s\" % keys[randint(0,len(keys)-1)] for x in range(0,2): ##tweet 3 tweet += \", %s\" % keys[randint(0,len(keys)-1)] # post the tweet try: response = api.PostUpdate(tweet) except: logger.log_trace(\"Tweet Error: When attempting to tweet %s\" % tweet) In the at_script_creation method, we configure the script to fire immediately (useful for testing) and setup the delay (1 day) as well as script information seen when you use @scripts In the at_repeat method (which is called immediately and then at interval seconds later) we setup the Twitter API (just like in the initial configuration of twitter). numberTweetOutputs is used to show how many different types of outputs we have (in this case 2). We then build the tweet based on randomly choosing between these outputs. Shows the number of Player Characters, Rooms and Other/Objects Shows the number of prototypes currently in the game and then selects 3 random keys to show Scripts Information will show you how to add it as a Global script, however, for testing it may be useful to start/stop it quickly from within the game. Assuming that you create the file as mygame/typeclasses/tweet_stats.py it can be started by using the following command @script Here = tweet_stats.TweetStats","title":"Tutorial: Tweeting Game Stats"},{"location":"Tutorials.html","text":"Before continuing to read these tutorials (and especially before you start to code or build your game in earnest) it's strongly recommended that you read the Evennia coding introduction as well as the Planning your own game pages first. Please note that it's not within the scope of our tutorials to teach you basic Python. If you are new to the language, expect to have to look up concepts you are unfamiliar with. Usually a quick internet search will give you all info you need. Furthermore, our tutorials tend to focus on implementation and concepts. As such they give only brief explanations to use Evennia features while providing ample links to the relevant detailed documentation. The main information resource for builders is the Builder Documentation . Coders should refer to the Developer Central for further information. Building \u00b6 Help with populating your game world. Tutorial: Building Quick-start - helps you build your first rocks and crates using Evennia's defaults. Tutorial: Understanding Color Tags - explains how you color your game's text. Introduction: The Tutorial World - this introduces the full (if small) solo-adventure game that comes with the Evennia distribution. It is useful both as an example of building and of coding. Tutorial: Building a Giant Mech - this starts as a building tutorial and transitions into writing code. General Development tutorials \u00b6 General code practices for newbie game developers. To use Evennia, you will need basic understanding of Python modules , variables , conditional statements , loops , functions , lists, dictionaries, list comprehensions and string formatting . You should also have a basic understanding of object-oriented programming and what Python Classes are. Python tutorials for beginners - external link with tutorials for those not familiar with coding in general or Python in particular. Tutorial: Version Control - use GIT to organize your code both for your own game project and for contributing to Evennia. MIT offers free courses in many subjects. Their Introduction to Computer Science and Programming uses Python as its language of choice. Longer path, but more in-depth. Definitely worth a look. Coding - First Step tutorials \u00b6 Starting tutorials for you who are new to developing with Evennia. Python basic introduction (part 1) - Python intro using Evennia. Python basic introduction (part 2) - More on objects, classes and finding where things are. Tutorial: First Steps Coding - learn each basic feature on their own through step-by-step instruction. Tutorial: A small first game - learn basic features as part of building a small but working game from scratch. Tutorial: Adding new commands - focuses specifically on how to add new commands. Tutorial: Parsing command argument . Tutorial: Adding new objects - focuses specifically on how to add new objects. Tutorial: Searching objects in the database - how to find existing objects so you can operate on them. Custom objects and typeclasses \u00b6 Examples of designing new objects for your game world Tutorial: Rooms with Weather Tutorial: Aggressive NPC's Tutorial: Listening NPC's Tutorial: Creating a vehicle Tutorial: Making an NPC shop (also advanced EvMenu usage) Tutorial: Implementing a Static In Game Map (also Batch Code usage) Tutorial: Implementing a Dynamic In Game Map Tutorial: Writing your own unit tests Game mechanics tutorials \u00b6 Creating the underlying game mechanics of game play. Hints: Implementing a game rule system Tutorial: Implementing a Combat system Tutorial: Evennia for running tabletop rpgs Miscellaneous system tutorials \u00b6 Design various game systems and achieve particular effects. FAQ : A place for users to enter their own hints on achieving various goals in Evennia. Tutorial: Adding a Command prompt Tutorial: Creating a Zoning system Tutorial: Letting players manually configure color settings Hints: Asking the user a question and dealing with the result Hints: Designing commands that take time to finish Hints: Adding cooldowns to commands Tutorial: Mass and weight for objects Hints: Show a different message when trying a non-existent exit Tutorial: Make automatic tweets of game statistics Tutorial: Handling virtual time in your game Tutorial: Setting up a coordinate system for rooms Tutorial: customize the way channels and channel commands work in your game Tutorial: Adding unit tests to your game project Contrib \u00b6 This section contains tutorials linked with contribs. These contribs can be used in your game, but you'll need to install them explicitly. They add common features that can earn you time in implementation. list of contribs In-game Python: dialogues with characters . In-game Python: a voice-operated elevator . Web tutorials \u00b6 Expanding Evennia's web presence. Tutorial: Add a new web page - simple example to see how Django pages hang together. Tutorial: Website customization - learn how to start customizing your game's web presence. Tutorial: Bootstrap & Evennia - Learn more about Bootstrap, the current CSS framework Evennia is using Tutorial: Build a web page displaying a game character - make a way to view your character on the web page. Tutorial: access your help system from your website Tutorial: add a wiki on your website Tutorial: Web Character Generation - make a web-based character application form. Tutorial: Bootstrap Components and Utilities - Describes some common Bootstrap Components and Utilities that might help in designing for Evennia Evennia for [Engine]-Users \u00b6 Hints for new users more familiar with other game engines. Evennia for Diku Users - read up on the differences between Diku style muds and Evennia. Evennia for MUSH Users - an introduction to Evennia for those accustomed to MUSH-style servers.","title":"Tutorials"},{"location":"Tutorials.html#building","text":"Help with populating your game world. Tutorial: Building Quick-start - helps you build your first rocks and crates using Evennia's defaults. Tutorial: Understanding Color Tags - explains how you color your game's text. Introduction: The Tutorial World - this introduces the full (if small) solo-adventure game that comes with the Evennia distribution. It is useful both as an example of building and of coding. Tutorial: Building a Giant Mech - this starts as a building tutorial and transitions into writing code.","title":"Building"},{"location":"Tutorials.html#general-development-tutorials","text":"General code practices for newbie game developers. To use Evennia, you will need basic understanding of Python modules , variables , conditional statements , loops , functions , lists, dictionaries, list comprehensions and string formatting . You should also have a basic understanding of object-oriented programming and what Python Classes are. Python tutorials for beginners - external link with tutorials for those not familiar with coding in general or Python in particular. Tutorial: Version Control - use GIT to organize your code both for your own game project and for contributing to Evennia. MIT offers free courses in many subjects. Their Introduction to Computer Science and Programming uses Python as its language of choice. Longer path, but more in-depth. Definitely worth a look.","title":"General Development tutorials"},{"location":"Tutorials.html#coding-first-step-tutorials","text":"Starting tutorials for you who are new to developing with Evennia. Python basic introduction (part 1) - Python intro using Evennia. Python basic introduction (part 2) - More on objects, classes and finding where things are. Tutorial: First Steps Coding - learn each basic feature on their own through step-by-step instruction. Tutorial: A small first game - learn basic features as part of building a small but working game from scratch. Tutorial: Adding new commands - focuses specifically on how to add new commands. Tutorial: Parsing command argument . Tutorial: Adding new objects - focuses specifically on how to add new objects. Tutorial: Searching objects in the database - how to find existing objects so you can operate on them.","title":"Coding - First Step tutorials"},{"location":"Tutorials.html#custom-objects-and-typeclasses","text":"Examples of designing new objects for your game world Tutorial: Rooms with Weather Tutorial: Aggressive NPC's Tutorial: Listening NPC's Tutorial: Creating a vehicle Tutorial: Making an NPC shop (also advanced EvMenu usage) Tutorial: Implementing a Static In Game Map (also Batch Code usage) Tutorial: Implementing a Dynamic In Game Map Tutorial: Writing your own unit tests","title":"Custom objects and typeclasses"},{"location":"Tutorials.html#game-mechanics-tutorials","text":"Creating the underlying game mechanics of game play. Hints: Implementing a game rule system Tutorial: Implementing a Combat system Tutorial: Evennia for running tabletop rpgs","title":"Game mechanics tutorials"},{"location":"Tutorials.html#miscellaneous-system-tutorials","text":"Design various game systems and achieve particular effects. FAQ : A place for users to enter their own hints on achieving various goals in Evennia. Tutorial: Adding a Command prompt Tutorial: Creating a Zoning system Tutorial: Letting players manually configure color settings Hints: Asking the user a question and dealing with the result Hints: Designing commands that take time to finish Hints: Adding cooldowns to commands Tutorial: Mass and weight for objects Hints: Show a different message when trying a non-existent exit Tutorial: Make automatic tweets of game statistics Tutorial: Handling virtual time in your game Tutorial: Setting up a coordinate system for rooms Tutorial: customize the way channels and channel commands work in your game Tutorial: Adding unit tests to your game project","title":"Miscellaneous system tutorials"},{"location":"Tutorials.html#contrib","text":"This section contains tutorials linked with contribs. These contribs can be used in your game, but you'll need to install them explicitly. They add common features that can earn you time in implementation. list of contribs In-game Python: dialogues with characters . In-game Python: a voice-operated elevator .","title":"Contrib"},{"location":"Tutorials.html#web-tutorials","text":"Expanding Evennia's web presence. Tutorial: Add a new web page - simple example to see how Django pages hang together. Tutorial: Website customization - learn how to start customizing your game's web presence. Tutorial: Bootstrap & Evennia - Learn more about Bootstrap, the current CSS framework Evennia is using Tutorial: Build a web page displaying a game character - make a way to view your character on the web page. Tutorial: access your help system from your website Tutorial: add a wiki on your website Tutorial: Web Character Generation - make a web-based character application form. Tutorial: Bootstrap Components and Utilities - Describes some common Bootstrap Components and Utilities that might help in designing for Evennia","title":"Web tutorials"},{"location":"Tutorials.html#evennia-for-engine-users","text":"Hints for new users more familiar with other game engines. Evennia for Diku Users - read up on the differences between Diku style muds and Evennia. Evennia for MUSH Users - an introduction to Evennia for those accustomed to MUSH-style servers.","title":"Evennia for [Engine]-Users"},{"location":"Typeclasses.html","text":"Typeclasses form the core of Evennia data storage. It allows Evennia to represent any number of different game entities as Python classes, without having to modify the database schema for every new type. In Evennia the most important game entities, Accounts , Objects , Scripts and Channels are all Python classes inheriting, at varying distance, from evennia.typeclasses.models.TypedObject . In the documentation we refer to these objects as being \"typeclassed\" or even \"being a typeclass\". This is how the inheritance looks for the typeclasses in Evennia: TypedObject _________________|_________________________________ | | | | 1: AccountDB ObjectDB ScriptDB ChannelDB | | | | 2: DefaultAccount DefaultObject DefaultScript DefaultChannel | DefaultCharacter | | | DefaultRoom | | | DefaultExit | | | | | | 3: Account Object Script Channel Character Room Exit Level 1 above is the \"database model\" level. This describes the database tables and fields (this is technically a Django model ). Level 2 is where we find Evennia's default implementations of the various game entities, on top of the database. These classes define all the hook methods that Evennia calls in various situations. DefaultObject is a little special since it's the parent for DefaultCharacter , DefaultRoom and DefaultExit . They are all grouped under level 2 because they all represents defaults to build from. Level 3 , finally, holds empty template classes created in your game directory. This is the level you are meant to modify and tweak as you please, overloading the defaults as befits your game. The templates inherit directly from their defaults, so Object inherits from DefaultObject and Room inherits from DefaultRoom . The typeclass/list command will provide a list of all typeclasses known to Evennia. This can be useful for getting a feel for what is available. Note however that if you add a new module with a class in it but do not import that module from anywhere, the typeclass/list will not find it. To make it known to Evennia you must import that module from somewhere. Difference between typeclasses and classes \u00b6 All Evennia classes inheriting from class in the table above share one important feature and two important limitations. This is why we don't simply call them \"classes\" but \"typeclasses\". A typeclass can save itself to the database. This means that some properties (actually not that many) on the class actually represents database fields and can only hold very specific data types. This is detailed below . Due to its connection to the database, the typeclass' name must be unique across the entire server namespace. That is, there must never be two same-named classes defined anywhere. So the below code would give an error (since DefaultObject is now globally found both in this module and in the default library): python from evennia import DefaultObject as BaseObject class DefaultObject(BaseObject): pass A typeclass' __init__ method should normally not be overloaded. This has mostly to do with the fact that the __init__ method is not called in a predictable way. Instead Evennia suggest you use the at_*_creation hooks (like at_object_creation for Objects) for setting things the very first time the typeclass is saved to the database or the at_init hook which is called every time the object is cached to memory. If you know what you are doing and want to use __init__ , it must both accept arbitrary keyword arguments and use super to call its parent:: python def __init__(self, **kwargs): # my content super().__init__(**kwargs) # my content Apart from this, a typeclass works like any normal Python class and you can treat it as such. Creating a new typeclass \u00b6 It's easy to work with Typeclasses. Either you use an existing typeclass or you create a new Python class inheriting from an existing typeclass. Here is an example of creating a new type of Object: from evennia import DefaultObject class Furniture(DefaultObject): # this defines what 'furniture' is, like # storing who sits on it or something. pass You can now create a new Furniture object in two ways. First (and usually not the most convenient) way is to create an instance of the class and then save it manually to the database: chair = Furniture(db_key=\"Chair\") chair.save() To use this you must give the database field names as keywords to the call. Which are available depends on the entity you are creating, but all start with db_* in Evennia. This is a method you may be familiar with if you know Django from before. It is recommended that you instead use the create_* functions to create typeclassed entities: from evennia import create_object chair = create_object(Furniture, key=\"Chair\") # or (if your typeclass is in a module furniture.py) chair = create_object(\"furniture.Furniture\", key=\"Chair\") The create_object ( create_account , create_script etc) takes the typeclass as its first argument; this can both be the actual class or the python path to the typeclass as found under your game directory. So if your Furniture typeclass sits in mygame/typeclasses/furniture.py , you could point to it as typeclasses.furniture.Furniture . Since Evennia will itself look in mygame/typeclasses , you can shorten this even further to just furniture.Furniture . The create-functions take a lot of extra keywords allowing you to set things like Attributes and Tags all in one go. These keywords don't use the db_* prefix. This will also automatically save the new instance to the database, so you don't need to call save() explicitly. About typeclass properties \u00b6 An example of a database field is db_key . This stores the \"name\" of the entity you are modifying and can thus only hold a string. This is one way of making sure to update the db_key : chair.db_key = \"Table\" chair.save() print(chair.db_key) <<< Table That is, we change the chair object to have the db_key \"Table\", then save this to the database. However, you almost never do things this way; Evennia defines property wrappers for all the database fields. These are named the same as the field, but without the db_ part: chair.key = \"Table\" print(chair.key) <<< Table The key wrapper is not only shorter to write, it will make sure to save the field for you, and does so more efficiently by levering sql update mechanics under the hood. So whereas it is good to be aware that the field is named db_key you should use key as much as you can. Each typeclass entity has some unique fields relevant to that type. But all also share the following fields (the wrapper name without db_ is given): key (str): The main identifier for the entity, like \"Rose\", \"myscript\" or \"Paul\". name is an alias. date_created (datetime): Time stamp when this object was created. typeclass_path (str): A python path pointing to the location of this (type)class There is one special field that doesn't use the db_ prefix (it's defined by Django): id (int): the database id (database ref) of the object. This is an ever-increasing, unique integer. It can also be accessed as dbid (database ID) or pk (primary key). The dbref property returns the string form \"#id\". The typeclassed entity has several common handlers: tags - the TagHandler that handles tagging. Use tags.add() , tags.get() etc. locks - the LockHandler that manages access restrictions. Use locks.add() , locks.get() etc. attributes - the AttributeHandler that manages Attributes on the object. Use attributes.add() etc. db (DataBase) - a shortcut property to the AttributeHandler; allowing obj.db.attrname = value nattributes - the Non-persistent AttributeHandler for attributes not saved in the database. ndb (NotDataBase) - a shortcut property to the Non-peristent AttributeHandler. Allows obj.ndb.attrname = value Each of the typeclassed entities then extend this list with their own properties. Go to the respective pages for Objects , Scripts , Accounts and Channels for more info. It's also recommended that you explore the available entities using Evennia's flat API to explore which properties and methods they have available. Overloading hooks \u00b6 The way to customize typeclasses is usually to overload hook methods on them. Hooks are methods that Evennia call in various situations. An example is the at_object_creation hook on Objects , which is only called once, the very first time this object is saved to the database. Other examples are the at_login hook of Accounts and the at_repeat hook of Scripts. Querying for typeclasses \u00b6 Most of the time you search for objects in the database by using convenience methods like the caller.search() of Commands or the search functions like evennia.search_objects . You can however also query for them directly using Django's query language . This makes use of a database manager that sits on all typeclasses, named objects . This manager holds methods that allow database searches against that particular type of object (this is the way Django normally works too). When using Django queries, you need to use the full field names (like db_key ) to search: matches = Furniture.objects.get(db_key=\"Chair\") It is important that this will only find objects inheriting directly from Furniture in your database. If there was a subclass of Furniture named Sitables you would not find any chairs derived from Sitables with this query (this is not a Django feature but special to Evennia). To find objects from subclasses Evennia instead makes the get_family and filter_family query methods available: # search for all furnitures and subclasses of furnitures # whose names starts with \"Chair\" matches = Furniture.objects.filter_family(db_key__startswith=\"Chair\") To make sure to search, say, all Scripts regardless of typeclass, you need to query from the database model itself. So for Objects, this would be ObjectDB in the diagram above. Here's an example for Scripts: from evennia import ScriptDB matches = ScriptDB.objects.filter(db_key__contains=\"Combat\") When querying from the database model parent you don't need to use filter_family or get_family - you will always query all children on the database model. Updating existing typeclass instances \u00b6 If you already have created instances of Typeclasses, you can modify the Python code at any time - due to how Python inheritance works your changes will automatically be applied to all children once you have reloaded the server. However, database-saved data, like db_* fields, Attributes , Tags etc, are not themselves embedded into the class and will not be updated automatically. This you need to manage yourself, by searching for all relevant objects and updating or adding the data: # add a worth Attribute to all existing Furniture for obj in Furniture.objects.all(): # this will loop over all Furniture instances obj.db.worth = 100 A common use case is putting all Attributes in the at_*_creation hook of the entity, such as at_object_creation for Objects . This is called every time an object is created - and only then. This is usually what you want but it does mean already existing objects won't get updated if you change the contents of at_object_creation later. You can fix this in a similar way as above (manually setting each Attribute) or with something like this: # Re-run at_object_creation only on those objects not having the new Attribute for obj in Furniture.objects.all(): if not obj.db.worth: obj.at_object_creation() The above examples can be run in the command prompt created by evennia shell . You could also run it all in-game using @py . That however requires you to put the code (including imports) as one single line using ; and list comprehensions , like this (ignore the line break, that's only for readability in the wiki): @py from typeclasses.furniture import Furniture; [obj.at_object_creation() for obj in Furniture.objects.all() if not obj.db.worth] It is recommended that you plan your game properly before starting to build, to avoid having to retroactively update objects more than necessary. Swap typeclass \u00b6 If you want to swap an already existing typeclass, there are two ways to do so: From in-game and via code. From inside the game you can use the default @typeclass command: @typeclass objname = path.to.new.typeclass There are two important switches to this command: - /reset - This will purge all existing Attributes on the object and re-run the creation hook (like at_object_creation for Objects). This assures you get an object which is purely of this new class. - /force - This is required if you are changing the class to be the same class the object already has - it's a safety check to avoid user errors. This is usually used together with /reset to re-run the creation hook on an existing class. In code you instead use the swap_typeclass method which you can find on all typeclassed entities: obj_to_change.swap_typeclass(new_typeclass_path, clean_attributes=False, run_start_hooks=\"all\", no_default=True, clean_cmdsets=False) The arguments to this method are described in the API docs here . How typeclasses actually work \u00b6 This is considered an advanced section. Technically, typeclasses are Django proxy models . The only database models that are \"real\" in the typeclass system (that is, are represented by actual tables in the database) are AccountDB , ObjectDB , ScriptDB and ChannelDB (there are also Attributes and Tags but they are not typeclasses themselves). All the subclasses of them are \"proxies\", extending them with Python code without actually modifying the database layout. Evennia modifies Django's proxy model in various ways to allow them to work without any boiler plate (for example you don't need to set the Django \"proxy\" property in the model Meta subclass, Evennia handles this for you using metaclasses). Evennia also makes sure you can query subclasses as well as patches django to allow multiple inheritance from the same base class. Caveats \u00b6 Evennia uses the idmapper to cache its typeclasses (Django proxy models) in memory. The idmapper allows things like on-object handlers and properties to be stored on typeclass instances and to not get lost as long as the server is running (they will only be cleared on a Server reload). Django does not work like this by default; by default every time you search for an object in the database you'll get a different instance of that object back and anything you stored on it that was not in the database would be lost. The bottom line is that Evennia's Typeclass instances subside in memory a lot longer than vanilla Django model instance do. There is one caveat to consider with this, and that relates to making your own models : Foreign relationships to typeclasses are cached by Django and that means that if you were to change an object in a foreign relationship via some other means than via that relationship, the object seeing the relationship may not reliably update but will still see its old cached version. Due to typeclasses staying so long in memory, stale caches of such relationships could be more visible than common in Django. See the closed issue #1098 and its comments for examples and solutions.","title":"Typeclasses"},{"location":"Typeclasses.html#difference-between-typeclasses-and-classes","text":"All Evennia classes inheriting from class in the table above share one important feature and two important limitations. This is why we don't simply call them \"classes\" but \"typeclasses\". A typeclass can save itself to the database. This means that some properties (actually not that many) on the class actually represents database fields and can only hold very specific data types. This is detailed below . Due to its connection to the database, the typeclass' name must be unique across the entire server namespace. That is, there must never be two same-named classes defined anywhere. So the below code would give an error (since DefaultObject is now globally found both in this module and in the default library): python from evennia import DefaultObject as BaseObject class DefaultObject(BaseObject): pass A typeclass' __init__ method should normally not be overloaded. This has mostly to do with the fact that the __init__ method is not called in a predictable way. Instead Evennia suggest you use the at_*_creation hooks (like at_object_creation for Objects) for setting things the very first time the typeclass is saved to the database or the at_init hook which is called every time the object is cached to memory. If you know what you are doing and want to use __init__ , it must both accept arbitrary keyword arguments and use super to call its parent:: python def __init__(self, **kwargs): # my content super().__init__(**kwargs) # my content Apart from this, a typeclass works like any normal Python class and you can treat it as such.","title":"Difference between typeclasses and classes"},{"location":"Typeclasses.html#creating-a-new-typeclass","text":"It's easy to work with Typeclasses. Either you use an existing typeclass or you create a new Python class inheriting from an existing typeclass. Here is an example of creating a new type of Object: from evennia import DefaultObject class Furniture(DefaultObject): # this defines what 'furniture' is, like # storing who sits on it or something. pass You can now create a new Furniture object in two ways. First (and usually not the most convenient) way is to create an instance of the class and then save it manually to the database: chair = Furniture(db_key=\"Chair\") chair.save() To use this you must give the database field names as keywords to the call. Which are available depends on the entity you are creating, but all start with db_* in Evennia. This is a method you may be familiar with if you know Django from before. It is recommended that you instead use the create_* functions to create typeclassed entities: from evennia import create_object chair = create_object(Furniture, key=\"Chair\") # or (if your typeclass is in a module furniture.py) chair = create_object(\"furniture.Furniture\", key=\"Chair\") The create_object ( create_account , create_script etc) takes the typeclass as its first argument; this can both be the actual class or the python path to the typeclass as found under your game directory. So if your Furniture typeclass sits in mygame/typeclasses/furniture.py , you could point to it as typeclasses.furniture.Furniture . Since Evennia will itself look in mygame/typeclasses , you can shorten this even further to just furniture.Furniture . The create-functions take a lot of extra keywords allowing you to set things like Attributes and Tags all in one go. These keywords don't use the db_* prefix. This will also automatically save the new instance to the database, so you don't need to call save() explicitly.","title":"Creating a new typeclass"},{"location":"Typeclasses.html#about-typeclass-properties","text":"An example of a database field is db_key . This stores the \"name\" of the entity you are modifying and can thus only hold a string. This is one way of making sure to update the db_key : chair.db_key = \"Table\" chair.save() print(chair.db_key) <<< Table That is, we change the chair object to have the db_key \"Table\", then save this to the database. However, you almost never do things this way; Evennia defines property wrappers for all the database fields. These are named the same as the field, but without the db_ part: chair.key = \"Table\" print(chair.key) <<< Table The key wrapper is not only shorter to write, it will make sure to save the field for you, and does so more efficiently by levering sql update mechanics under the hood. So whereas it is good to be aware that the field is named db_key you should use key as much as you can. Each typeclass entity has some unique fields relevant to that type. But all also share the following fields (the wrapper name without db_ is given): key (str): The main identifier for the entity, like \"Rose\", \"myscript\" or \"Paul\". name is an alias. date_created (datetime): Time stamp when this object was created. typeclass_path (str): A python path pointing to the location of this (type)class There is one special field that doesn't use the db_ prefix (it's defined by Django): id (int): the database id (database ref) of the object. This is an ever-increasing, unique integer. It can also be accessed as dbid (database ID) or pk (primary key). The dbref property returns the string form \"#id\". The typeclassed entity has several common handlers: tags - the TagHandler that handles tagging. Use tags.add() , tags.get() etc. locks - the LockHandler that manages access restrictions. Use locks.add() , locks.get() etc. attributes - the AttributeHandler that manages Attributes on the object. Use attributes.add() etc. db (DataBase) - a shortcut property to the AttributeHandler; allowing obj.db.attrname = value nattributes - the Non-persistent AttributeHandler for attributes not saved in the database. ndb (NotDataBase) - a shortcut property to the Non-peristent AttributeHandler. Allows obj.ndb.attrname = value Each of the typeclassed entities then extend this list with their own properties. Go to the respective pages for Objects , Scripts , Accounts and Channels for more info. It's also recommended that you explore the available entities using Evennia's flat API to explore which properties and methods they have available.","title":"About typeclass properties"},{"location":"Typeclasses.html#overloading-hooks","text":"The way to customize typeclasses is usually to overload hook methods on them. Hooks are methods that Evennia call in various situations. An example is the at_object_creation hook on Objects , which is only called once, the very first time this object is saved to the database. Other examples are the at_login hook of Accounts and the at_repeat hook of Scripts.","title":"Overloading hooks"},{"location":"Typeclasses.html#querying-for-typeclasses","text":"Most of the time you search for objects in the database by using convenience methods like the caller.search() of Commands or the search functions like evennia.search_objects . You can however also query for them directly using Django's query language . This makes use of a database manager that sits on all typeclasses, named objects . This manager holds methods that allow database searches against that particular type of object (this is the way Django normally works too). When using Django queries, you need to use the full field names (like db_key ) to search: matches = Furniture.objects.get(db_key=\"Chair\") It is important that this will only find objects inheriting directly from Furniture in your database. If there was a subclass of Furniture named Sitables you would not find any chairs derived from Sitables with this query (this is not a Django feature but special to Evennia). To find objects from subclasses Evennia instead makes the get_family and filter_family query methods available: # search for all furnitures and subclasses of furnitures # whose names starts with \"Chair\" matches = Furniture.objects.filter_family(db_key__startswith=\"Chair\") To make sure to search, say, all Scripts regardless of typeclass, you need to query from the database model itself. So for Objects, this would be ObjectDB in the diagram above. Here's an example for Scripts: from evennia import ScriptDB matches = ScriptDB.objects.filter(db_key__contains=\"Combat\") When querying from the database model parent you don't need to use filter_family or get_family - you will always query all children on the database model.","title":"Querying for typeclasses"},{"location":"Typeclasses.html#updating-existing-typeclass-instances","text":"If you already have created instances of Typeclasses, you can modify the Python code at any time - due to how Python inheritance works your changes will automatically be applied to all children once you have reloaded the server. However, database-saved data, like db_* fields, Attributes , Tags etc, are not themselves embedded into the class and will not be updated automatically. This you need to manage yourself, by searching for all relevant objects and updating or adding the data: # add a worth Attribute to all existing Furniture for obj in Furniture.objects.all(): # this will loop over all Furniture instances obj.db.worth = 100 A common use case is putting all Attributes in the at_*_creation hook of the entity, such as at_object_creation for Objects . This is called every time an object is created - and only then. This is usually what you want but it does mean already existing objects won't get updated if you change the contents of at_object_creation later. You can fix this in a similar way as above (manually setting each Attribute) or with something like this: # Re-run at_object_creation only on those objects not having the new Attribute for obj in Furniture.objects.all(): if not obj.db.worth: obj.at_object_creation() The above examples can be run in the command prompt created by evennia shell . You could also run it all in-game using @py . That however requires you to put the code (including imports) as one single line using ; and list comprehensions , like this (ignore the line break, that's only for readability in the wiki): @py from typeclasses.furniture import Furniture; [obj.at_object_creation() for obj in Furniture.objects.all() if not obj.db.worth] It is recommended that you plan your game properly before starting to build, to avoid having to retroactively update objects more than necessary.","title":"Updating existing typeclass instances"},{"location":"Typeclasses.html#swap-typeclass","text":"If you want to swap an already existing typeclass, there are two ways to do so: From in-game and via code. From inside the game you can use the default @typeclass command: @typeclass objname = path.to.new.typeclass There are two important switches to this command: - /reset - This will purge all existing Attributes on the object and re-run the creation hook (like at_object_creation for Objects). This assures you get an object which is purely of this new class. - /force - This is required if you are changing the class to be the same class the object already has - it's a safety check to avoid user errors. This is usually used together with /reset to re-run the creation hook on an existing class. In code you instead use the swap_typeclass method which you can find on all typeclassed entities: obj_to_change.swap_typeclass(new_typeclass_path, clean_attributes=False, run_start_hooks=\"all\", no_default=True, clean_cmdsets=False) The arguments to this method are described in the API docs here .","title":"Swap typeclass"},{"location":"Typeclasses.html#how-typeclasses-actually-work","text":"This is considered an advanced section. Technically, typeclasses are Django proxy models . The only database models that are \"real\" in the typeclass system (that is, are represented by actual tables in the database) are AccountDB , ObjectDB , ScriptDB and ChannelDB (there are also Attributes and Tags but they are not typeclasses themselves). All the subclasses of them are \"proxies\", extending them with Python code without actually modifying the database layout. Evennia modifies Django's proxy model in various ways to allow them to work without any boiler plate (for example you don't need to set the Django \"proxy\" property in the model Meta subclass, Evennia handles this for you using metaclasses). Evennia also makes sure you can query subclasses as well as patches django to allow multiple inheritance from the same base class.","title":"How typeclasses actually work"},{"location":"Typeclasses.html#caveats","text":"Evennia uses the idmapper to cache its typeclasses (Django proxy models) in memory. The idmapper allows things like on-object handlers and properties to be stored on typeclass instances and to not get lost as long as the server is running (they will only be cleared on a Server reload). Django does not work like this by default; by default every time you search for an object in the database you'll get a different instance of that object back and anything you stored on it that was not in the database would be lost. The bottom line is that Evennia's Typeclass instances subside in memory a lot longer than vanilla Django model instance do. There is one caveat to consider with this, and that relates to making your own models : Foreign relationships to typeclasses are cached by Django and that means that if you were to change an object in a foreign relationship via some other means than via that relationship, the object seeing the relationship may not reliably update but will still see its old cached version. Due to typeclasses staying so long in memory, stale caches of such relationships could be more visible than common in Django. See the closed issue #1098 and its comments for examples and solutions.","title":"Caveats"},{"location":"Understanding-Color-Tags.html","text":"This tutorial aims at dispelling confusions regarding the use of color tags within Evennia. Correct understanding of this topic requires having read the TextTags page and learned Evennia's color tags. Here we'll explain by examples the reasons behind the unexpected (or apparently incoherent) behaviors of some color tags, as mentioned en passant in the TextTags page. All you'll need for this tutorial is access to a running instance of Evennia via a color-enabled client. The examples provided are just commands that you can type in your client. Evennia, ANSI and Xterm256 \u00b6 All modern MUD clients support colors; nevertheless, the standards to which all clients abide dates back to old day of terminals, and when it comes to colors we are dealing with ANSI and Xterm256 standards. Evennia handles transparently, behind the scenes, all the code required to enforce these standards\u2014so, if a user connects with a client which doesn't support colors, or supports only ANSI (16 colors), Evennia will take all due steps to ensure that the output will be adjusted to look right at the client side. As for you, the developer, all you need to care about is knowing how to correctly use the color tags within your MUD. Most likely, you'll be adding colors to help pages, descriptions, automatically generated text, etc. You are free to mix together ANSI and Xterm256 color tags, but you should be aware of a few pitfalls. ANSI and Xterm256 coexist without conflicts in Evennia, but in many ways they don't \u00absee\u00bb each other: ANSI-specific color tags will have no effect on Xterm-defined colors, as we shall see here. ANSI \u00b6 ANSI has a set of 16 colors, to be more precise: ANSI has 8 basic colors which come in dark and bright flavours\u2014with dark being normal . The colors are: red, green, yellow, blue, magenta, cyan, white and black. White in its dark version is usually referred to as gray, and black in its bright version as darkgray. Here, for sake of simplicity they'll be referred to as dark and bright: bright/dark black, bright/dark white. The default colors of MUD clients is normal (dark) white on normal black (ie: gray on black). It's important to grasp that in the ANSI standard bright colors apply only to text (foreground), not to background. Evennia allows to bypass this limitation via Xterm256, but doing so will impact the behavior of ANSI tags, as we shall see. Also, it's important to remember that the 16 ANSI colors are a convention, and the final user can always customize their appearance\u2014he might decide to have green show as red, and dark green as blue, etc. Xterm256 \u00b6 The 16 colors of ANSI should be more than enough to handle simple coloring of text. But when an author wants to be sure that a given color will show as he intended it, she might choose to rely on Xterm256 colors. Xterm256 doesn't rely on a palette of named colors, it instead represent colors by their values. So, a red color could be |[500 (bright and pure red), or |[300 (darker red), and so on. ANSI Color Tags in Evennia \u00b6 NOTE: for ease of reading, the examples contain extra white spaces after the color tags (eg: |g green |b blue ). This is done only so that it's easier to see the tags separated from their context; it wouldn't be good practice in real-life coding. Let's proceed by examples. In your MUD client type: say Normal |* Negative Evennia should output the word \"Normal\" normally (ie: gray on black) and \"Negative\" in reversed colors (ie: black on gray). This is pretty straight forward, the |* ANSI invert tag switches between foreground and background\u2014from now on, FG and BG shorthands will be used to refer to foreground and background. But take mental note of this: |* has switched dark white and dark black . Now try this: say |w Bright white FG |* Negative You'll notice that the word \"Negative\" is not black on white, it's darkgray on gray. Why is this? Shouldn't it be black text on a white BG? Two things are happening here. As mentioned, ANSI has 8 base colors, the dark ones. The bright ones are achieved by means of highlighting the base/dark/normal colors, and they only apply to FG. What happened here is that when we set the bright white FG with |w , Evennia translated this into the ANSI sequence of Highlight On + White FG. In terms of Evennia's color tags, it's as if we typed: say |h|!W Bright white FG |* Negative Furthermore, the Highlight-On property (which only works for BG!) is preserved after the FG/BG switch, this being the reason why we see black as darkgray: highlighting makes it bright black (ie: darkgray). As for the BG being also grey, that is normal\u2014ie: you are seeing normal white (ie: dark white = gray). Remember that since there are no bright BG colors, the ANSI |* tag will transpose any FG color in its normal/dark version. So here the FG's bright white became dark white in the BG! In reality, it was always normal/dark white, except that in the FG is seen as bright because of the highlight tag behind the scenes. Let's try the same thing with some color: say |m |[G Bright Magenta on Dark Green |* Negative Again, the BG stays dark because of ANSI rules, and the FG stays bright because of the implicit |h in |m . Now, let's see what happens if we set a bright BG and then invert\u2014yes, Evennia kindly allows us to do it, even if it's not within ANSI expectations. say |[b Dark White on Bright Blue |* Negative Before color inversion, the BG does show in bright blue, and after inversion (as expected) it's dark white (gray). The bright blue of the BG survived the inversion and gave us a bright blue FG. This behavior is tricky though, and not as simple as it might look. If the inversion were to be pure ANSI, the bright blue would have been accounted just as normal blue, and should have converted to normal blue in the FG (after all, there was no highlighting on). The fact is that in reality this color is not bright blue at all, it just an Xterm version of it! To demonstrate this, type: say |[b Dark White on Bright Blue |* Negative |H un-bright The |H Highlight-Off tag should have turned dark blue the last word; but it didn't because it couldn't: in order to enforce the non-ANSI bright BG Evennia turned to Xterm, and Xterm entities are not affected by ANSI tags! So, we are getting at the heart of all confusions and possible odd-behaviors pertaining color tags in Evennia: apart from Evennia's translations from- and to- ANSI/Xterm, the two systems are independent and transparent to each other. The bright blue of the previous example was just an Xterm representation of the ANSI standard blue. Try to change the default settings of your client, so that blue shows as some other color, you'll then realize the difference when Evennia is sending a true ANSI color (which will show up according to your settings) and when instead it's sending an Xterm representation of that color (which will show up always as defined by Evennia). You'll have to keep in mind that the presence of an Xterm BG or FG color might affect the way your tags work on the text. For example: say |[b Bright Blue BG |* Negative |!Y Dark Yellow |h not bright Here the |h tag no longer affects the FG color. Even though it was changed via the |! tag, the ANSI system is out-of-tune because of the intrusion of an Xterm color (bright blue BG, then moved to FG with |* ). All unexpected ANSI behaviours are the result of mixing Xterm colors (either on purpose or either via bright BG colors). The |n tag will restore things in place and ANSI tags will respond properly again. So, at the end is just an issue of being mindful when using Xterm colors or bright BGs, and avoid wild mixing them with ANSI tags without normalizing ( |n ) things again. Try this: say |[b Bright Blue BG |* Negative |!R Red FG And then: say |[B Dark Blue BG |* Negative |!R Red BG?? In this second example the |! changes the BG color instead of the FG! In fact, the odd behavior is the one from the former example, non the latter. When you invert FG and BG with |* you actually inverting their references. This is why the last example (which has a normal/dark BG!) allows |! to change the BG color. In the first example, it's again the presence of an Xterm color (bright blue BG) which changes the default behavior. Try this: say Normal |* Negative |!R Red BG This is the normal behavior, and as you can see it allows |! to change BG color after the inversion of FG and BG. As long as you have an understanding of how ANSI works, it should be easy to handle color tags avoiding the pitfalls of Xterm-ANSI promisquity. One last example: say Normal |* Negative |* still Negative Shows that |* only works once in a row and will not (and should not!) revert back if used again. Nor it will have any effect until the |n tag is called to \"reset\" ANSI back to normal. This is how it is meant to work. ANSI operates according to a simple states-based mechanism, and it's important to understand the positive effect of resetting with the |n tag, and not try to push it over the limit, so to speak.","title":"Understanding Color Tags"},{"location":"Understanding-Color-Tags.html#evennia-ansi-and-xterm256","text":"All modern MUD clients support colors; nevertheless, the standards to which all clients abide dates back to old day of terminals, and when it comes to colors we are dealing with ANSI and Xterm256 standards. Evennia handles transparently, behind the scenes, all the code required to enforce these standards\u2014so, if a user connects with a client which doesn't support colors, or supports only ANSI (16 colors), Evennia will take all due steps to ensure that the output will be adjusted to look right at the client side. As for you, the developer, all you need to care about is knowing how to correctly use the color tags within your MUD. Most likely, you'll be adding colors to help pages, descriptions, automatically generated text, etc. You are free to mix together ANSI and Xterm256 color tags, but you should be aware of a few pitfalls. ANSI and Xterm256 coexist without conflicts in Evennia, but in many ways they don't \u00absee\u00bb each other: ANSI-specific color tags will have no effect on Xterm-defined colors, as we shall see here.","title":"Evennia, ANSI and Xterm256"},{"location":"Understanding-Color-Tags.html#ansi","text":"ANSI has a set of 16 colors, to be more precise: ANSI has 8 basic colors which come in dark and bright flavours\u2014with dark being normal . The colors are: red, green, yellow, blue, magenta, cyan, white and black. White in its dark version is usually referred to as gray, and black in its bright version as darkgray. Here, for sake of simplicity they'll be referred to as dark and bright: bright/dark black, bright/dark white. The default colors of MUD clients is normal (dark) white on normal black (ie: gray on black). It's important to grasp that in the ANSI standard bright colors apply only to text (foreground), not to background. Evennia allows to bypass this limitation via Xterm256, but doing so will impact the behavior of ANSI tags, as we shall see. Also, it's important to remember that the 16 ANSI colors are a convention, and the final user can always customize their appearance\u2014he might decide to have green show as red, and dark green as blue, etc.","title":"ANSI"},{"location":"Understanding-Color-Tags.html#xterm256","text":"The 16 colors of ANSI should be more than enough to handle simple coloring of text. But when an author wants to be sure that a given color will show as he intended it, she might choose to rely on Xterm256 colors. Xterm256 doesn't rely on a palette of named colors, it instead represent colors by their values. So, a red color could be |[500 (bright and pure red), or |[300 (darker red), and so on.","title":"Xterm256"},{"location":"Understanding-Color-Tags.html#ansi-color-tags-in-evennia","text":"NOTE: for ease of reading, the examples contain extra white spaces after the color tags (eg: |g green |b blue ). This is done only so that it's easier to see the tags separated from their context; it wouldn't be good practice in real-life coding. Let's proceed by examples. In your MUD client type: say Normal |* Negative Evennia should output the word \"Normal\" normally (ie: gray on black) and \"Negative\" in reversed colors (ie: black on gray). This is pretty straight forward, the |* ANSI invert tag switches between foreground and background\u2014from now on, FG and BG shorthands will be used to refer to foreground and background. But take mental note of this: |* has switched dark white and dark black . Now try this: say |w Bright white FG |* Negative You'll notice that the word \"Negative\" is not black on white, it's darkgray on gray. Why is this? Shouldn't it be black text on a white BG? Two things are happening here. As mentioned, ANSI has 8 base colors, the dark ones. The bright ones are achieved by means of highlighting the base/dark/normal colors, and they only apply to FG. What happened here is that when we set the bright white FG with |w , Evennia translated this into the ANSI sequence of Highlight On + White FG. In terms of Evennia's color tags, it's as if we typed: say |h|!W Bright white FG |* Negative Furthermore, the Highlight-On property (which only works for BG!) is preserved after the FG/BG switch, this being the reason why we see black as darkgray: highlighting makes it bright black (ie: darkgray). As for the BG being also grey, that is normal\u2014ie: you are seeing normal white (ie: dark white = gray). Remember that since there are no bright BG colors, the ANSI |* tag will transpose any FG color in its normal/dark version. So here the FG's bright white became dark white in the BG! In reality, it was always normal/dark white, except that in the FG is seen as bright because of the highlight tag behind the scenes. Let's try the same thing with some color: say |m |[G Bright Magenta on Dark Green |* Negative Again, the BG stays dark because of ANSI rules, and the FG stays bright because of the implicit |h in |m . Now, let's see what happens if we set a bright BG and then invert\u2014yes, Evennia kindly allows us to do it, even if it's not within ANSI expectations. say |[b Dark White on Bright Blue |* Negative Before color inversion, the BG does show in bright blue, and after inversion (as expected) it's dark white (gray). The bright blue of the BG survived the inversion and gave us a bright blue FG. This behavior is tricky though, and not as simple as it might look. If the inversion were to be pure ANSI, the bright blue would have been accounted just as normal blue, and should have converted to normal blue in the FG (after all, there was no highlighting on). The fact is that in reality this color is not bright blue at all, it just an Xterm version of it! To demonstrate this, type: say |[b Dark White on Bright Blue |* Negative |H un-bright The |H Highlight-Off tag should have turned dark blue the last word; but it didn't because it couldn't: in order to enforce the non-ANSI bright BG Evennia turned to Xterm, and Xterm entities are not affected by ANSI tags! So, we are getting at the heart of all confusions and possible odd-behaviors pertaining color tags in Evennia: apart from Evennia's translations from- and to- ANSI/Xterm, the two systems are independent and transparent to each other. The bright blue of the previous example was just an Xterm representation of the ANSI standard blue. Try to change the default settings of your client, so that blue shows as some other color, you'll then realize the difference when Evennia is sending a true ANSI color (which will show up according to your settings) and when instead it's sending an Xterm representation of that color (which will show up always as defined by Evennia). You'll have to keep in mind that the presence of an Xterm BG or FG color might affect the way your tags work on the text. For example: say |[b Bright Blue BG |* Negative |!Y Dark Yellow |h not bright Here the |h tag no longer affects the FG color. Even though it was changed via the |! tag, the ANSI system is out-of-tune because of the intrusion of an Xterm color (bright blue BG, then moved to FG with |* ). All unexpected ANSI behaviours are the result of mixing Xterm colors (either on purpose or either via bright BG colors). The |n tag will restore things in place and ANSI tags will respond properly again. So, at the end is just an issue of being mindful when using Xterm colors or bright BGs, and avoid wild mixing them with ANSI tags without normalizing ( |n ) things again. Try this: say |[b Bright Blue BG |* Negative |!R Red FG And then: say |[B Dark Blue BG |* Negative |!R Red BG?? In this second example the |! changes the BG color instead of the FG! In fact, the odd behavior is the one from the former example, non the latter. When you invert FG and BG with |* you actually inverting their references. This is why the last example (which has a normal/dark BG!) allows |! to change the BG color. In the first example, it's again the presence of an Xterm color (bright blue BG) which changes the default behavior. Try this: say Normal |* Negative |!R Red BG This is the normal behavior, and as you can see it allows |! to change BG color after the inversion of FG and BG. As long as you have an understanding of how ANSI works, it should be easy to handle color tags avoiding the pitfalls of Xterm-ANSI promisquity. One last example: say Normal |* Negative |* still Negative Shows that |* only works once in a row and will not (and should not!) revert back if used again. Nor it will have any effect until the |n tag is called to \"reset\" ANSI back to normal. This is how it is meant to work. ANSI operates according to a simple states-based mechanism, and it's important to understand the positive effect of resetting with the |n tag, and not try to push it over the limit, so to speak.","title":"ANSI Color Tags in Evennia"},{"location":"Unit-Testing.html","text":"Unit testing means testing components of a program in isolation from each other to make sure every part works on its own before using it with others. Extensive testing helps avoid new updates causing unexpected side effects as well as alleviates general code rot (a more comprehensive wikipedia article on unit testing can be found here ). A typical unit test set calls some function or method with a given input, looks at the result and makes sure that this result looks as expected. Rather than having lots of stand-alone test programs, Evennia makes use of a central test runner . This is a program that gathers all available tests all over the Evennia source code (called test suites ) and runs them all in one go. Errors and tracebacks are reported. By default Evennia only tests itself. But you can also add your own tests to your game code and have Evennia run those for you. Running the Evennia test suite \u00b6 To run the full Evennia test suite, go to your game folder and issue the command evennia test evennia This will run all the evennia tests using the default settings. You could also run only a subset of all tests by specifying a subpackage of the library: evennia test evennia.commands.default A temporary database will be instantiated to manage the tests. If everything works out you will see how many tests were run and how long it took. If something went wrong you will get error messages. If you contribute to Evennia, this is a useful sanity check to see you haven't introduced an unexpected bug. Running tests with custom settings file \u00b6 If you have implemented your own tests for your game (see below) you can run them from your game dir with evennia test . The period ( . ) means to run all tests found in the current directory and all subdirectories. You could also specify, say, typeclasses or world if you wanted to just run tests in those subdirs. Those tests will all be run using the default settings. To run the tests with your own settings file you must use the --settings option: evennia --settings settings.py test . The --settings option of Evennia takes a file name in the mygame/server/conf folder. It is normally used to swap settings files for testing and development. In combination with test , it forces Evennia to use this settings file over the default one. Writing new tests \u00b6 Evennia's test suite makes use of Django unit test system, which in turn relies on Python's unittest module. If you want to help out writing unittests for Evennia, take a look at Evennia's coveralls.io page . There you see which modules have any form of test coverage and which does not. To make the test runner find the tests, they must be put in a module named test*.py (so test.py , tests.py etc). Such a test module will be found wherever it is in the package. It can be a good idea to look at some of Evennia's tests.py modules to see how they look. Inside a testing file, a unittest.TestCase class is used to test a single aspect or component in various ways. Each test case contains one ore more test methods - these define the actual tests to run. You can name the test methods anything you want as long as the name starts with \" test_ \". Your TestCase class can also have a method setUp() . This is run before each test, setting up and storing whatever preparations the test methods need. Conversely, a tearDown() method can optionally do cleanup after each test. To test the results, you use special methods of the TestCase class. Many of those start with \" assert \", such as assertEqual or assertTrue . Example of a TestCase class: import unittest # the function we want to test from mypath import myfunc class TestObj(unittest.TestCase): \"This tests a function myfunc.\" def test_return_value(self): \"test method. Makes sure return value is as expected.\" expected_return = \"This is me being nice.\" actual_return = myfunc() # test self.assertEqual(expected_return, actual_return) def test_alternative_call(self): \"test method. Calls with a keyword argument.\" expected_return = \"This is me being baaaad.\" actual_return = myfunc(bad=True) # test self.assertEqual(expected_return, actual_return) You might also want to read the documentation for the unittest module . Using the EvenniaTest class \u00b6 Evennia offers a custom TestCase, the evennia.utils.test_resources.EvenniaTest class. This class initiates a range of useful properties on themselves for testing Evennia systems. Examples are .account and .session representing a mock connected Account and its Session and .char1 and char2 representing Characters complete with a location in the test database. These are all useful when testing Evennia system requiring any of the default Evennia typeclasses as inputs. See the full definition of the EvenniaTest class in evennia/utils/test_resources.py . # in a test module from evennia.utils.test_resources import EvenniaTest class TestObject(EvenniaTest): def test_object_search(self): # char1 and char2 are both created in room1 self.assertEqual(self.char1.search(self.char2.key), self.char2) self.assertEqual(self.char1.search(self.char1.location.key), self.char1.location) # ... Testing in-game Commands \u00b6 In-game Commands are a special case. Tests for the default commands are put in evennia/commands/default/tests.py . This uses a custom CommandTest class that inherits from evennia.utils.test_resources.EvenniaTest described above. CommandTest supplies extra convenience functions for executing commands and check that their return values (calls of msg() returns expected values. It uses Characters and Sessions generated on the EvenniaTest class to call each class). Each command tested should have its own TestCase class. Inherit this class from the CommandTest class in the same module to get access to the command-specific utilities mentioned. from evennia.commands.default.tests import CommandTest from evennia.commands.default import general class TestSet(CommandTest): \"tests the look command by simple call, using Char2 as a target\" def test_mycmd_char(self): self.call(general.CmdLook(), \"Char2\", \"Char2(#7)\") \"tests the look command by simple call, with target as room\" def test_mycmd_room(self): self.call(general.CmdLook(), \"Room\", \"Room(#1)\\nroom_desc\\nExits: out(#3)\\n\" \"You see: Obj(#4), Obj2(#5), Char2(#7)\") Unit testing contribs with custom models \u00b6 A special case is if you were to create a contribution to go to the evennia/contrib folder that uses its own database models . The problem with this is that Evennia (and Django) will only recognize models in settings.INSTALLED_APPS . If a user wants to use your contrib, they will be required to add your models to their settings file. But since contribs are optional you cannot add the model to Evennia's central settings_default.py file - this would always create your optional models regardless of if the user wants them. But at the same time a contribution is a part of the Evennia distribution and its unit tests should be run with all other Evennia tests using evennia test evennia . The way to do this is to only temporarily add your models to the INSTALLED_APPS directory when the test runs. here is an example of how to do it. Note that this solution, derived from this stackexchange answer is currently untested! Please report your findings. # a file contrib/mycontrib/tests.py from django.conf import settings import django from evennia.utils.test_resources import EvenniaTest OLD_DEFAULT_SETTINGS = settings.INSTALLED_APPS DEFAULT_SETTINGS = dict( INSTALLED_APPS=( 'contrib.mycontrib.tests', ), DATABASES={ \"default\": { \"ENGINE\": \"django.db.backends.sqlite3\" } }, SILENCED_SYSTEM_CHECKS=[\"1_7.W001\"], ) class TestMyModel(EvenniaTest): def setUp(self): if not settings.configured: settings.configure(**DEFAULT_SETTINGS) django.setup() from django.core.management import call_command from django.db.models import loading loading.cache.loaded = False call_command('syncdb', verbosity=0) def tearDown(self): settings.configure(**OLD_DEFAULT_SETTINGS) django.setup() from django.core.management import call_command from django.db.models import loading loading.cache.loaded = False call_command('syncdb', verbosity=0) # test cases below ... def test_case(self): # test case here A note on adding new tests \u00b6 Having an extensive tests suite is very important for avoiding code degradation as Evennia is developed. Only a small fraction of the Evennia codebase is covered by test suites at this point. Writing new tests is not hard, it's more a matter of finding the time to do so. So adding new tests is really an area where everyone can contribute, also with only limited Python skills. A note on making the test runner faster \u00b6 If you have custom models with a large number of migrations, creating the test database can take a very long time. If you don't require migrations to run for your tests, you can disable them with the django-test-without-migrations package. To install it, simply: $ pip install django-test-without-migrations Then add it to your INSTALLED_APPS in your server.conf.settings.py : INSTALLED_APPS = ( # ... 'test_without_migrations', ) After doing so, you can then run tests without migrations by adding the --nomigrations argument: evennia test --settings settings.py --nomigrations . Testing for Game development (mini-tutorial) \u00b6 Unit testing can be of paramount importance to game developers. When starting with a new game, it is recommended to look into unit testing as soon as possible; an already huge game is much harder to write tests for. The benefits of testing a game aren't different from the ones regarding library testing. For example it is easy to introduce bugs that affect previously working code. Testing is there to ensure your project behaves the way it should and continue to do so. If you have never used unit testing (with Python or another language), you might want to check the official Python documentation about unit testing , particularly the first section dedicated to a basic example. Basic testing using Evennia \u00b6 Evennia's test runner can be used to launch tests in your game directory (let's call it 'mygame'). Evennia's test runner does a few useful things beyond the normal Python unittest module: It creates and sets up an empty database, with some useful objects (accounts, characters and rooms, among others). It provides simple ways to test commands, which can be somewhat tricky at times, if not tested properly. Therefore, you should use the command-line to execute the test runner, while specifying your own game directories (not the one containing evennia). Go to your game directory (referred as 'mygame' in this section) and execute the test runner: evennia --settings settings.py test commands This command will execute Evennia's test runner using your own settings file. It will set up a dummy database of your choice and look into the 'commands' package defined in your game directory ( mygame/commands in this example) to find tests. The test module's name should begin with 'test' and contain one or more TestCase . A full example can be found below. A simple example \u00b6 In your game directory, go to commands and create a new file tests.py inside (it could be named anything starting with test ). We will start by making a test that has nothing to do with Commands, just to show how unit testing works: # mygame/commands/tests.py import unittest class TestString(unittest.TestCase): \"\"\"Unittest for strings (just a basic example).\"\"\" def test_upper(self): \"\"\"Test the upper() str method.\"\"\" self.assertEqual('foo'.upper(), 'FOO') This example, inspired from the Python documentation, is used to test the 'upper()' method of the 'str' class. Not very useful, but it should give you a basic idea of how tests are used. Let's execute that test to see if it works. > evennia --settings settings.py test commands TESTING: Using specified settings file 'server.conf.settings'. (Obs: Evennia's full test suite may not pass if the settings are very different from the default. Use 'test .' as arguments to run only tests on the game dir.) Creating test database for alias 'default'... . ---------------------------------------------------------------------- Ran 1 test in 0.001s OK Destroying test database for alias 'default'... We specified the commands package to the evennia test command since that's where we put our test file. In this case we could just as well just said . to search all of mygame for testing files. If we have a lot of tests it may be useful to test only a single set at a time though. We get an information text telling us we are using our custom settings file (instead of Evennia's default file) and then the test runs. The test passes! Change the \"FOO\" string to something else in the test to see how it looks when it fails. Testing commands \u00b6 This section will test the proper execution of the 'abilities' command, as described in the First Steps Coding page. Follow this tutorial to create the 'abilities' command, we will need it to test it. Testing commands in Evennia is a bit more complex than the simple testing example we have seen. Luckily, Evennia supplies a special test class to do just that ... we just need to inherit from it and use it properly. This class is called 'CommandTest' and is defined in the 'evennia.commands.default.tests' package. To create a test for our 'abilities' command, we just need to create a class that inherits from 'CommandTest' and add methods. We could create a new test file for this but for now we just append to the tests.py file we already have in commands from before. # bottom of mygame/commands/tests.py from evennia.commands.default.tests import CommandTest from commands.command import CmdAbilities from typeclasses.characters import Character class TestAbilities(CommandTest): character_typeclass = Character def test_simple(self): self.call(CmdAbilities(), \"\", \"STR: 5, AGI: 4, MAG: 2\") Line 1-4: we do some importing. 'CommandTest' is going to be our base class for our test, so we need it. We also import our command ('CmdAbilities' in this case). Finally we import the 'Character' typeclass. We need it, since 'CommandTest' doesn't use 'Character', but 'DefaultCharacter', which means the character calling the command won't have the abilities we have written in the 'Character' typeclass. Line 6-8: that's the body of our test. Here, a single command is tested in an entire class. Default commands are usually grouped by category in a single class. There is no rule, as long as you know where you put your tests. Note that we set the 'character_typeclass' class attribute to Character. As explained above, if you didn't do that, the system would create a 'DefaultCharacter' object, not a 'Character'. You can try to remove line 4 and 8 to see what happens when running the test. Line 10-11: our unique testing method. Note its name: it should begin by 'test_'. Apart from that, the method is quite simple: it's an instance method (so it takes the 'self' argument) but no other arguments are needed. Line 11 uses the 'call' method, which is defined in 'CommandTest'. It's a useful method that compares a command against an expected result. It would be like comparing two strings with 'assertEqual', but the 'call' method does more things, including testing the command in a realistic way (calling its hooks in the right order, so you don't have to worry about that). Line 11 can be understood as: test the 'abilities' command (first parameter), with no argument (second parameter), and check that the character using it receives his/her abilities (third parameter). Let's run our new test: > evennia --settings settings.py test commands [...] Creating test database for alias 'default'... .. ---------------------------------------------------------------------- Ran 2 tests in 0.156s OK Destroying test database for alias 'default'... Two tests were executed, since we have kept 'TestString' from last time. In case of failure, you will get much more information to help you fix the bug.","title":"Unit Testing"},{"location":"Unit-Testing.html#running-the-evennia-test-suite","text":"To run the full Evennia test suite, go to your game folder and issue the command evennia test evennia This will run all the evennia tests using the default settings. You could also run only a subset of all tests by specifying a subpackage of the library: evennia test evennia.commands.default A temporary database will be instantiated to manage the tests. If everything works out you will see how many tests were run and how long it took. If something went wrong you will get error messages. If you contribute to Evennia, this is a useful sanity check to see you haven't introduced an unexpected bug.","title":"Running the Evennia test suite"},{"location":"Unit-Testing.html#running-tests-with-custom-settings-file","text":"If you have implemented your own tests for your game (see below) you can run them from your game dir with evennia test . The period ( . ) means to run all tests found in the current directory and all subdirectories. You could also specify, say, typeclasses or world if you wanted to just run tests in those subdirs. Those tests will all be run using the default settings. To run the tests with your own settings file you must use the --settings option: evennia --settings settings.py test . The --settings option of Evennia takes a file name in the mygame/server/conf folder. It is normally used to swap settings files for testing and development. In combination with test , it forces Evennia to use this settings file over the default one.","title":"Running tests with custom settings file"},{"location":"Unit-Testing.html#writing-new-tests","text":"Evennia's test suite makes use of Django unit test system, which in turn relies on Python's unittest module. If you want to help out writing unittests for Evennia, take a look at Evennia's coveralls.io page . There you see which modules have any form of test coverage and which does not. To make the test runner find the tests, they must be put in a module named test*.py (so test.py , tests.py etc). Such a test module will be found wherever it is in the package. It can be a good idea to look at some of Evennia's tests.py modules to see how they look. Inside a testing file, a unittest.TestCase class is used to test a single aspect or component in various ways. Each test case contains one ore more test methods - these define the actual tests to run. You can name the test methods anything you want as long as the name starts with \" test_ \". Your TestCase class can also have a method setUp() . This is run before each test, setting up and storing whatever preparations the test methods need. Conversely, a tearDown() method can optionally do cleanup after each test. To test the results, you use special methods of the TestCase class. Many of those start with \" assert \", such as assertEqual or assertTrue . Example of a TestCase class: import unittest # the function we want to test from mypath import myfunc class TestObj(unittest.TestCase): \"This tests a function myfunc.\" def test_return_value(self): \"test method. Makes sure return value is as expected.\" expected_return = \"This is me being nice.\" actual_return = myfunc() # test self.assertEqual(expected_return, actual_return) def test_alternative_call(self): \"test method. Calls with a keyword argument.\" expected_return = \"This is me being baaaad.\" actual_return = myfunc(bad=True) # test self.assertEqual(expected_return, actual_return) You might also want to read the documentation for the unittest module .","title":"Writing new tests"},{"location":"Unit-Testing.html#using-the-evenniatest-class","text":"Evennia offers a custom TestCase, the evennia.utils.test_resources.EvenniaTest class. This class initiates a range of useful properties on themselves for testing Evennia systems. Examples are .account and .session representing a mock connected Account and its Session and .char1 and char2 representing Characters complete with a location in the test database. These are all useful when testing Evennia system requiring any of the default Evennia typeclasses as inputs. See the full definition of the EvenniaTest class in evennia/utils/test_resources.py . # in a test module from evennia.utils.test_resources import EvenniaTest class TestObject(EvenniaTest): def test_object_search(self): # char1 and char2 are both created in room1 self.assertEqual(self.char1.search(self.char2.key), self.char2) self.assertEqual(self.char1.search(self.char1.location.key), self.char1.location) # ...","title":"Using the EvenniaTest class"},{"location":"Unit-Testing.html#testing-in-game-commands","text":"In-game Commands are a special case. Tests for the default commands are put in evennia/commands/default/tests.py . This uses a custom CommandTest class that inherits from evennia.utils.test_resources.EvenniaTest described above. CommandTest supplies extra convenience functions for executing commands and check that their return values (calls of msg() returns expected values. It uses Characters and Sessions generated on the EvenniaTest class to call each class). Each command tested should have its own TestCase class. Inherit this class from the CommandTest class in the same module to get access to the command-specific utilities mentioned. from evennia.commands.default.tests import CommandTest from evennia.commands.default import general class TestSet(CommandTest): \"tests the look command by simple call, using Char2 as a target\" def test_mycmd_char(self): self.call(general.CmdLook(), \"Char2\", \"Char2(#7)\") \"tests the look command by simple call, with target as room\" def test_mycmd_room(self): self.call(general.CmdLook(), \"Room\", \"Room(#1)\\nroom_desc\\nExits: out(#3)\\n\" \"You see: Obj(#4), Obj2(#5), Char2(#7)\")","title":"Testing in-game Commands"},{"location":"Unit-Testing.html#unit-testing-contribs-with-custom-models","text":"A special case is if you were to create a contribution to go to the evennia/contrib folder that uses its own database models . The problem with this is that Evennia (and Django) will only recognize models in settings.INSTALLED_APPS . If a user wants to use your contrib, they will be required to add your models to their settings file. But since contribs are optional you cannot add the model to Evennia's central settings_default.py file - this would always create your optional models regardless of if the user wants them. But at the same time a contribution is a part of the Evennia distribution and its unit tests should be run with all other Evennia tests using evennia test evennia . The way to do this is to only temporarily add your models to the INSTALLED_APPS directory when the test runs. here is an example of how to do it. Note that this solution, derived from this stackexchange answer is currently untested! Please report your findings. # a file contrib/mycontrib/tests.py from django.conf import settings import django from evennia.utils.test_resources import EvenniaTest OLD_DEFAULT_SETTINGS = settings.INSTALLED_APPS DEFAULT_SETTINGS = dict( INSTALLED_APPS=( 'contrib.mycontrib.tests', ), DATABASES={ \"default\": { \"ENGINE\": \"django.db.backends.sqlite3\" } }, SILENCED_SYSTEM_CHECKS=[\"1_7.W001\"], ) class TestMyModel(EvenniaTest): def setUp(self): if not settings.configured: settings.configure(**DEFAULT_SETTINGS) django.setup() from django.core.management import call_command from django.db.models import loading loading.cache.loaded = False call_command('syncdb', verbosity=0) def tearDown(self): settings.configure(**OLD_DEFAULT_SETTINGS) django.setup() from django.core.management import call_command from django.db.models import loading loading.cache.loaded = False call_command('syncdb', verbosity=0) # test cases below ... def test_case(self): # test case here","title":"Unit testing contribs with custom models"},{"location":"Unit-Testing.html#a-note-on-adding-new-tests","text":"Having an extensive tests suite is very important for avoiding code degradation as Evennia is developed. Only a small fraction of the Evennia codebase is covered by test suites at this point. Writing new tests is not hard, it's more a matter of finding the time to do so. So adding new tests is really an area where everyone can contribute, also with only limited Python skills.","title":"A note on adding new tests"},{"location":"Unit-Testing.html#a-note-on-making-the-test-runner-faster","text":"If you have custom models with a large number of migrations, creating the test database can take a very long time. If you don't require migrations to run for your tests, you can disable them with the django-test-without-migrations package. To install it, simply: $ pip install django-test-without-migrations Then add it to your INSTALLED_APPS in your server.conf.settings.py : INSTALLED_APPS = ( # ... 'test_without_migrations', ) After doing so, you can then run tests without migrations by adding the --nomigrations argument: evennia test --settings settings.py --nomigrations .","title":"A note on making the test runner faster"},{"location":"Unit-Testing.html#testing-for-game-development-mini-tutorial","text":"Unit testing can be of paramount importance to game developers. When starting with a new game, it is recommended to look into unit testing as soon as possible; an already huge game is much harder to write tests for. The benefits of testing a game aren't different from the ones regarding library testing. For example it is easy to introduce bugs that affect previously working code. Testing is there to ensure your project behaves the way it should and continue to do so. If you have never used unit testing (with Python or another language), you might want to check the official Python documentation about unit testing , particularly the first section dedicated to a basic example.","title":"Testing for Game development (mini-tutorial)"},{"location":"Unit-Testing.html#basic-testing-using-evennia","text":"Evennia's test runner can be used to launch tests in your game directory (let's call it 'mygame'). Evennia's test runner does a few useful things beyond the normal Python unittest module: It creates and sets up an empty database, with some useful objects (accounts, characters and rooms, among others). It provides simple ways to test commands, which can be somewhat tricky at times, if not tested properly. Therefore, you should use the command-line to execute the test runner, while specifying your own game directories (not the one containing evennia). Go to your game directory (referred as 'mygame' in this section) and execute the test runner: evennia --settings settings.py test commands This command will execute Evennia's test runner using your own settings file. It will set up a dummy database of your choice and look into the 'commands' package defined in your game directory ( mygame/commands in this example) to find tests. The test module's name should begin with 'test' and contain one or more TestCase . A full example can be found below.","title":"Basic testing using Evennia"},{"location":"Unit-Testing.html#a-simple-example","text":"In your game directory, go to commands and create a new file tests.py inside (it could be named anything starting with test ). We will start by making a test that has nothing to do with Commands, just to show how unit testing works: # mygame/commands/tests.py import unittest class TestString(unittest.TestCase): \"\"\"Unittest for strings (just a basic example).\"\"\" def test_upper(self): \"\"\"Test the upper() str method.\"\"\" self.assertEqual('foo'.upper(), 'FOO') This example, inspired from the Python documentation, is used to test the 'upper()' method of the 'str' class. Not very useful, but it should give you a basic idea of how tests are used. Let's execute that test to see if it works. > evennia --settings settings.py test commands TESTING: Using specified settings file 'server.conf.settings'. (Obs: Evennia's full test suite may not pass if the settings are very different from the default. Use 'test .' as arguments to run only tests on the game dir.) Creating test database for alias 'default'... . ---------------------------------------------------------------------- Ran 1 test in 0.001s OK Destroying test database for alias 'default'... We specified the commands package to the evennia test command since that's where we put our test file. In this case we could just as well just said . to search all of mygame for testing files. If we have a lot of tests it may be useful to test only a single set at a time though. We get an information text telling us we are using our custom settings file (instead of Evennia's default file) and then the test runs. The test passes! Change the \"FOO\" string to something else in the test to see how it looks when it fails.","title":"A simple example"},{"location":"Unit-Testing.html#testing-commands","text":"This section will test the proper execution of the 'abilities' command, as described in the First Steps Coding page. Follow this tutorial to create the 'abilities' command, we will need it to test it. Testing commands in Evennia is a bit more complex than the simple testing example we have seen. Luckily, Evennia supplies a special test class to do just that ... we just need to inherit from it and use it properly. This class is called 'CommandTest' and is defined in the 'evennia.commands.default.tests' package. To create a test for our 'abilities' command, we just need to create a class that inherits from 'CommandTest' and add methods. We could create a new test file for this but for now we just append to the tests.py file we already have in commands from before. # bottom of mygame/commands/tests.py from evennia.commands.default.tests import CommandTest from commands.command import CmdAbilities from typeclasses.characters import Character class TestAbilities(CommandTest): character_typeclass = Character def test_simple(self): self.call(CmdAbilities(), \"\", \"STR: 5, AGI: 4, MAG: 2\") Line 1-4: we do some importing. 'CommandTest' is going to be our base class for our test, so we need it. We also import our command ('CmdAbilities' in this case). Finally we import the 'Character' typeclass. We need it, since 'CommandTest' doesn't use 'Character', but 'DefaultCharacter', which means the character calling the command won't have the abilities we have written in the 'Character' typeclass. Line 6-8: that's the body of our test. Here, a single command is tested in an entire class. Default commands are usually grouped by category in a single class. There is no rule, as long as you know where you put your tests. Note that we set the 'character_typeclass' class attribute to Character. As explained above, if you didn't do that, the system would create a 'DefaultCharacter' object, not a 'Character'. You can try to remove line 4 and 8 to see what happens when running the test. Line 10-11: our unique testing method. Note its name: it should begin by 'test_'. Apart from that, the method is quite simple: it's an instance method (so it takes the 'self' argument) but no other arguments are needed. Line 11 uses the 'call' method, which is defined in 'CommandTest'. It's a useful method that compares a command against an expected result. It would be like comparing two strings with 'assertEqual', but the 'call' method does more things, including testing the command in a realistic way (calling its hooks in the right order, so you don't have to worry about that). Line 11 can be understood as: test the 'abilities' command (first parameter), with no argument (second parameter), and check that the character using it receives his/her abilities (third parameter). Let's run our new test: > evennia --settings settings.py test commands [...] Creating test database for alias 'default'... .. ---------------------------------------------------------------------- Ran 2 tests in 0.156s OK Destroying test database for alias 'default'... Two tests were executed, since we have kept 'TestString' from last time. In case of failure, you will get much more information to help you fix the bug.","title":"Testing commands"},{"location":"Updating-Your-Game.html","text":"Fortunately, it's extremely easy to keep your Evennia server up-to-date. If you haven't already, see the Getting Started guide and get everything running. Updating with the latest Evennia code changes \u00b6 Very commonly we make changes to the Evennia code to improve things. There are many ways to get told when to update: You can subscribe to the RSS feed or manually check up on the feeds from http://www.evennia.com. You can also simply fetch the latest regularly. When you're wanting to apply updates, simply cd to your cloned evennia root directory and type: git pull assuming you've got the command line client. If you're using a graphical client, you will probably want to navigate to the evennia directory and either right click and find your client's pull function, or use one of the menus (if applicable). You can review the latest changes with git log or the equivalent in the graphical client. You can also see the latest changes online here . You will always need to do evennia reload (or reload from -in-game) from your game-dir to have the new code affect your game. If you want to be really sure you should run a full evennia reboot so that both Server and Portal can restart (this will disconnect everyone though, so if you know the Portal has had no updates you don't have to do that). Upgrading Evennia dependencies \u00b6 On occasion we update the versions of third-party libraries Evennia depend on (or we may add a new dependency). This will be announced on the mailing list/forum. If you run into errors when starting Evennia, always make sure you have the latest versions of everything. In some cases, like for Django, starting the server may also give warning saying that you are using a working, but too-old version that should not be used in production. Upgrading evennia will automatically fetch all the latest packages that it now need. First cd to your cloned evennia folder. Make sure your virtualenv is active and use pip install --upgrade -e . Remember the period ( . ) at the end - that applies the upgrade to the current location (your evennia dir). The -e means that we are linking the evennia sources rather than copying them into the environment. This means we can most of the time just update the sources (with git pull ) and see those changes directly applied to our installed evennia package. Without installing/upgrading the package with -e , we would have to remember to upgrade the package every time we downloaded any new source-code changes. Follow the upgrade output to make sure it finishes without errors. To check what packages are currently available in your python environment after the upgrade, use pip list This will show you the version of all installed packages. The evennia package will also show the location of its source code. Migrating the Database Schema \u00b6 Whenever we change the database layout of Evennia upstream (such as when we add new features) you will need to migrate your existing database. When this happens it will be clearly noted in the git log (it will say something to the effect of \"Run migrations\"). Database changes will also be announced on the Evennia mailing list . When the database schema changes, you just go to your game folder and run evennia migrate Hint: If the evennia command is not found, you most likely need to activate your virtualenv . Resetting your database \u00b6 Should you ever want to start over completely from scratch, there is no need to re-download Evennia or anything like that. You just need to clear your database. Once you are done, you just rebuild it from scratch as described in step 2 of the Getting Started guide . First stop a running server with evennia stop If you run the default SQlite3 database (to change this you need to edit your settings.py file), the database is actually just a normal file in mygame/server/ called evennia.db3 . Simply delete that file - that's it. Now run evennia migrate to recreate a new, fresh one. If you run some other database system you can instead flush the database: evennia flush This will empty the database. However, it will not reset the internal counters of the database, so you will start with higher dbref values. If this is okay, this is all you need. Django also offers an easy way to start the database's own management should we want more direct control: evennia dbshell In e.g. MySQL you can then do something like this (assuming your MySQL database is named \"Evennia\": mysql> DROP DATABASE Evennia; mysql> exit NOTE: Under Windows OS, in order to access SQLite dbshell you need to download the SQLite command-line shell program . It's a single executable file (sqlite3.exe) that you should place in the root of either your MUD folder or Evennia's (it's the same, in both cases Django will find it). More about schema migrations \u00b6 If and when an Evennia update modifies the database schema (that is, the under-the-hood details as to how data is stored in the database), you must update your existing database correspondingly to match the change. If you don't, the updated Evennia will complain that it cannot read the database properly. Whereas schema changes should become more and more rare as Evennia matures, it may still happen from time to time. One way one could handle this is to apply the changes manually to your database using the database's command line. This often means adding/removing new tables or fields as well as possibly convert existing data to match what the new Evennia version expects. It should be quite obvious that this quickly becomes cumbersome and error-prone. If your database doesn't contain anything critical yet it's probably easiest to simply reset it and start over rather than to bother converting. Enter migrations . Migrations keeps track of changes in the database schema and applies them automatically for you. Basically, whenever the schema changes we distribute small files called \"migrations\" with the source. Those tell the system exactly how to implement the change so you don't have to do so manually. When a migration has been added we will tell you so on Evennia's mailing lists and in commit messages - you then just run evennia migrate to be up-to-date again.","title":"Updating Your Game"},{"location":"Updating-Your-Game.html#updating-with-the-latest-evennia-code-changes","text":"Very commonly we make changes to the Evennia code to improve things. There are many ways to get told when to update: You can subscribe to the RSS feed or manually check up on the feeds from http://www.evennia.com. You can also simply fetch the latest regularly. When you're wanting to apply updates, simply cd to your cloned evennia root directory and type: git pull assuming you've got the command line client. If you're using a graphical client, you will probably want to navigate to the evennia directory and either right click and find your client's pull function, or use one of the menus (if applicable). You can review the latest changes with git log or the equivalent in the graphical client. You can also see the latest changes online here . You will always need to do evennia reload (or reload from -in-game) from your game-dir to have the new code affect your game. If you want to be really sure you should run a full evennia reboot so that both Server and Portal can restart (this will disconnect everyone though, so if you know the Portal has had no updates you don't have to do that).","title":"Updating with the latest Evennia code changes"},{"location":"Updating-Your-Game.html#upgrading-evennia-dependencies","text":"On occasion we update the versions of third-party libraries Evennia depend on (or we may add a new dependency). This will be announced on the mailing list/forum. If you run into errors when starting Evennia, always make sure you have the latest versions of everything. In some cases, like for Django, starting the server may also give warning saying that you are using a working, but too-old version that should not be used in production. Upgrading evennia will automatically fetch all the latest packages that it now need. First cd to your cloned evennia folder. Make sure your virtualenv is active and use pip install --upgrade -e . Remember the period ( . ) at the end - that applies the upgrade to the current location (your evennia dir). The -e means that we are linking the evennia sources rather than copying them into the environment. This means we can most of the time just update the sources (with git pull ) and see those changes directly applied to our installed evennia package. Without installing/upgrading the package with -e , we would have to remember to upgrade the package every time we downloaded any new source-code changes. Follow the upgrade output to make sure it finishes without errors. To check what packages are currently available in your python environment after the upgrade, use pip list This will show you the version of all installed packages. The evennia package will also show the location of its source code.","title":"Upgrading Evennia dependencies"},{"location":"Updating-Your-Game.html#migrating-the-database-schema","text":"Whenever we change the database layout of Evennia upstream (such as when we add new features) you will need to migrate your existing database. When this happens it will be clearly noted in the git log (it will say something to the effect of \"Run migrations\"). Database changes will also be announced on the Evennia mailing list . When the database schema changes, you just go to your game folder and run evennia migrate Hint: If the evennia command is not found, you most likely need to activate your virtualenv .","title":"Migrating the Database Schema"},{"location":"Updating-Your-Game.html#resetting-your-database","text":"Should you ever want to start over completely from scratch, there is no need to re-download Evennia or anything like that. You just need to clear your database. Once you are done, you just rebuild it from scratch as described in step 2 of the Getting Started guide . First stop a running server with evennia stop If you run the default SQlite3 database (to change this you need to edit your settings.py file), the database is actually just a normal file in mygame/server/ called evennia.db3 . Simply delete that file - that's it. Now run evennia migrate to recreate a new, fresh one. If you run some other database system you can instead flush the database: evennia flush This will empty the database. However, it will not reset the internal counters of the database, so you will start with higher dbref values. If this is okay, this is all you need. Django also offers an easy way to start the database's own management should we want more direct control: evennia dbshell In e.g. MySQL you can then do something like this (assuming your MySQL database is named \"Evennia\": mysql> DROP DATABASE Evennia; mysql> exit NOTE: Under Windows OS, in order to access SQLite dbshell you need to download the SQLite command-line shell program . It's a single executable file (sqlite3.exe) that you should place in the root of either your MUD folder or Evennia's (it's the same, in both cases Django will find it).","title":"Resetting your database"},{"location":"Updating-Your-Game.html#more-about-schema-migrations","text":"If and when an Evennia update modifies the database schema (that is, the under-the-hood details as to how data is stored in the database), you must update your existing database correspondingly to match the change. If you don't, the updated Evennia will complain that it cannot read the database properly. Whereas schema changes should become more and more rare as Evennia matures, it may still happen from time to time. One way one could handle this is to apply the changes manually to your database using the database's command line. This often means adding/removing new tables or fields as well as possibly convert existing data to match what the new Evennia version expects. It should be quite obvious that this quickly becomes cumbersome and error-prone. If your database doesn't contain anything critical yet it's probably easiest to simply reset it and start over rather than to bother converting. Enter migrations . Migrations keeps track of changes in the database schema and applies them automatically for you. Basically, whenever the schema changes we distribute small files called \"migrations\" with the source. Those tell the system exactly how to implement the change so you don't have to do so manually. When a migration has been added we will tell you so on Evennia's mailing lists and in commit messages - you then just run evennia migrate to be up-to-date again.","title":"More about schema migrations"},{"location":"Using-MUX-as-a-Standard.html","text":"Evennia allows for any command syntax. If you like the way DikuMUDs, LPMuds or MOOs handle things, you could emulate that with Evennia. If you are ambitious you could even design a whole new style, perfectly fitting your own dreams of the ideal game. We do offer a default however. The default Evennia setup tends to resemble MUX2 , and its cousins PennMUSH , TinyMUSH , and RhostMUSH . While the reason for this similarity is partly historical, these codebases offer very mature feature sets for administration and building. Evennia is not a MUX system though. It works very differently in many ways. For example, Evennia deliberately lacks an online softcode language (a policy explained on our softcode policy page ). Evennia also does not shy from using its own syntax when deemed appropriate: the MUX syntax has grown organically over a long time and is, frankly, rather arcane in places. All in all the default command syntax should at most be referred to as \"MUX-like\" or \"MUX-inspired\". Documentation policy \u00b6 All the commands in the default command sets should have their doc-strings formatted on a similar form: \"\"\" Short header Usage: key[/switches, if any] <mandatory args> [optional] choice1||choice2||choice3 Switches: switch1 - description switch2 - description Examples: usage example and output Longer documentation detailing the command. \"\"\" Two spaces are used for indentation in all default commands. Square brackets [ ] surround optional, skippable arguments . Angled brackets < > surround a description of what to write rather than the exact syntax. *Explicit choices are separated by | . To avoid this being parsed as a color code, use || (this will come out as a single | ) or put spaces around the character (\" | \") if there's plenty of room. The Switches and Examples blocks are optional based on the Command. Here is the nick command as an example: \"\"\" Define a personal alias/nick Usage: nick[/switches] <nickname> = [<string>] alias '' Switches: object - alias an object account - alias an account clearall - clear all your aliases list - show all defined aliases (also \"nicks\" works) Examples: nick hi = say Hello, I'm Sarah! nick/object tom = the tall man A 'nick' is a personal shortcut you create for your own use [...] \"\"\" For commands that require arguments , the policy is for it to return a Usage: string if the command is entered without any arguments. So for such commands, the Command body should contain something to the effect of if not self.args: self.caller.msg(\"Usage: nick[/switches] <nickname> = [<string>]\") return","title":"Using MUX as a Standard"},{"location":"Using-MUX-as-a-Standard.html#documentation-policy","text":"All the commands in the default command sets should have their doc-strings formatted on a similar form: \"\"\" Short header Usage: key[/switches, if any] <mandatory args> [optional] choice1||choice2||choice3 Switches: switch1 - description switch2 - description Examples: usage example and output Longer documentation detailing the command. \"\"\" Two spaces are used for indentation in all default commands. Square brackets [ ] surround optional, skippable arguments . Angled brackets < > surround a description of what to write rather than the exact syntax. *Explicit choices are separated by | . To avoid this being parsed as a color code, use || (this will come out as a single | ) or put spaces around the character (\" | \") if there's plenty of room. The Switches and Examples blocks are optional based on the Command. Here is the nick command as an example: \"\"\" Define a personal alias/nick Usage: nick[/switches] <nickname> = [<string>] alias '' Switches: object - alias an object account - alias an account clearall - clear all your aliases list - show all defined aliases (also \"nicks\" works) Examples: nick hi = say Hello, I'm Sarah! nick/object tom = the tall man A 'nick' is a personal shortcut you create for your own use [...] \"\"\" For commands that require arguments , the policy is for it to return a Usage: string if the command is entered without any arguments. So for such commands, the Command body should contain something to the effect of if not self.args: self.caller.msg(\"Usage: nick[/switches] <nickname> = [<string>]\") return","title":"Documentation policy"},{"location":"Using-Travis.html","text":"Evennia uses Travis CI to check that it's building successfully after every commit to its Github repository (you can for example see the build: passing badge at the top of Evennia's Readme file ). If your game is open source on Github you may also use Travis for free. See the Travis docs for how to get started. After logging in you will get to point Travis to your repository on github. One further thing you need to set up yourself is a Travis config file named .travis.yml (note the initial period . ). This should be created in the root of your game directory. The idea with this file is that it describes what Travis needs to import and build in order to create an instance of Evennia from scratch and then run validation tests on it. Here is an example: language: python python: - \"2.7\" install: - git clone https://github.com/evennia/evennia.git - cd evennia - pip install -e . - cd $TRAVIS_BUILD_DIR script: - evennia migrate - evennia test evennia - evennia test This will tell travis how to download Evennia, install it, set up a database and then run the test suite. You need to add this file to git ( git add .travis.yml ) and then commit your changes before Travis will be able to see it. For properly testing your game you of course also need to write unittests. We have a page on how we set those up for Evennia, you should be able to refer to that for making tests fitting your game.","title":"Using Travis"},{"location":"Version-Control.html","text":"Version control software allows you to track the changes you make to your code, as well as being able to easily backtrack these changes, share your development efforts and more. Even if you are not contributing to Evennia itself, and only wish to develop your own MU* using Evennia, having a version control system in place is a good idea (and standard coding practice). For an introduction to the concept, start with the Wikipedia article here . Evennia uses the version control system Git and this is what will be covered henceforth. Note that this page also deals with commands for Linux operating systems, and the steps below may vary for other systems, however where possible links will be provided for alternative instructions. For more help on using Git, please refer to the Official GitHub documentation . Setting up Git \u00b6 If you have gotten Evennia installed, you will have Git already and can skip to Step 2 below. Otherwise you will need to install Git on your platform. You can find expanded instructions for installation here . Step 1: Install Git \u00b6 Fedora Linux yum install git-core Debian Linux (Ubuntu, Linux Mint, etc.) apt-get install git Windows : It is recommended to use Git for Windows . Mac : Mac platforms offer two methods for installation, one via MacPorts, which you can find out about here , or you can use the Git OSX Installer . Step 2: Define user/e-mail Settings for Git \u00b6 To avoid a common issue later, you will need to set a couple of settings; first you will need to tell Git your username, followed by your e-mail address, so that when you commit code later you will be properly credited. Note that your commit information will be visible to everyone if you ever contribute to Evennia or use an online service like github to host your code. So if you are not comfortable with using your real, full name online, put a nickname here. Set the default name for git to use when you commit: git config --global user.name \"Your Name Here\" Set the default email for git to use when you commit: git config --global user.email \"your_email@example.com\" Putting your game folder under version control \u00b6 Note: The game folder's version control is completely separate from Evennia's repository. After you have set up your game you will have created a new folder to host your particular game (let's call this folder mygame for now). This folder is not under version control at this point. git init mygame Your mygame folder is now ready for version control! Now add all the content and make a first commit: cd mygame git add * git commit -m \"Initial commit\" Read on for help on what these commands do. Tracking files \u00b6 When working on your code or fix bugs in your local branches you may end up creating new files. If you do you must tell Git to track them by using the add command: git add <filename> You can check the current status of version control with git status . This will show if you have any modified, added or otherwise changed files. Some files, like database files, logs and temporary PID files are usually not tracked in version control. These should either not show up or have a question mark in front of them. Controlling tracking \u00b6 You will notice that some files are not covered by your git version control, notably your settings file ( mygame/server/conf/settings.py ) and your sqlite3 database file mygame/server/evennia.db3 . This is controlled by the hidden file mygame/.gitignore . Evennia creates this file as part of the creation of your game directory. Everything matched in this file will be ignored by GIT. If you want to, for example, include your settings file for collaborators to access, remove that entry in .gitignore . Note: You should never put your sqlite3 database file into git by removing its entry in .gitignore . GIT is for backing up your code, not your database. That way lies madness and a good chance you'll confuse yourself so that after a few commits and reverts don't know what is in your database or not. If you want to backup your database, do so by simply copying the file on your hard drive to a backup-name. Committing your Code \u00b6 Committing means storing the current snapshot of your code within git. This creates a \"save point\" or \"history\" of your development process. You can later jump back and forth in your history, for example to figure out just when a bug was introduced or see what results the code used to produce compared to now. It's usually a good idea to commit your changes often. Committing is fast and local only - you will never commit anything online at this point. To commit your changes, use git commit --all This will save all changes you made since last commit. The command will open a text editor where you can add a message detailing the changes you've made. Make it brief but informative. You can see the history of commits with git log . If you don't want to use the editor you can set the message directly by using the -m flag: git commit --all -m \"This fixes a bug in the combat code.\" Changing your mind \u00b6 If you have non-committed changes that you realize you want to throw away, you can do the following: git checkout <file to revert> This will revert the file to the state it was in at your last commit , throwing away the changes you did to it since. It's a good way to make wild experiments without having to remember just what you changed. If you do git checkout . you will throw away all changes since the last commit. Pushing your code online \u00b6 So far your code is only located on your private machine. A good idea is to back it up online. The easiest way to do this is to push it to your own remote repository on GitHub. Make sure you have your game directory setup under git version control as described above. Make sure to commit any changes. Create a new, empty repository on Github. Github explains how here (do not \"Initialize the repository with a README\" or else you'll create unrelated histories). From your local game dir, do git remote add origin <github URL> where <github URL> is the URL to your online repo. This tells your game dir that it should be pushing to the remote online dir. git remote -v to verify the online dir. git push origin master now pushes your game dir online so you can see it on github.com. You can commit your work locally ( git commit --all -m \"Make a change that ...\" ) as many times as you want. When you want to push those changes to your online repo, you do git push . You can also git clone <url_to_online_repo> from your online repo to somewhere else (like your production server) and henceforth do git pull to update that to the latest thing you pushed. Note that GitHub's repos are, by default publicly visible by all. Creating a publicly visible online clone might not be what you want for all parts of your development process - you may prefer a more private venue when sharing your revolutionary work with your team. If that's the case you can change your repository to \"Private\" in the github settings. Then your code will only be visible to those you specifically grant access. Forking Evennia \u00b6 This helps you set up an online fork of Evennia so you can easily commit fixes and help with upstream development. Step 1: Fork the evennia/master repository \u00b6 Before proceeding with the following step, make sure you have registered and created an account on GitHub.com . This is necessary in order to create a fork of Evennia's master repository, and to push your commits to your fork either for yourself or for contributing to Evennia. A fork is a clone of the master repository that you can make your own commits and changes to. At the top of this page , click the \"Fork\" button, as it appears below. Step 2: Clone your fork \u00b6 The fork only exists online as of yet. In a terminal, change your directory to the folder you wish to develop in. From this directory run the following command: git clone https://github.com/yourusername/evennia.git This will download your fork to your computer. It creates a new folder evennia/ at your current location. Step 3: Configure remotes \u00b6 A remote is a repository stored on another computer, in this case on GitHub's server. When a repository is cloned, it has a default remote called origin . This points to your fork on GitHub, not the original repository it was forked from. To easily keep track of the original repository (that is, Evennia's official repository), you need to add another remote. The standard name for this remote is \"upstream\". Below we change the active directory to the newly cloned \"evennia\" directory and then assign the original Evennia repository to a remote called \"upstream\": cd evennia git remote add upstream https://github.com/evennia/evennia.git If you also want to access Evennia's develop branch (the bleeding edge development branch) do the following: git fetch upstream develop git checkout develop You should now have the upstream branch available locally. You can use this instead of master below if you are contributing new features rather than bug fixes. Working with your fork \u00b6 A branch is a separate instance of your code. Changes you do to code in a branch does not affect that in other branches (so if you for example add/commit a file to one branch and then switches to another branch, that file will be gone until you switch back to the first branch again). One can switch between branches at will and create as many branches as one needs for a given project. The content of branches can also be merged together or deleted without affecting other branches. This is not only a common way to organize development but also to test features without messing with existing code. The default branch of git is called the \"master\" branch. As a rule of thumb, you should never make modifications directly to your local copy of the master branch. Rather keep the master clean and only update it by pulling our latest changes to it. Any work you do should instead happen in a local, other branches. Making a work branch \u00b6 git checkout -b myfixes This command will checkout and automatically create the new branch myfixes on your machine. If you stared out in the master branch, myfixes will be a perfect copy of the master branch. You can see which branch you are on with git branch and change between different branches with git checkout <branchname> . Branches are fast and cheap to create and manage. It is common practice to create a new branch for every bug you want to work on or feature you want to create, then create a pull request for that branch to be merged upstream (see below). Not only will this organize your work, it will also make sure that your master branch version of Evennia is always exactly in sync with the upstream version's master branch. Updating with upstream changes \u00b6 When Evennia's official repository updates, first make sure to commit all your changes to your branch and then checkout the \"clean\" master branch: git commit --all git checkout master Pull the latest changes from upstream: git pull upstream master This should sync your local master branch with upstream Evennia's master branch. Now we go back to our own work-branch (let's say it's still called \"myfixes\") and merge the updated master into our branch. git checkout myfixes git merge master If everything went well, your myfixes branch will now have the latest version of Evennia merged with whatever changes you have done. Use git log to see what has changed. You may need to restart the server or run manage.py migrate if the database schema changed (this will be seen in the commit log and on the mailing list). See the Git manuals for learning more about useful day-to-day commands, and special situations such as dealing with merge collisions. Sharing your Code Publicly \u00b6 Up to this point your myfixes branch only exists on your local computer. No one else can see it. If you want a copy of this branch to also appear in your online fork on GitHub, make sure to have checked out your \"myfixes\" branch and then run the following: git push -u origin myfixes This will create a new remote branch named \"myfixes\" in your online repository (which is refered to as \"origin\" by default); the -u flag makes sure to set this to the default push location. Henceforth you can just use git push from your myfixes branch to push your changes online. This is a great way to keep your source backed-up and accessible. Remember though that by default your repository will be public so everyone will be able to browse and download your code (same way as you can with Evennia itself). If you want secrecy you can change your repository to \"Private\" in the Github settings. Note though that if you do, you might have trouble contributing to Evennia (since we can't see the code you want to share). Note: If you hadn't setup a public key on GitHub or aren't asked for a username/password, you might get an error 403: Forbidden Access at this stage. In that case, some users have reported that the workaround is to create a file .netrc under your home directory and add your credentials there: machine github.com login <my_github_username> password <my_github_password> Committing fixes to Evennia \u00b6 Contributing can mean both bug-fixes or adding new features to Evennia. Please note that if your change is not already listed and accepted in the Issue Tracker , it is recommended that you first hit the developer mailing list or IRC chat to see beforehand if your feature is deemed suitable to include as a core feature in the engine. When it comes to bug-fixes, other developers may also have good input on how to go about resolving the issue. To contribute you need to have forked Evennia first. As described above you should do your modification in a separate local branch (not in the master branch). This branch is what you then present to us (as a Pull request , PR, see below). We can then merge your change into the upstream master and you then do git pull to update master usual. Now that the master is updated with your fixes, you can safely delete your local work branch. Below we describe this work flow. First update the Evennia master branch to the latest Evennia version: git checkout master git pull upstream master Next, create a new branch to hold your contribution. Let's call it the \"fixing_strange_bug\" branch: git checkout -b fixing_strange_bug It is wise to make separate branches for every fix or series of fixes you want to contribute. You are now in your new fixing_strange_bug branch. You can list all branches with git branch and jump between branches with git checkout <branchname> . Code and test things in here, committing as you go: git commit --all -m \"Fix strange bug in look command. Resolves #123.\" You can make multiple commits if you want, depending on your work flow and progress. Make sure to always make clear and descriptive commit messages so it's easy to see what you intended. To refer to, say, issue number 123, write #123 , it will turn to a link on GitHub. If you include the text \"Resolves #123\", that issue will be auto-closed on GitHub if your commit gets merged into main Evennia. If you refer to in-game commands that start with @ (such as @examine ), please put them in backticks `, for example `@examine`. The reason for this is that GitHub uses @username to refer to GitHub users, so if you forget the ticks, any user happening to be named examine will get a notification .... If you implement multiple separate features/bug-fixes, split them into different branches if they are very different and should be handled as separate PRs. You can do any number of commits to your branch as you work. Once you are at a stage where you want to show the world what you did you might want to consider making it clean for merging into Evennia's master branch by using git rebase (this is not always necessary, and if it sounds too hard, say so and we'll handle it on our end). Once you are ready, push your work to your online Evennia fork on github, in a new remote branch: git push -u origin fixing_strange_bug The -u flag is only needed the first time - this tells GIT to create a remote branch. If you already created the remote branch earlier, just stand in your fixing_strange_bug branch and do git push . Now you should tell the Evennia developers that they should consider merging your brilliant changes into Evennia proper. Create a pull request and follow the instructions. Make sure to specifically select your fixing_strange_bug branch to be the source of the merge. Evennia developers will then be able to examine your request and merge it if it's deemed suitable. Once your changes have been merged into Evennia your local fixing_strange_bug can be deleted (since your changes are now available in the \"clean\" Evennia repository). Do git branch -D fixing_strange_bug to delete your work branch. Update your master branch ( checkout master and then git pull ) and you should get your fix back, now as a part of official Evennia! GIT tips and tricks \u00b6 Some of the GIT commands can feel a little long and clunky if you need to do them often. Luckily you can create aliases for those. Here are some useful commands to run: # git st # - view brief status info git config --global alias.st 'status -s' Above, you only need to ever enter the git config ... command once - you have then added the new alias. Afterwards, just do git st to get status info. All the examples below follow the same template. # git cl # - clone a repository git config --global alias.cl clone # git cma \"commit message\" # - commit all changes without opening editor for message git config --global alias.cma 'commit -a -m' # git ca # - amend text to your latest commit message git config --global alias.ca 'commit --amend' # git fl # - file log; shows diffs of files in latest commits git config --global alias.fl 'log -u' # git co [branchname] # - checkout git config --global alias.co checkout # git br <branchname> # - create branch git config --global alias.br branch # git ls # - view log tree git config --global alias.ls 'log --pretty=format:\"%C(green)%h\\ %C(yellow)[%ad]%Cred%d\\ %Creset%s%Cblue\\ [%cn]\" --decorate --date=relative --graph' # git diff # - show current uncommitted changes git config --global alias.diff 'diff --word-diff' # git grep <query> # - search (grep) codebase for a search criterion git config --global alias.grep 'grep -Ii' To get a further feel for GIT there is also a good YouTube talk about it - it's a bit long but it will help you understand the underlying ideas behind GIT (which in turn makes it a lot more intuitive to use).","title":"Version Control"},{"location":"Version-Control.html#setting-up-git","text":"If you have gotten Evennia installed, you will have Git already and can skip to Step 2 below. Otherwise you will need to install Git on your platform. You can find expanded instructions for installation here .","title":"Setting up Git"},{"location":"Version-Control.html#step-1-install-git","text":"Fedora Linux yum install git-core Debian Linux (Ubuntu, Linux Mint, etc.) apt-get install git Windows : It is recommended to use Git for Windows . Mac : Mac platforms offer two methods for installation, one via MacPorts, which you can find out about here , or you can use the Git OSX Installer .","title":"Step 1: Install Git"},{"location":"Version-Control.html#step-2-define-usere-mail-settings-for-git","text":"To avoid a common issue later, you will need to set a couple of settings; first you will need to tell Git your username, followed by your e-mail address, so that when you commit code later you will be properly credited. Note that your commit information will be visible to everyone if you ever contribute to Evennia or use an online service like github to host your code. So if you are not comfortable with using your real, full name online, put a nickname here. Set the default name for git to use when you commit: git config --global user.name \"Your Name Here\" Set the default email for git to use when you commit: git config --global user.email \"your_email@example.com\"","title":"Step 2: Define user/e-mail Settings for Git"},{"location":"Version-Control.html#putting-your-game-folder-under-version-control","text":"Note: The game folder's version control is completely separate from Evennia's repository. After you have set up your game you will have created a new folder to host your particular game (let's call this folder mygame for now). This folder is not under version control at this point. git init mygame Your mygame folder is now ready for version control! Now add all the content and make a first commit: cd mygame git add * git commit -m \"Initial commit\" Read on for help on what these commands do.","title":"Putting your game folder under version control"},{"location":"Version-Control.html#tracking-files","text":"When working on your code or fix bugs in your local branches you may end up creating new files. If you do you must tell Git to track them by using the add command: git add <filename> You can check the current status of version control with git status . This will show if you have any modified, added or otherwise changed files. Some files, like database files, logs and temporary PID files are usually not tracked in version control. These should either not show up or have a question mark in front of them.","title":"Tracking files"},{"location":"Version-Control.html#controlling-tracking","text":"You will notice that some files are not covered by your git version control, notably your settings file ( mygame/server/conf/settings.py ) and your sqlite3 database file mygame/server/evennia.db3 . This is controlled by the hidden file mygame/.gitignore . Evennia creates this file as part of the creation of your game directory. Everything matched in this file will be ignored by GIT. If you want to, for example, include your settings file for collaborators to access, remove that entry in .gitignore . Note: You should never put your sqlite3 database file into git by removing its entry in .gitignore . GIT is for backing up your code, not your database. That way lies madness and a good chance you'll confuse yourself so that after a few commits and reverts don't know what is in your database or not. If you want to backup your database, do so by simply copying the file on your hard drive to a backup-name.","title":"Controlling tracking"},{"location":"Version-Control.html#committing-your-code","text":"Committing means storing the current snapshot of your code within git. This creates a \"save point\" or \"history\" of your development process. You can later jump back and forth in your history, for example to figure out just when a bug was introduced or see what results the code used to produce compared to now. It's usually a good idea to commit your changes often. Committing is fast and local only - you will never commit anything online at this point. To commit your changes, use git commit --all This will save all changes you made since last commit. The command will open a text editor where you can add a message detailing the changes you've made. Make it brief but informative. You can see the history of commits with git log . If you don't want to use the editor you can set the message directly by using the -m flag: git commit --all -m \"This fixes a bug in the combat code.\"","title":"Committing your Code"},{"location":"Version-Control.html#changing-your-mind","text":"If you have non-committed changes that you realize you want to throw away, you can do the following: git checkout <file to revert> This will revert the file to the state it was in at your last commit , throwing away the changes you did to it since. It's a good way to make wild experiments without having to remember just what you changed. If you do git checkout . you will throw away all changes since the last commit.","title":"Changing your mind"},{"location":"Version-Control.html#pushing-your-code-online","text":"So far your code is only located on your private machine. A good idea is to back it up online. The easiest way to do this is to push it to your own remote repository on GitHub. Make sure you have your game directory setup under git version control as described above. Make sure to commit any changes. Create a new, empty repository on Github. Github explains how here (do not \"Initialize the repository with a README\" or else you'll create unrelated histories). From your local game dir, do git remote add origin <github URL> where <github URL> is the URL to your online repo. This tells your game dir that it should be pushing to the remote online dir. git remote -v to verify the online dir. git push origin master now pushes your game dir online so you can see it on github.com. You can commit your work locally ( git commit --all -m \"Make a change that ...\" ) as many times as you want. When you want to push those changes to your online repo, you do git push . You can also git clone <url_to_online_repo> from your online repo to somewhere else (like your production server) and henceforth do git pull to update that to the latest thing you pushed. Note that GitHub's repos are, by default publicly visible by all. Creating a publicly visible online clone might not be what you want for all parts of your development process - you may prefer a more private venue when sharing your revolutionary work with your team. If that's the case you can change your repository to \"Private\" in the github settings. Then your code will only be visible to those you specifically grant access.","title":"Pushing your code online"},{"location":"Version-Control.html#forking-evennia","text":"This helps you set up an online fork of Evennia so you can easily commit fixes and help with upstream development.","title":"Forking Evennia"},{"location":"Version-Control.html#step-1-fork-the-evenniamaster-repository","text":"Before proceeding with the following step, make sure you have registered and created an account on GitHub.com . This is necessary in order to create a fork of Evennia's master repository, and to push your commits to your fork either for yourself or for contributing to Evennia. A fork is a clone of the master repository that you can make your own commits and changes to. At the top of this page , click the \"Fork\" button, as it appears below.","title":"Step 1: Fork the evennia/master repository"},{"location":"Version-Control.html#step-2-clone-your-fork","text":"The fork only exists online as of yet. In a terminal, change your directory to the folder you wish to develop in. From this directory run the following command: git clone https://github.com/yourusername/evennia.git This will download your fork to your computer. It creates a new folder evennia/ at your current location.","title":"Step 2: Clone your fork"},{"location":"Version-Control.html#step-3-configure-remotes","text":"A remote is a repository stored on another computer, in this case on GitHub's server. When a repository is cloned, it has a default remote called origin . This points to your fork on GitHub, not the original repository it was forked from. To easily keep track of the original repository (that is, Evennia's official repository), you need to add another remote. The standard name for this remote is \"upstream\". Below we change the active directory to the newly cloned \"evennia\" directory and then assign the original Evennia repository to a remote called \"upstream\": cd evennia git remote add upstream https://github.com/evennia/evennia.git If you also want to access Evennia's develop branch (the bleeding edge development branch) do the following: git fetch upstream develop git checkout develop You should now have the upstream branch available locally. You can use this instead of master below if you are contributing new features rather than bug fixes.","title":"Step 3: Configure remotes"},{"location":"Version-Control.html#working-with-your-fork","text":"A branch is a separate instance of your code. Changes you do to code in a branch does not affect that in other branches (so if you for example add/commit a file to one branch and then switches to another branch, that file will be gone until you switch back to the first branch again). One can switch between branches at will and create as many branches as one needs for a given project. The content of branches can also be merged together or deleted without affecting other branches. This is not only a common way to organize development but also to test features without messing with existing code. The default branch of git is called the \"master\" branch. As a rule of thumb, you should never make modifications directly to your local copy of the master branch. Rather keep the master clean and only update it by pulling our latest changes to it. Any work you do should instead happen in a local, other branches.","title":"Working with your fork"},{"location":"Version-Control.html#making-a-work-branch","text":"git checkout -b myfixes This command will checkout and automatically create the new branch myfixes on your machine. If you stared out in the master branch, myfixes will be a perfect copy of the master branch. You can see which branch you are on with git branch and change between different branches with git checkout <branchname> . Branches are fast and cheap to create and manage. It is common practice to create a new branch for every bug you want to work on or feature you want to create, then create a pull request for that branch to be merged upstream (see below). Not only will this organize your work, it will also make sure that your master branch version of Evennia is always exactly in sync with the upstream version's master branch.","title":"Making a work branch"},{"location":"Version-Control.html#updating-with-upstream-changes","text":"When Evennia's official repository updates, first make sure to commit all your changes to your branch and then checkout the \"clean\" master branch: git commit --all git checkout master Pull the latest changes from upstream: git pull upstream master This should sync your local master branch with upstream Evennia's master branch. Now we go back to our own work-branch (let's say it's still called \"myfixes\") and merge the updated master into our branch. git checkout myfixes git merge master If everything went well, your myfixes branch will now have the latest version of Evennia merged with whatever changes you have done. Use git log to see what has changed. You may need to restart the server or run manage.py migrate if the database schema changed (this will be seen in the commit log and on the mailing list). See the Git manuals for learning more about useful day-to-day commands, and special situations such as dealing with merge collisions.","title":"Updating with upstream changes"},{"location":"Version-Control.html#sharing-your-code-publicly","text":"Up to this point your myfixes branch only exists on your local computer. No one else can see it. If you want a copy of this branch to also appear in your online fork on GitHub, make sure to have checked out your \"myfixes\" branch and then run the following: git push -u origin myfixes This will create a new remote branch named \"myfixes\" in your online repository (which is refered to as \"origin\" by default); the -u flag makes sure to set this to the default push location. Henceforth you can just use git push from your myfixes branch to push your changes online. This is a great way to keep your source backed-up and accessible. Remember though that by default your repository will be public so everyone will be able to browse and download your code (same way as you can with Evennia itself). If you want secrecy you can change your repository to \"Private\" in the Github settings. Note though that if you do, you might have trouble contributing to Evennia (since we can't see the code you want to share). Note: If you hadn't setup a public key on GitHub or aren't asked for a username/password, you might get an error 403: Forbidden Access at this stage. In that case, some users have reported that the workaround is to create a file .netrc under your home directory and add your credentials there: machine github.com login <my_github_username> password <my_github_password>","title":"Sharing your Code Publicly"},{"location":"Version-Control.html#committing-fixes-to-evennia","text":"Contributing can mean both bug-fixes or adding new features to Evennia. Please note that if your change is not already listed and accepted in the Issue Tracker , it is recommended that you first hit the developer mailing list or IRC chat to see beforehand if your feature is deemed suitable to include as a core feature in the engine. When it comes to bug-fixes, other developers may also have good input on how to go about resolving the issue. To contribute you need to have forked Evennia first. As described above you should do your modification in a separate local branch (not in the master branch). This branch is what you then present to us (as a Pull request , PR, see below). We can then merge your change into the upstream master and you then do git pull to update master usual. Now that the master is updated with your fixes, you can safely delete your local work branch. Below we describe this work flow. First update the Evennia master branch to the latest Evennia version: git checkout master git pull upstream master Next, create a new branch to hold your contribution. Let's call it the \"fixing_strange_bug\" branch: git checkout -b fixing_strange_bug It is wise to make separate branches for every fix or series of fixes you want to contribute. You are now in your new fixing_strange_bug branch. You can list all branches with git branch and jump between branches with git checkout <branchname> . Code and test things in here, committing as you go: git commit --all -m \"Fix strange bug in look command. Resolves #123.\" You can make multiple commits if you want, depending on your work flow and progress. Make sure to always make clear and descriptive commit messages so it's easy to see what you intended. To refer to, say, issue number 123, write #123 , it will turn to a link on GitHub. If you include the text \"Resolves #123\", that issue will be auto-closed on GitHub if your commit gets merged into main Evennia. If you refer to in-game commands that start with @ (such as @examine ), please put them in backticks `, for example `@examine`. The reason for this is that GitHub uses @username to refer to GitHub users, so if you forget the ticks, any user happening to be named examine will get a notification .... If you implement multiple separate features/bug-fixes, split them into different branches if they are very different and should be handled as separate PRs. You can do any number of commits to your branch as you work. Once you are at a stage where you want to show the world what you did you might want to consider making it clean for merging into Evennia's master branch by using git rebase (this is not always necessary, and if it sounds too hard, say so and we'll handle it on our end). Once you are ready, push your work to your online Evennia fork on github, in a new remote branch: git push -u origin fixing_strange_bug The -u flag is only needed the first time - this tells GIT to create a remote branch. If you already created the remote branch earlier, just stand in your fixing_strange_bug branch and do git push . Now you should tell the Evennia developers that they should consider merging your brilliant changes into Evennia proper. Create a pull request and follow the instructions. Make sure to specifically select your fixing_strange_bug branch to be the source of the merge. Evennia developers will then be able to examine your request and merge it if it's deemed suitable. Once your changes have been merged into Evennia your local fixing_strange_bug can be deleted (since your changes are now available in the \"clean\" Evennia repository). Do git branch -D fixing_strange_bug to delete your work branch. Update your master branch ( checkout master and then git pull ) and you should get your fix back, now as a part of official Evennia!","title":"Committing fixes to Evennia"},{"location":"Version-Control.html#git-tips-and-tricks","text":"Some of the GIT commands can feel a little long and clunky if you need to do them often. Luckily you can create aliases for those. Here are some useful commands to run: # git st # - view brief status info git config --global alias.st 'status -s' Above, you only need to ever enter the git config ... command once - you have then added the new alias. Afterwards, just do git st to get status info. All the examples below follow the same template. # git cl # - clone a repository git config --global alias.cl clone # git cma \"commit message\" # - commit all changes without opening editor for message git config --global alias.cma 'commit -a -m' # git ca # - amend text to your latest commit message git config --global alias.ca 'commit --amend' # git fl # - file log; shows diffs of files in latest commits git config --global alias.fl 'log -u' # git co [branchname] # - checkout git config --global alias.co checkout # git br <branchname> # - create branch git config --global alias.br branch # git ls # - view log tree git config --global alias.ls 'log --pretty=format:\"%C(green)%h\\ %C(yellow)[%ad]%Cred%d\\ %Creset%s%Cblue\\ [%cn]\" --decorate --date=relative --graph' # git diff # - show current uncommitted changes git config --global alias.diff 'diff --word-diff' # git grep <query> # - search (grep) codebase for a search criterion git config --global alias.grep 'grep -Ii' To get a further feel for GIT there is also a good YouTube talk about it - it's a bit long but it will help you understand the underlying ideas behind GIT (which in turn makes it a lot more intuitive to use).","title":"GIT tips and tricks"},{"location":"Weather-Tutorial.html","text":"This tutorial will have us create a simple weather system for our MUD. The way we want to use this is to have all outdoor rooms echo weather-related messages to the room at regular and semi-random intervals. Things like \"Clouds gather above\", \"It starts to rain\" and so on. One could imagine every outdoor room in the game having a script running on themselves that fires regularly. For this particular example it is however more efficient to do it another way, namely by using a \"ticker-subscription\" model. The principle is simple: Instead of having each Object individually track the time, they instead subscribe to be called by a global ticker who handles time keeping. Not only does this centralize and organize much of the code in one place, it also has less computing overhead. Evennia offers the TickerHandler specifically for using the subscription model. We will use it for our weather system. We will assume you know how to make your own Typeclasses. If not see one of the beginning tutorials. We will create a new WeatherRoom typeclass that is aware of the day-night cycle. import random from evennia import DefaultRoom, TICKER_HANDLER ECHOES = [\"The sky is clear.\", \"Clouds gather overhead.\", \"It's starting to drizzle.\", \"A breeze of wind is felt.\", \"The wind is picking up\"] # etc class WeatherRoom(DefaultRoom): \"This room is ticked at regular intervals\" def at_object_creation(self): \"called only when the object is first created\" TICKER_HANDLER.add(60 * 60, self.at_weather_update) def at_weather_update(self, *args, **kwargs): \"ticked at regular intervals\" echo = random.choice(ECHOES) self.msg_contents(echo) In the at_object_creation method, we simply added ourselves to the TickerHandler and tell it to call at_weather_update every hour ( 60*60 seconds). During testing you might want to play with a shorter time duration. For this to work we also create a custom hook at_weather_update(*args, **kwargs) , which is the call sign required by TickerHandler hooks. Henceforth the room will inform everyone inside it when the weather changes. This particular example is of course very simplistic - the weather echoes are just randomly chosen and don't care what weather came before it. Expanding it to be more realistic is a useful exercise.","title":"Weather Tutorial"},{"location":"Web-Character-Generation.html","text":"Introduction \u00b6 This tutorial will create a simple web-based interface for generating a new in-game Character. Accounts will need to have first logged into the website (with their AccountDB account). Once finishing character generation the Character will be created immediately and the Accounts can then log into the game and play immediately (the Character will not require staff approval or anything like that). This guide does not go over how to create an AccountDB on the website with the right permissions to transfer to their web-created characters. It is probably most useful to set MULTISESSION_MODE = 2 or 3 (which gives you a character-selection screen when you log into the game later). Other modes can be used with some adaptation to auto-puppet the new Character. You should have some familiarity with how Django sets up its Model Template View framework. You need to understand what is happening in the basic Web Character View tutorial . If you don\u2019t understand the listed tutorial or have a grasp of Django basics, please look at the Django tutorial to get a taste of what Django does, before throwing Evennia into the mix (Evennia shares its API and attributes with the website interface). This guide will outline the format of the models, views, urls, and html templates needed. Pictures \u00b6 Here are some screenshots of the simple app we will be making. Index page, with no character application yet done: Having clicked the \"create\" link you get to create your character (here we will only have name and background, you can add whatever is needed to fit your game): Back to the index page. Having entered our character application (we called our character \"TestApp\") you see it listed: We can also view an already written character application by clicking on it - this brings us to the detail page: Installing an App \u00b6 Assuming your game is named \"mygame\", navigate to your mygame/ directory, and type: evennia startapp chargen This will initialize a new Django app we choose to call \"chargen\". It is directory containing some basic starting things Django needs. You will need to move this directory: for the time being, it is in your mygame directory. Better to move it in your mygame/web directory, so you have mygame/web/chargen in the end. Next, navigate to mygame/server/conf/settings.py and add or edit the following line to make Evennia (and Django) aware of our new app: INSTALLED_APPS += ('web.chargen',) After this, we will get into defining our models (the description of the database storage), views (the server-side website content generators), urls (how the web browser finds the pages) and templates (how the web page should be structured). Checkpoint: \u00b6 you should have a folder named chargen or whatever you chose in your mygame/web/ directory you should have your application name added to your INSTALLED_APPS in settings.py Create Models \u00b6 Models are created in mygame/web/chargen/models.py . A Django database model is a Python class that describes the database storage of the data you want to manage. Any data you choose to store is stored in the same database as the game and you have access to all the game's objects here. We need to define what a character application actually is. This will differ from game to game so for this tutorial we will define a simple character sheet with the following database fields: app_id (AutoField): Primary key for this character application sheet. char_name (CharField): The new character's name. date_applied (DateTimeField): Date that this application was received. background (TextField): Character story background. account_id (IntegerField): Which account ID does this application belong to? This is an AccountID from the AccountDB object. submitted (BooleanField): True / False depending on if the application has been submitted yet. Note: In a full-fledged game, you\u2019d likely want them to be able to select races, skills, attributes and so on. Our models.py file should look something like this: # in mygame/web/chargen/models.py from django.db import models class CharApp(models.Model): app_id = models.AutoField(primary_key=True) char_name = models.CharField(max_length=80, verbose_name='Character Name') date_applied = models.DateTimeField(verbose_name='Date Applied') background = models.TextField(verbose_name='Background') account_id = models.IntegerField(default=1, verbose_name='Account ID') submitted = models.BooleanField(default=False) You should consider how you are going to link your application to your account. For this tutorial, we are using the account_id attribute on our character application model in order to keep track of which characters are owned by which accounts. Since the account id is a primary key in Evennia, it is a good candidate, as you will never have two of the same IDs in Evennia. You can feel free to use anything else, but for the purposes of this guide, we are going to use account ID to join the character applications with the proper account. Checkpoint: \u00b6 you should have filled out mygame/web/chargen/models.py with the model class shown above (eventually adding fields matching what you need for your game). Create Views \u00b6 Views are server-side constructs that make dynamic data available to a web page. We are going to add them to mygame/web/chargen.views.py . Each view in our example represents the backbone of a specific web page. We will use three views and three pages here: The index (managing index.html ). This is what you see when you navigate to http://yoursite.com/chargen . The detail display sheet (manages detail.html ). A page that passively displays the stats of a given Character. Character creation sheet (manages create.html ). This is the main form with fields to fill in. Index view \u00b6 Let\u2019s get started with the index first. We\u2019ll want characters to be able to see their created characters so let\u2019s # file mygame/web/chargen.views.py from .models import CharApp def index(request): current_user = request.user # current user logged in p_id = current_user.id # the account id # submitted Characters by this account sub_apps = CharApp.objects.filter(account_id=p_id, submitted=True) context = {'sub_apps': sub_apps} # make the variables in 'context' available to the web page template return render(request, 'chargen/index.html', context) Detail view \u00b6 Our detail page will have pertinent character application information our users can see. Since this is a basic demonstration, our detail page will only show two fields: Character name Character background We will use the account ID again just to double-check that whoever tries to check our character page is actually the account who owns the application. # file mygame/web/chargen.views.py def detail(request, app_id): app = CharApp.objects.get(app_id=app_id) name = app.char_name background = app.background submitted = app.submitted p_id = request.user.id context = {'name': name, 'background': background, 'p_id': p_id, 'submitted': submitted} return render(request, 'chargen/detail.html', context) Creating view \u00b6 Predictably, our create function will be the most complicated of the views, as it needs to accept information from the user, validate the information, and send the information to the server. Once the form content is validated will actually create a playable Character. The form itself we will define first. In our simple example we are just looking for the Character's name and background. This form we create in mygame/web/chargen/forms.py : # file mygame/web/chargen/forms.py from django import forms class AppForm(forms.Form): name = forms.CharField(label='Character Name', max_length=80) background = forms.CharField(label='Background') Now we make use of this form in our view. # file mygame/web/chargen/views.py from web.chargen.models import CharApp from web.chargen.forms import AppForm from django.http import HttpResponseRedirect from datetime import datetime from evennia.objects.models import ObjectDB from django.conf import settings from evennia.utils import create def creating(request): user = request.user if request.method == 'POST': form = AppForm(request.POST) if form.is_valid(): name = form.cleaned_data['name'] background = form.cleaned_data['background'] applied_date = datetime.now() submitted = True if 'save' in request.POST: submitted = False app = CharApp(char_name=name, background=background, date_applied=applied_date, account_id=user.id, submitted=submitted) app.save() if submitted: # Create the actual character object typeclass = settings.BASE_CHARACTER_TYPECLASS home = ObjectDB.objects.get_id(settings.GUEST_HOME) # turn the permissionhandler to a string perms = str(user.permissions) # create the character char = create.create_object(typeclass=typeclass, key=name, home=home, permissions=perms) user.db._playable_characters.append(char) # add the right locks for the character so the account can # puppet it char.locks.add(\"puppet:id(%i) or pid(%i) or perm(Developers) \" \"or pperm(Developers)\" % (char.id, user.id)) char.db.background = background # set the character background return HttpResponseRedirect('/chargen') else: form = AppForm() return render(request, 'chargen/create.html', {'form': form}) Note also that we basically create the character using the Evennia API, and we grab the proper permissions from the AccountDB object and copy them to the character object. We take the user permissions attribute and turn that list of strings into a string object in order for the create_object function to properly process the permissions. Most importantly, the following attributes must be set on the created character object: Evennia permissions (copied from the AccountDB ). The right puppet locks so the Account can actually play as this Character later. The relevant Character typeclass Character name (key) The Character's home room location ( #2 by default) Other attributes are strictly speaking optional, such as the background attribute on our character. It may be a good idea to decompose this function and create a separate _create_character function in order to set up your character object the account owns. But with the Evennia API, setting custom attributes is as easy as doing it in the meat of your Evennia game directory. After all of this, our views.py file should look like something like this: # file mygame/web/chargen/views.py from django.shortcuts import render from web.chargen.models import CharApp from web.chargen.forms import AppForm from django.http import HttpResponseRedirect from datetime import datetime from evennia.objects.models import ObjectDB from django.conf import settings from evennia.utils import create def index(request): current_user = request.user # current user logged in p_id = current_user.id # the account id # submitted apps under this account sub_apps = CharApp.objects.filter(account_id=p_id, submitted=True) context = {'sub_apps': sub_apps} return render(request, 'chargen/index.html', context) def detail(request, app_id): app = CharApp.objects.get(app_id=app_id) name = app.char_name background = app.background submitted = app.submitted p_id = request.user.id context = {'name': name, 'background': background, 'p_id': p_id, 'submitted': submitted} return render(request, 'chargen/detail.html', context) def creating(request): user = request.user if request.method == 'POST': form = AppForm(request.POST) if form.is_valid(): name = form.cleaned_data['name'] background = form.cleaned_data['background'] applied_date = datetime.now() submitted = True if 'save' in request.POST: submitted = False app = CharApp(char_name=name, background=background, date_applied=applied_date, account_id=user.id, submitted=submitted) app.save() if submitted: # Create the actual character object typeclass = settings.BASE_CHARACTER_TYPECLASS home = ObjectDB.objects.get_id(settings.GUEST_HOME) # turn the permissionhandler to a string perms = str(user.permissions) # create the character char = create.create_object(typeclass=typeclass, key=name, home=home, permissions=perms) user.db._playable_characters.append(char) # add the right locks for the character so the account can # puppet it char.locks.add(\"puppet:id(%i) or pid(%i) or perm(Developers) \" \"or pperm(Developers)\" % (char.id, user.id)) char.db.background = background # set the character background return HttpResponseRedirect('/chargen') else: form = AppForm() return render(request, 'chargen/create.html', {'form': form}) Checkpoint: \u00b6 you\u2019ve defined a views.py that has an index, detail, and creating functions. you\u2019ve defined a forms.py with the AppForm class needed by the creating function of views.py . your mygame/web/chargen directory should now have a views.py and forms.py file Create URLs \u00b6 URL patterns helps redirect requests from the web browser to the right views. These patterns are created in mygame/web/chargen/urls.py . # file mygame/web/chargen/urls.py from django.conf.urls import url from web.chargen import views urlpatterns = [ # ex: /chargen/ url(r'^$', views.index, name='index'), # ex: /chargen/5/ url(r'^(?P<app_id>[0-9]+)/$', views.detail, name='detail'), # ex: /chargen/create url(r'^create/$', views.creating, name='creating'), ] You could change the format as you desire. To make it more secure, you could remove app_id from the \"detail\" url, and instead just fetch the account\u2019s applications using a unifying field like account_id to find all the character application objects to display. We must also update the main mygame/web/urls.py file (that is, one level up from our chargen app), so the main website knows where our app's views are located. Find the patterns variable, and change it to include: # in file mygame/web/urls.py from django.conf.urls import url, include # default evennia patterns from evennia.web.urls import urlpatterns # eventual custom patterns custom_patterns = [ # url(r'/desired/url/', view, name='example'), ] # this is required by Django. urlpatterns += [ url(r'^chargen/', include('web.chargen.urls')), ] urlpatterns = custom_patterns + urlpatterns Checkpoint: \u00b6 You\u2019ve created a urls.py file in the mygame/web/chargen directory You have edited the main mygame/web/urls.py file to include urls to the chargen directory. HTML Templates \u00b6 So we have our url patterns, views, and models defined. Now we must define our HTML templates that the actual user will see and interact with. For this tutorial we us the basic prosimii template that comes with Evennia. Take note that we use user.is_authenticated to make sure that the user cannot create a character without logging in. These files will all go into the /mygame/web/chargen/templates/chargen/ directory. index.html \u00b6 This HTML template should hold a list of all the applications the account currently has active. For this demonstration, we will only list the applications that the account has submitted. You could easily adjust this to include saved applications, or other types of applications if you have different kinds. Please refer back to views.py to see where we define the variables these templates make use of. <!-- file mygame/web/chargen/templates/chargen/index.html--> {% extends \"base.html\" %} {% block content %} {% if user.is_authenticated %} <h1>Character Generation</h1> {% if sub_apps %} <ul> {% for sub_app in sub_apps %} <li><a href=\"/chargen/{{ sub_app.app_id }}/\">{{ sub_app.char_name }}</a></li> {% endfor %} </ul> {% else %} <p>You haven't submitted any character applications.</p> {% endif %} {% else %} <p>Please <a href=\"{% url 'login'%}\">login</a>first.<a/></p> {% endif %} {% endblock %} detail.html \u00b6 This page should show a detailed character sheet of their application. This will only show their name and character background. You will likely want to extend this to show many more fields for your game. In a full-fledged character generation, you may want to extend the boolean attribute of submitted to allow accounts to save character applications and submit them later. <!-- file mygame/web/chargen/templates/chargen/detail.html--> {% extends \"base.html\" %} {% block content %} <h1>Character Information</h1> {% if user.is_authenticated %} {% if user.id == p_id %} <h2>{{name}}</h2> <h2>Background</h2> <p>{{background}}</p> <p>Submitted: {{submitted}}</p> {% else %} <p>You didn't submit this character.</p> {% endif %} {% else %} <p>You aren't logged in.</p> {% endif %} {% endblock %} create.html \u00b6 Our create HTML template will use the Django form we defined back in views.py/forms.py to drive the majority of the application process. There will be a form input for every field we defined in forms.py, which is handy. We have used POST as our method because we are sending information to the server that will update the database. As an alternative, GET would be much less secure. You can read up on documentation elsewhere on the web for GET vs. POST. <!-- file mygame/web/chargen/templates/chargen/create.html--> {% extends \"base.html\" %} {% block content %} <h1>Character Creation</h1> {% if user.is_authenticated %} <form action=\"/chargen/create/\" method=\"post\"> {% csrf_token %} {{ form }} <input type=\"submit\" name=\"submit\" value=\"Submit\"/> </form> {% else %} <p>You aren't logged in.</p> {% endif %} {% endblock %} Checkpoint: \u00b6 Create a index.html , detail.html and create.html template in your mygame/web/chargen/templates/chargen directory Activating your new character generation \u00b6 After finishing this tutorial you should have edited or created the following files: mygame/web/urls.py mygame/web/chargen/models.py mygame/web/chargen/views.py mygame/web/chargen/urls.py mygame/web/chargen/templates/chargen/index.html mygame/web/chargen/templates/chargen/create.html mygame/web/chargen/templates/chargen/detail.html Once you have all these files stand in your mygame/ folder and run: evennia makemigrations evennia migrate This will create and update the models. If you see any errors at this stage, read the traceback carefully, it should be relatively easy to figure out where the error is. Login to the website (you need to have previously registered an Player account with the game to do this). Next you navigate to http://yourwebsite.com/chargen (if you are running locally this will be something like http://localhost:4001/chargen and you will see your new app in action. This should hopefully give you a good starting point in figuring out how you\u2019d like to approach your own web generation. The main difficulties are in setting the appropriate settings on your newly created character object. Thankfully, the Evennia API makes this easy. Adding a no CAPCHA reCAPCHA on your character generation \u00b6 As sad as it is, if your server is open to the web, bots might come to visit and take advantage of your open form to create hundreds, thousands, millions of characters if you give them the opportunity. This section shows you how to use the No CAPCHA reCAPCHA designed by Google. Not only is it easy to use, it is user-friendly... for humans. A simple checkbox to check, except if Google has some suspicion, in which case you will have a more difficult test with an image and the usual text inside. It's worth pointing out that, as long as Google doesn't suspect you of being a robot, this is quite useful, not only for common users, but to screen-reader users, to which reading inside of an image is pretty difficult, if not impossible. And to top it all, it will be so easy to add in your website. Step 1: Obtain a SiteKey and secret from Google \u00b6 The first thing is to ask Google for a way to safely authenticate your website to their service. To do it, we need to create a site key and a secret. Go to https://www.google.com/recaptcha/admin to create such a site key. It's quite easy when you have a Google account. When you have created your site key, save it safely. Also copy your secret key as well. You should find both information on the web page. Both would contain a lot of letters and figures. Step 2: installing and configuring the dedicated Django app \u00b6 Since Evennia runs on Django, the easiest way to add our CAPCHA and perform the proper check is to install the dedicated Django app. Quite easy: pip install django-nocaptcha-recaptcha And add it to the installed apps in your settings. In your mygame/server/conf/settings.py , you might have something like this: # ... INSTALLED_APPS += ( 'web.chargen', 'nocaptcha_recaptcha', ) Don't close the setting file just yet. We have to add in the site key and secret key. You can add them below: # NoReCAPCHA site key NORECAPTCHA_SITE_KEY = \"PASTE YOUR SITE KEY HERE\" # NoReCAPCHA secret key NORECAPTCHA_SECRET_KEY = \"PUT YOUR SECRET KEY HERE\" Step 3: Adding the CAPCHA to our form \u00b6 Finally we have to add the CAPCHA to our form. It will be pretty easy too. First, open your web/chargen/forms.py file. We're going to add a new field, but hopefully, all the hard work has been done for us. Update at your convenience, You might end up with something like this: from django import forms from nocaptcha_recaptcha.fields import NoReCaptchaField class AppForm(forms.Form): name = forms.CharField(label='Character Name', max_length=80) background = forms.CharField(label='Background') captcha = NoReCaptchaField() As you see, we added a line of import (line 2) and a field in our form. And lastly, we need to update our HTML file to add in the Google library. You can open web/chargen/templates/chargen/create.html . There's only one line to add: <script src=\"https://www.google.com/recaptcha/api.js\" async defer></script> And you should put it at the bottom of the page. Just before the closing body would be good, but for the time being, the base page doesn't provide a footer block, so we'll put it in the content block. Note that it's not the best place, but it will work. In the end, your web/chargen/templates/chargen/create.html file should look like this: {% extends \"base.html\" %} {% block content %} <h1>Character Creation</h1> {% if user.is_authenticated %} <form action=\"/chargen/create/\" method=\"post\"> {% csrf_token %} {{ form }} <input type=\"submit\" name=\"submit\" value=\"Submit\"/> </form> {% else %} <p>You aren't logged in.</p> {% endif %} <script src=\"https://www.google.com/recaptcha/api.js\" async defer></script> {% endblock %} Reload and open http://localhost:4001/chargen/create and you should see your beautiful CAPCHA just before the \"submit\" button. Try not to check the checkbox to see what happens. And do the same while checking the checkbox!","title":"Web Character Generation"},{"location":"Web-Character-Generation.html#introduction","text":"This tutorial will create a simple web-based interface for generating a new in-game Character. Accounts will need to have first logged into the website (with their AccountDB account). Once finishing character generation the Character will be created immediately and the Accounts can then log into the game and play immediately (the Character will not require staff approval or anything like that). This guide does not go over how to create an AccountDB on the website with the right permissions to transfer to their web-created characters. It is probably most useful to set MULTISESSION_MODE = 2 or 3 (which gives you a character-selection screen when you log into the game later). Other modes can be used with some adaptation to auto-puppet the new Character. You should have some familiarity with how Django sets up its Model Template View framework. You need to understand what is happening in the basic Web Character View tutorial . If you don\u2019t understand the listed tutorial or have a grasp of Django basics, please look at the Django tutorial to get a taste of what Django does, before throwing Evennia into the mix (Evennia shares its API and attributes with the website interface). This guide will outline the format of the models, views, urls, and html templates needed.","title":"Introduction"},{"location":"Web-Character-Generation.html#pictures","text":"Here are some screenshots of the simple app we will be making. Index page, with no character application yet done: Having clicked the \"create\" link you get to create your character (here we will only have name and background, you can add whatever is needed to fit your game): Back to the index page. Having entered our character application (we called our character \"TestApp\") you see it listed: We can also view an already written character application by clicking on it - this brings us to the detail page:","title":"Pictures"},{"location":"Web-Character-Generation.html#installing-an-app","text":"Assuming your game is named \"mygame\", navigate to your mygame/ directory, and type: evennia startapp chargen This will initialize a new Django app we choose to call \"chargen\". It is directory containing some basic starting things Django needs. You will need to move this directory: for the time being, it is in your mygame directory. Better to move it in your mygame/web directory, so you have mygame/web/chargen in the end. Next, navigate to mygame/server/conf/settings.py and add or edit the following line to make Evennia (and Django) aware of our new app: INSTALLED_APPS += ('web.chargen',) After this, we will get into defining our models (the description of the database storage), views (the server-side website content generators), urls (how the web browser finds the pages) and templates (how the web page should be structured).","title":"Installing an App"},{"location":"Web-Character-Generation.html#checkpoint","text":"you should have a folder named chargen or whatever you chose in your mygame/web/ directory you should have your application name added to your INSTALLED_APPS in settings.py","title":"Checkpoint:"},{"location":"Web-Character-Generation.html#create-models","text":"Models are created in mygame/web/chargen/models.py . A Django database model is a Python class that describes the database storage of the data you want to manage. Any data you choose to store is stored in the same database as the game and you have access to all the game's objects here. We need to define what a character application actually is. This will differ from game to game so for this tutorial we will define a simple character sheet with the following database fields: app_id (AutoField): Primary key for this character application sheet. char_name (CharField): The new character's name. date_applied (DateTimeField): Date that this application was received. background (TextField): Character story background. account_id (IntegerField): Which account ID does this application belong to? This is an AccountID from the AccountDB object. submitted (BooleanField): True / False depending on if the application has been submitted yet. Note: In a full-fledged game, you\u2019d likely want them to be able to select races, skills, attributes and so on. Our models.py file should look something like this: # in mygame/web/chargen/models.py from django.db import models class CharApp(models.Model): app_id = models.AutoField(primary_key=True) char_name = models.CharField(max_length=80, verbose_name='Character Name') date_applied = models.DateTimeField(verbose_name='Date Applied') background = models.TextField(verbose_name='Background') account_id = models.IntegerField(default=1, verbose_name='Account ID') submitted = models.BooleanField(default=False) You should consider how you are going to link your application to your account. For this tutorial, we are using the account_id attribute on our character application model in order to keep track of which characters are owned by which accounts. Since the account id is a primary key in Evennia, it is a good candidate, as you will never have two of the same IDs in Evennia. You can feel free to use anything else, but for the purposes of this guide, we are going to use account ID to join the character applications with the proper account.","title":"Create Models"},{"location":"Web-Character-Generation.html#checkpoint_1","text":"you should have filled out mygame/web/chargen/models.py with the model class shown above (eventually adding fields matching what you need for your game).","title":"Checkpoint:"},{"location":"Web-Character-Generation.html#create-views","text":"Views are server-side constructs that make dynamic data available to a web page. We are going to add them to mygame/web/chargen.views.py . Each view in our example represents the backbone of a specific web page. We will use three views and three pages here: The index (managing index.html ). This is what you see when you navigate to http://yoursite.com/chargen . The detail display sheet (manages detail.html ). A page that passively displays the stats of a given Character. Character creation sheet (manages create.html ). This is the main form with fields to fill in.","title":"Create Views"},{"location":"Web-Character-Generation.html#index-view","text":"Let\u2019s get started with the index first. We\u2019ll want characters to be able to see their created characters so let\u2019s # file mygame/web/chargen.views.py from .models import CharApp def index(request): current_user = request.user # current user logged in p_id = current_user.id # the account id # submitted Characters by this account sub_apps = CharApp.objects.filter(account_id=p_id, submitted=True) context = {'sub_apps': sub_apps} # make the variables in 'context' available to the web page template return render(request, 'chargen/index.html', context)","title":"Index view"},{"location":"Web-Character-Generation.html#detail-view","text":"Our detail page will have pertinent character application information our users can see. Since this is a basic demonstration, our detail page will only show two fields: Character name Character background We will use the account ID again just to double-check that whoever tries to check our character page is actually the account who owns the application. # file mygame/web/chargen.views.py def detail(request, app_id): app = CharApp.objects.get(app_id=app_id) name = app.char_name background = app.background submitted = app.submitted p_id = request.user.id context = {'name': name, 'background': background, 'p_id': p_id, 'submitted': submitted} return render(request, 'chargen/detail.html', context)","title":"Detail view"},{"location":"Web-Character-Generation.html#creating-view","text":"Predictably, our create function will be the most complicated of the views, as it needs to accept information from the user, validate the information, and send the information to the server. Once the form content is validated will actually create a playable Character. The form itself we will define first. In our simple example we are just looking for the Character's name and background. This form we create in mygame/web/chargen/forms.py : # file mygame/web/chargen/forms.py from django import forms class AppForm(forms.Form): name = forms.CharField(label='Character Name', max_length=80) background = forms.CharField(label='Background') Now we make use of this form in our view. # file mygame/web/chargen/views.py from web.chargen.models import CharApp from web.chargen.forms import AppForm from django.http import HttpResponseRedirect from datetime import datetime from evennia.objects.models import ObjectDB from django.conf import settings from evennia.utils import create def creating(request): user = request.user if request.method == 'POST': form = AppForm(request.POST) if form.is_valid(): name = form.cleaned_data['name'] background = form.cleaned_data['background'] applied_date = datetime.now() submitted = True if 'save' in request.POST: submitted = False app = CharApp(char_name=name, background=background, date_applied=applied_date, account_id=user.id, submitted=submitted) app.save() if submitted: # Create the actual character object typeclass = settings.BASE_CHARACTER_TYPECLASS home = ObjectDB.objects.get_id(settings.GUEST_HOME) # turn the permissionhandler to a string perms = str(user.permissions) # create the character char = create.create_object(typeclass=typeclass, key=name, home=home, permissions=perms) user.db._playable_characters.append(char) # add the right locks for the character so the account can # puppet it char.locks.add(\"puppet:id(%i) or pid(%i) or perm(Developers) \" \"or pperm(Developers)\" % (char.id, user.id)) char.db.background = background # set the character background return HttpResponseRedirect('/chargen') else: form = AppForm() return render(request, 'chargen/create.html', {'form': form}) Note also that we basically create the character using the Evennia API, and we grab the proper permissions from the AccountDB object and copy them to the character object. We take the user permissions attribute and turn that list of strings into a string object in order for the create_object function to properly process the permissions. Most importantly, the following attributes must be set on the created character object: Evennia permissions (copied from the AccountDB ). The right puppet locks so the Account can actually play as this Character later. The relevant Character typeclass Character name (key) The Character's home room location ( #2 by default) Other attributes are strictly speaking optional, such as the background attribute on our character. It may be a good idea to decompose this function and create a separate _create_character function in order to set up your character object the account owns. But with the Evennia API, setting custom attributes is as easy as doing it in the meat of your Evennia game directory. After all of this, our views.py file should look like something like this: # file mygame/web/chargen/views.py from django.shortcuts import render from web.chargen.models import CharApp from web.chargen.forms import AppForm from django.http import HttpResponseRedirect from datetime import datetime from evennia.objects.models import ObjectDB from django.conf import settings from evennia.utils import create def index(request): current_user = request.user # current user logged in p_id = current_user.id # the account id # submitted apps under this account sub_apps = CharApp.objects.filter(account_id=p_id, submitted=True) context = {'sub_apps': sub_apps} return render(request, 'chargen/index.html', context) def detail(request, app_id): app = CharApp.objects.get(app_id=app_id) name = app.char_name background = app.background submitted = app.submitted p_id = request.user.id context = {'name': name, 'background': background, 'p_id': p_id, 'submitted': submitted} return render(request, 'chargen/detail.html', context) def creating(request): user = request.user if request.method == 'POST': form = AppForm(request.POST) if form.is_valid(): name = form.cleaned_data['name'] background = form.cleaned_data['background'] applied_date = datetime.now() submitted = True if 'save' in request.POST: submitted = False app = CharApp(char_name=name, background=background, date_applied=applied_date, account_id=user.id, submitted=submitted) app.save() if submitted: # Create the actual character object typeclass = settings.BASE_CHARACTER_TYPECLASS home = ObjectDB.objects.get_id(settings.GUEST_HOME) # turn the permissionhandler to a string perms = str(user.permissions) # create the character char = create.create_object(typeclass=typeclass, key=name, home=home, permissions=perms) user.db._playable_characters.append(char) # add the right locks for the character so the account can # puppet it char.locks.add(\"puppet:id(%i) or pid(%i) or perm(Developers) \" \"or pperm(Developers)\" % (char.id, user.id)) char.db.background = background # set the character background return HttpResponseRedirect('/chargen') else: form = AppForm() return render(request, 'chargen/create.html', {'form': form})","title":"Creating view"},{"location":"Web-Character-Generation.html#checkpoint_2","text":"you\u2019ve defined a views.py that has an index, detail, and creating functions. you\u2019ve defined a forms.py with the AppForm class needed by the creating function of views.py . your mygame/web/chargen directory should now have a views.py and forms.py file","title":"Checkpoint:"},{"location":"Web-Character-Generation.html#create-urls","text":"URL patterns helps redirect requests from the web browser to the right views. These patterns are created in mygame/web/chargen/urls.py . # file mygame/web/chargen/urls.py from django.conf.urls import url from web.chargen import views urlpatterns = [ # ex: /chargen/ url(r'^$', views.index, name='index'), # ex: /chargen/5/ url(r'^(?P<app_id>[0-9]+)/$', views.detail, name='detail'), # ex: /chargen/create url(r'^create/$', views.creating, name='creating'), ] You could change the format as you desire. To make it more secure, you could remove app_id from the \"detail\" url, and instead just fetch the account\u2019s applications using a unifying field like account_id to find all the character application objects to display. We must also update the main mygame/web/urls.py file (that is, one level up from our chargen app), so the main website knows where our app's views are located. Find the patterns variable, and change it to include: # in file mygame/web/urls.py from django.conf.urls import url, include # default evennia patterns from evennia.web.urls import urlpatterns # eventual custom patterns custom_patterns = [ # url(r'/desired/url/', view, name='example'), ] # this is required by Django. urlpatterns += [ url(r'^chargen/', include('web.chargen.urls')), ] urlpatterns = custom_patterns + urlpatterns","title":"Create URLs"},{"location":"Web-Character-Generation.html#checkpoint_3","text":"You\u2019ve created a urls.py file in the mygame/web/chargen directory You have edited the main mygame/web/urls.py file to include urls to the chargen directory.","title":"Checkpoint:"},{"location":"Web-Character-Generation.html#html-templates","text":"So we have our url patterns, views, and models defined. Now we must define our HTML templates that the actual user will see and interact with. For this tutorial we us the basic prosimii template that comes with Evennia. Take note that we use user.is_authenticated to make sure that the user cannot create a character without logging in. These files will all go into the /mygame/web/chargen/templates/chargen/ directory.","title":"HTML Templates"},{"location":"Web-Character-Generation.html#indexhtml","text":"This HTML template should hold a list of all the applications the account currently has active. For this demonstration, we will only list the applications that the account has submitted. You could easily adjust this to include saved applications, or other types of applications if you have different kinds. Please refer back to views.py to see where we define the variables these templates make use of. <!-- file mygame/web/chargen/templates/chargen/index.html--> {% extends \"base.html\" %} {% block content %} {% if user.is_authenticated %} <h1>Character Generation</h1> {% if sub_apps %} <ul> {% for sub_app in sub_apps %} <li><a href=\"/chargen/{{ sub_app.app_id }}/\">{{ sub_app.char_name }}</a></li> {% endfor %} </ul> {% else %} <p>You haven't submitted any character applications.</p> {% endif %} {% else %} <p>Please <a href=\"{% url 'login'%}\">login</a>first.<a/></p> {% endif %} {% endblock %}","title":"index.html"},{"location":"Web-Character-Generation.html#detailhtml","text":"This page should show a detailed character sheet of their application. This will only show their name and character background. You will likely want to extend this to show many more fields for your game. In a full-fledged character generation, you may want to extend the boolean attribute of submitted to allow accounts to save character applications and submit them later. <!-- file mygame/web/chargen/templates/chargen/detail.html--> {% extends \"base.html\" %} {% block content %} <h1>Character Information</h1> {% if user.is_authenticated %} {% if user.id == p_id %} <h2>{{name}}</h2> <h2>Background</h2> <p>{{background}}</p> <p>Submitted: {{submitted}}</p> {% else %} <p>You didn't submit this character.</p> {% endif %} {% else %} <p>You aren't logged in.</p> {% endif %} {% endblock %}","title":"detail.html"},{"location":"Web-Character-Generation.html#createhtml","text":"Our create HTML template will use the Django form we defined back in views.py/forms.py to drive the majority of the application process. There will be a form input for every field we defined in forms.py, which is handy. We have used POST as our method because we are sending information to the server that will update the database. As an alternative, GET would be much less secure. You can read up on documentation elsewhere on the web for GET vs. POST. <!-- file mygame/web/chargen/templates/chargen/create.html--> {% extends \"base.html\" %} {% block content %} <h1>Character Creation</h1> {% if user.is_authenticated %} <form action=\"/chargen/create/\" method=\"post\"> {% csrf_token %} {{ form }} <input type=\"submit\" name=\"submit\" value=\"Submit\"/> </form> {% else %} <p>You aren't logged in.</p> {% endif %} {% endblock %}","title":"create.html"},{"location":"Web-Character-Generation.html#checkpoint_4","text":"Create a index.html , detail.html and create.html template in your mygame/web/chargen/templates/chargen directory","title":"Checkpoint:"},{"location":"Web-Character-Generation.html#activating-your-new-character-generation","text":"After finishing this tutorial you should have edited or created the following files: mygame/web/urls.py mygame/web/chargen/models.py mygame/web/chargen/views.py mygame/web/chargen/urls.py mygame/web/chargen/templates/chargen/index.html mygame/web/chargen/templates/chargen/create.html mygame/web/chargen/templates/chargen/detail.html Once you have all these files stand in your mygame/ folder and run: evennia makemigrations evennia migrate This will create and update the models. If you see any errors at this stage, read the traceback carefully, it should be relatively easy to figure out where the error is. Login to the website (you need to have previously registered an Player account with the game to do this). Next you navigate to http://yourwebsite.com/chargen (if you are running locally this will be something like http://localhost:4001/chargen and you will see your new app in action. This should hopefully give you a good starting point in figuring out how you\u2019d like to approach your own web generation. The main difficulties are in setting the appropriate settings on your newly created character object. Thankfully, the Evennia API makes this easy.","title":"Activating your new character generation"},{"location":"Web-Character-Generation.html#adding-a-no-capcha-recapcha-on-your-character-generation","text":"As sad as it is, if your server is open to the web, bots might come to visit and take advantage of your open form to create hundreds, thousands, millions of characters if you give them the opportunity. This section shows you how to use the No CAPCHA reCAPCHA designed by Google. Not only is it easy to use, it is user-friendly... for humans. A simple checkbox to check, except if Google has some suspicion, in which case you will have a more difficult test with an image and the usual text inside. It's worth pointing out that, as long as Google doesn't suspect you of being a robot, this is quite useful, not only for common users, but to screen-reader users, to which reading inside of an image is pretty difficult, if not impossible. And to top it all, it will be so easy to add in your website.","title":"Adding a no CAPCHA reCAPCHA on your character generation"},{"location":"Web-Character-Generation.html#step-1-obtain-a-sitekey-and-secret-from-google","text":"The first thing is to ask Google for a way to safely authenticate your website to their service. To do it, we need to create a site key and a secret. Go to https://www.google.com/recaptcha/admin to create such a site key. It's quite easy when you have a Google account. When you have created your site key, save it safely. Also copy your secret key as well. You should find both information on the web page. Both would contain a lot of letters and figures.","title":"Step 1: Obtain a SiteKey and secret from Google"},{"location":"Web-Character-Generation.html#step-2-installing-and-configuring-the-dedicated-django-app","text":"Since Evennia runs on Django, the easiest way to add our CAPCHA and perform the proper check is to install the dedicated Django app. Quite easy: pip install django-nocaptcha-recaptcha And add it to the installed apps in your settings. In your mygame/server/conf/settings.py , you might have something like this: # ... INSTALLED_APPS += ( 'web.chargen', 'nocaptcha_recaptcha', ) Don't close the setting file just yet. We have to add in the site key and secret key. You can add them below: # NoReCAPCHA site key NORECAPTCHA_SITE_KEY = \"PASTE YOUR SITE KEY HERE\" # NoReCAPCHA secret key NORECAPTCHA_SECRET_KEY = \"PUT YOUR SECRET KEY HERE\"","title":"Step 2: installing and configuring the dedicated Django app"},{"location":"Web-Character-Generation.html#step-3-adding-the-capcha-to-our-form","text":"Finally we have to add the CAPCHA to our form. It will be pretty easy too. First, open your web/chargen/forms.py file. We're going to add a new field, but hopefully, all the hard work has been done for us. Update at your convenience, You might end up with something like this: from django import forms from nocaptcha_recaptcha.fields import NoReCaptchaField class AppForm(forms.Form): name = forms.CharField(label='Character Name', max_length=80) background = forms.CharField(label='Background') captcha = NoReCaptchaField() As you see, we added a line of import (line 2) and a field in our form. And lastly, we need to update our HTML file to add in the Google library. You can open web/chargen/templates/chargen/create.html . There's only one line to add: <script src=\"https://www.google.com/recaptcha/api.js\" async defer></script> And you should put it at the bottom of the page. Just before the closing body would be good, but for the time being, the base page doesn't provide a footer block, so we'll put it in the content block. Note that it's not the best place, but it will work. In the end, your web/chargen/templates/chargen/create.html file should look like this: {% extends \"base.html\" %} {% block content %} <h1>Character Creation</h1> {% if user.is_authenticated %} <form action=\"/chargen/create/\" method=\"post\"> {% csrf_token %} {{ form }} <input type=\"submit\" name=\"submit\" value=\"Submit\"/> </form> {% else %} <p>You aren't logged in.</p> {% endif %} <script src=\"https://www.google.com/recaptcha/api.js\" async defer></script> {% endblock %} Reload and open http://localhost:4001/chargen/create and you should see your beautiful CAPCHA just before the \"submit\" button. Try not to check the checkbox to see what happens. And do the same while checking the checkbox!","title":"Step 3: Adding the CAPCHA to our form"},{"location":"Web-Character-View-Tutorial.html","text":"Before doing this tutorial you will probably want to read the intro in Basic Web tutorial . In this tutorial we will create a web page that displays the stats of a game character. For this, and all other pages we want to make specific to our game, we'll need to create our own Django \"app\" We'll call our app character , since it will be dealing with character information. From your game dir, run evennia startapp character This will create a directory named character in the root of your game dir. It contains all basic files that a Django app needs. To keep mygame well ordered, move it to your mygame/web/ directory instead: mv character web/ Note that we will not edit all files in this new directory, many of the generated files are outside the scope of this tutorial. In order for Django to find our new web app, we'll need to add it to the INSTALLED_APPS setting. Evennia's default installed apps are already set, so in server/conf/settings.py , we'll just extend them: INSTALLED_APPS += ('web.character',) Note: That end comma is important. It makes sure that Python interprets the addition as a tuple instead of a string. The first thing we need to do is to create a view and an URL pattern to point to it. A view is a function that generates the web page that a visitor wants to see, while the URL pattern lets Django know what URL should trigger the view. The pattern may also provide some information of its own as we shall see. Here is our character/urls.py file ( Note : you may have to create this file if a blank one wasn't generated for you): # URL patterns for the character app from django.conf.urls import url from web.character.views import sheet urlpatterns = [ url(r'^sheet/(?P<object_id>\\d+)/$', sheet, name=\"sheet\") ] This file contains all of the URL patterns for the application. The url function in the urlpatterns list are given three arguments. The first argument is a pattern-string used to identify which URLs are valid. Patterns are specified as regular expressions . Regular expressions are used to match strings and are written in a special, very compact, syntax. A detailed description of regular expressions is beyond this tutorial but you can learn more about them here . For now, just accept that this regular expression requires that the visitor's URL looks something like this: sheet/123/ That is, sheet/ followed by a number, rather than some other possible URL pattern. We will interpret this number as object ID. Thanks to how the regular expression is formulated, the pattern recognizer stores the number in a variable called object_id . This will be passed to the view (see below). We add the imported view function ( sheet ) in the second argument. We also add the name keyword to identify the URL pattern itself. You should always name your URL patterns, this makes them easy to refer to in html templates using the {% url %} tag (but we won't get more into that in this tutorial). Security Note: Normally, users do not have the ability to see object IDs within the game (it's restricted to superusers only). Exposing the game's object IDs to the public like this enables griefers to perform what is known as an account enumeration attack in the efforts of hijacking your superuser account. Consider this: in every Evennia installation, there are two objects that we can always expect to exist and have the same object IDs-- Limbo (#2) and the superuser you create in the beginning (#1). Thus, the griefer can get 50% of the information they need to hijack the admin account (the admin's username) just by navigating to sheet/1 ! Next we create views.py , the view file that urls.py refers to. # Views for our character app from django.http import Http404 from django.shortcuts import render from django.conf import settings from evennia.utils.search import object_search from evennia.utils.utils import inherits_from def sheet(request, object_id): object_id = '#' + object_id try: character = object_search(object_id)[0] except IndexError: raise Http404(\"I couldn't find a character with that ID.\") if not inherits_from(character, settings.BASE_CHARACTER_TYPECLASS): raise Http404(\"I couldn't find a character with that ID. \" \"Found something else instead.\") return render(request, 'character/sheet.html', {'character': character}) As explained earlier, the URL pattern parser in urls.py parses the URL and passes object_id to our view function sheet . We do a database search for the object using this number. We also make sure such an object exists and that it is actually a Character. The view function is also handed a request object. This gives us information about the request, such as if a logged-in user viewed it - we won't use that information here but it is good to keep in mind. On the last line, we call the render function. Apart from the request object, the render function takes a path to an html template and a dictionary with extra data you want to pass into said template. As extra data we pass the Character object we just found. In the template it will be available as the variable \"character\". The html template is created as templates/character/sheet.html under your character app folder. You may have to manually create both template and its subfolder character . Here's the template to create: {% extends \"base.html\" %} {% block content %} <h1>{{ character.name }}</h1> <p>{{ character.db.desc }}</p> <h2>Stats</h2> <table> <thead> <tr> <th>Stat</th> <th>Value</th> </tr> </thead> <tbody> <tr> <td>Strength</td> <td>{{ character.db.str }}</td> </tr> <tr> <td>Intelligence</td> <td>{{ character.db.int }}</td> </tr> <tr> <td>Speed</td> <td>{{ character.db.spd }}</td> </tr> </tbody> </table> <h2>Skills</h2> <ul> {% for skill in character.db.skills %} <li>{{ skill }}</li> {% empty %} <li>This character has no skills yet.</li> {% endfor %} </ul> {% if character.db.approved %} <p class=\"success\">This character has been approved!</p> {% else %} <p class=\"warning\">This character has not yet been approved!</p> {% endif %} {% endblock %} In Django templates, {% ... %} denotes special in-template \"functions\" that Django understands. The {{ ... }} blocks work as \"slots\". They are replaced with whatever value the code inside the block returns. The first line, {% extends \"base.html\" %} , tells Django that this template extends the base template that Evennia is using. The base template is provided by the theme. Evennia comes with the open-source third-party theme prosimii . You can find it and its base.html in evennia/web/templates/prosimii . Like other templates, these can be overwritten. The next line is {% block content %} . The base.html file has block s, which are placeholders that templates can extend. The main block, and the one we use, is named content . We can access the character variable anywhere in the template because we passed it in the render call at the end of view.py . That means we also have access to the Character's db attributes, much like you would in normal Python code. You don't have the ability to call functions with arguments in the template-- in fact, if you need to do any complicated logic, you should do it in view.py and pass the results as more variables to the template. But you still have a great deal of flexibility in how you display the data. We can do a little bit of logic here as well. We use the {% for %} ... {% endfor %} and {% if %} ... {% else %} ... {% endif %} structures to change how the template renders depending on how many skills the user has, or if the user is approved (assuming your game has an approval system). The last file we need to edit is the master URLs file. This is needed in order to smoothly integrate the URLs from your new character app with the URLs from Evennia's existing pages. Find the file web/urls.py and update its patterns list as follows: # web/urls.py custom_patterns = [ url(r'^character/', include('web.character.urls)) ] Now reload the server with evennia reload and visit the page in your browser. If you haven't changed your defaults, you should be able to find the sheet for character #1 at http://localhost:4001/character/sheet/1/ Try updating the stats in-game and refresh the page in your browser. The results should show immediately. As an optional final step, you can also change your character typeclass to have a method called 'get_absolute_url'. # typeclasses/characters.py # inside Character def get_absolute_url(self): from django.core.urlresolvers import reverse return reverse('character:sheet', kwargs={'object_id':self.id}) Doing so will give you a 'view on site' button in the top right of the Django Admin Objects changepage that links to your new character sheet, and allow you to get the link to a character's page by using {{ object.get_absolute_url }} in any template where you have a given object. Now that you've made a basic page and app with Django, you may want to read the full Django tutorial to get a better idea of what it can do. You can find Django's tutorial here .","title":"Web Character View Tutorial"},{"location":"Web-Client-Webclient.html","text":"THIS IS A WORK IN PROGRESS \u00b6 Web client \u00b6 Evennia comes with a MUD client accessible from a normal web browser. During development you can try it at http://localhost:4001/webclient . The client consists of several parts, all under evennia/web/webclient/ : templates/webclient/webclient.html and templates/webclient/base.html are the very simplistic django html templates describing the webclient layout. static/webclient/js/evennia.js is the main evennia javascript library. This handles all communication between Evennia and the client over websockets and via AJAX/COMET if the browser can't handle websockets. It will make the Evennia object available to the javascript namespace, which offers methods for sending and receiving data to/from the server transparently. This is intended to be used also if swapping out the gui front end. static/webclient/js/webclient_gui.js is the default plugin manager. It adds the plugins and plugin_manager objects to the javascript namespace, coordinates the GUI operations between the various plugins, and uses the Evennia object library for all in/out. static/webclient/js/plugins provides a default set of plugins that implement a \"telnet-like\" interface. static/webclient/css/webclient.css is the CSS file for the client; it also defines things like how to display ANSI/Xterm256 colors etc. The server-side webclient protocols are found in evennia/server/portal/webclient.py and webclient_ajax.py for the two types of connections. You can't (and should not need to) modify these. Customizing the web client \u00b6 Like was the case for the website, you override the webclient from your game directory. You need to add/modify a file in the matching directory location within one of the _overrides directories. Example: To change the utilized plugin list, you need to override base.html by copying evennia/web/webclient/templates/webclient/base.html to mygame/web/template_overrides/webclient/base.html and editing it to add your new plugin. Evennia Web Client API (from evennia.js) \u00b6 Evennia.init( opts ) Evennia.connect() Evennia.isConnected() Evennia.msg( cmdname, args, kwargs, callback ) Evennia.emit( cmdname, args, kwargs ) log() Plugin Manager API (from webclient_gui.js) \u00b6 options Object, Stores key/value 'state' that can be used by plugins to coordinate behavior. plugins Object, key/value list of the all the loaded plugins. plugin_handler Object plugin_handler.add(\"name\", plugin) plugin_handler.onSend(string) Plugin callbacks API \u00b6 init() -- The only required callback boolean onKeydown(event) This plugin listens for Keydown events onBeforeUnload() This plugin does something special just before the webclient page/tab is closed. onLoggedIn(args, kwargs) This plugin does something when the webclient first logs in. onGotOptions(args, kwargs) This plugin does something with options sent from the server. boolean onText(args, kwargs) This plugin does something with messages sent from the server. boolean onPrompt(args, kwargs) This plugin does something when the server sends a prompt. boolean onUnknownCmd(cmdname, args, kwargs) This plugin does something with \"unknown commands\". onConnectionClose(args, kwargs) This plugin does something when the webclient disconnects from the server. newstring onSend(string) This plugin examines/alters text that other plugins generate. Use with caution The order of the plugins defined in base.html is important. All the callbacks for each plugin will be executed in that order. Functions marked \"boolean\" above must return true/false. Returning true will short-circuit the execution, so no other plugins lower in the base.html list will have their callback for this event called. This enables things like the up/down arrow keys for the history.js plugin to always occur before the default_in.js plugin adds that key to the current input buffer. Example/Default Plugins (plugins/*.js) \u00b6 default_in.js Defines onKeydown. key or mouse clicking the arrow will send the currently typed text. default_out.js Defines onText, onPrompt, and onUnknownCmd. Generates HTML output for the user. default_unload.js Defines onBeforeUnload. Prompts the user to confirm that they meant to leave/close the game. history.js Defines onKeydown and onSend. Creates a history of past sent commands, and uses arrow keys to peruse. notifications.js Defines onText. Generates browser notification events for each new message while the tab is hidden. oob.js Defines onSend. Allows the user to test/send Out Of Band json messages to the server. options.js Defines most callbacks. Provides a popup-based UI to coordinate options settings with the server. popups.js Provides default popups/Dialog UI for other plugins to use. splithandler.js Defines onText. Provides a powerful multi-window UI extension to automatically separate out screen real-estate by type of message. Writing your own Plugins \u00b6 So, you love the functionality of the webclient, but your game has specific types of text that need to be separated out into its own space, visually. The splithandler.js plugin provides a means to do this, but you don't want to have to force every player to set up their own layout every time they use the client. Let's create a mygame/web/static_overrides/webclient/js/plugins/layout.js plugin! First up, follow the directions in Customizing the Web Client section above to override the base.html. Next, add the new plugin to your copy of base.html: <script src={% static \"webclient/js/plugins/layout.js\" %} language=\"javascript\" type=\"text/javascript\"></script> Remember, plugins are load-order dependent, so make sure the new <script> tag comes after the splithandler.js And finally create the layout.js file and add the minimum skeleton of a plugin to it: // my new plugin var my_plugin = (function () { let init = function () { console.log(\"myplugin! Hello World!\"); } return { init: init, } })(); plugin_handler.add(\"myplugin\", my_plugin); Now, evennia stop , evennia collectstatic , and evennia start and then load the webclient up in your browser. Enable developer options and look in the console, and you should see the message 'myplugin! Hello World!' Since our layout.js plugin is going to use the splithandler, let's enhance this by adding a check to make sure the splithandler.js plugin has been loaded: change the above init function to: let init = function () { let splithandler = plugins['splithandler']; if( splithandler ) { console.log(\"MyPlugin initialized\"); } else { alert('MyPlugin requires the splithandler.js plugin. Please contact the game maintainer to correct this'); } } And finally, the splithandler.js provides provides two functions to cut up the screen real-estate: dynamic_split( pane_name_to_cut_apart, direction_of_split, new_pane_name1, new_pane_name2, text_flow_pane1, text_flow_pane2, array_of_split_percentages ) and set_pane_types( pane_to_set, array_of_known_message_types_to_assign) In this case, we'll cut it into 3 panes, 1 bigger, two smaller, and assign 'help' messages to the top-right pane: let init = function () { let splithandler = plugins['splithandler']; if( splithandler ) { splithandler.dynamic_split(\"main\",\"horizontal\",\"left\",\"right\",\"linefeed\",\"linefeed\",[50,50]); splithandler.dynamic_split(\"right\",\"vertical\",\"help\",\"misc\",\"replace\",\"replace\",[50,50]); splithandler.set_pane_types('help', ['help']); console.log(\"MyPlugin initialized\"); } else { alert('MyPlugin requires the splithandler.js plugin. Please contact the game maintainer to correct this'); } } evennia stop , evennia collectstatic , and evennia start once more, and force-reload your browser page to clear any cached version. You should now have a nicely split layout.","title":"**THIS IS A WORK IN PROGRESS**"},{"location":"Web-Client-Webclient.html#this-is-a-work-in-progress","text":"","title":"THIS IS A WORK IN PROGRESS"},{"location":"Web-Client-Webclient.html#web-client","text":"Evennia comes with a MUD client accessible from a normal web browser. During development you can try it at http://localhost:4001/webclient . The client consists of several parts, all under evennia/web/webclient/ : templates/webclient/webclient.html and templates/webclient/base.html are the very simplistic django html templates describing the webclient layout. static/webclient/js/evennia.js is the main evennia javascript library. This handles all communication between Evennia and the client over websockets and via AJAX/COMET if the browser can't handle websockets. It will make the Evennia object available to the javascript namespace, which offers methods for sending and receiving data to/from the server transparently. This is intended to be used also if swapping out the gui front end. static/webclient/js/webclient_gui.js is the default plugin manager. It adds the plugins and plugin_manager objects to the javascript namespace, coordinates the GUI operations between the various plugins, and uses the Evennia object library for all in/out. static/webclient/js/plugins provides a default set of plugins that implement a \"telnet-like\" interface. static/webclient/css/webclient.css is the CSS file for the client; it also defines things like how to display ANSI/Xterm256 colors etc. The server-side webclient protocols are found in evennia/server/portal/webclient.py and webclient_ajax.py for the two types of connections. You can't (and should not need to) modify these.","title":"Web client"},{"location":"Web-Client-Webclient.html#customizing-the-web-client","text":"Like was the case for the website, you override the webclient from your game directory. You need to add/modify a file in the matching directory location within one of the _overrides directories. Example: To change the utilized plugin list, you need to override base.html by copying evennia/web/webclient/templates/webclient/base.html to mygame/web/template_overrides/webclient/base.html and editing it to add your new plugin.","title":"Customizing the web client"},{"location":"Web-Client-Webclient.html#evennia-web-client-api-from-evenniajs","text":"Evennia.init( opts ) Evennia.connect() Evennia.isConnected() Evennia.msg( cmdname, args, kwargs, callback ) Evennia.emit( cmdname, args, kwargs ) log()","title":"Evennia Web Client API (from evennia.js)"},{"location":"Web-Client-Webclient.html#plugin-manager-api-from-webclient_guijs","text":"options Object, Stores key/value 'state' that can be used by plugins to coordinate behavior. plugins Object, key/value list of the all the loaded plugins. plugin_handler Object plugin_handler.add(\"name\", plugin) plugin_handler.onSend(string)","title":"Plugin Manager API (from webclient_gui.js)"},{"location":"Web-Client-Webclient.html#plugin-callbacks-api","text":"init() -- The only required callback boolean onKeydown(event) This plugin listens for Keydown events onBeforeUnload() This plugin does something special just before the webclient page/tab is closed. onLoggedIn(args, kwargs) This plugin does something when the webclient first logs in. onGotOptions(args, kwargs) This plugin does something with options sent from the server. boolean onText(args, kwargs) This plugin does something with messages sent from the server. boolean onPrompt(args, kwargs) This plugin does something when the server sends a prompt. boolean onUnknownCmd(cmdname, args, kwargs) This plugin does something with \"unknown commands\". onConnectionClose(args, kwargs) This plugin does something when the webclient disconnects from the server. newstring onSend(string) This plugin examines/alters text that other plugins generate. Use with caution The order of the plugins defined in base.html is important. All the callbacks for each plugin will be executed in that order. Functions marked \"boolean\" above must return true/false. Returning true will short-circuit the execution, so no other plugins lower in the base.html list will have their callback for this event called. This enables things like the up/down arrow keys for the history.js plugin to always occur before the default_in.js plugin adds that key to the current input buffer.","title":"Plugin callbacks API"},{"location":"Web-Client-Webclient.html#exampledefault-plugins-pluginsjs","text":"default_in.js Defines onKeydown. key or mouse clicking the arrow will send the currently typed text. default_out.js Defines onText, onPrompt, and onUnknownCmd. Generates HTML output for the user. default_unload.js Defines onBeforeUnload. Prompts the user to confirm that they meant to leave/close the game. history.js Defines onKeydown and onSend. Creates a history of past sent commands, and uses arrow keys to peruse. notifications.js Defines onText. Generates browser notification events for each new message while the tab is hidden. oob.js Defines onSend. Allows the user to test/send Out Of Band json messages to the server. options.js Defines most callbacks. Provides a popup-based UI to coordinate options settings with the server. popups.js Provides default popups/Dialog UI for other plugins to use. splithandler.js Defines onText. Provides a powerful multi-window UI extension to automatically separate out screen real-estate by type of message.","title":"Example/Default Plugins (plugins/*.js)"},{"location":"Web-Client-Webclient.html#writing-your-own-plugins","text":"So, you love the functionality of the webclient, but your game has specific types of text that need to be separated out into its own space, visually. The splithandler.js plugin provides a means to do this, but you don't want to have to force every player to set up their own layout every time they use the client. Let's create a mygame/web/static_overrides/webclient/js/plugins/layout.js plugin! First up, follow the directions in Customizing the Web Client section above to override the base.html. Next, add the new plugin to your copy of base.html: <script src={% static \"webclient/js/plugins/layout.js\" %} language=\"javascript\" type=\"text/javascript\"></script> Remember, plugins are load-order dependent, so make sure the new <script> tag comes after the splithandler.js And finally create the layout.js file and add the minimum skeleton of a plugin to it: // my new plugin var my_plugin = (function () { let init = function () { console.log(\"myplugin! Hello World!\"); } return { init: init, } })(); plugin_handler.add(\"myplugin\", my_plugin); Now, evennia stop , evennia collectstatic , and evennia start and then load the webclient up in your browser. Enable developer options and look in the console, and you should see the message 'myplugin! Hello World!' Since our layout.js plugin is going to use the splithandler, let's enhance this by adding a check to make sure the splithandler.js plugin has been loaded: change the above init function to: let init = function () { let splithandler = plugins['splithandler']; if( splithandler ) { console.log(\"MyPlugin initialized\"); } else { alert('MyPlugin requires the splithandler.js plugin. Please contact the game maintainer to correct this'); } } And finally, the splithandler.js provides provides two functions to cut up the screen real-estate: dynamic_split( pane_name_to_cut_apart, direction_of_split, new_pane_name1, new_pane_name2, text_flow_pane1, text_flow_pane2, array_of_split_percentages ) and set_pane_types( pane_to_set, array_of_known_message_types_to_assign) In this case, we'll cut it into 3 panes, 1 bigger, two smaller, and assign 'help' messages to the top-right pane: let init = function () { let splithandler = plugins['splithandler']; if( splithandler ) { splithandler.dynamic_split(\"main\",\"horizontal\",\"left\",\"right\",\"linefeed\",\"linefeed\",[50,50]); splithandler.dynamic_split(\"right\",\"vertical\",\"help\",\"misc\",\"replace\",\"replace\",[50,50]); splithandler.set_pane_types('help', ['help']); console.log(\"MyPlugin initialized\"); } else { alert('MyPlugin requires the splithandler.js plugin. Please contact the game maintainer to correct this'); } } evennia stop , evennia collectstatic , and evennia start once more, and force-reload your browser page to clear any cached version. You should now have a nicely split layout.","title":"Writing your own Plugins"},{"location":"Web-Features.html","text":"Evennia is its own webserver and hosts a default website and browser webclient. Web site \u00b6 The Evennia website is a Django application that ties in with the MUD database. Since the website shares this database you could, for example, tell website visitors how many accounts are logged into the game at the moment, how long the server has been up and any other database information you may want. During development you can access the website by pointing your browser to http://localhost:4001 . You may also want to set DEBUG = True in your settings file for debugging the website. You will then see proper tracebacks in the browser rather than just error codes. Note however that this will leak memory a lot (it stores everything all the time) and is not to be used in production . It's recommended to only use DEBUG for active web development and to turn it off otherwise. A Django (and thus Evennia) website basically consists of three parts, a view an associated template and an urls.py file. Think of the view as the Python back-end and the template as the HTML files you are served, optionally filled with data from the back-end. The urls file is a sort of mapping that tells Django that if a specific URL is given in the browser, a particular view should be triggered. You are wise to review the Django documentation for details on how to use these components. Evennia's default website is located in evennia/web/website . In this folder you'll find the simple default view as well as subfolders templates and static . Static files are things like images, CSS files and Javascript. Customizing the Website \u00b6 You customize your website from your game directory. In the folder web you'll find folders static , templates , static_overrides and templates_overrides . The first two of those are populated automatically by Django and used to serve the website. You should not edit anything in them - the change will be lost. To customize the website you'll need to copy the file you want to change from the web/website/template/ or web/website/static/ path to the corresponding place under one of _overrides` directories. Example: To override or modify evennia/web/website/template/website/index.html you need to add/modify mygame/web/template_overrides/website/index.html . The detailed description on how to customize the website is best described in tutorial form. See the Web Tutorial for more information. Overloading Django views \u00b6 The Python backend for every HTML page is called a Django view . A view can do all sorts of functions, but the main one is to update variables data that the page can display, like how your out-of-the-box website will display statistics about number of users and database objects. To re-point a given page to a view.py of your own, you need to modify mygame/web/urls.py . An URL pattern is a regular expression that you need to enter in the address field of your web browser to get to the page in question. If you put your own URL pattern before the default ones, your own view will be used instead. The file urls.py even marks where you should put your change. Here's an example: # mygame/web/urls.py from django.conf.urls import url, include # default patterns from evennia.web.urls import urlpatterns # our own view to use as a replacement from web.myviews import myview # custom patterns to add patterns = [ # overload the main page view url(r'^', myview, name='mycustomview'), ] urlpatterns = patterns + urlpatterns Django will always look for a list named urlpatterns which consists of the results of url() calls. It will use the first match it finds in this list. Above, we add a new URL redirect from the root of the website. It will now our own function myview from a new module mygame/web/myviews.py . If our game is found on http://mygame.com , the regular expression \"^\" means we just entered mygame.com in the address bar. If we had wanted to add a view for http://mygame.com/awesome , the regular expression would have been ^/awesome . Look at evennia/web/website/views.py to see the inputs and outputs you must have to define a view. Easiest may be to copy the default file to mygame/web to have something to modify and expand on. Restart the server and reload the page in the browser - the website will now use your custom view. If there are errors, consider turning on settings.DEBUG to see the full tracebacks - in debug mode you will also log all requests in mygame/server/logs/http_requests.log . Web client \u00b6 Evennia comes with a MUD client accessible from a normal web browser. During development you can try it at http://localhost:4001/webclient . The client consists of several parts, all under evennia/web/webclient/ : templates/webclient/webclient.html and templates/base.html are the very simplistic django html templates describing the webclient layout. The base.html acts as a header that sets up all the basic stuff the client needs, so one only needs to modify the much cleaner webclient.html . static/webclient/evennia.js is the main evennia javascript library. This handles all communication between Evennia and the client over websockets and via AJAX/COMET if the browser can't handle websockets. It will make the Evennia object available to the javascript namespace, which offers methods for sending and receiving data to/from the server transparently. This is intended to be used also if swapping out the gui front end. static/webclient/js/evennia.js is the default GUI of the webclient. This handles the input line, the send button and sends text to the right DOM elements in the html file. It makes use of the evennia.js library for all in/out and implements a \"telnet-like\" interface. static/webclient/css/webclient.css is the CSS file for the client; it also defines things like how to display ANSI/Xterm256 colors etc. The server-side webclient protocols are found in evennia/server/portal/webclient.py and webclient_ajax.py for the two types of connections. You can't (and should not need to) modify these. Customizing the web client \u00b6 Like was the case for the website, you override the webclient from your game directory. You need to add/modify a file in the matching directory location within one of the _overrides directories. Example: To replace/modify evennia/web/webclient/static/webclient/js/webclient_gui.js you need copy and modify the file at mygame/web/static_overrides/webclient/js/webclient_gui.js . See the Web Tutorial for more on how to customize the webclient. The Django 'Admin' Page \u00b6 Django comes with a built-in admin website . This is accessible by clicking the 'admin' button from your game website. The admin site allows you to see, edit and create objects in your database from a graphical interface. The behavior of default Evennia models are controlled by files admin.py in the Evennia package. New database models you choose to add yourself (such as in the Web Character View Tutorial) can/will also have admin.py files. New models are registered to the admin website by a call of admin.site.register(model class, admin class) inside an admin.py file. It is an error to attempt to register a model that has already been registered. To overload Evennia's admin files you don't need to modify Evennia itself. To customize you can call admin.site.unregister(model class) , then follow that with admin.site.register in one of your own admin.py files in a new app that you add. More reading \u00b6 Evennia relies on Django for its web features. For details on expanding your web experience, the Django documentation or the Django Book are the main resources to look into. In Django lingo, the Evennia is a django \"project\" that consists of Django \"applications\". For the sake of web implementation, the relevant django \"applications\" in default Evennia are web/website or web/webclient .","title":"Web Features"},{"location":"Web-Features.html#web-site","text":"The Evennia website is a Django application that ties in with the MUD database. Since the website shares this database you could, for example, tell website visitors how many accounts are logged into the game at the moment, how long the server has been up and any other database information you may want. During development you can access the website by pointing your browser to http://localhost:4001 . You may also want to set DEBUG = True in your settings file for debugging the website. You will then see proper tracebacks in the browser rather than just error codes. Note however that this will leak memory a lot (it stores everything all the time) and is not to be used in production . It's recommended to only use DEBUG for active web development and to turn it off otherwise. A Django (and thus Evennia) website basically consists of three parts, a view an associated template and an urls.py file. Think of the view as the Python back-end and the template as the HTML files you are served, optionally filled with data from the back-end. The urls file is a sort of mapping that tells Django that if a specific URL is given in the browser, a particular view should be triggered. You are wise to review the Django documentation for details on how to use these components. Evennia's default website is located in evennia/web/website . In this folder you'll find the simple default view as well as subfolders templates and static . Static files are things like images, CSS files and Javascript.","title":"Web site"},{"location":"Web-Features.html#customizing-the-website","text":"You customize your website from your game directory. In the folder web you'll find folders static , templates , static_overrides and templates_overrides . The first two of those are populated automatically by Django and used to serve the website. You should not edit anything in them - the change will be lost. To customize the website you'll need to copy the file you want to change from the web/website/template/ or web/website/static/ path to the corresponding place under one of _overrides` directories. Example: To override or modify evennia/web/website/template/website/index.html you need to add/modify mygame/web/template_overrides/website/index.html . The detailed description on how to customize the website is best described in tutorial form. See the Web Tutorial for more information.","title":"Customizing the Website"},{"location":"Web-Features.html#overloading-django-views","text":"The Python backend for every HTML page is called a Django view . A view can do all sorts of functions, but the main one is to update variables data that the page can display, like how your out-of-the-box website will display statistics about number of users and database objects. To re-point a given page to a view.py of your own, you need to modify mygame/web/urls.py . An URL pattern is a regular expression that you need to enter in the address field of your web browser to get to the page in question. If you put your own URL pattern before the default ones, your own view will be used instead. The file urls.py even marks where you should put your change. Here's an example: # mygame/web/urls.py from django.conf.urls import url, include # default patterns from evennia.web.urls import urlpatterns # our own view to use as a replacement from web.myviews import myview # custom patterns to add patterns = [ # overload the main page view url(r'^', myview, name='mycustomview'), ] urlpatterns = patterns + urlpatterns Django will always look for a list named urlpatterns which consists of the results of url() calls. It will use the first match it finds in this list. Above, we add a new URL redirect from the root of the website. It will now our own function myview from a new module mygame/web/myviews.py . If our game is found on http://mygame.com , the regular expression \"^\" means we just entered mygame.com in the address bar. If we had wanted to add a view for http://mygame.com/awesome , the regular expression would have been ^/awesome . Look at evennia/web/website/views.py to see the inputs and outputs you must have to define a view. Easiest may be to copy the default file to mygame/web to have something to modify and expand on. Restart the server and reload the page in the browser - the website will now use your custom view. If there are errors, consider turning on settings.DEBUG to see the full tracebacks - in debug mode you will also log all requests in mygame/server/logs/http_requests.log .","title":"Overloading Django views"},{"location":"Web-Features.html#web-client","text":"Evennia comes with a MUD client accessible from a normal web browser. During development you can try it at http://localhost:4001/webclient . The client consists of several parts, all under evennia/web/webclient/ : templates/webclient/webclient.html and templates/base.html are the very simplistic django html templates describing the webclient layout. The base.html acts as a header that sets up all the basic stuff the client needs, so one only needs to modify the much cleaner webclient.html . static/webclient/evennia.js is the main evennia javascript library. This handles all communication between Evennia and the client over websockets and via AJAX/COMET if the browser can't handle websockets. It will make the Evennia object available to the javascript namespace, which offers methods for sending and receiving data to/from the server transparently. This is intended to be used also if swapping out the gui front end. static/webclient/js/evennia.js is the default GUI of the webclient. This handles the input line, the send button and sends text to the right DOM elements in the html file. It makes use of the evennia.js library for all in/out and implements a \"telnet-like\" interface. static/webclient/css/webclient.css is the CSS file for the client; it also defines things like how to display ANSI/Xterm256 colors etc. The server-side webclient protocols are found in evennia/server/portal/webclient.py and webclient_ajax.py for the two types of connections. You can't (and should not need to) modify these.","title":"Web client"},{"location":"Web-Features.html#customizing-the-web-client","text":"Like was the case for the website, you override the webclient from your game directory. You need to add/modify a file in the matching directory location within one of the _overrides directories. Example: To replace/modify evennia/web/webclient/static/webclient/js/webclient_gui.js you need copy and modify the file at mygame/web/static_overrides/webclient/js/webclient_gui.js . See the Web Tutorial for more on how to customize the webclient.","title":"Customizing the web client"},{"location":"Web-Features.html#the-django-admin-page","text":"Django comes with a built-in admin website . This is accessible by clicking the 'admin' button from your game website. The admin site allows you to see, edit and create objects in your database from a graphical interface. The behavior of default Evennia models are controlled by files admin.py in the Evennia package. New database models you choose to add yourself (such as in the Web Character View Tutorial) can/will also have admin.py files. New models are registered to the admin website by a call of admin.site.register(model class, admin class) inside an admin.py file. It is an error to attempt to register a model that has already been registered. To overload Evennia's admin files you don't need to modify Evennia itself. To customize you can call admin.site.unregister(model class) , then follow that with admin.site.register in one of your own admin.py files in a new app that you add.","title":"The Django 'Admin' Page"},{"location":"Web-Features.html#more-reading","text":"Evennia relies on Django for its web features. For details on expanding your web experience, the Django documentation or the Django Book are the main resources to look into. In Django lingo, the Evennia is a django \"project\" that consists of Django \"applications\". For the sake of web implementation, the relevant django \"applications\" in default Evennia are web/website or web/webclient .","title":"More reading"},{"location":"Web-Tutorial.html","text":"Evennia uses the Django web framework as the basis of both its database configuration and the website it provides. While a full understanding of Django requires reading the Django documentation, we have provided this tutorial to get you running with the basics and how they pertain to Evennia. This text details getting everything set up. The Web-based Character view Tutorial gives a more explicit example of making a custom web page connected to your game, and you may want to read that after finishing this guide. A Basic Overview \u00b6 Django is a web framework. It gives you a set of development tools for building a website quickly and easily. Django projects are split up into apps and these apps all contribute to one project. For instance, you might have an app for conducting polls, or an app for showing news posts or, like us, one for creating a web client. Each of these applications has a urls.py file, which specifies what URL s are used by the app, a views.py file for the code that the URLs activate, a templates directory for displaying the results of that code in HTML for the user, and a static folder that holds assets like CSS , Javascript , and Image files (You may note your mygame/web folder does not have a static or template folder. This is intended and explained further below). Django applications may also have a models.py file for storing information in the database. We will not change any models here, take a look at the New Models page (as well as the Django docs on models) if you are interested. There is also a root urls.py that determines the URL structure for the entire project. A starter urls.py is included in the default game template, and automatically imports all of Evennia's default URLs for you. This is located in web/urls.py . Changing the logo on the front page \u00b6 Evennia's default logo is a fun little googly-eyed snake wrapped around a gear globe. As cute as it is, it probably doesn't represent your game. So one of the first things you may wish to do is replace it with a logo of your own. Django web apps all have static assets : CSS files, Javascript files, and Image files. In order to make sure the final project has all the static files it needs, the system collects the files from every app's static folder and places it in the STATIC_ROOT defined in settings.py . By default, the Evennia STATIC_ROOT is in web/static . Because Django pulls files from all of those separate places and puts them in one folder, it's possible for one file to overwrite another. We will use this to plug in our own files without having to change anything in the Evennia itself. By default, Evennia is configured to pull files you put in the web/static_overrides after all other static files. That means that files in static_overrides folder will overwrite any previously loaded files having the same path under its static folder . This last part is important to repeat: To overload the static resource from a standard static folder you need to replicate the path of folders and file names from that static folder in exactly the same way inside static_overrides . Let's see how this works for our logo. The default web application is in the Evennia library itself, in evennia/web/ . We can see that there is a static folder here. If we browse down, we'll eventually find the full path to the Evennia logo file: evennia/web/static/evennia_general/images/evennia_logo.png . Inside our static_overrides we must replicate the part of the path inside the static folder, in other words, we must replicate evennia_general/images/evennia_logo.png . So, to change the logo, we need to create the folder path evennia_general/images/ in static_overrides . We then rename our own logo file to evennia_logo.png and copy it there. The final path for this file would thus be: web/static_overrides/evennia_general/images/evennia_logo.png in your local game folder. To get this file pulled in, just change to your own game directory and reload the server: evennia reload This will reload the configuration and bring in the new static file(s). If you didn't want to reload the server you could instead use evennia collectstatic to only update the static files without any other changes. Note : Evennia will collect static files automatically during startup. So if evennia collectstatic reports finding 0 files to collect, make sure you didn't start the engine at some point - if so the collector has already done its work! To make sure, connect to the website and check so the logo has actually changed to your own version. Note : Sometimes the static asset collector can get confused. If no matter what you do, your overridden files aren't getting copied over the defaults, try removing the target file (or everything) in the web/static directory, and re-running collectstatic to gather everything from scratch. Changing the Front Page's Text \u00b6 The default front page for Evennia contains information about the Evennia project. You'll probably want to replace this information with information about your own project. Changing the page template is done in a similar way to changing static resources. Like static files, Django looks through a series of template folders to find the file it wants. The difference is that Django does not copy all of the template files into one place, it just searches through the template folders until it finds a template that matches what it's looking for. This means that when you edit a template, the changes are instant. You don't have to reload the server or run any extra commands to see these changes - reloading the web page in your browser is enough. To replace the index page's text, we'll need to find the template for it. We'll go into more detail about how to determine which template is used for rendering a page in the Web-based Character view Tutorial . For now, you should know that the template we want to change is stored in evennia/web/website/templates/website/index.html . To replace this template file, you will put your changed template inside the web/template_overrides/website directory in your game folder. In the same way as with static resources you must replicate the path inside the default template directory exactly. So we must copy our replacement template named index.html there (or create the website directory in web/template_overrides if it does not exist, first). The final path to the file should thus be: web/template_overrides/website/index.html` within your game directory. Note that it is usually easier to just copy the original template over and edit it in place. The original file already has all the markup and tags, ready for editing. Further reading \u00b6 For further hints on working with the web presence, you could now continue to the Web-based Character view Tutorial where you learn to make a web page that displays in-game character stats. You can also look at Django's own tutorial to get more insight in how Django works and what possibilities exist.","title":"Web Tutorial"},{"location":"Web-Tutorial.html#a-basic-overview","text":"Django is a web framework. It gives you a set of development tools for building a website quickly and easily. Django projects are split up into apps and these apps all contribute to one project. For instance, you might have an app for conducting polls, or an app for showing news posts or, like us, one for creating a web client. Each of these applications has a urls.py file, which specifies what URL s are used by the app, a views.py file for the code that the URLs activate, a templates directory for displaying the results of that code in HTML for the user, and a static folder that holds assets like CSS , Javascript , and Image files (You may note your mygame/web folder does not have a static or template folder. This is intended and explained further below). Django applications may also have a models.py file for storing information in the database. We will not change any models here, take a look at the New Models page (as well as the Django docs on models) if you are interested. There is also a root urls.py that determines the URL structure for the entire project. A starter urls.py is included in the default game template, and automatically imports all of Evennia's default URLs for you. This is located in web/urls.py .","title":"A Basic Overview"},{"location":"Web-Tutorial.html#changing-the-logo-on-the-front-page","text":"Evennia's default logo is a fun little googly-eyed snake wrapped around a gear globe. As cute as it is, it probably doesn't represent your game. So one of the first things you may wish to do is replace it with a logo of your own. Django web apps all have static assets : CSS files, Javascript files, and Image files. In order to make sure the final project has all the static files it needs, the system collects the files from every app's static folder and places it in the STATIC_ROOT defined in settings.py . By default, the Evennia STATIC_ROOT is in web/static . Because Django pulls files from all of those separate places and puts them in one folder, it's possible for one file to overwrite another. We will use this to plug in our own files without having to change anything in the Evennia itself. By default, Evennia is configured to pull files you put in the web/static_overrides after all other static files. That means that files in static_overrides folder will overwrite any previously loaded files having the same path under its static folder . This last part is important to repeat: To overload the static resource from a standard static folder you need to replicate the path of folders and file names from that static folder in exactly the same way inside static_overrides . Let's see how this works for our logo. The default web application is in the Evennia library itself, in evennia/web/ . We can see that there is a static folder here. If we browse down, we'll eventually find the full path to the Evennia logo file: evennia/web/static/evennia_general/images/evennia_logo.png . Inside our static_overrides we must replicate the part of the path inside the static folder, in other words, we must replicate evennia_general/images/evennia_logo.png . So, to change the logo, we need to create the folder path evennia_general/images/ in static_overrides . We then rename our own logo file to evennia_logo.png and copy it there. The final path for this file would thus be: web/static_overrides/evennia_general/images/evennia_logo.png in your local game folder. To get this file pulled in, just change to your own game directory and reload the server: evennia reload This will reload the configuration and bring in the new static file(s). If you didn't want to reload the server you could instead use evennia collectstatic to only update the static files without any other changes. Note : Evennia will collect static files automatically during startup. So if evennia collectstatic reports finding 0 files to collect, make sure you didn't start the engine at some point - if so the collector has already done its work! To make sure, connect to the website and check so the logo has actually changed to your own version. Note : Sometimes the static asset collector can get confused. If no matter what you do, your overridden files aren't getting copied over the defaults, try removing the target file (or everything) in the web/static directory, and re-running collectstatic to gather everything from scratch.","title":"Changing the logo on the front page"},{"location":"Web-Tutorial.html#changing-the-front-pages-text","text":"The default front page for Evennia contains information about the Evennia project. You'll probably want to replace this information with information about your own project. Changing the page template is done in a similar way to changing static resources. Like static files, Django looks through a series of template folders to find the file it wants. The difference is that Django does not copy all of the template files into one place, it just searches through the template folders until it finds a template that matches what it's looking for. This means that when you edit a template, the changes are instant. You don't have to reload the server or run any extra commands to see these changes - reloading the web page in your browser is enough. To replace the index page's text, we'll need to find the template for it. We'll go into more detail about how to determine which template is used for rendering a page in the Web-based Character view Tutorial . For now, you should know that the template we want to change is stored in evennia/web/website/templates/website/index.html . To replace this template file, you will put your changed template inside the web/template_overrides/website directory in your game folder. In the same way as with static resources you must replicate the path inside the default template directory exactly. So we must copy our replacement template named index.html there (or create the website directory in web/template_overrides if it does not exist, first). The final path to the file should thus be: web/template_overrides/website/index.html` within your game directory. Note that it is usually easier to just copy the original template over and edit it in place. The original file already has all the markup and tags, ready for editing.","title":"Changing the Front Page's Text"},{"location":"Web-Tutorial.html#further-reading","text":"For further hints on working with the web presence, you could now continue to the Web-based Character view Tutorial where you learn to make a web page that displays in-game character stats. You can also look at Django's own tutorial to get more insight in how Django works and what possibilities exist.","title":"Further reading"},{"location":"Webclient-brainstorm.html","text":"Ideas for a future webclient gui \u00b6 This is a brainstorming whitepage. Add your own comments in a named section below. From Chat on 2019/09/02 \u00b6 Griatch (IRC)APP @friarzen: Could one (with goldenlayout) programmatically provide pane positions and sizes? I recall it was not trivial for the old split.js solution. friarzen take a look at the goldenlayout_default_config.js It is kinda cryptic but that is the layout json. Griatch (IRC)APP @friarzen: Hm, so dynamically replacing the goldenlayout_config in the global scope at the right thing would do it? friarzen yep friarzen the biggest pain in the butt is that goldenlayout_config needs to be set before the goldenlayout init() is called, which isn't trivial with the current structure, but it isn't impossible. Griatch (IRC)APP One could in principle re-run init() at a later date though, right? friarzen Hmm...not sure I've ever tried it... seems doable off the top of my head... right now, that whole file exists to be overridden on page load as a separate <script> HTML tag, so it can get force-loaded early. you could just as easily call the server at that time for the proper config info and store it into the variable. Griatch (IRC)APP @friarzen: Right. I picture the default would either be modified directly in that file or even be in settings. friarzen And if you have it call with an authenticated session at that early point, you could even have the layout be defined as a per-user setting. Griatch (IRC)APP Yeah, I think that'd be a very important feature. So one part of the config would be the golden-layout config blob; then another section with custom per-pane settings. Things like which tag a pane filters on, its type, and options for that type (like replace/scroll for a text pane etc). And probably one general config section; things like notifications, sounds, popup settings and the like friarzen Actually, that information is already somewhat stored into the data as componentState {} Griatch (IRC)APP I imagine a pane would need to be identified uniquely for golden-layout to know which is which, so that'd need to be associated. friarzen see line 55. that's....where it gets tricky... goldenlayout is kinda dumb in that it treats the whole json blob as a state object. Griatch (IRC)APP componentState, is the idea that it takes arbitrary settings then? friarzen so each sub-dictionary with a type of \"component\" in it is a window and as you move stuff around it dynamically creates new dictionaries as needed to keep it all together. yep right now I'm storing the list of types as a string and the updateMethod type as a string, just to be as obvious as possible. Griatch (IRC)APP I wonder if one could populate componentState(s) just before initializing the system, and then extract them into a more Evennia-friendly storage when saving. Or maybe it's no big deal to just store that whole blob as-is, with some extra things added? friarzen if you want to see it in action, take a look at the values in your localstorage after you've moved stuff around, created new windows, etc. I think their preference is to just store the whole blob. which is what the localstorage save does, in fact. Griatch (IRC)APP Yes, I see. It allows you to retain the session within your browser as well friarzen One trick I've been thinking about for the whole interface is to have another pair of components, one being a \"dynamic\" config window that displays a series of dropdowns, one for each plugin that defines it's own settings. And another that has an embedded i-frame to allow a split-screen where half of the display is the text interface and the other loads the local main website page and allows further browsing. Griatch (IRC)APP I think ideally, each pane should handle its per-pane settings as a dropdown or popup triggered from its header. friarzen well, pane != plugin... Griatch (IRC)APP True, one tends to sometimes make the other available but they are not the same friarzen think of the history plugin for example...if you want to make keyboard keys dynamically configurable, you need some place to enter that information. yeah. Griatch (IRC)APP Yes, I buy that - a dynamical option window would be needed. I'd say the 'global' settings should be treated as just another module in this regard though So that if you have no modules installed, there is one entry in that option pane, the one that opens the global options friarzen Yeah, so that is that component...one pane. Griatch (IRC)APP Another thing that the config should contain would be the available message tags. Waiting for them to actually show up before being able to use them is not that useful. This would likely have to be a setting though I imagine. friarzen we could remove the current pop-up and just open the new component pane instead, and then that pane would display the list of plugins that registered a config() callback. Griatch (IRC)APP Yes friarzen yeah, the server has to pre-define what tags it is going to send. Griatch (IRC)APP The process for adding a tag would be to adding to, say, a list in settings, restart and then .. profit friarzen yep, which is kind of how I see spawns working. Griatch (IRC)APP spawns, meaning stand-alone windows? friarzen we just have a plugin that defines it's config pane with a \"match this text\" box and a tag type to send the data to, or spawn a new pane with that tag type preselected to capture that text. wouldn't be stand alone windows. just new tabs, for now. Griatch (IRC)APP Ok, so a filter target that filters on text content and directs to tag friarzen yep. Griatch (IRC)APP (or re-tags it, I suppose) friarzen yeah, exactly. and opens a new window for that tag if one doesn't already exist. Griatch (IRC)APP A lot of complex effects could be achieved there. Should the filter extract the text and re-tag, or should it keep the text with its original tag and make a copy of it with the new tag? O_o; friarzen yet more options for the user. :slightly_smiling_face: baby steps first I think. \"pages from bob should go to bob's window, not the general chat window\" Griatch (IRC)APP It doesn't sound too hard to do - using tagging like that is really neat since then the rerouting can just work normally without knowing which pane you are actually rerouting too (and you could have multiple panes getting the same content too) friarzen yep. and the i-frame component, I think, provides just as much wow facter. Griatch (IRC)APP Yes, the setting would be something like: If text contains \"bob\" -> set tag \"bob\" (auto-create pane if not exist []?) friarzen just being able to load a character page from the wiki side in half the screen (including the pictures and whatnot) while playing/reading the text from the other half is really nice. Griatch (IRC)APP Could there not be some cross-scripting warnings in modern browsers if trying to load another website in an iframe? I doubt you could open Github like that, for example. friarzen well, assuming it is all from the same origin game server, it will all be from the same domain, so should avoid that, but it will take some testing to make sure. I want to get it to the point where you can click on somebody's name in the general terminal-style window and have it pop up that characters' wiki page. Griatch (IRC)APP That does sound nice :) friarzen i-frames are pretty much the only way to handle cross-domain content, but they are a pain in the butt to get that to work. Griatch (IRC)APP If it's on the same domain it would be fine, but it should probably give a \"you are now leaving ...\" message and switch to a new window if going elsewhere. friarzen (without getting into modern CORS url blessings) yeah Griatch (IRC)APP Just to avoid headaches :) friarzen So, yeah, two new goldenlayout components that I am working on but they aren't ready yet. heh. Griatch (IRC)APP Oh, you are working on them already? friarzen yeah, some initial \"will this work\" structure. I haven't found anything yet that will not make it work. it's mostly just not going to look very pretty to start with. It'll take a few iterations I bet. Griatch (IRC)APP Sounds good! We should probably try to formalize our thoughts around a future config format as well. Depending just how and when the golden-layout blob needs to be in place and if we can construct it on-the- fly, it affects the format style chosen. friarzen Yeah, that's new from today's conversation, so I don't really have anything built for that. Griatch (IRC)APP I'm still unsure about how the Evennia/pane specific things (that'd need to be serialized to the database on a per-account basis) would interact with the golden-layout structure. friarzen maybe the place to start is to wipe-out/update the old https://github.com/evennia/evennia/wiki/Webclient- brainstorm entry? Griatch (IRC)APP I don't think we need to wipe the old, but we could certainly add a new section above the old and start some new discussions. friarzen It is really just that per componentState bit. anything in that json is treated as a blackbox that goldenlayout just passes around. Griatch (IRC)APP So would we save the whole blob then, componentState and all, and simply not worry about ourselves storing per-pane options? The drawback with that would be that a dev could not offer an exact default layout/setup for the user. ... unless they set it up and saved the blob I guess friarzen Yeah, that's exactly how I built mine. :slightly_smiling_face: not the most dev-friendly way to do it, but it works. Griatch (IRC)APP Heh. Ok, so the config would be one section for the golden-layout-blob, one for module settings, one of which is the global settings. and a list of the available tags friarzen yep Griatch (IRC)APP And probably an empty misc section for future use ... friarzen seems reasonable. Griatch (IRC)APP So, that means that in the future one would need a procedure for the dev to easily create and save the player-wide default to central storage. Well, one step at a time. For now, good night! friarzen Yep, I expect that would be some kind of admin-approved api/command Griatch (IRC)APP And thanks for the discussion! Relates to the activity happening relating to the Webclient extensions task #614 . Griatch Jan 23, 2017 \u00b6 These are my ideas for the functionality of Evennia's webclient in the (possibly distant) future. It assumes the webclient options have been implemented as per #1172 . The idea of the GUI is based around panes (a \"window\" feels like something that pops open). These are areas of the window of the type you would see from a javascript library like Split.js . Each pane has a separator with a handle for resizing it. Each pane has an icon for opening a dropdown menu (see next mockup image). Above image could show the default setup; mimicking the traditional telnet mud client setup. There should be at least one input pane (but you could add multiple). The Input pane has the icon for launching the main webclient options window. Alternatively the options icon could hover transparently in the upper left, \"above\" all panes . The main webclient options window should have an option for hiding all GUI customization icons (the draggable handles of panes and the dropdown menu) for users who does not want to have to worry about changing things accidentally. Devs not wanting to offer players the ability to customize their client GUIs could maybe just set it up the way they want and then turn the gui controls off on the javascript level. The dropdown menu allows for splitting each pane horizontally and vertically. Each pane is \"tagged\" with what data will be sent to it. It could accept more than one type of tagged data. Just which tags are available is different for each game (and should be reported by the server). For example, the server could send the return of the \"look\" command as msg(\"you see ...\", {\"pane\": \"look\"}) If one (or more) of the panes is set to receive \"look\" data, all such will go there. If no pane is assigned to \"look\", this text will end up in the pane(s) with the \"Unassigned\" designation. It might be necessary to enforce that at least one window has the \"unassigned\" designation in order to not lose output without a clear pane target. By contrast the pane tagged with \"All\" receives all output regardless of if it is also being sent to other panes. Another thing that came to mind is logging. It might be an idea to tie a given log file to a specific pane (panes?) to limit spam in the log (it might be one reason for having a pane with the \"All\" tag, for those wanting to log everything ). This could also be set in the dropdown menu or in the webclient options window, maybe. Comments? titeuf87 Jan 23, 2017 \u00b6 That way of splitting panes seems easy to manage while still being powerful at the same time. It's certainly a lot more flexible than what I had in mind. This is a quick sketch of what I was thinking about: ===================== Options [x] ===================== help: [popup] map: [top left] channels: [top right] look: [main output] But that's not as good as Griatch's proposal. The panes themselves can work differently depending on the content though: channel messages: when someone talks on a channel, the output text needs to be appended to the text already shown. inventory: this pane should clear its output every time the inventory is displayed, so old inventory is not displayed. Also what about dropping items? As long as the player doesn't check its inventory then that pane won't be updated, unless more OOB data is added to track the inventory. help/look: those pane should probably also clear their content before displaying new content. logging: do you mean have a \"save to log\" item in the pane menu? Griatch Jan 23, 2017 \u00b6 It makes sense that different types of panes would have different functionality. I was thinking that something like inventory would be very specific to a given game. But titeuf87 has a point - maybe you can get a rather generalized behavior just by defining if a pane should replace or append to the existing data. As for the updating of inventory when dropping items, not sure if that can be generalized, but I guess drop/get commands could be wired to do that. As for logging - yes I picture a \"save to log\" thing in the menu. The problem is just where to save the log. I think at least for an initial setup, one could maybe set the logging file path in the webclient options and just append logs from all the panes marked for logging to that same file. chainsol 3rd of October, 2017 \u00b6 I've been messing a little bit with split.js - I've managed to split a split dynamically with a data attribute on a button and jQuery. My current thinking on this issue is to use jQuery Templates to write the template for horizontal and vertical splits, then using jQuery to set up the initial split layout by inserting those templates as appropriate for user settings. We would have a dropdown per split that decides what tag it's meant to handle - perhaps a data attribute that we change in the template for easy selection through jQuery - and then send tags for messages to the webclient. This dropdown would also have a setting per split to either append new content or replace content - again, perhaps a data attribute. We might also want to store \"mobile\" and \"desktop\" layouts separately - or just default to a mobile-friendly layout at a certain screen size, and turn off the splits. Oh, and embedding Bootstrap containers in splits works perfectly - that could help us too. chainsol 9th of October, 2017 \u00b6 I've got a demo of this working at my development box , if anyone wants to take a look. So far, I've got tag handling, dynamic splits, and the ability to swap splits' contents. Since this doesn't have a fancy interface yet, if you want to see a dynamic split, open your browser's console and try these commands: SplitHandler.split(\"#main\", \"horizontal\") will split the top-half into two 50-50 splits, both receiving content that's not tagged or is tagged \"all\" from the server. SplitHandler.swapContent(\"#input\", \"#split_2\") after doing so will swap the input into the top-left split. I'm trying to figure out where to put each split's configuration - maybe a dropdown button that's semi-transparent until you hover over it? So far, if you edited the data attributes, you could change each split to receive only tagged messages ( data-tag=\"all\" ), and you could change them to overwrite instead of append data ( data-update-append or data-update-overwrite ) Griatch Oct 13, 2017 \u00b6 I would suggest that, assuming the game dev allows the user to modify their GUI in the first place, that modification is a \"mode\". I picture that 99% of the time a user doesn't need to modify their interface. They only want to click whatever game-related buttons etc are present in the pane without risk of resizing things accidentally. So I'd say that normally the panes are all fixed, with minimal spacing between them, no handles etc. But you can enter the client settings window and choose Customize GUI mode (or something like that). When you do, then separators get handles and the dropdown menu markers appear (permanently) in the corner of each pane. This means that if a user wants to easily tweak their window they could stay in this mode, but they could also \"lock\" the gui layout at any time.","title":"Ideas for a future webclient gui"},{"location":"Webclient-brainstorm.html#ideas-for-a-future-webclient-gui","text":"This is a brainstorming whitepage. Add your own comments in a named section below.","title":"Ideas for a future webclient gui"},{"location":"Webclient-brainstorm.html#from-chat-on-20190902","text":"Griatch (IRC)APP @friarzen: Could one (with goldenlayout) programmatically provide pane positions and sizes? I recall it was not trivial for the old split.js solution. friarzen take a look at the goldenlayout_default_config.js It is kinda cryptic but that is the layout json. Griatch (IRC)APP @friarzen: Hm, so dynamically replacing the goldenlayout_config in the global scope at the right thing would do it? friarzen yep friarzen the biggest pain in the butt is that goldenlayout_config needs to be set before the goldenlayout init() is called, which isn't trivial with the current structure, but it isn't impossible. Griatch (IRC)APP One could in principle re-run init() at a later date though, right? friarzen Hmm...not sure I've ever tried it... seems doable off the top of my head... right now, that whole file exists to be overridden on page load as a separate <script> HTML tag, so it can get force-loaded early. you could just as easily call the server at that time for the proper config info and store it into the variable. Griatch (IRC)APP @friarzen: Right. I picture the default would either be modified directly in that file or even be in settings. friarzen And if you have it call with an authenticated session at that early point, you could even have the layout be defined as a per-user setting. Griatch (IRC)APP Yeah, I think that'd be a very important feature. So one part of the config would be the golden-layout config blob; then another section with custom per-pane settings. Things like which tag a pane filters on, its type, and options for that type (like replace/scroll for a text pane etc). And probably one general config section; things like notifications, sounds, popup settings and the like friarzen Actually, that information is already somewhat stored into the data as componentState {} Griatch (IRC)APP I imagine a pane would need to be identified uniquely for golden-layout to know which is which, so that'd need to be associated. friarzen see line 55. that's....where it gets tricky... goldenlayout is kinda dumb in that it treats the whole json blob as a state object. Griatch (IRC)APP componentState, is the idea that it takes arbitrary settings then? friarzen so each sub-dictionary with a type of \"component\" in it is a window and as you move stuff around it dynamically creates new dictionaries as needed to keep it all together. yep right now I'm storing the list of types as a string and the updateMethod type as a string, just to be as obvious as possible. Griatch (IRC)APP I wonder if one could populate componentState(s) just before initializing the system, and then extract them into a more Evennia-friendly storage when saving. Or maybe it's no big deal to just store that whole blob as-is, with some extra things added? friarzen if you want to see it in action, take a look at the values in your localstorage after you've moved stuff around, created new windows, etc. I think their preference is to just store the whole blob. which is what the localstorage save does, in fact. Griatch (IRC)APP Yes, I see. It allows you to retain the session within your browser as well friarzen One trick I've been thinking about for the whole interface is to have another pair of components, one being a \"dynamic\" config window that displays a series of dropdowns, one for each plugin that defines it's own settings. And another that has an embedded i-frame to allow a split-screen where half of the display is the text interface and the other loads the local main website page and allows further browsing. Griatch (IRC)APP I think ideally, each pane should handle its per-pane settings as a dropdown or popup triggered from its header. friarzen well, pane != plugin... Griatch (IRC)APP True, one tends to sometimes make the other available but they are not the same friarzen think of the history plugin for example...if you want to make keyboard keys dynamically configurable, you need some place to enter that information. yeah. Griatch (IRC)APP Yes, I buy that - a dynamical option window would be needed. I'd say the 'global' settings should be treated as just another module in this regard though So that if you have no modules installed, there is one entry in that option pane, the one that opens the global options friarzen Yeah, so that is that component...one pane. Griatch (IRC)APP Another thing that the config should contain would be the available message tags. Waiting for them to actually show up before being able to use them is not that useful. This would likely have to be a setting though I imagine. friarzen we could remove the current pop-up and just open the new component pane instead, and then that pane would display the list of plugins that registered a config() callback. Griatch (IRC)APP Yes friarzen yeah, the server has to pre-define what tags it is going to send. Griatch (IRC)APP The process for adding a tag would be to adding to, say, a list in settings, restart and then .. profit friarzen yep, which is kind of how I see spawns working. Griatch (IRC)APP spawns, meaning stand-alone windows? friarzen we just have a plugin that defines it's config pane with a \"match this text\" box and a tag type to send the data to, or spawn a new pane with that tag type preselected to capture that text. wouldn't be stand alone windows. just new tabs, for now. Griatch (IRC)APP Ok, so a filter target that filters on text content and directs to tag friarzen yep. Griatch (IRC)APP (or re-tags it, I suppose) friarzen yeah, exactly. and opens a new window for that tag if one doesn't already exist. Griatch (IRC)APP A lot of complex effects could be achieved there. Should the filter extract the text and re-tag, or should it keep the text with its original tag and make a copy of it with the new tag? O_o; friarzen yet more options for the user. :slightly_smiling_face: baby steps first I think. \"pages from bob should go to bob's window, not the general chat window\" Griatch (IRC)APP It doesn't sound too hard to do - using tagging like that is really neat since then the rerouting can just work normally without knowing which pane you are actually rerouting too (and you could have multiple panes getting the same content too) friarzen yep. and the i-frame component, I think, provides just as much wow facter. Griatch (IRC)APP Yes, the setting would be something like: If text contains \"bob\" -> set tag \"bob\" (auto-create pane if not exist []?) friarzen just being able to load a character page from the wiki side in half the screen (including the pictures and whatnot) while playing/reading the text from the other half is really nice. Griatch (IRC)APP Could there not be some cross-scripting warnings in modern browsers if trying to load another website in an iframe? I doubt you could open Github like that, for example. friarzen well, assuming it is all from the same origin game server, it will all be from the same domain, so should avoid that, but it will take some testing to make sure. I want to get it to the point where you can click on somebody's name in the general terminal-style window and have it pop up that characters' wiki page. Griatch (IRC)APP That does sound nice :) friarzen i-frames are pretty much the only way to handle cross-domain content, but they are a pain in the butt to get that to work. Griatch (IRC)APP If it's on the same domain it would be fine, but it should probably give a \"you are now leaving ...\" message and switch to a new window if going elsewhere. friarzen (without getting into modern CORS url blessings) yeah Griatch (IRC)APP Just to avoid headaches :) friarzen So, yeah, two new goldenlayout components that I am working on but they aren't ready yet. heh. Griatch (IRC)APP Oh, you are working on them already? friarzen yeah, some initial \"will this work\" structure. I haven't found anything yet that will not make it work. it's mostly just not going to look very pretty to start with. It'll take a few iterations I bet. Griatch (IRC)APP Sounds good! We should probably try to formalize our thoughts around a future config format as well. Depending just how and when the golden-layout blob needs to be in place and if we can construct it on-the- fly, it affects the format style chosen. friarzen Yeah, that's new from today's conversation, so I don't really have anything built for that. Griatch (IRC)APP I'm still unsure about how the Evennia/pane specific things (that'd need to be serialized to the database on a per-account basis) would interact with the golden-layout structure. friarzen maybe the place to start is to wipe-out/update the old https://github.com/evennia/evennia/wiki/Webclient- brainstorm entry? Griatch (IRC)APP I don't think we need to wipe the old, but we could certainly add a new section above the old and start some new discussions. friarzen It is really just that per componentState bit. anything in that json is treated as a blackbox that goldenlayout just passes around. Griatch (IRC)APP So would we save the whole blob then, componentState and all, and simply not worry about ourselves storing per-pane options? The drawback with that would be that a dev could not offer an exact default layout/setup for the user. ... unless they set it up and saved the blob I guess friarzen Yeah, that's exactly how I built mine. :slightly_smiling_face: not the most dev-friendly way to do it, but it works. Griatch (IRC)APP Heh. Ok, so the config would be one section for the golden-layout-blob, one for module settings, one of which is the global settings. and a list of the available tags friarzen yep Griatch (IRC)APP And probably an empty misc section for future use ... friarzen seems reasonable. Griatch (IRC)APP So, that means that in the future one would need a procedure for the dev to easily create and save the player-wide default to central storage. Well, one step at a time. For now, good night! friarzen Yep, I expect that would be some kind of admin-approved api/command Griatch (IRC)APP And thanks for the discussion! Relates to the activity happening relating to the Webclient extensions task #614 .","title":"From Chat on 2019/09/02"},{"location":"Webclient-brainstorm.html#griatch-jan-23-2017","text":"These are my ideas for the functionality of Evennia's webclient in the (possibly distant) future. It assumes the webclient options have been implemented as per #1172 . The idea of the GUI is based around panes (a \"window\" feels like something that pops open). These are areas of the window of the type you would see from a javascript library like Split.js . Each pane has a separator with a handle for resizing it. Each pane has an icon for opening a dropdown menu (see next mockup image). Above image could show the default setup; mimicking the traditional telnet mud client setup. There should be at least one input pane (but you could add multiple). The Input pane has the icon for launching the main webclient options window. Alternatively the options icon could hover transparently in the upper left, \"above\" all panes . The main webclient options window should have an option for hiding all GUI customization icons (the draggable handles of panes and the dropdown menu) for users who does not want to have to worry about changing things accidentally. Devs not wanting to offer players the ability to customize their client GUIs could maybe just set it up the way they want and then turn the gui controls off on the javascript level. The dropdown menu allows for splitting each pane horizontally and vertically. Each pane is \"tagged\" with what data will be sent to it. It could accept more than one type of tagged data. Just which tags are available is different for each game (and should be reported by the server). For example, the server could send the return of the \"look\" command as msg(\"you see ...\", {\"pane\": \"look\"}) If one (or more) of the panes is set to receive \"look\" data, all such will go there. If no pane is assigned to \"look\", this text will end up in the pane(s) with the \"Unassigned\" designation. It might be necessary to enforce that at least one window has the \"unassigned\" designation in order to not lose output without a clear pane target. By contrast the pane tagged with \"All\" receives all output regardless of if it is also being sent to other panes. Another thing that came to mind is logging. It might be an idea to tie a given log file to a specific pane (panes?) to limit spam in the log (it might be one reason for having a pane with the \"All\" tag, for those wanting to log everything ). This could also be set in the dropdown menu or in the webclient options window, maybe. Comments?","title":"Griatch Jan 23, 2017"},{"location":"Webclient-brainstorm.html#titeuf87-jan-23-2017","text":"That way of splitting panes seems easy to manage while still being powerful at the same time. It's certainly a lot more flexible than what I had in mind. This is a quick sketch of what I was thinking about: ===================== Options [x] ===================== help: [popup] map: [top left] channels: [top right] look: [main output] But that's not as good as Griatch's proposal. The panes themselves can work differently depending on the content though: channel messages: when someone talks on a channel, the output text needs to be appended to the text already shown. inventory: this pane should clear its output every time the inventory is displayed, so old inventory is not displayed. Also what about dropping items? As long as the player doesn't check its inventory then that pane won't be updated, unless more OOB data is added to track the inventory. help/look: those pane should probably also clear their content before displaying new content. logging: do you mean have a \"save to log\" item in the pane menu?","title":"titeuf87 Jan 23, 2017"},{"location":"Webclient-brainstorm.html#griatch-jan-23-2017_1","text":"It makes sense that different types of panes would have different functionality. I was thinking that something like inventory would be very specific to a given game. But titeuf87 has a point - maybe you can get a rather generalized behavior just by defining if a pane should replace or append to the existing data. As for the updating of inventory when dropping items, not sure if that can be generalized, but I guess drop/get commands could be wired to do that. As for logging - yes I picture a \"save to log\" thing in the menu. The problem is just where to save the log. I think at least for an initial setup, one could maybe set the logging file path in the webclient options and just append logs from all the panes marked for logging to that same file.","title":"Griatch Jan 23, 2017"},{"location":"Webclient-brainstorm.html#chainsol-3rd-of-october-2017","text":"I've been messing a little bit with split.js - I've managed to split a split dynamically with a data attribute on a button and jQuery. My current thinking on this issue is to use jQuery Templates to write the template for horizontal and vertical splits, then using jQuery to set up the initial split layout by inserting those templates as appropriate for user settings. We would have a dropdown per split that decides what tag it's meant to handle - perhaps a data attribute that we change in the template for easy selection through jQuery - and then send tags for messages to the webclient. This dropdown would also have a setting per split to either append new content or replace content - again, perhaps a data attribute. We might also want to store \"mobile\" and \"desktop\" layouts separately - or just default to a mobile-friendly layout at a certain screen size, and turn off the splits. Oh, and embedding Bootstrap containers in splits works perfectly - that could help us too.","title":"chainsol 3rd of October, 2017"},{"location":"Webclient-brainstorm.html#chainsol-9th-of-october-2017","text":"I've got a demo of this working at my development box , if anyone wants to take a look. So far, I've got tag handling, dynamic splits, and the ability to swap splits' contents. Since this doesn't have a fancy interface yet, if you want to see a dynamic split, open your browser's console and try these commands: SplitHandler.split(\"#main\", \"horizontal\") will split the top-half into two 50-50 splits, both receiving content that's not tagged or is tagged \"all\" from the server. SplitHandler.swapContent(\"#input\", \"#split_2\") after doing so will swap the input into the top-left split. I'm trying to figure out where to put each split's configuration - maybe a dropdown button that's semi-transparent until you hover over it? So far, if you edited the data attributes, you could change each split to receive only tagged messages ( data-tag=\"all\" ), and you could change them to overwrite instead of append data ( data-update-append or data-update-overwrite )","title":"chainsol 9th of October, 2017"},{"location":"Webclient-brainstorm.html#griatch-oct-13-2017","text":"I would suggest that, assuming the game dev allows the user to modify their GUI in the first place, that modification is a \"mode\". I picture that 99% of the time a user doesn't need to modify their interface. They only want to click whatever game-related buttons etc are present in the pane without risk of resizing things accidentally. So I'd say that normally the panes are all fixed, with minimal spacing between them, no handles etc. But you can enter the client settings window and choose Customize GUI mode (or something like that). When you do, then separators get handles and the dropdown menu markers appear (permanently) in the corner of each pane. This means that if a user wants to easily tweak their window they could stay in this mode, but they could also \"lock\" the gui layout at any time.","title":"Griatch Oct 13, 2017"},{"location":"Wiki-Index.html","text":"This wiki index is automatically generated. Do not modify, your changes will be lost. A-Z \u00b6 There are 141 entries in the wiki. A voice operated elevator using events - Adding-an-elevator-using-the-in-game-Python-system Accounts - This-stores-passwords-and-acts-as-the-'account'-that-controls-in-game-characters. Add a simple new web page - Simple-tutorial-for-getting-going-with-the-web-components-of-evennia Add a wiki on your website - Add-a-wiki-on-your-website-through-Django-wiki Adding command tutorial - First-steps-for-changing-commands. Adding object typeclass tutorial - Describes-adding-a-simple-typeclass. Administrative docs - Administration-section-index. Apache config - Optional-info-for-using-Apache-as-a-webserver-instead-of-Evennia's-own. Api refactoring - A page about Api refactoring. Arxcode installing help - A page about Arxcode installing help. Async process - Using-asynchronous-techniques-to-avoid-blocking-the-server-(advanced). Attributes - Used-for-storing-arbitrary-data,-using-for-example-obj.db.name=value. Banning - How-to-get-rid-of-unwanted-players. Batch code processor - Running-code-snippets-for-building-by-reading-from-a-text-file. Batch command processor - Running-building-game-commands-from-a-text-file. Batch processors - Overview-of-the-mechanism-for-reading-build-instructions-from-text-files. Bootstrap & evennia - A page about Bootstrap & evennia. Bootstrap components and utilities - A page about Bootstrap components and utilities. Builder docs - Index-for-all-pages-related-to-building-a-game-world. Building a mech tutorial - A page about Building a mech tutorial. Building menus - Describe-building-menus-in-a-tutorial. Building permissions - Changing-account's-access-and-describes-the-permission-hierarchy. Building quickstart - Introduces-some-basic-commands-and-builds-some-example-objects. Choosing an sql server - Information-about-the-various-database-systems-which-are-supported. Client support grid - A page about Client support grid. Coding faq - A page about Coding faq. Coding introduction - Some-brief-points-to-think-about-when-starting-to-use-the-system. Coding utils - A-non-complete-list-of-some-of-the-useful-code-utilities-in-src/utils. Command cooldown - A-tutorial-for-making-commands-that-cannot-be-repeated-until-after-a-cooldown-time-has-passed. Command duration - A-tutorial-for-creating-commands-that-take-time-to-complete-(advanced). Command prompt - A-little-hint-for-how-to-add-a-command-prompt-for-players-to-see. Command sets - Containers-for-commands,-merges-to-describe-which-commands-are-available-at-any-moment. Command system - A page about Command system. Commands - Main-technical-description-of-commands-and-how-they-work. Communications - How-to-code-with-Channels,-Messages-and-other-systems-for-sending-info-to-others. Connection screen - Describes-how-to-change-the-connection-screen-you-see-when-first-connecting. Continuous integration - A page about Continuous integration. Contributing - How-to-help-out-in-the-development-of-Evennia. Coordinates - A page about Coordinates. Custom protocols - Implementing-new-server-protocols-(advanced). Customize channels - A-tutorial-on-customizing-channel-commands. Debugging - Debugging-code-with-pdb Default command help - A page about Default command help. Default exit errors - A-tutorial-for-changing-what-error-you-get-when-walking-in-a-non-existing-direction. Developer central - Main-hub-for-all-technical-developer-and-coding-information. Dialogues in events - Adding-dialogues-using-the-in-game-Python-system Directory overview - Shows-where-everything-is-in-the-codebase. Docs refactoring - A page about Docs refactoring. Dynamic in game map - Tutorial-for-making-a-dynamically-updating-map Eveditor - Describes-the-use-of-the-Line-editor Evennia api - The-top-level-evennia-API-module. Evennia for diku users - Introduction-of-Evennia-for-users-of-the-Diku-codebase Evennia for mush users - Soft-introduction-of-Evennia-for-MUSH-users Evennia for roleplaying sessions - A page about Evennia for roleplaying sessions. Evennia game index - Connecting-the-game-to-the-Evennia-game-index Evennia introduction - The-first-introduction-to-what-Evennia-is.-You-should-have-read-this-already. Evmenu - Describes-the-built-in-menu-creation-tool Evmore - Describes-the-pager-utility Execute python code - How-to-run-snippets-of-Python-code-from-inside-the-game,-for-testing-and-experimenting. First steps coding - Tutorial-describing-the-very-first-steps-for-setting-everything-up-before-you-can-start-to-code. Game planning - A-list-of-things-to-think-about-before-jumping-into-making-your-first-game. Gametime tutorial - A-tutorial-on-using-tools-to-handle-game-time. Getting started - Explains-how-to-download,-install-and-start-Evennia-for-the-first-time. Glossary - Indexed-explanations-of-common-terms Grapevine - Connecting-your-game-to-the-Grapevine-chat-network. Guest logins - Setting-up-guest-accounts Haproxy config (optional) - A page about Haproxy config (optional). Help system - How-to-use-and-add-help-files-to-the-game. Help system tutorial - Create-a-page-to-see-your-game-help-online Home - Wiki-front-page. How to connect evennia to twitter - Connecting-your-game-to-a-twitter-account. How to get and give help - Summing-up-how-to-best-get-help-or-give-it. Implementing a game rule system - Tutorial-giving-ideas-about-creating-a-game-rule-system Inputfuncs - These-handle-incoming-requests-from-the-client Installing on android - Describes-how-to-install-Evennia-on-an-Android-phone Internationalization - How-to-modify-Evennia's-core-strings-to-use-another-language-than-English. Irc - Connecting-your-game-to-an-external-IRC-channel. Learn python for evennia the hard way - A page about Learn python for evennia the hard way. Licensing - Tells-you-how-free-you-are-to-use-Evennia-to-your-personal-whims.-Really! Links - A-long-list-of-Evennia,-MU*-and-other-game-related-resources. Locks - How-to-check-for-access-and-define-what-gives-access-or-not. Manually configuring color - A-tutorial-on-how-to-make-it-so-players-can-turn-on-and-off-color-in-your-game. Mass and weight for objects - A-tutorial-on-how-to-add-mass-attributes-to-objects-and-calculate-total-weight-of-object-and-its-contents. Messagepath - Describes-the-path-messages-take-through-the-server Monitorhandler - An-explaination-of-the-monitor-handler-system-to-watch-for-attribute-changes-on-objects New models - Expanding-the-database-with-new-models-(advanced). Nicks - Re-naming-how-to-access-and-find-other-entities,-without-modifying-them. Npc shop tutorial - A page about Npc shop tutorial. Objects - Describes-the-basic-Object-typeclass,-the-base-for-all-in-game-things. Online setup - Goes-through-the-options-for-getting-your-game-visible-online-and-how-to-do-it. Oob - A page about Oob. Parsing command arguments, theory and best practices - Parsing-command-arguments-best-practices Portal and server - The-two-processes-that-make-up-the-running-Evennia-server-are-described. Profiling - A page about Profiling. Python 3 - A page about Python 3. Python basic introduction - A page about Python basic introduction. Python basic tutorial part two - A page about Python basic tutorial part two. Quirks - Some-less-than-intuitive-things-we-know-people-have-trouble-getting-their-heads-around. Roadmap - A-tentative-list-of-future-Evennia-milestones Rss - How-to-connect-your-game-to-an-external-RSS-feed. Running evennia in docker - A page about Running evennia in docker. Screenshot - A-screenshot-of-Evennia-running. Scripts - Controls-time-and-can-store-data-that-has-no-in-game-existence. Security - A page about Security. Server conf - Some-things-to-remember-when-dealing-with-the-settings.py-file. Sessions - Summarizes-the-use-of-Sessions. Setting up pycharm - A page about Setting up pycharm. Signals - Signals-fired-at-particular-times Soft code - Details-Evennia's-position-on-using-Softcode-along-with-some-history. Spawner and prototypes - Describing-how-to-create-objects-with-the-spawner. Start stop reload - How-to-control-the-Server-and-Portal-process-from-the-terminal-and-inside-the-game. Static in game map - Tutorial-for-creating-static-map-view Tags - These-are-used-to-quickly-group-and-later-retrieve-game-entities. Text encodings - Technical-discussion-about-how-to-deal-with-text-using-different-character-sets. Texttags - Describes-the-markup-for-adding-colours-and-other-tags-to-text. Tickerhandler - Used-to-repeatedly-'tick'-a-method-on-an-Object. Turn based combat system - Describes-how-to-build-a-combat-system-from-scratch Tutorial for basic mush like game - A-long-tutorial-for-building-a-simple-MUSH-in-Evennia,-from-scratch. Tutorial world introduction - This-is-a-small-single-player-quest-with-code-you-can-learn-from. Tutorial: aggressive npcs - A-tutorial-on-making-NPC's-do-things-(like-attack)-when-a-character-enters. Tutorial: npc's listening - A-tutorial-on-making-NPC's-do-things-(like-reply)-when-a-character-says-something. Tutorial: vehicles - Creating-vehicles Tutorial: searching for objects - Searching-For-Objects. Tutorial: tweeting game stats - A-tutorial-on-tweeting-game-stats-automatically. Tutorials - Overview-of-all-tutorial-type-documentation. Typeclasses - The-main-technical-description-of-a-core-concept.-how-Typeclasses-are-used-and-work. Understanding color tags - A page about Understanding color tags. Unit testing - Describes-how-to-expand-the-code-with-automatic-testing-suites. Updating your game - Describes-how-to-update-the-source-from-the-repo-and-how-to-reset-the-database. Using mux as a standard - A-policy-discussion-about-how-why-the-default-commands-look-the-way-they-do. Using travis - A page about Using travis. Version control - A-tutorial-on-using-version-control-for-your-own-sanity-and-safety. Weather tutorial - A-tutorial-on-using-tickers-to-make-days-go-by. Web character generation - A-tutorial-for-making-a-web-based-chargen-app-for-your-game. Web character view tutorial - Create-a-new-web-page-displaying-character-info Web client webclient - A page about Web client webclient. Web features - Gets-you-started-on-using-Evennia's-web-integration-abilities. Web tutorial - Gives-examples-on-how-to-customize-the-web-interface. Webclient brainstorm - A page about Webclient brainstorm. Wiki index - This very index. Zones - Using-Tags-to-implement-game-Zones.","title":"Wiki Index"},{"location":"Wiki-Index.html#a-z","text":"There are 141 entries in the wiki. A voice operated elevator using events - Adding-an-elevator-using-the-in-game-Python-system Accounts - This-stores-passwords-and-acts-as-the-'account'-that-controls-in-game-characters. Add a simple new web page - Simple-tutorial-for-getting-going-with-the-web-components-of-evennia Add a wiki on your website - Add-a-wiki-on-your-website-through-Django-wiki Adding command tutorial - First-steps-for-changing-commands. Adding object typeclass tutorial - Describes-adding-a-simple-typeclass. Administrative docs - Administration-section-index. Apache config - Optional-info-for-using-Apache-as-a-webserver-instead-of-Evennia's-own. Api refactoring - A page about Api refactoring. Arxcode installing help - A page about Arxcode installing help. Async process - Using-asynchronous-techniques-to-avoid-blocking-the-server-(advanced). Attributes - Used-for-storing-arbitrary-data,-using-for-example-obj.db.name=value. Banning - How-to-get-rid-of-unwanted-players. Batch code processor - Running-code-snippets-for-building-by-reading-from-a-text-file. Batch command processor - Running-building-game-commands-from-a-text-file. Batch processors - Overview-of-the-mechanism-for-reading-build-instructions-from-text-files. Bootstrap & evennia - A page about Bootstrap & evennia. Bootstrap components and utilities - A page about Bootstrap components and utilities. Builder docs - Index-for-all-pages-related-to-building-a-game-world. Building a mech tutorial - A page about Building a mech tutorial. Building menus - Describe-building-menus-in-a-tutorial. Building permissions - Changing-account's-access-and-describes-the-permission-hierarchy. Building quickstart - Introduces-some-basic-commands-and-builds-some-example-objects. Choosing an sql server - Information-about-the-various-database-systems-which-are-supported. Client support grid - A page about Client support grid. Coding faq - A page about Coding faq. Coding introduction - Some-brief-points-to-think-about-when-starting-to-use-the-system. Coding utils - A-non-complete-list-of-some-of-the-useful-code-utilities-in-src/utils. Command cooldown - A-tutorial-for-making-commands-that-cannot-be-repeated-until-after-a-cooldown-time-has-passed. Command duration - A-tutorial-for-creating-commands-that-take-time-to-complete-(advanced). Command prompt - A-little-hint-for-how-to-add-a-command-prompt-for-players-to-see. Command sets - Containers-for-commands,-merges-to-describe-which-commands-are-available-at-any-moment. Command system - A page about Command system. Commands - Main-technical-description-of-commands-and-how-they-work. Communications - How-to-code-with-Channels,-Messages-and-other-systems-for-sending-info-to-others. Connection screen - Describes-how-to-change-the-connection-screen-you-see-when-first-connecting. Continuous integration - A page about Continuous integration. Contributing - How-to-help-out-in-the-development-of-Evennia. Coordinates - A page about Coordinates. Custom protocols - Implementing-new-server-protocols-(advanced). Customize channels - A-tutorial-on-customizing-channel-commands. Debugging - Debugging-code-with-pdb Default command help - A page about Default command help. Default exit errors - A-tutorial-for-changing-what-error-you-get-when-walking-in-a-non-existing-direction. Developer central - Main-hub-for-all-technical-developer-and-coding-information. Dialogues in events - Adding-dialogues-using-the-in-game-Python-system Directory overview - Shows-where-everything-is-in-the-codebase. Docs refactoring - A page about Docs refactoring. Dynamic in game map - Tutorial-for-making-a-dynamically-updating-map Eveditor - Describes-the-use-of-the-Line-editor Evennia api - The-top-level-evennia-API-module. Evennia for diku users - Introduction-of-Evennia-for-users-of-the-Diku-codebase Evennia for mush users - Soft-introduction-of-Evennia-for-MUSH-users Evennia for roleplaying sessions - A page about Evennia for roleplaying sessions. Evennia game index - Connecting-the-game-to-the-Evennia-game-index Evennia introduction - The-first-introduction-to-what-Evennia-is.-You-should-have-read-this-already. Evmenu - Describes-the-built-in-menu-creation-tool Evmore - Describes-the-pager-utility Execute python code - How-to-run-snippets-of-Python-code-from-inside-the-game,-for-testing-and-experimenting. First steps coding - Tutorial-describing-the-very-first-steps-for-setting-everything-up-before-you-can-start-to-code. Game planning - A-list-of-things-to-think-about-before-jumping-into-making-your-first-game. Gametime tutorial - A-tutorial-on-using-tools-to-handle-game-time. Getting started - Explains-how-to-download,-install-and-start-Evennia-for-the-first-time. Glossary - Indexed-explanations-of-common-terms Grapevine - Connecting-your-game-to-the-Grapevine-chat-network. Guest logins - Setting-up-guest-accounts Haproxy config (optional) - A page about Haproxy config (optional). Help system - How-to-use-and-add-help-files-to-the-game. Help system tutorial - Create-a-page-to-see-your-game-help-online Home - Wiki-front-page. How to connect evennia to twitter - Connecting-your-game-to-a-twitter-account. How to get and give help - Summing-up-how-to-best-get-help-or-give-it. Implementing a game rule system - Tutorial-giving-ideas-about-creating-a-game-rule-system Inputfuncs - These-handle-incoming-requests-from-the-client Installing on android - Describes-how-to-install-Evennia-on-an-Android-phone Internationalization - How-to-modify-Evennia's-core-strings-to-use-another-language-than-English. Irc - Connecting-your-game-to-an-external-IRC-channel. Learn python for evennia the hard way - A page about Learn python for evennia the hard way. Licensing - Tells-you-how-free-you-are-to-use-Evennia-to-your-personal-whims.-Really! Links - A-long-list-of-Evennia,-MU*-and-other-game-related-resources. Locks - How-to-check-for-access-and-define-what-gives-access-or-not. Manually configuring color - A-tutorial-on-how-to-make-it-so-players-can-turn-on-and-off-color-in-your-game. Mass and weight for objects - A-tutorial-on-how-to-add-mass-attributes-to-objects-and-calculate-total-weight-of-object-and-its-contents. Messagepath - Describes-the-path-messages-take-through-the-server Monitorhandler - An-explaination-of-the-monitor-handler-system-to-watch-for-attribute-changes-on-objects New models - Expanding-the-database-with-new-models-(advanced). Nicks - Re-naming-how-to-access-and-find-other-entities,-without-modifying-them. Npc shop tutorial - A page about Npc shop tutorial. Objects - Describes-the-basic-Object-typeclass,-the-base-for-all-in-game-things. Online setup - Goes-through-the-options-for-getting-your-game-visible-online-and-how-to-do-it. Oob - A page about Oob. Parsing command arguments, theory and best practices - Parsing-command-arguments-best-practices Portal and server - The-two-processes-that-make-up-the-running-Evennia-server-are-described. Profiling - A page about Profiling. Python 3 - A page about Python 3. Python basic introduction - A page about Python basic introduction. Python basic tutorial part two - A page about Python basic tutorial part two. Quirks - Some-less-than-intuitive-things-we-know-people-have-trouble-getting-their-heads-around. Roadmap - A-tentative-list-of-future-Evennia-milestones Rss - How-to-connect-your-game-to-an-external-RSS-feed. Running evennia in docker - A page about Running evennia in docker. Screenshot - A-screenshot-of-Evennia-running. Scripts - Controls-time-and-can-store-data-that-has-no-in-game-existence. Security - A page about Security. Server conf - Some-things-to-remember-when-dealing-with-the-settings.py-file. Sessions - Summarizes-the-use-of-Sessions. Setting up pycharm - A page about Setting up pycharm. Signals - Signals-fired-at-particular-times Soft code - Details-Evennia's-position-on-using-Softcode-along-with-some-history. Spawner and prototypes - Describing-how-to-create-objects-with-the-spawner. Start stop reload - How-to-control-the-Server-and-Portal-process-from-the-terminal-and-inside-the-game. Static in game map - Tutorial-for-creating-static-map-view Tags - These-are-used-to-quickly-group-and-later-retrieve-game-entities. Text encodings - Technical-discussion-about-how-to-deal-with-text-using-different-character-sets. Texttags - Describes-the-markup-for-adding-colours-and-other-tags-to-text. Tickerhandler - Used-to-repeatedly-'tick'-a-method-on-an-Object. Turn based combat system - Describes-how-to-build-a-combat-system-from-scratch Tutorial for basic mush like game - A-long-tutorial-for-building-a-simple-MUSH-in-Evennia,-from-scratch. Tutorial world introduction - This-is-a-small-single-player-quest-with-code-you-can-learn-from. Tutorial: aggressive npcs - A-tutorial-on-making-NPC's-do-things-(like-attack)-when-a-character-enters. Tutorial: npc's listening - A-tutorial-on-making-NPC's-do-things-(like-reply)-when-a-character-says-something. Tutorial: vehicles - Creating-vehicles Tutorial: searching for objects - Searching-For-Objects. Tutorial: tweeting game stats - A-tutorial-on-tweeting-game-stats-automatically. Tutorials - Overview-of-all-tutorial-type-documentation. Typeclasses - The-main-technical-description-of-a-core-concept.-how-Typeclasses-are-used-and-work. Understanding color tags - A page about Understanding color tags. Unit testing - Describes-how-to-expand-the-code-with-automatic-testing-suites. Updating your game - Describes-how-to-update-the-source-from-the-repo-and-how-to-reset-the-database. Using mux as a standard - A-policy-discussion-about-how-why-the-default-commands-look-the-way-they-do. Using travis - A page about Using travis. Version control - A-tutorial-on-using-version-control-for-your-own-sanity-and-safety. Weather tutorial - A-tutorial-on-using-tickers-to-make-days-go-by. Web character generation - A-tutorial-for-making-a-web-based-chargen-app-for-your-game. Web character view tutorial - Create-a-new-web-page-displaying-character-info Web client webclient - A page about Web client webclient. Web features - Gets-you-started-on-using-Evennia's-web-integration-abilities. Web tutorial - Gives-examples-on-how-to-customize-the-web-interface. Webclient brainstorm - A page about Webclient brainstorm. Wiki index - This very index. Zones - Using-Tags-to-implement-game-Zones.","title":"A-Z"},{"location":"Zones.html","text":"Say you create a room named Meadow in your nice big forest MUD. That's all nice and dandy, but what if you, in the other end of that forest want another Meadow ? As a game creator, this can cause all sorts of confusion. For example, teleporting to Meadow will now give you a warning that there are two Meadow s and you have to select which one. It's no problem to do that, you just choose for example to go to 2-meadow , but unless you examine them you couldn't be sure which of the two sat in the magical part of the forest and which didn't. Another issue is if you want to group rooms in geographic regions. Let's say the \"normal\" part of the forest should have separate weather patterns from the magical part. Or maybe a magical disturbance echoes through all magical-forest rooms. It would then be convenient to be able to simply find all rooms that are \"magical\" so you could send messages to them. Zones in Evennia \u00b6 Zones try to separate rooms by global location. In our example we would separate the forest into two parts - the magical and the non-magical part. Each have a Meadow and rooms belonging to each part should be easy to retrieve. Many MUD codebases hardcode zones as part of the engine and database. Evennia does no such distinction due to the fact that rooms themselves are meant to be customized to any level anyway. Below is a suggestion for how to implement zones in Evennia. All objects in Evennia can hold any number of Tags . Tags are short labels that you attach to objects. They make it very easy to retrieve groups of objects. An object can have any number of different tags. So let's attach the relevant tag to our forest: forestobj.tags.add(\"magicalforest\", category=\"zone\") You could add this manually, or automatically during creation somehow (you'd need to modify your @dig command for this, most likely). You can also use the default @tag command during building: @tag forestobj = magicalforest : zone Henceforth you can then easily retrieve only objects with a given tag: import evennia rooms = evennia.search_tag(\"magicalforest\", category=\"zone\") Using typeclasses and inheritance for zoning \u00b6 The tagging or aliasing systems above don't instill any sort of functional difference between a magical forest room and a normal one - they are just arbitrary ways to mark objects for quick retrieval later. Any functional differences must be expressed using Typeclasses . Of course, an alternative way to implement zones themselves is to have all rooms/objects in a zone inherit from a given typeclass parent - and then limit your searches to objects inheriting from that given parent. The effect would be similar but you'd need to expand the search functionality to properly search the inheritance tree.","title":"Zones"},{"location":"Zones.html#zones-in-evennia","text":"Zones try to separate rooms by global location. In our example we would separate the forest into two parts - the magical and the non-magical part. Each have a Meadow and rooms belonging to each part should be easy to retrieve. Many MUD codebases hardcode zones as part of the engine and database. Evennia does no such distinction due to the fact that rooms themselves are meant to be customized to any level anyway. Below is a suggestion for how to implement zones in Evennia. All objects in Evennia can hold any number of Tags . Tags are short labels that you attach to objects. They make it very easy to retrieve groups of objects. An object can have any number of different tags. So let's attach the relevant tag to our forest: forestobj.tags.add(\"magicalforest\", category=\"zone\") You could add this manually, or automatically during creation somehow (you'd need to modify your @dig command for this, most likely). You can also use the default @tag command during building: @tag forestobj = magicalforest : zone Henceforth you can then easily retrieve only objects with a given tag: import evennia rooms = evennia.search_tag(\"magicalforest\", category=\"zone\")","title":"Zones in Evennia"},{"location":"Zones.html#using-typeclasses-and-inheritance-for-zoning","text":"The tagging or aliasing systems above don't instill any sort of functional difference between a magical forest room and a normal one - they are just arbitrary ways to mark objects for quick retrieval later. Any functional differences must be expressed using Typeclasses . Of course, an alternative way to implement zones themselves is to have all rooms/objects in a zone inherit from a given typeclass parent - and then limit your searches to objects inheriting from that given parent. The effect would be similar but you'd need to expand the search functionality to properly search the inheritance tree.","title":"Using typeclasses and inheritance for zoning"},{"location":"_Sidebar.html","text":"Navigation Home [[Search|https://cse.google.com:443/cse/publicurl?cx=010440404980795145992:h6xl9txbq3i]] / [[Index|Wiki Index]] Evennia Introduction [[Get and Give Help|How To Get And Give Help]] [[Glossary of terms|Glossary]] Sections Getting Started [[Admin Docs|Administrative Docs]] Builder Docs Developer Central [[Tutorials & Examples|Tutorials]] [[API|evennia]] Links Evennia home Code Discussions Chat [[Links and Resources|Links]]","title":" Sidebar"}]}