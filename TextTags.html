<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="./img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>TextTags - Evennia Manual</title>
    <link href="./css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="./css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="./css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="./css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="./js/jquery-3.2.1.min.js"></script>
    <script src="./js/bootstrap-3.3.7.min.js"></script>
    <script src="./js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '.';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Coloured text", url: "#_top", children: [
              {title: "ANSI colours", url: "#ansi-colours" },
              {title: "Xterm256 Colours", url: "#xterm256-colours" },
          ]},
          {title: "Clickable links", url: "#clickable-links", children: [
          ]},
          {title: "Inline functions", url: "#inline-functions", children: [
              {title: "New inlinefuncs", url: "#new-inlinefuncs" },
          ]},
        ];

    </script>
    <script src="./js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <p>This documentation details the various text tags supported by Evennia, namely <em>colours</em>, <em>command links</em> and <em>inline functions</em>. </p>
<p>There is also an <a href="Understanding-Color-Tags">Understanding Color Tags</a> tutorial which expands on the use of ANSI color tags and the pitfalls of mixing ANSI and Xterms256 color tags in the same context.</p>
<h2 id="coloured-text">Coloured text<a class="headerlink" href="#coloured-text" title="Permanent link">&para;</a></h2>
<p><em>Note that the Documentation does not display colour the way it would look on the screen.</em></p>
<p>Color can be a very useful tool for your game. It can be used to increase readability and make your game more appealing visually. </p>
<p>Remember however that, with the exception of the webclient, you generally don't control the client used to connect to the game.  There is, for example, one special tag meaning "yellow". But exactly <em>which</em> hue of yellow is actually displayed on the user's screen depends on the settings of their particular mud client. They could even swap the colours around or turn them off altogether if so desired. Some clients don't even support color - text games are also played with special reading equipment by people who are blind or have otherwise diminished eyesight. </p>
<p>So a good rule of thumb is to use colour to enhance your game but don't <em>rely</em> on it to display critical information. If you are coding the game, you can add functionality to let users disable colours as they please, as described <a href="Manually-Configuring-Color">here</a>. </p>
<p>To see which colours your client support, use the default <code>@color</code> command. This will list all available colours for ANSI and Xterm256 along with the codes you use for them. You can find a list of all the parsed <code>ANSI</code>-colour codes in <code>evennia/utils/ansi.py</code>.</p>
<h3 id="ansi-colours">ANSI colours<a class="headerlink" href="#ansi-colours" title="Permanent link">&para;</a></h3>
<p>Evennia supports the <code>ANSI</code> standard for text. This is by far the most supported MUD-color standard, available in all but the most ancient mud clients. The ANSI colours are <strong>r</strong>ed, <strong>g</strong>reen, <strong>y</strong>ellow, <strong>b</strong>lue, <strong>m</strong>agenta, <strong>c</strong>yan, <strong>w</strong>hite and black. They are abbreviated by their first letter except for black which is abbreviated with the letter <strong>x</strong>. In ANSI there are "bright" and "normal" (darker) versions of each color, adding up to a total of 16 colours to use for foreground text. There are also 8 "background" colours. These have no bright alternative in ANSI (but Evennia uses the <a href="https://github.com/evennia/evennia/wiki/TextTags#xterm256-colours">Xterm256</a> extension behind the scenes to offer them anyway). </p>
<p>To colour your text you put special tags in it. Evennia will parse these and convert them to the correct markup for the client used. If the user's client/console/display supports ANSI colour, they will see the text in the specified colour, otherwise the tags will be stripped (uncolored text). This works also for non-terminal clients, such as the webclient. For the webclient, Evennia will translate the codes to HTML RGB colors.</p>
<p>Here is an example of the tags in action: </p>
<pre><code> |rThis text is bright red.|n This is normal text.
 |RThis is a dark red text.|n This is normal text.
 |[rThis text has red background.|n This is normal text.
 |b|[yThis is bright blue text on yellow background.|n This is normal text.
</code></pre>
<ul>
<li><code>|n</code> - this tag will turn off all color formatting, including background colors.</li>
<li><code>|#</code>- markup marks the start of foreground color. The case defines if the text is "bright" or "normal". So <code>|g</code> is a bright green and <code>|G</code> is "normal" (darker) green.</li>
<li><code>|[#</code> is used to add a background colour to the text. The case again specifies if it is "bright" or "normal", so <code>|[c</code> starts a bright cyan background and <code>|[C</code> a darker cyan background.</li>
<li><code>|!#</code> is used to add foreground color without any enforced brightness/normal information. 
    These are normal-intensity and are thus always given as uppercase, such as 
    <code>|!R</code> for red. The difference between e.g. <code>|!R</code> and <code>|R</code> is that 
    <code>|!R</code> will "inherit" the brightness setting from previously set color tags, whereas <code>|R</code> will always reset to the normal-intensity red. The <code>|#</code> format contains an implicit <code>|h</code>/<code>|H</code> tag in it: disabling highlighting when switching to a normal color, and enabling it for bright ones. So <code>|btest |!Rtest2</code> will result in a bright red <code>test2</code> since the brightness setting from <code>|b</code> "bleeds over". You could use this to for example quickly switch the intensity of a multitude of color tags.  There is  no background-color equivalent to <code>|!</code> style tags.</li>
<li><code>|h</code> is used to make any following foreground ANSI colors bright (it has no effect on Xterm colors). This is only relevant  to use with <code>|!</code> type tags and will be valid until the next <code>|n</code>, <code>|H</code> or normal (upper-case) <code>|#</code> tag. This tag will never affect background colors, those have to be set bright/normal explicitly.  Technically, <code>|h|!G</code> is identical to <code>|g</code>. </li>
<li><code>|H</code> negates the effects <code>|h</code> and returns all ANSI foreground colors (<code>|!</code> and <code>|</code> types) to 'normal' intensity. It has no effect on background and Xterm colors. </li>
</ul>
<blockquote>
<p>Note: The ANSI standard does not actually support bright backgrounds like <code>|[r</code> - the standard only supports "normal" intensity backgrounds.  To get around this Evennia instead implements these as <a href="https://github.com/evennia/evennia/wiki/TextTags#xterm256-colours">Xterm256 colours</a> behind the scenes. If the client does not support Xterm256 the ANSI colors will be used instead and there will be no visible difference between using upper- and lower-case background tags.</p>
</blockquote>
<p>If you want to display an ANSI marker as output text (without having any effect), you need to escape it by preceding its <code>|</code> with another <code>|</code>:</p>
<pre><code>say The ||r ANSI marker changes text color to bright red.
</code></pre>

<p>This will output the raw <code>|r</code> without any color change. This can also be necessary if you are doing ansi art that uses <code>|</code> with a letter directly following it.</p>
<p>Use the command</p>
<pre><code>@color ansi
</code></pre>
<p>to get a list of all supported ANSI colours and the tags used to produce them.</p>
<p>A few additional ANSI codes are supported: </p>
<ul>
<li><code>|/</code> A line break. You cannot put the normal Python <code>\n</code> line breaks in text entered inside the game (Evennia will filter this for security reasons). This is what you use instead: use the <code>|/</code> marker to format text with line breaks from the game command line.</li>
<li><code>|-</code> This will translate into a <code>TAB</code> character. This will not always show (or show differently) to the client since it depends on their local settings. It's often better to use multiple spaces.</li>
<li><code>|_</code> This is a space. You can usually use the normal space character, but if the space is <em>at the end of the line</em>, Evennia will likely crop it. This tag will not be cropped but always result in a space.</li>
<li><code>|*</code> This will invert the current text/background colours. Can be useful to mark things (but see below).</li>
</ul>
<h5 id="caveats-of">Caveats of <code>|*</code><a class="headerlink" href="#caveats-of" title="Permanent link">&para;</a></h5>
<p>The <code>|*</code> tag (inverse video) is an old ANSI standard and should usually not be used for more than to mark short snippets of text. If combined with other tags it comes with a series of potentially confusing behaviors: </p>
<ul>
<li>
<p>The <code>|*</code> tag will only work once in a row:, ie: after using it once it won't have an effect again until you declare another tag. This is an example: </p>
<p><code>Normal text, |*reversed text|*, still reversed text.</code></p>
</li>
</ul>
<p>that is, it will not reverse to normal at the second <code>|*</code>. You need to reset it manually: </p>
<pre><code>```
Normal text, |*reversed text|n, normal again.
```
</code></pre>
<ul>
<li>
<p>The <code>|*</code> tag does not take "bright" colors into account:</p>
<p><code>|RNormal red, |hnow brightened. |*BG is normal red.</code></p>
</li>
</ul>
<p>So <code>|*</code> only considers the 'true' foreground color, ignoring any highlighting. Think of the bright state (<code>|h</code>) as something like like <code>&lt;strong&gt;</code> in HTML: it modifies the <em>appearance</em> of a normal foreground color to match its bright counterpart, without changing its normal color.<br />
* Finally, after a <code>|*</code>, if the previous background was set to a dark color (via <code>|[</code>), <code>|!#</code>) will actually change the background color instead of the foreground:</p>
<pre><code>```
|*reversed text |!R now BG is red.
```
</code></pre>
<p>For a detailed explanation of these caveats, see the <a href="Understanding-Color-Tags">Understanding Color Tags</a> tutorial. But most of the time you might be better off to simply avoid <code>|*</code> and mark your text manually instead. </p>
<h3 id="xterm256-colours">Xterm256 Colours<a class="headerlink" href="#xterm256-colours" title="Permanent link">&para;</a></h3>
<p>The <em>Xterm256</em> standard is a colour scheme that supports 256 colours for text and/or background. While this offers many more possibilities than traditional ANSI colours, be wary that too many text colors will be confusing to the eye. Also, not all clients support Xterm256 - these will instead see the closest equivalent ANSI color. You can mix Xterm256 tags with ANSI tags as you please.</p>
<pre><code>|555 This is pure white text.|n This is normal text.
|230 This is olive green text.
|[300 This text has a dark red background.
|005|[054 This is dark blue text on a bright cyan background.
|=a This is a greyscale value, equal to black.
|=m This is a greyscale value, midway between white and black.
|=z This is a greyscale value, equal to white.
|[=m This is a background greyscale value.
</code></pre>
<ul>
<li><code>|###</code> - markup consists of three digits, each an integer from 0 to 5. The three digits describe the amount of <strong>r</strong>ed, <strong>g</strong>reen and <strong>b</strong>lue (RGB) components used in the colour. So <code>|500</code> means maximum red and none of the other colours - the result is a bright red. <code>|520</code> is red with a touch of green - the result is orange. As opposed to ANSI colors, Xterm256 syntax does not worry about bright/normal intensity, a brighter (lighter) color is just achieved by upping all RGB values with the same amount.</li>
<li><code>|[###</code> - this works the same way but produces a coloured background.</li>
<li><code>|=#</code> - markup produces the xterm256 gray scale tones, where <code>#</code> is a letter from <code>a</code> (black) to <code>z</code> (white). This offers many more nuances of gray than the normal <code>|###</code> markup (which only has four gray tones between solid black and white (<code>|000</code>, <code>|111</code>, <code>|222</code>, <code>|333</code> and <code>|444</code>)).</li>
<li><code>|[=#</code> - this works in the same way but produces background gray scale tones.</li>
</ul>
<p>If you have a client that supports Xterm256, you can use</p>
<pre><code>@color xterm256
</code></pre>
<p>to get a table of all the 256 colours and the codes that produce them. If the table looks broken up into a few blocks of colors, it means Xterm256 is not supported and ANSI are used as a replacement. You can use the <code>@options</code> command to see if xterm256 is active for you. This depends on if your client told Evennia what it supports - if not, and you know what your client supports, you may have to activate some features manually. </p>
<h2 id="clickable-links">Clickable links<a class="headerlink" href="#clickable-links" title="Permanent link">&para;</a></h2>
<p>Evennia supports clickable links for clients that supports it. This marks certain text so it can be clicked by a mouse and trigger a given Evennia command. To support clickable links, Evennia requires the webclient or an third-party telnet client with <a href="http://www.zuggsoft.com/zmud/mxp.htm">MXP</a> support (<em>Note: Evennia only supports clickable links, no other MXP features</em>).</p>
<ul>
<li><code>|lc</code> to start the link, by defining the command to execute.</li>
<li><code>|lt</code> to continue with the text to show to the user (the link text).</li>
<li><code>|le</code> to end the link text and the link definition.</li>
</ul>
<p>All elements must appear in exactly this order to make a valid link. For example, </p>
<pre><code>&quot;If you go |lcnorth|ltto the north|le you will find a cottage.&quot;
</code></pre>

<p>This will display as "If you go <strong>to the north</strong> you will find a cottage." where clicking the link will execute the command <code>north</code>. If the client does not support clickable links, only the link text will be shown.</p>
<h2 id="inline-functions">Inline functions<a class="headerlink" href="#inline-functions" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Note: Inlinefuncs are <strong>not</strong> activated by default. To use them you need to add <code>INLINEFUNC_ENABLED=True</code> to your settings file.</p>
</blockquote>
<p>Evennia has its own inline text formatting language, known as <em>inlinefuncs</em>. It allows the builder to include special function calls in code. They are executed dynamically by each session that receives them. </p>
<p>To add an inlinefunc, you embed it in a text string like this: </p>
<pre><code>&quot;A normal string with $funcname(arg, arg, ...) embedded inside it.&quot;
</code></pre>

<p>When this string is sent to a session (with the <code>msg()</code> method), these embedded inlinefuncs will be parsed. Their return value (which always is a string) replace their call location in the finalized string. The interesting thing with this is that the function called will have access to which session is seeing the string, meaning the string can end up looking different depending on who is looking. It could of course also vary depending on other factors like game time. </p>
<p>Any number of comma-separated arguments can be given (or none). No keywords are supported. You can also nest inlinefuncs by letting an argument itself also be another <code>$funcname(arg, arg, ...)</code> call (down to any depth of nesting). Function call resolution happens as in all programming languages inside-out, with the nested calls replacing the argument with their return strings before calling he parent. </p>
<pre><code>   &gt; say  &quot;This is $pad(a center-padded text, 30,c,-) of width 30.&quot;
   You say, &quot;This is ---- a center-padded text----- of width 30.&quot;
</code></pre>

<p>A special case happens if wanting to use an inlinefunc argument that itself includes a comma - this would be parsed as an argument separator. To escape commas you can either escape each comma manually with a backslash <code>\,</code>, or you can embed the entire string in python triple-quotes <code>"""</code> or <code>'''</code> - this will escape the entire argument, including commas and any nested inlinefunc calls within. </p>
<p>Only certain functions are available to use as inlinefuncs and the game developer may add their own functions as needed. </p>
<h3 id="new-inlinefuncs">New inlinefuncs<a class="headerlink" href="#new-inlinefuncs" title="Permanent link">&para;</a></h3>
<p>To add new inlinefuncs, edit the file <code>mygame/server/conf/inlinefuncs.py</code>.</p>
<p><em>All globally defined functions in this module</em> are considered inline functions by the system. The only exception is functions whose name starts with an underscore <code>_</code>.  An inlinefunc must be of the following form: </p>
<pre><code class="python">def funcname(*args, **kwargs):
    # ...
    return modified_text
</code></pre>

<p>where <code>*args</code> denotes all the arguments this function will accept as an <code>$inlinefunc</code>. The inline function is expected to clean arguments and check that they are valid. If needed arguments are not given, default values should be used. The function should always return a string (even if it's empty). An inlinefunc should never cause a traceback regardless of the input (but it could log errors if desired). </p>
<p>Note that whereas the function should accept <code>**kwargs</code>, keyword inputs are <em>not</em> usable in the call to the inlinefunction. The <code>kwargs</code> part is instead intended for Evennia to be able to supply extra information. Currently Evennia sends a single keyword to every inline function and that is <code>session</code>, which holds the <a href="Sessions.html">serversession</a> this text is targeted at. Through the session object, a lot of dynamic possibilities are opened up for your inline functions. </p>
<p>The <code>settings.INLINEFUNC_MODULES</code> configuration option is a list that decides which modules should be parsed for inline function definitions. This will include <code>mygame/server/conf/inlinefuncs.py</code> but more could be added. The list is read from left to right so if you want to overload default functions you just have to put your custom module-paths later in the list and name your functions the same as default ones.</p>
<p>Here is an example, the <code>crop</code> default inlinefunction:</p>
<pre><code class="python">from evennia.utils import utils

def crop(*args, **kwargs):
    &quot;&quot;&quot;
    Inlinefunc. Crops ingoing text to given widths.
    Args:
        text (str, optional): Text to crop.
        width (str, optional): Will be converted to an integer. Width of
            crop in characters.
        suffix (str, optional): End string to mark the fact that a part
            of the string was cropped. Defaults to `[...]`.
    Kwargs:
        session (Session): Session performing the crop.
    Example:
        `$crop(text, 50, [...])`

    &quot;&quot;&quot;
    text, width, suffix = &quot;&quot;, 78, &quot;[...]&quot;
    nargs = len(args)
    if nargs &gt; 0:
        text = args[0]
    if nargs &gt; 1:
        width = int(args[1]) if args[1].strip().isdigit() else 78
    if nargs &gt; 2:
        suffix = args[2]
    return utils.crop(text, width=width, suffix=suffix)
</code></pre>

<p>Another example, making use of the Session:</p>
<pre><code class="python">def charactername(*args, **kwargs):
    &quot;&quot;&quot;
    Inserts the character name of whomever sees the string
    (so everyone will see their own name). Uses the account
    name for OOC communications. 

    Example:
        say &quot;This means YOU, $charactername()!&quot;   

    &quot;&quot;&quot;
    session = kwargs[&quot;session&quot;]
    if session.puppet:
        return kwargs[&quot;session&quot;].puppet.key
    else:
        return session.account.key
</code></pre>

<p>Evennia itself offers the following default inline functions (mostly as examples):</p>
<ul>
<li><code>crop(text, width, suffix)</code> - See above. </li>
<li><code>pad(text, width, align, fillchar)</code> - this pads the text to <code>width</code> (default 78), alignment ("c", "l" or "r", defaulting to "c") and fill-in character (defaults to space). Example: <code>$pad(40,l,-)</code></li>
<li><code>clr(startclr, text, endclr)</code> - A programmatic way to enter colored text for those who don't want to use the normal <code>|c</code> type color markers for some reason. The <code>color</code> argument is the same as the color markers except without the actual pre-marker, so <code>|r</code> would be just <code>r</code>. If <code>endclr</code> is not given, it defaults to resetting the color (<code>n</code>). Example: <code>$clr(b, A blue text)</code></li>
<li><code>space(number)</code> - Inserts the given number of spaces. If no argument is given, use 4 spaces. </li>
</ul>

  <br>
    

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>