<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="img/favicon.ico">
        <title>Building menus - Evennia Manual</title>
        <link href="css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="css/font-awesome.min.css" rel="stylesheet">
        <link href="css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="js/jquery-1.10.2.min.js" defer></script>
        <script src="js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html">Evennia Manual</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="index.html">Home</a>
                            </li>
                            <li >
                                <a href="Administrative-Docs.html">Admin</a>
                            </li>
                            <li >
                                <a href="Builder-Docs.html">Building</a>
                            </li>
                            <li >
                                <a href="Developer-Central.html">Game Development</a>
                            </li>
                            <li >
                                <a href="Tutorials.html">Tutorials</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#the-building_menu-contrib">The building_menu contrib</a></li>
            <li><a href="#a-simple-menu">A simple menu</a></li>
            <li><a href="#customizing-building-menus">Customizing building menus</a></li>
            <li><a href="#conclusion">Conclusion</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p><a href="Describe-building-menus-in-a-tutorial."></a></p>
<h1 id="the-building_menu-contrib">The building_menu contrib<a class="headerlink" href="#the-building_menu-contrib" title="Permanent link">&para;</a></h1>
<p>This contrib allows you to write custom and easy to use building menus.  As the name implies, these menus are most useful for building things, that is, your builders might appreciate them, although you can use them for your players as well.</p>
<p>Building menus are somewhat similar to <code>EvMenu</code> although they don't use the same system at all and are intended to make building easier.  They replicate what other engines refer to as "building editors", which allow to you to build in a menu instead of having to enter a lot of complex commands.  Builders might appreciate this simplicity, and if the code that was used to create them is simple as well, coders could find this contrib useful.</p>
<h2 id="a-simple-menu">A simple menu<a class="headerlink" href="#a-simple-menu" title="Permanent link">&para;</a></h2>
<p>Before diving in, there are some things to point out:</p>
<ul>
<li>Building menus work on an object.  This object will be edited by manipulations in the menu.  So you can create a menu to add/edit a room, an exit, a character and so on.</li>
<li>Building menus are arranged in layers of choices.  A choice gives access to an option or to a sub-menu.  Choices are linked to commands (usually very short).  For instance, in the example shown below, to edit the room key, after opening the building menu, you can type <code>k</code>.  That will lead you to the key choice where you can enter a new key for the room.  Then you can enter <code>@</code> to leave this choice and go back to the entire menu.  (All of this can be changed).</li>
<li>To open the menu, you will need something like a command.  This contrib offers a basic command for demonstration, but we will override it in this example, using the same code with more flexibility.</li>
</ul>
<p>So let's add a very basic example to begin with.</p>
<h3 id="a-generic-editing-command">A generic editing command<a class="headerlink" href="#a-generic-editing-command" title="Permanent link">&para;</a></h3>
<p>Let's begin by adding a new command.  You could add or edit the following file (there's no trick here, feel free to organize the code differently):</p>
<pre><code class="python"># file: commands/building.py
from evennia.contrib.building_menu import BuildingMenu
from commands.command import Command

class EditCmd(Command):

    &quot;&quot;&quot;
    Editing command.

    Usage:
      @edit [object]

    Open a building menu to edit the specified object.  This menu allows to
    specific information about this object.

    Examples:
      @edit here
      @edit self
      @edit #142

    &quot;&quot;&quot;

    key = &quot;@edit&quot;
    locks = &quot;cmd:id(1) or perm(Builders)&quot;
    help_category = &quot;Building&quot;

    def func(self):
        if not self.args.strip():
            self.msg(&quot;|rYou should provide an argument to this function: the object to edit.|n&quot;)
            return

        obj = self.caller.search(self.args.strip(), global_search=True)
        if not obj:
            return

        if obj.typename == &quot;Room&quot;:
            Menu = RoomBuildingMenu
        else:
            self.msg(&quot;|rThe object {} cannot be edited.|n&quot;.format(obj.get_display_name(self.caller)))
            return

        menu = Menu(self.caller, obj)
        menu.open()
</code></pre>

<p>This command is rather simple in itself:</p>
<ol>
<li>It has a key <code>@edit</code> and a lock to only allow builders to use it.</li>
<li>In its <code>func</code> method, it begins by checking the arguments, returning an error if no argument is specified.</li>
<li>It then searches for the given argument.  We search globally.  The <code>search</code> method used in this way will return the found object or <code>None</code>.  It will also send the error message to the caller if necessary.</li>
<li>Assuming we have found an object, we check the object <code>typename</code>.  This will be used later when we want to display several building menus.  For the time being, we only handle <code>Room</code>.  If the caller specified something else, we'll display an error.</li>
<li>Assuming this object is a <code>Room</code>, we have defined a <code>Menu</code> object containing the class of our building menu.  We build this class (creating an instance), giving it the caller and the object to edit.</li>
<li>We then open the building menu, using the <code>open</code> method.</li>
</ol>
<p>The end might sound a bit surprising at first glance.  But the process is still very simple: we create an instance of our building menu and call its <code>open</code> method.  Nothing more.</p>
<blockquote>
<p>Where is our building menu?</p>
</blockquote>
<p>If you go ahead and add this command and test it, you'll get an error.  We haven't defined <code>RoomBuildingMenu</code> yet.</p>
<p>To add this command, edit <code>commands/default_cmdsets.py</code>.  Import our command, adding an import line at the top of the file:</p>
<pre><code class="python">&quot;&quot;&quot;
...
&quot;&quot;&quot;

from evennia import default_cmds

# The following line is to be added
from commands.building import EditCmd
</code></pre>

<p>And in the class below (<code>CharacterCmdSet</code>), add the last line of this code:</p>
<pre><code class="python">class CharacterCmdSet(default_cmds.CharacterCmdSet):
    &quot;&quot;&quot;
    The `CharacterCmdSet` contains general in-game commands like `look`,
    `get`, etc available on in-game Character objects. It is merged with
    the `AccountCmdSet` when an Account puppets a Character.
    &quot;&quot;&quot;
    key = &quot;DefaultCharacter&quot;

    def at_cmdset_creation(self):
        &quot;&quot;&quot;
        Populates the cmdset
        &quot;&quot;&quot;
        super().at_cmdset_creation()
        #
        # any commands you add below will overload the default ones.
        #
        self.add(EditCmd())
</code></pre>

<h3 id="our-first-menu">Our first menu<a class="headerlink" href="#our-first-menu" title="Permanent link">&para;</a></h3>
<p>So far, we can't use our building menu.  Our <code>@edit</code> command will throw an error.  We have to define the <code>RoomBuildingMenu</code> class.  Open the <code>commands/building.py</code> file and add to the end of the file:</p>
<pre><code class="python"># ... at the end of commands/building.py
# Our building menu

class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.

    For the time being, we have only one choice: key, to edit the room key.

    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;key&quot;, &quot;k&quot;, attr=&quot;key&quot;)
</code></pre>

<p>Save these changes, reload your game.  You can now use the <code>@edit</code> command.  Here's what we get (notice that the commands we enter into the game are prefixed with <code>&gt;</code>, though this prefix will probably not appear in your MUD client):</p>
<pre><code>&gt; look
Limbo(#2)
Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need
help, want to contribute, report issues or just join the community.
As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build.

&gt; @edit here
Building menu: Limbo

 [K]ey: Limbo
 [Q]uit the menu

&gt; q
Closing the building menu.

&gt; @edit here
Building menu: Limbo

 [K]ey: Limbo
 [Q]uit the menu

&gt; k
-------------------------------------------------------------------------------
key for Limbo(#2)

You can change this value simply by entering it.

Use @ to go back to the main menu.

Current value: Limbo

&gt; A beautiful meadow
-------------------------------------------------------------------------------

key for A beautiful meadow(#2)

You can change this value simply by entering it.

Use @ to go back to the main menu.

Current value: A beautiful meadow

&gt; @
Building menu: A beautiful meadow

 [K]ey: A beautiful meadow
 [Q]uit the menu

&gt; q

Closing the building menu.

&gt; look
A beautiful meadow(#2)
Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need
help, want to contribute, report issues or just join the community.
As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build.
</code></pre>

<p>Before diving into the code, let's examine what we have:</p>
<ul>
<li>When we use the <code>@edit here</code> command, a building menu for this room appears.</li>
<li>This menu has two choices:<ul>
<li>Enter <code>k</code> to edit the room key.  You will go into a choice where you can simply type the key room key (the way we have done here).  You can use <code>@</code> to go back to the menu.</li>
<li>You can use <code>q</code> to quit the menu.</li>
</ul>
</li>
</ul>
<p>We then check, with the <code>look</code> command, that the menu has modified this room key.  So by adding a class, with a method and a single line of code within, we've added a menu with two choices.</p>
<h3 id="code-explanation">Code explanation<a class="headerlink" href="#code-explanation" title="Permanent link">&para;</a></h3>
<p>Let's examine our code again:</p>
<pre><code class="python">class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.

    For the time being, we have only one choice: key, to edit the room key.

    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;key&quot;, &quot;k&quot;, attr=&quot;key&quot;)
</code></pre>

<ul>
<li>We first create a class inheriting from <code>BuildingMenu</code>.  This is usually the case when we want to create a building menu with this contrib.</li>
<li>In this class, we override the <code>init</code> method, which is called when the menu opens.</li>
<li>In this <code>init</code> method, we call <code>add_choice</code>.  This takes several arguments, but we've defined only three here:<ul>
<li>The choice name.  This is mandatory and will be used by the building menu to know how to display this choice.</li>
<li>The command key to access this choice.  We've given a simple <code>"k"</code>.  Menu commands usually are pretty short (that's part of the reason building menus are appreciated by builders).  You can also specify additional aliases, but we'll see that later.</li>
<li>We've added a keyword argument, <code>attr</code>.  This tells the building menu that when we are in this choice, the text we enter goes into this attribute name.  It's called <code>attr</code>, but it could be a room attribute or a typeclass persistent or non-persistent attribute (we'll see other examples as well).</li>
</ul>
</li>
</ul>
<blockquote>
<p>We've added the menu choice for <code>key</code> here, why is another menu choice defined for <code>quit</code>?</p>
</blockquote>
<p>Our building menu creates a choice at the end of our choice list if it's a top-level menu (sub-menus don't have this feature).  You can, however, override it to provide a different "quit" message or to perform some actions.</p>
<p>I encourage you to play with this code.  As simple as it is, it offers some functionalities already.</p>
<h2 id="customizing-building-menus">Customizing building menus<a class="headerlink" href="#customizing-building-menus" title="Permanent link">&para;</a></h2>
<p>This somewhat long section explains how to customize building menus.  There are different ways depending on what you would like to achieve.  We'll go from specific to more advanced here.</p>
<h3 id="generic-choices">Generic choices<a class="headerlink" href="#generic-choices" title="Permanent link">&para;</a></h3>
<p>In the previous example, we've used <code>add_choice</code>.  This is one of three methods you can use to add choices.  The other two are to handle more generic actions:</p>
<ul>
<li><code>add_choice_edit</code>: this is called to add a choice which points to the <code>EvEditor</code>.  It is used to edit a description in most cases, although you could edit other things.  We'll see an example shortly.  <code>add_choice_edit</code> uses most of the <code>add_choice</code> keyword arguments we'll see, but usually we specify only two (sometimes three):<ul>
<li>The choice title as usual.</li>
<li>The choice key (command key) as usual.</li>
<li>Optionally, the attribute of the object to edit, with the <code>attr</code> keyword argument.  By default, <code>attr</code> contains <code>db.desc</code>.  It means that this persistent data attribute will be edited by the <code>EvEditor</code>.  You can change that to whatever you want though.</li>
</ul>
</li>
<li><code>add_choice_quit</code>: this allows to add a choice to quit the editor.  Most advisable!  If you don't do it, the building menu will do it automatically, except if you really tell it not to.  Again, you can specify the title and key of this menu.  You can also call a function when this menu closes.</li>
</ul>
<p>So here's a more complete example (you can replace your <code>RoomBuildingMenu</code> class in <code>commands/building.py</code> to see it):</p>
<pre><code class="python">class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.
    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;key&quot;, &quot;k&quot;, attr=&quot;key&quot;)
        self.add_choice_edit(&quot;description&quot;, &quot;d&quot;)
        self.add_choice_quit(&quot;quit this editor&quot;, &quot;q&quot;)
</code></pre>

<p>So far, our building menu class is still thin... and yet we already have some interesting feature.  See for yourself the following MUD client output (again, the commands are prefixed with <code>&gt;</code> to distinguish them):</p>
<pre><code>&gt; @reload

&gt; @edit here
Building menu: A beautiful meadow

 [K]ey: A beautiful meadow
 [D]escription: 
   Welcome to your new Evennia-based game! Visit http://www.evennia.com if you need
help, want to contribute, report issues or just join the community.
As Account #1 you can create a demo/tutorial area with @batchcommand tutorial_world.build.
 [Q]uit this editor

&gt; d

----------Line Editor [editor]----------------------------------------------------
01| Welcome to your new |wEvennia|n-based game! Visit http://www.evennia.com if you need
02| help, want to contribute, report issues or just join the community.
03| As Account #1 you can create a demo/tutorial area with |w@batchcommand tutorial_world.build|n.

&gt; :DD

----------[l:03 w:034 c:0247]------------(:h for help)----------------------------
Cleared 3 lines from buffer.

&gt; This is a beautiful meadow. But so beautiful I can't describe it.

01| This is a beautiful meadow. But so beautiful I can't describe it.

&gt; :wq
Building menu: A beautiful meadow

 [K]ey: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [Q]uit this editor

&gt; q
Closing the building menu.

&gt; look
A beautiful meadow(#2)
This is a beautiful meadow.  But so beautiful I can't describe it.
</code></pre>

<p>So by using the <code>d</code> shortcut in our building menu, an <code>EvEditor</code> opens.  You can use the <code>EvEditor</code> commands (like we did here, <code>:DD</code> to remove all, <code>:wq</code> to save and quit).  When you quit the editor, the description is saved (here, in <code>room.db.desc</code>) and you go back to the building menu.</p>
<p>Notice that the choice to quit has changed too, which is due to our adding <code>add_choice_quit</code>.  In most cases, you will probably not use this method, since the quit menu is added automatically.</p>
<h3 id="add_choice-options"><code>add_choice</code> options<a class="headerlink" href="#add_choice-options" title="Permanent link">&para;</a></h3>
<p><code>add_choice</code> and the two methods <code>add_choice_edit</code> and <code>add_choice_quit</code> take a lot of optional arguments to make customization easier.  Some of these options might not apply to <code>add_choice_edit</code> or <code>add_choice_quit</code> however.</p>
<p>Below are the options of <code>add_choice</code>, specify them as arguments:</p>
<ul>
<li>The first positional, mandatory argument is the choice title, as we have seen.  This will influence how the choice appears in the menu.</li>
<li>The second positional, mandatory argument is the command key to access to this menu.  It is best to use keyword arguments for the other arguments.</li>
<li>The <code>aliases</code> keyword argument can contain a list of aliases that can be used to access to this menu.  For instance: <code>add_choice(..., aliases=['t'])</code></li>
<li>The <code>attr</code> keyword argument contains the attribute to edit when this choice is selected.  It's a string, it has to be the name, from the object (specified in the menu constructor) to reach this attribute.  For instance, a <code>attr</code> of <code>"key"</code> will try to find <code>obj.key</code> to read and write the attribute.  You can specify more complex attribute names, for instance, <code>attr="db.desc"</code> to set the <code>desc</code> persistent attribute, or <code>attr="ndb.something"</code> so use a non-persistent data attribute on the object.</li>
<li>The <code>text</code> keyword argument is used to change the text that will be displayed when the menu choice is selected.  Menu choices provide a default text that you can change.  Since this is a long text, it's useful to use multi-line strings (see an example below).</li>
<li>The <code>glance</code> keyword argument is used to specify how to display the current information while in the menu, when the choice hasn't been opened.  If you examine the previous examples, you will see that the current (<code>key</code> or <code>db.desc</code>) was shown in the menu, next to the command key.  This is useful for seeing at a glance the current value (hence the name).  Again, menu choices will provide a default glance if you don't specify one.</li>
<li>The <code>on_enter</code> keyword argument allows to add a callback to use when the menu choice is opened.  This is more advanced, but sometimes useful.</li>
<li>The <code>on_nomatch</code> keyword argument is called when, once in the menu, the caller enters some text that doesn't match any command (including the <code>@</code> command).  By default, this will edit the specified <code>attr</code>.</li>
<li>The <code>on_leave</code> keyword argument allows to specify a callback used when the caller leaves the menu choice.  This can be useful for cleanup as well.</li>
</ul>
<p>These are a lot of possibilities, and most of the time you won't need them all.  Here is a short example using some of these arguments (again, replace the <code>RoomBuildingMenu</code> class in <code>commands/building.py</code> with the following code to see it working):</p>
<pre><code class="python">class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.

    For the time being, we have only one choice: key, to edit the room key.

    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;title&quot;, key=&quot;t&quot;, attr=&quot;key&quot;, glance=&quot;{obj.key}&quot;, text=&quot;&quot;&quot;
                -------------------------------------------------------------------------------
                Editing the title of {{obj.key}}(#{{obj.id}})

                You can change the title simply by entering it.
                Use |y{back}|n to go back to the main menu.

                Current title: |c{{obj.key}}|n
        &quot;&quot;&quot;.format(back=&quot;|n or |y&quot;.join(self.keys_go_back)))
        self.add_choice_edit(&quot;description&quot;, &quot;d&quot;)
</code></pre>

<p>Reload your game and see it in action:</p>
<pre><code>&gt; @edit here
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [Q]uit the menu

&gt; t
-------------------------------------------------------------------------------

Editing the title of A beautiful meadow(#2)

You can change the title simply by entering it.
Use @ to go back to the main menu.

Current title: A beautiful meadow

&gt; @

Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [Q]uit the menu

&gt; q
Closing the building menu.
</code></pre>

<p>The most surprising part is no doubt the text.  We use the multi-line syntax (with <code>"""</code>).  Excessive spaces will be removed from the left for each line automatically.  We specify some information between braces... sometimes using double braces.  What might be a bit odd:</p>
<ul>
<li><code>{back}</code> is a direct format argument we'll use (see the <code>.format</code> specifiers).</li>
<li><code>{{obj...}} refers to the object being edited.  We use two braces, because</code>.format` will remove them.</li>
</ul>
<p>In <code>glance</code>, we also use <code>{obj.key}</code> to indicate we want to show the room's key.</p>
<h3 id="everything-can-be-a-function">Everything can be a function<a class="headerlink" href="#everything-can-be-a-function" title="Permanent link">&para;</a></h3>
<p>The keyword arguments of <code>add_choice</code> are often strings (type <code>str</code>).  But each of these arguments can also be a function.  This allows for a lot of customization, since we define the callbacks that will be executed to achieve such and such an operation.</p>
<p>To demonstrate, we will try to add a new feature.  Our building menu for rooms isn't that bad, but it would be great to be able to edit exits too.  So we can add a new menu choice below description... but how to actually edit exits?  Exits are not just an attribute to set: exits are objects (of type <code>Exit</code> by default) which stands between two rooms (object of type <code>Room</code>).  So how can we show that?</p>
<p>First let's add a couple of exits in limbo, so we have something to work with:</p>
<pre><code>@tunnel n
@tunnel s
</code></pre>

<p>This should create two new rooms, exits leading to them from limbo and back to limbo.</p>
<pre><code>&gt; look
A beautiful meadow(#2)
This is a beautiful meadow.  But so beautiful I can't describe it.
Exits: north(#4) and south(#7)
</code></pre>

<p>We can access room exits with the <code>exits</code> property:</p>
<pre><code>&gt; @py here.exits
[&lt;Exit: north&gt;, &lt;Exit: south&gt;]
</code></pre>

<p>So what we need is to display this list in our building menu... and to allow to edit it would be great.  Perhaps even add new exits?</p>
<p>First of all, let's write a function to display the <code>glance</code> on existing exits.  Here's the code, it's explained below:</p>
<pre><code class="python">class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.

    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;title&quot;, key=&quot;t&quot;, attr=&quot;key&quot;, glance=&quot;{obj.key}&quot;, text=&quot;&quot;&quot;
                -------------------------------------------------------------------------------
                Editing the title of {{obj.key}}(#{{obj.id}})

                You can change the title simply by entering it.
                Use |y{back}|n to go back to the main menu.

                Current title: |c{{obj.key}}|n
        &quot;&quot;&quot;.format(back=&quot;|n or |y&quot;.join(self.keys_go_back)))
        self.add_choice_edit(&quot;description&quot;, &quot;d&quot;)
        self.add_choice(&quot;exits&quot;, &quot;e&quot;, glance=glance_exits, attr=&quot;exits&quot;)


# Menu functions
def glance_exits(room):
    &quot;&quot;&quot;Show the room exits.&quot;&quot;&quot;
    if room.exits:
        glance = &quot;&quot;
        for exit in room.exits:
            glance += &quot;\n  |y{exit}|n&quot;.format(exit=exit.key)

        return glance

    return &quot;\n  |gNo exit yet|n&quot;
</code></pre>

<p>When the building menu opens, it displays each choice to the caller.  A choice is displayed with its title (rendered a bit nicely to show the key as well) and the glance.  In the case of the <code>exits</code> choice, the glance is a function, so the building menu calls this function giving it the object being edited (the room here).  The function should return the text to see.</p>
<pre><code>&gt; @edit here
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [E]xits: 
  north
  south
 [Q]uit the menu

&gt; q
Closing the editor.
</code></pre>

<blockquote>
<p>How do I know the parameters of the function to give?</p>
</blockquote>
<p>The function you give can accept a lot of different parameters.  This allows for a flexible approach but might seem complicated at first.  Basically, your function can accept any parameter, and the building menu will send only the parameter based on their names.  If your function defines an argument named <code>caller</code> for instance (like <code>def func(caller):</code> ), then the building menu knows that the first argument should contain the caller of the building menu.  Here are the arguments, you don't have to specify them (if you do, they need to have the same name):</p>
<ul>
<li><code>menu</code>: if your function defines an argument named <code>menu</code>, it will contain the building menu itself.</li>
<li><code>choice</code>: if your function defines an argument named <code>choice</code>, it will contain the <code>Choice</code> object representing this menu choice.</li>
<li><code>string</code>: if your function defines an argument named <code>string</code>, it will contain the user input to reach this menu choice.  This is not very useful, except on <code>nomatch</code> callbacks which we'll see later.</li>
<li><code>obj</code>: if your function defines an argument named <code>obj</code>, it will contain the building menu edited object.</li>
<li><code>caller</code>: if your function defines an argument named <code>caller</code>, it will contain the caller of the building menu.</li>
<li>Anything else: any other argument will contain the object being edited by the building menu.</li>
</ul>
<p>So in our case:</p>
<pre><code class="python">def glance_exits(room):
</code></pre>

<p>The only argument we need is <code>room</code>.  It's not present in the list of possible arguments, so the editing object of the building menu (the room, here) is given.</p>
<blockquote>
<p>Why is it useful to get the menu or choice object?</p>
</blockquote>
<p>Most of the time, you will not need these arguments.  In very rare cases, you will use them to get specific data (like the default attribute that was set).  This tutorial will not elaborate on these possibilities.  Just know that they exist.</p>
<p>We should also define a text callback, so that we can enter our menu to see the room exits.  We'll see how to edit them in the next section but this is a good opportunity to show a more complete callback.  To see it in action, as usual, replace the class and functions in <code>commands/building.py</code>:</p>
<pre><code class="python"># Our building menu

class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.

    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;title&quot;, key=&quot;t&quot;, attr=&quot;key&quot;, glance=&quot;{obj.key}&quot;, text=&quot;&quot;&quot;
                -------------------------------------------------------------------------------
                Editing the title of {{obj.key}}(#{{obj.id}})

                You can change the title simply by entering it.
                Use |y{back}|n to go back to the main menu.

                Current title: |c{{obj.key}}|n
        &quot;&quot;&quot;.format(back=&quot;|n or |y&quot;.join(self.keys_go_back)))
        self.add_choice_edit(&quot;description&quot;, &quot;d&quot;)
        self.add_choice(&quot;exits&quot;, &quot;e&quot;, glance=glance_exits, attr=&quot;exits&quot;, text=text_exits)


# Menu functions
def glance_exits(room):
    &quot;&quot;&quot;Show the room exits.&quot;&quot;&quot;
    if room.exits:
        glance = &quot;&quot;
        for exit in room.exits:
            glance += &quot;\n  |y{exit}|n&quot;.format(exit=exit.key)

        return glance

    return &quot;\n  |gNo exit yet|n&quot;

def text_exits(caller, room):
    &quot;&quot;&quot;Show the room exits in the choice itself.&quot;&quot;&quot;
    text = &quot;-&quot; * 79
    text += &quot;\n\nRoom exits:&quot;
    text += &quot;\n Use |y@c|n to create a new exit.&quot;
    text += &quot;\n\nExisting exits:&quot;
    if room.exits:
        for exit in room.exits:
            text += &quot;\n  |y@e {exit}|n&quot;.format(exit=exit.key)
            if exit.aliases.all():
                text += &quot; (|y{aliases}|n)&quot;.format(aliases=&quot;|n, |y&quot;.join(
                        alias for alias in exit.aliases.all()))
            if exit.destination:
                text += &quot; toward {destination}&quot;.format(destination=exit.get_display_name(caller))
    else:
        text += &quot;\n\n |gNo exit has yet been defined.|n&quot;

    return text
</code></pre>

<p>Look at the second callback in particular.  It takes an additional argument, the caller (remember, the argument names are important, their order is not relevant).  This is useful for displaying destination of exits accurately.  Here is a demonstration of this menu:</p>
<pre><code>&gt; @edit here
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [E]xits: 
  north
  south
 [Q]uit the menu

&gt; e
-------------------------------------------------------------------------------

Room exits:
 Use @c to create a new exit.

Existing exits:
  @e north (n) toward north(#4)
  @e south (s) toward south(#7)

&gt; @
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [E]xits: 
  north
  south
 [Q]uit the menu

&gt; q
Closing the building menu.
</code></pre>

<p>Using callbacks allows a great flexibility.  We'll now see how to handle sub-menus.</p>
<h3 id="sub-menus-for-complex-menus">Sub-menus for complex menus<a class="headerlink" href="#sub-menus-for-complex-menus" title="Permanent link">&para;</a></h3>
<p>A menu is relatively flat: it has a root (where you see all the menu choices) and individual choices you can go to using the menu choice keys.  Once in a choice you can type some input or go back to the root menu by entering the return command (usually <code>@</code>).</p>
<p>Why shouldn't individual exits have their own menu though?  Say, you edit an exit and can change its key, description or aliases... perhaps even destination?  Why ever not?  It would make building much easier!</p>
<p>The building menu system offers two ways to do that.  The first is nested keys: nested keys allow to go beyond just one menu/choice, to have menus with more layers.  Using them is quick but might feel a bit counter-intuitive at first.  Another option is to create a different menu class and redirect from the first to the second.  This option might require more lines but is more explicit and can be re-used for multiple menus.  Adopt one of them depending of your taste.</p>
<h4 id="nested-menu-keys">Nested menu keys<a class="headerlink" href="#nested-menu-keys" title="Permanent link">&para;</a></h4>
<p>So far, we've only used menu keys with one letter.  We can add more, of course, but menu keys in their simple shape are just command keys.  Press "e" to go to the "exits" choice.</p>
<p>But menu keys can be nested.  Nested keys allow to add choices with sub-menus.  For instance, type "e" to go to the "exits" choice, and then you can type "c" to open a menu to create a new exit, or "d" to open a menu to delete an exit.  The first menu would have the "e.c" key (first e, then c), the second menu would have key as "e.d".</p>
<p>That's more advanced and, if the following code doesn't sound very friendly to you, try the next section which provides a different approach of the same problem.</p>
<p>So we would like to edit exits.  That is, you can type "e" to go into the choice of exits, then enter <code>@e</code> followed by the exit name to edit it... which will open another menu.  In this sub-menu you could change the exit key or description.</p>
<p>So we have a menu hierarchy similar to that:</p>
<pre><code>t                       Change the room title
d                       Change the room description
e                       Access the room exits
  [exit name]           Access the exit name sub-menu
                 [text] Change the exit key
</code></pre>

<p>Or, if you prefer an example output:</p>
<pre><code>&gt; look
A beautiful meadow(#2)
This is a beautiful meadow.  But so beautiful I can't describe it.
Exits: north(#4) and south(#7)

&gt; @edit here
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [E]xits: 
  north
  south
 [Q]uit the menu

&gt; e
-------------------------------------------------------------------------------

Room exits :
 Use @c to create a new exit.

Existing exits:
  @e north (n) toward north(#4)
  @e south (s) toward south(#7)

&gt; @e north
Editing: north
Exit north:
Enter the exit key to change it, or @ to go back.

New exit key:

&gt; door

Exit door:
Enter the exit key to change it, or @ to go back.

New exit key:

&gt; @

-------------------------------------------------------------------------------

Room exits :
 Use @c to create a new exit.

Existing exits:
  @e door (n) toward door(#4)
  @e south (s) toward south(#7)

&gt; @
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [E]xits: 
  door
  south
 [Q]uit the menu

&gt; q
Closing the building menu.
</code></pre>

<p>This needs a bit of code and a bit of explanation.  So here we go... the code first, the explanations next!</p>
<pre><code class="python"># ... from commands/building.py
# Our building menu

class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.

    For the time being, we have only one choice: key, to edit the room key.

    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;title&quot;, key=&quot;t&quot;, attr=&quot;key&quot;, glance=&quot;{obj.key}&quot;, text=&quot;&quot;&quot;
                -------------------------------------------------------------------------------
                Editing the title of {{obj.key}}(#{{obj.id}})

                You can change the title simply by entering it.
                Use |y{back}|n to go back to the main menu.

                Current title: |c{{obj.key}}|n
        &quot;&quot;&quot;.format(back=&quot;|n or |y&quot;.join(self.keys_go_back)))
        self.add_choice_edit(&quot;description&quot;, &quot;d&quot;)
        self.add_choice(&quot;exits&quot;, &quot;e&quot;, glance=glance_exits, text=text_exits, on_nomatch=nomatch_exits)

        # Exit sub-menu
        self.add_choice(&quot;exit&quot;, &quot;e.*&quot;, text=text_single_exit, on_nomatch=nomatch_single_exit)



# Menu functions
def glance_exits(room):
    &quot;&quot;&quot;Show the room exits.&quot;&quot;&quot;
    if room.exits:
        glance = &quot;&quot;
        for exit in room.exits:
            glance += &quot;\n  |y{exit}|n&quot;.format(exit=exit.key)

        return glance

    return &quot;\n  |gNo exit yet|n&quot;

def text_exits(caller, room):
    &quot;&quot;&quot;Show the room exits in the choice itself.&quot;&quot;&quot;
    text = &quot;-&quot; * 79
    text += &quot;\n\nRoom exits:&quot;
    text += &quot;\n Use |y@c|n to create a new exit.&quot;
    text += &quot;\n\nExisting exits:&quot;
    if room.exits:
        for exit in room.exits:
            text += &quot;\n  |y@e {exit}|n&quot;.format(exit=exit.key)
            if exit.aliases.all():
                text += &quot; (|y{aliases}|n)&quot;.format(aliases=&quot;|n, |y&quot;.join(
                        alias for alias in exit.aliases.all()))
            if exit.destination:
                text += &quot; toward {destination}&quot;.format(destination=exit.get_display_name(caller))
    else:
        text += &quot;\n\n |gNo exit has yet been defined.|n&quot;

    return text

def nomatch_exits(menu, caller, room, string):
    &quot;&quot;&quot;
    The user typed something in the list of exits.  Maybe an exit name?
    &quot;&quot;&quot;
    string = string[3:]
    exit = caller.search(string, candidates=room.exits)
    if exit is None:
        return

    # Open a sub-menu, using nested keys
    caller.msg(&quot;Editing: {}&quot;.format(exit.key))
    menu.move(exit)
    return False

# Exit sub-menu
def text_single_exit(menu, caller):
    &quot;&quot;&quot;Show the text to edit single exits.&quot;&quot;&quot;
    exit = menu.keys[1]
    if exit is None:
        return &quot;&quot;

    return &quot;&quot;&quot;
        Exit {exit}:

        Enter the exit key to change it, or |y@|n to go back.

        New exit key:
    &quot;&quot;&quot;.format(exit=exit.key)

def nomatch_single_exit(menu, caller, room, string):
    &quot;&quot;&quot;The user entered something in the exit sub-menu.  Replace the exit key.&quot;&quot;&quot;
    # exit is the second key element: keys should contain ['e', &lt;Exit object&gt;]
    exit = menu.keys[1]
    if exit is None:
        caller.msg(&quot;|rCannot find the exit.|n&quot;)
        menu.move(back=True)
        return False

    exit.key = string
    return True
</code></pre>

<blockquote>
<p>That's a lot of code!  And we only handle editing the exit key!</p>
</blockquote>
<p>That's why at some point you might want to write a real sub-menu, instead of using simple nested keys.  But you might need both to build pretty menus too!</p>
<ol>
<li>The first thing new is in our menu class.  After creating a <code>on_nomatch</code> callback for the exits menu (that shouldn't be a surprised), we need to add a nested key.  We give this menu a key of <code>"e.*"</code>.  That's a bit odd!  "e" is our key to the exits menu, . is the separator to indicate a nested menu, and * means anything.  So basically, we create a nested menu that is contains within the exits menu and anything.  We'll see what this "anything" is in practice.</li>
<li>The <code>glance_exits</code> and <code>text_exits</code> are basically the same.</li>
<li>The <code>nomatch_exits</code> is short but interesting.  It's called when we enter some text in the "exits" menu (that is, in the list of exits).  We have said that the user should enter <code>@e</code> followed by the exit name to edit it.  So in the <code>nomatch_exits</code> callbac, we check for that input.  If the entered text begins by <code>@e</code>, we try to find the exit in the room.  If we do...</li>
<li>We call the <code>menu.move</code> method.  That's where things get a bit complicated with nested menus: we need to use <code>menu.move</code> to change from layer to layer.  Here, we are in the choice of exits (the exits menu, of key "e").  We need to go down one layer to edit an exit.  So we call <code>menu.move</code> and give it an exit object.  The menu system remembers what position the user is based on the keys she has entered: when the user opens the menu, there is no key.  If she selects the exits choice, the menu key being "e", the position of the user is <code>["e"]</code> (a list with the menu keys).  If we call <code>menu.move</code>, whatever we give to this method will be appended to the list of keys, so that the user position becomes <code>["e", &lt;Exit object&gt;]</code>.</li>
<li>In the menu class, we have defined the menu "e.*", meaning "the menu contained in the exits choice plus anything".  The "anything" here is an exit:  we have called <code>menu.move(exit)</code>, so the <code>"e.*"</code> menu choice is chosen.</li>
<li>In this menu, the text is set to a callback.  There is also a <code>on_nomatch</code> callback that is called whenever the user enters some text.  If so, we change the exit name.</li>
</ol>
<p>Using <code>menu.move</code> like this is a bit confusing at first.  Sometimes it's useful.  In this case, if we want a more complex menu for exits, it makes sense to use a real sub-menu, not nested keys like this.  But sometimes, you will find yourself in a situation where you don't need a full menu to handle a choice.</p>
<h4 id="full-sub-menu-as-separate-classes">Full sub-menu as separate classes<a class="headerlink" href="#full-sub-menu-as-separate-classes" title="Permanent link">&para;</a></h4>
<p>The best way to handle individual exits is to create two separate classes:</p>
<ul>
<li>One for the room menu.</li>
<li>One for the individual exit menu.</li>
</ul>
<p>The first one will have to redirect on the second.  This might be more intuitive and flexible, depending on what you want to achieve.  So let's build two menus:</p>
<pre><code class="python"># Still in commands/building.py, replace the menu class and functions by...
# Our building menus

class RoomBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit a room.
    &quot;&quot;&quot;

    def init(self, room):
        self.add_choice(&quot;title&quot;, key=&quot;t&quot;, attr=&quot;key&quot;, glance=&quot;{obj.key}&quot;, text=&quot;&quot;&quot;
                -------------------------------------------------------------------------------
                Editing the title of {{obj.key}}(#{{obj.id}})

                You can change the title simply by entering it.
                Use |y{back}|n to go back to the main menu.

                Current title: |c{{obj.key}}|n
        &quot;&quot;&quot;.format(back=&quot;|n or |y&quot;.join(self.keys_go_back)))
        self.add_choice_edit(&quot;description&quot;, &quot;d&quot;)
        self.add_choice(&quot;exits&quot;, &quot;e&quot;, glance=glance_exits, text=text_exits, on_nomatch=nomatch_exits)


# Menu functions
def glance_exits(room):
    &quot;&quot;&quot;Show the room exits.&quot;&quot;&quot;
    if room.exits:
        glance = &quot;&quot;
        for exit in room.exits:
            glance += &quot;\n  |y{exit}|n&quot;.format(exit=exit.key)

        return glance

    return &quot;\n  |gNo exit yet|n&quot;

def text_exits(caller, room):
    &quot;&quot;&quot;Show the room exits in the choice itself.&quot;&quot;&quot;
    text = &quot;-&quot; * 79
    text += &quot;\n\nRoom exits:&quot;
    text += &quot;\n Use |y@c|n to create a new exit.&quot;
    text += &quot;\n\nExisting exits:&quot;
    if room.exits:
        for exit in room.exits:
            text += &quot;\n  |y@e {exit}|n&quot;.format(exit=exit.key)
            if exit.aliases.all():
                text += &quot; (|y{aliases}|n)&quot;.format(aliases=&quot;|n, |y&quot;.join(
                        alias for alias in exit.aliases.all()))
            if exit.destination:
                text += &quot; toward {destination}&quot;.format(destination=exit.get_display_name(caller))
    else:
        text += &quot;\n\n |gNo exit has yet been defined.|n&quot;

    return text

def nomatch_exits(menu, caller, room, string):
    &quot;&quot;&quot;
    The user typed something in the list of exits.  Maybe an exit name?
    &quot;&quot;&quot;
    string = string[3:]
    exit = caller.search(string, candidates=room.exits)
    if exit is None:
        return

    # Open a sub-menu, using nested keys
    caller.msg(&quot;Editing: {}&quot;.format(exit.key))
    menu.open_submenu(&quot;commands.building.ExitBuildingMenu&quot;, exit, parent_keys=[&quot;e&quot;])
    return False

class ExitBuildingMenu(BuildingMenu):

    &quot;&quot;&quot;
    Building menu to edit an exit.

    &quot;&quot;&quot;

    def init(self, exit):
        self.add_choice(&quot;key&quot;, key=&quot;k&quot;, attr=&quot;key&quot;, glance=&quot;{obj.key}&quot;)
        self.add_choice_edit(&quot;description&quot;, &quot;d&quot;)
</code></pre>

<p>The code might be much easier to read.  But before detailing it, let's see how it behaves in the game:</p>
<pre><code>&gt; @edit here
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [E]xits: 
  door
  south
 [Q]uit the menu

&gt; e
-------------------------------------------------------------------------------

Room exits:
 Use @c to create a new exit.

Existing exits:
  @e door (n) toward door(#4)
  @e south (s) toward south(#7)

Editing: door

&gt; @e door
Building menu: door

 [K]ey: door
 [D]escription: 
   None

&gt; k
-------------------------------------------------------------------------------
key for door(#4)

You can change this value simply by entering it.

Use @ to go back to the main menu.

Current value: door

&gt; north

-------------------------------------------------------------------------------
key for north(#4)

You can change this value simply by entering it.

Use @ to go back to the main menu.

Current value: north

&gt; @
Building menu: north

 [K]ey: north
 [D]escription: 
   None

&gt; d
----------Line Editor [editor]----------------------------------------------------
01| None
----------[l:01 w:001 c:0004]------------(:h for help)----------------------------

&gt; :DD
Cleared 1 lines from buffer.

&gt; This is the northern exit. Cool huh?
01| This is the northern exit. Cool huh?

&gt; :wq
Building menu: north
 [K]ey: north
 [D]escription: 
   This is the northern exit.  Cool huh?

&gt; @
-------------------------------------------------------------------------------
Room exits:
 Use @c to create a new exit.

Existing exits:
  @e north (n) toward north(#4)
  @e south (s) toward south(#7)

&gt; @
Building menu: A beautiful meadow

 [T]itle: A beautiful meadow
 [D]escription: 
   This is a beautiful meadow.  But so beautiful I can't describe it.
 [E]xits: 
  north
  south
 [Q]uit the menu

&gt; q
Closing the building menu.

&gt; look
A beautiful meadow(#2)
This is a beautiful meadow.  But so beautiful I can't describe it.
Exits: north(#4) and south(#7)
&gt; @py here.exits[0]
&gt;&gt;&gt; here.exits[0]
north
&gt; @py here.exits[0].db.desc
&gt;&gt;&gt; here.exits[0].db.desc
This is the northern exit.  Cool huh?
</code></pre>

<p>Very simply, we created two menus and bridged them together.  This needs much less callbacks.  There is only one line in the <code>nomatch_exits</code> to add:</p>
<pre><code class="python">    menu.open_submenu(&quot;commands.building.ExitBuildingMenu&quot;, exit, parent_keys=[&quot;e&quot;])
</code></pre>

<p>We have to call <code>open_submenu</code> on the menu object (which opens, as its name implies, a sub menu) with three arguments:</p>
<ul>
<li>The path of the menu class to create.  It's the Python class leading to the menu (notice the dots).</li>
<li>The object that will be edited by the menu.  Here, it's our exit, so we give it to the sub-menu.</li>
<li>The keys of the parent to open when the sub-menu closes.  Basically, when we're in the root of the sub-menu and press <code>@</code>, we'll open the parent menu, with the parent keys.  So we specify <code>["e"]</code>, since the parent menus is the "exits" choice.</li>
</ul>
<p>And that's it.  The new class will be automatically created.  As you can see, we have to create a <code>on_nomatch</code> callback to open the sub-menu, but once opened, it automatically close whenever needed.</p>
<h3 id="generic-menu-options">Generic menu options<a class="headerlink" href="#generic-menu-options" title="Permanent link">&para;</a></h3>
<p>There are some options that can be set on any menu class.  These options allow for greater customization.  They are class attributes (see the example below), so just set them in the class body:</p>
<ul>
<li><code>keys_go_back</code> (default to <code>["@"]</code>): the keys to use to go back in the menu hierarchy, from choice to root menu, from sub-menu to parent-menu.  By default, only a <code>@</code> is used.  You can change this key for one menu or all of them.  You can define multiple return commands if you want.</li>
<li><code>sep_keys</code> (default <code>"."</code>): this is the separator for nested keys.  There is no real need to redefine it except if you really need the dot as a key, and need nested keys in your menu.</li>
<li><code>joker_key</code> (default to <code>"*"</code>): used for nested keys to indicate "any key".  Again, you shouldn't need to change it unless you want to be able to use the @*@ in a command key, and also need nested keys in your menu.</li>
<li><code>min_shortcut</code> (default to <code>1</code>): although we didn't see it here, one can create a menu choice without giving it a key.  If so, the menu system will try to "guess" the key.  This option allows to change the minimum length of any key for security reasons.</li>
</ul>
<p>To set one of them just do so in your menu class(es):</p>
<pre><code class="python">class RoomBuildingMenu(BuildingMenu):
    keys_go_back = [&quot;/&quot;]
    min_shortcut = 2
</code></pre>

<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>Building menus mean to save you time and create a rich yet simple interface.  But they can be complicated to learn and require reading the source code to find out how to do such and such a thing.  This documentation, however long, is an attempt at describing this system, but chances are you'll still have questions about it after reading it, especially if you try to push this system to a great extent.  Do not hesitate to read the documentation of this contrib, it's meant to be exhaustive but user-friendly.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = ".",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="js/base.js" defer></script>
        <script src="search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
