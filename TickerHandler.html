<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="./img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>TickerHandler - Evennia Manual</title>
    <link href="./css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="./css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="./css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="./css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="./js/jquery-3.2.1.min.js"></script>
    <script src="./js/bootstrap-3.3.7.min.js"></script>
    <script src="./js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '.';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "About Tickers", url: "#_top", children: [
              {title: "When not to use TickerHandler", url: "#when-not-to-use-tickerhandler" },
          ]},
        ];

    </script>
    <script src="./js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <p><a href="Used-to-repeatedly-'tick'-a-method-on-an-Object."></a></p>
<p>One way to implement a dynamic MUD is by using "tickers", also known as "heartbeats". A ticker is a timer that fires ("ticks") at a given interval. The tick triggers updates in various game systems. </p>
<h2 id="about-tickers">About Tickers<a class="headerlink" href="#about-tickers" title="Permanent link">&para;</a></h2>
<p>Tickers are very common or even unavoidable in other mud code bases.  Certain code bases are even hard-coded to rely on the concept of the global 'tick'. Evennia has no such notion - the decision to use tickers is very much up to the need of your game and which requirements you have. The "ticker recipe" is just one way of cranking the wheels.</p>
<p>The most fine-grained way to manage the flow of time is of course to use <a href="Scripts">Scripts</a>. Many types of operations (weather being the classic example) are however done on multiple objects in the same way at regular intervals, and for this, storing separate Scripts on each object is inefficient. The way to do this is to use a ticker with a "subscription model" - let objects sign up to be triggered at the same interval, unsubscribing when the updating is no longer desired. </p>
<p>Evennia offers an optimized implementation of the subscription model - the <em>TickerHandler</em>. This is a singleton global handler reachable from <code>evennia.TICKER_HANDLER</code>. You can assign any <em>callable</em> (a function or, more commonly, a method on a database object) to this handler. The TickerHandler will then call this callable at an interval you specify, and with the arguments you supply when adding it. This continues until the callable un-subscribes from the ticker. The handler survives a reboot and is highly optimized in resource usage.</p>
<p>Here is an example of importing <code>TICKER_HANDLER</code> and using it: </p>
<pre><code class="python">    # we assume that obj has a hook &quot;at_tick&quot; defined on itself
    from evennia import TICKER_HANDLER as tickerhandler    

    tickerhandler.add(20, obj.at_tick)
</code></pre>

<p>That's it - from now on, <code>obj.at_tick()</code> will be called every 20 seconds. </p>
<p>You can also import function and tick that: </p>
<pre><code class="python">    from evennia import TICKER_HANDLER as tickerhandler
    from mymodule import myfunc

    tickerhandler.add(30, myfunc)
</code></pre>

<p>Removing (stopping) the ticker works as expected: </p>
<pre><code class="python">    tickerhandler.remove(20, obj.at_tick)
    tickerhandler.remove(30, myfunc) 
</code></pre>

<p>Note that you have to also supply <code>interval</code> to identify which subscription to remove. This is because the TickerHandler maintains a pool of tickers and a given callable can subscribe to be ticked at any number of different intervals.</p>
<p>The full definition of the <code>tickerhandler.add</code> method is</p>
<pre><code class="python">    tickerhandler.add(interval, callback, 
                      idstring=&quot;&quot;, persistent=True, *args, **kwargs)
</code></pre>

<p>Here <code>*args</code> and <code>**kwargs</code> will be passed to <code>callback</code> every <code>interval</code> seconds. If <code>persistent</code> is <code>False</code>, this subscription will not survive a server reload. </p>
<p>Tickers are identified and stored by making a key of the callable itself, the ticker-interval, the <code>persistent</code> flag and the <code>idstring</code> (the latter being an empty string when not given explicitly).</p>
<p>Since the arguments are not included in the ticker's identification, the <code>idstring</code> must be used to have a specific callback triggered multiple times on the same interval but with different arguments:</p>
<pre><code class="python">    tickerhandler.add(10, obj.update, &quot;ticker1&quot;, True, 1, 2, 3)
    tickerhandler.add(10, obj.update, &quot;ticker2&quot;, True, 4, 5)
</code></pre>

<blockquote>
<p>Note that, when we want to send arguments to our callback within a ticker handler, we need to specify <code>idstring</code> and <code>persistent</code> before, unless we call our arguments as keywords, which would often be more readable:</p>
</blockquote>
<pre><code class="python">    tickerhandler.add(10, obj.update, caller=self, value=118)
</code></pre>

<p>If you add a ticker with exactly the same combination of callback, interval and idstring, it will overload the existing ticker. This identification is also crucial for later removing (stopping) the subscription: </p>
<pre><code class="python">    tickerhandler.remove(10, obj.update, idstring=&quot;ticker1&quot;)
    tickerhandler.remove(10, obj.update, idstring=&quot;ticker2&quot;)
</code></pre>

<p>The <code>callable</code> can be on any form as long as it accepts the arguments you give to send to it in <code>TickerHandler.add</code>. </p>
<blockquote>
<p>Note that everything you supply to the TickerHandler will need to be pickled at some point to be saved into the database. Most of the time the handler will correctly store things like database objects, but the same restrictions as for <a href="Attributes">Attributes</a> apply to what the TickerHandler may store. </p>
</blockquote>
<p>When testing, you can stop all tickers in the entire game with <code>tickerhandler.clear()</code>. You can also view the currently subscribed objects with <code>tickerhandler.all()</code>.</p>
<p>See the <a href="Weather-Tutorial">Weather Tutorial</a> for an example of using the TickerHandler.</p>
<h3 id="when-not-to-use-tickerhandler">When <em>not</em> to use TickerHandler<a class="headerlink" href="#when-not-to-use-tickerhandler" title="Permanent link">&para;</a></h3>
<p>Using the TickerHandler may sound very useful but it is important to consider when not to use it. Even if you are used to habitually relying on tickers for everything in other code bases, stop and think about what you really need it for. This is the main point: </p>
<blockquote>
<p>You should <em>never</em>  use  a ticker to catch <em>changes</em>. </p>
</blockquote>
<p>Think about it - you might have to run the ticker every second to react to the change fast enough. Most likely nothing will have changed at a given moment. So you are doing pointless calls (since skipping the call gives the same result as doing it). Making sure nothing's changed might even be computationally expensive depending on the complexity of your system. Not to mention that you might need to run the check <em>on every object in the database</em>. Every second. Just to maintain status quo ...</p>
<p>Rather than checking over and over on the off-chance that something changed, consider a more proactive approach. Could you implement your rarely changing system to <em>itself</em> report when its status changes?  It's almost always much cheaper/efficient if you can do things "on demand". Evennia itself uses hook methods for this very reason.</p>
<p>So, if you consider a ticker that will fire very often but which you expect to have no effect 99% of the time, consider handling things things some other way. A self-reporting on-demand solution is usually cheaper also for fast-updating properties. Also remember that some things may not need to be updated until someone actually is examining or using them - any interim changes happening up to that moment are pointless waste of computing time. </p>
<p>The main reason for needing a ticker is when you want things to happen to multiple objects at the same time without input from something else. </p>

  <br>
    

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>