<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    
    <link rel="shortcut icon" href="./img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Custom Protocols - Evennia Manual</title>
    <link href="./css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="./css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="./css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="./css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="./js/jquery-3.2.1.min.js"></script>
    <script src="./js/bootstrap-3.3.7.min.js"></script>
    <script src="./js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '.';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Adding custom Protocols", url: "#_top", children: [
          ]},
          {title: "Writing your own Protocol", url: "#writing-your-own-protocol", children: [
              {title: "Sending data out", url: "#sending-data-out" },
              {title: "Receiving data", url: "#receiving-data" },
          ]},
          {title: "Assorted notes", url: "#assorted-notes", children: [
          ]},
        ];

    </script>
    <script src="./js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <p><a href="Implementing-new-server-protocols-(advanced)."></a></p>
<p><em>Note: This is considered an advanced topic and is mostly of interest to users planning to implement
their own custom client protocol.</em></p>
<p>A <a href="Portal-and-Server-Sessions">PortalSession</a> is the basic data object representing an external
connection to the Evennia <a href="Portal-And-Server">Portal</a> -- usually a human player running a mud client
of some kind.  The way they connect (the language the player's client and Evennia use to talk to
each other) is called the connection <em>Protocol</em>. The most common such protocol for MUD:s is the
<em>Telnet</em> protocol. All Portal Sessions are stored and managed by the Portal's <em>sessionhandler</em>.</p>
<p>It's technically sometimes hard to separate the concept of <em>PortalSession</em> from the concept of
<em>Protocol</em> since both depend heavily on the other (they are often created as the same class). When data flows through this part of the system, this is how it goes </p>
<pre><code># In the Portal
You &lt;-&gt; 
  Protocol + PortalSession &lt;-&gt; 
    PortalSessionHandler &lt;-&gt;
      (AMP) &lt;-&gt; 
        ServerSessionHandler &lt;-&gt;
          ServerSession &lt;-&gt;
            InputFunc  
</code></pre>

<p>(See the <a href="Messagepath">Message Path</a> for the bigger picture of how data flows through Evennia). The parts that needs to be customized to make your own custom protocol is the <code>Protocol + PortalSession</code> (which translates between data coming in/out over the wire to/from Evennia internal representation) as well as the <code>InputFunc</code> (which handles incoming data).</p>
<h2 id="adding-custom-protocols">Adding custom Protocols<a class="headerlink" href="#adding-custom-protocols" title="Permanent link">&para;</a></h2>
<p>Evennia has a plugin-system that add the protocol as a new "service" to the application.</p>
<p>Take a look at <code>evennia/server/portal/portal.py</code>, notably the sections towards the end of that file.
These are where the various in-built services like telnet, ssh, webclient etc are added to the
Portal (there is an equivalent but shorter list in <code>evennia/server/server.py</code>).</p>
<p>To add a new service of your own (for example your own custom client protocol) to the Portal or
Server, look at  <code>mygame/server/conf/server_services_plugins</code> and <code>portal_services_plugins</code>. By
default Evennia will look into these modules to find plugins. If you wanted to have it look for more
modules, you could do the following:</p>
<pre><code class="python">    # add to the Server
    SERVER_SERVICES_PLUGIN_MODULES.append('server.conf.my_server_plugins')
    # or, if you want to add to the Portal
    PORTAL_SERVICES_PLUGIN_MODULES.append('server.conf.my_portal_plugins')
</code></pre>

<p>When adding a new connection you'll most likely only need to add new things to the <code>PORTAL_SERVICES_PLUGIN_MODULES</code>.</p>
<p>This module can contain whatever you need to define your protocol, but it <em>must</em> contain a function
<code>start_plugin_services(app)</code>. This is called by the Portal as part of its upstart. The function
<code>start_plugin_services</code> must contain all startup code the server need.  The <code>app</code> argument is a
reference to the Portal/Server application itself so the custom service can be added to it. The
function should not return anything.</p>
<p>This is how it looks:</p>
<pre><code class="python">    # mygame/server/conf/portal_services_plugins.py

    # here the new Portal Twisted protocol is defined
    class MyOwnFactory( ... ):
       [...]

    # some configs
    MYPROC_ENABLED = True # convenient off-flag to avoid having to edit settings all the time
    MY_PORT = 6666

    def start_plugin_services(portal):
        &quot;This is called by the Portal during startup&quot;
         if not MYPROC_ENABLED:
             return
         # output to list this with the other services at startup
         print(&quot;  myproc: %s&quot; % MY_PORT)

         # some setup (simple example)
         factory = MyOwnFactory()
         my_service = internet.TCPServer(MY_PORT, factory)
         # all Evennia services must be uniquely named
         my_service.setName(&quot;MyService&quot;)
         # add to the main portal application
         portal.services.addService(my_service)
</code></pre>

<p>Once the module is defined and targeted in settings, just reload the server and your new
protocol/services should start with the others.</p>
<h2 id="writing-your-own-protocol">Writing your own Protocol<a class="headerlink" href="#writing-your-own-protocol" title="Permanent link">&para;</a></h2>
<p>Writing a stable communication protocol from scratch is not something we'll cover here, it's no
trivial task. The good news is that Twisted offers implementations of many common protocols, ready
for adapting.</p>
<p>Writing a protocol implementation in Twisted usually involves creating a class inheriting from an already existing Twisted protocol class and from <code>evennia.server.session.Session</code> (multiple inheritance), then overloading the methods that particular protocol uses to link them to the Evennia-specific inputs. </p>
<p>Here's a example to show the concept: </p>
<pre><code class="python"># In module that we'll later add to the system through PORTAL_SERVICE_PLUGIN_MODULES

# pseudo code 
from twisted.something import TwistedClient
# this class is used both for Portal- and Server Sessions
from evennia.server.session import Session 

from evennia.server.portal.portalsessionhandler import PORTAL_SESSIONS

class MyCustomClient(TwistedClient, Session): 

    def __init__(self, *args, **kwargs): 
        super().__init__(*args, **kwargs)
        self.sessionhandler = PORTAL_SESSIONS

    # these are methods we must know that TwistedClient uses for 
    # communication. Name and arguments could vary for different Twisted protocols
    def onOpen(self, *args, **kwargs):
        # let's say this is called when the client first connects

        # we need to init the session and connect to the sessionhandler. The .factory
        # is available through the Twisted parents

        client_address = self.getClientAddress()  # get client address somehow

        self.init_session(&quot;mycustom_protocol&quot;, client_address, self.factory.sessionhandler)
        self.sessionhandler.connect(self)

    def onClose(self, reason, *args, **kwargs):
        # called when the client connection is dropped
        # link to the Evennia equivalent
        self.disconnect(reason)

    def onMessage(self, indata, *args, **kwargs): 
        # called with incoming data
        # convert as needed here        
        self.data_in(data=indata) 

    def sendMessage(self, outdata, *args, **kwargs):
        # called to send data out
        # modify if needed        
        super().sendMessage(self, outdata, *args, **kwargs)

     # these are Evennia methods. They must all exist and look exactly like this
     # The above twisted-methods call them and vice-versa. This connects the protocol
     # the Evennia internals.  

     def disconnect(self, reason=None): 
         &quot;&quot;&quot;
         Called when connection closes. 
         This can also be called directly by Evennia when manually closing the connection.
         Do any cleanups here.
         &quot;&quot;&quot;
         self.sessionhandler.disconnect(self)

     def at_login(self): 
         &quot;&quot;&quot;
         Called when this session authenticates by the server (if applicable)
         &quot;&quot;&quot;    

     def data_in(self, **kwargs):
         &quot;&quot;&quot;
         Data going into the server should go through this method. It 
         should pass data into `sessionhandler.data_in`. THis will be called
         by the sessionhandler with the data it gets from the approrpriate 
         send_* method found later in this protocol. 
         &quot;&quot;&quot;
         self.sessionhandler.data_in(self, text=kwargs['data'])

     def data_out(self, **kwargs):
         &quot;&quot;&quot;
         Data going out from the server should go through this method. It should
         hand off to the protocol's send method, whatever it's called.
         &quot;&quot;&quot;
         # we assume we have a 'text' outputfunc
         self.onMessage(kwargs['text'])

     # 'outputfuncs' are defined as `send_&lt;outputfunc_name&gt;`. From in-code, they are called 
     # with `msg(outfunc_name=&lt;data&gt;)`. 

     def send_text(self, txt, *args, **kwargs): 
         &quot;&quot;&quot;
         Send text, used with e.g. `session.msg(text=&quot;foo&quot;)`
         &quot;&quot;&quot;
         # we make use of the 
         self.data_out(text=txt)

     def send_default(self, cmdname, *args, **kwargs): 
         &quot;&quot;&quot;
         Handles all outputfuncs without an explicit `send_*` method to handle them.
         &quot;&quot;&quot;
         self.data_out(**{cmdname: str(args)})

</code></pre>

<p>The principle here is that the Twisted-specific methods are overridden to redirect inputs/outputs to the Evennia-specific methods. </p>
<h3 id="sending-data-out">Sending data out<a class="headerlink" href="#sending-data-out" title="Permanent link">&para;</a></h3>
<p>To send data out through this protocol, you'd need to get its Session and then you could e.g. </p>
<pre><code class="python">    session.msg(text=&quot;foo&quot;)
</code></pre>

<p>The message will pass through the system such that the sessionhandler will dig out the session and check if it has a <code>send_text</code> method (it has). It will then pass the "foo" into that method, which in our case means sending "foo" across the network. </p>
<h3 id="receiving-data">Receiving data<a class="headerlink" href="#receiving-data" title="Permanent link">&para;</a></h3>
<p>Just because the protocol is there, does not mean Evennia knows what to do with it. An <a href="Inputfunc">Inputfunc</a> must exist to receive it. In the case of the <code>text</code> input exemplified above, Evennia alredy handles this input - it will parse it as a Command name followed by its inputs. So handle that you need to simply add a cmdset with commands on your receiving Session (and/or the Object/Character it is puppeting). If not you may need to add your own Inputfunc (see the <a href="Inputfunc">Inputfunc</a> page for how to do this. </p>
<p>These might not be as clear-cut in all protocols, but the principle is there. These four basic
components - however they are accessed - links to the <em>Portal Session</em>, which is the actual common
interface between the different low-level protocols and Evennia.</p>
<h2 id="assorted-notes">Assorted notes<a class="headerlink" href="#assorted-notes" title="Permanent link">&para;</a></h2>
<p>To take two examples, Evennia supports the <em>telnet</em> protocol as well as <em>webclient</em>, via ajax or
websockets. You'll find that whereas telnet is a textbook example of a Twisted protocol as seen
above, the ajax protocol looks quite different due to how it interacts with the
webserver through long-polling (comet) style requests. All the necessary parts
mentioned above are still there, but by necessity implemented in very different
ways. </p>

  <br>
    

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>